declare module vsphere {
   function cisService(hostname: string, options?: {definition?: boolean; debug?: boolean; endpoint?: string, key?: string, port?: number, prefixes?: boolean;proxy?: boolean;proxyHeader?: string;}): Promise<vsphere.cisService>;
   interface cisService {
      addHandler(handler: Function): void;
      removeHandler(handler: Function): void;
      serializeObject(obj: Object, name: string): Object;
      deserializeObject(obj: Object): Object;
      getSecurityContext(): Object;
      setSecurityContext(securityContext: Object): void;
      uuid(): string;
      builtin: {
         ANYERROR: {
            (options?: cisService.builtin.ANYERROR): cisService.builtin.ANYERROR;
         };
         BINARY: {
            (options?: cisService.builtin.BINARY): cisService.builtin.BINARY;
         };
         BOOLEAN: {
            (options?: cisService.builtin.BOOLEAN): cisService.builtin.BOOLEAN;
         };
         DATETIME: {
            (options?: cisService.builtin.DATETIME): cisService.builtin.DATETIME;
         };
         DOUBLE: {
            (options?: cisService.builtin.DOUBLE): cisService.builtin.DOUBLE;
         };
         DYNAMICSTRUCTURE: {
            (options?: cisService.builtin.DYNAMICSTRUCTURE): cisService.builtin.DYNAMICSTRUCTURE;
         };
         ID: {
            (options?: cisService.builtin.ID): cisService.builtin.ID;
         };
         LONG: {
            (options?: cisService.builtin.LONG): cisService.builtin.LONG;
         };
         OPAQUE: {
            (options?: cisService.builtin.OPAQUE): cisService.builtin.OPAQUE;
         };
         SECRET: {
            (options?: cisService.builtin.SECRET): cisService.builtin.SECRET;
         };
         STRING: {
            (options?: cisService.builtin.STRING): cisService.builtin.STRING;
         };
         URI: {
            (options?: cisService.builtin.URI): cisService.builtin.URI;
         };
         VOID: {
            (options?: cisService.builtin.VOID): cisService.builtin.VOID;
         };
      }
      cis: {
         session: {
            get(): Promise<cisService.cis.session.Info>;
            delete(): Promise<void>;
            create(): Promise<string>;
            Info: {
               (options?: cisService.cis.session.Info): cisService.cis.session.Info;
            };
         }
      }
      tagging: {
         sessions: {
            sessionManager: {
               logout(): Promise<void>;
               keepAlive(): Promise<void>;
               login(): Promise<string>;
            }
         }
         tag: {
            listTagsForCategory(categoryId: string): Promise<Array<string>>;
            update(tagId: string, updateSpec: cisService.tagging.tag.UpdateSpec): Promise<void>;
            listUsedTags(usedByEntity: string): Promise<Array<string>>;
            removeFromUsedBy(tagId: string, usedByEntity: string): Promise<void>;
            get(tagId: string): Promise<cisService.tagging.TagModel>;
            revokePropagatingPermissions(tagId: string): Promise<void>;
            addToUsedBy(tagId: string, usedByEntity: string): Promise<void>;
            delete(tagId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(createSpec: cisService.tagging.tag.CreateSpec): Promise<string>;
            CreateSpec: {
               (options?: cisService.tagging.tag.CreateSpec): cisService.tagging.tag.CreateSpec;
            };
            UpdateSpec: {
               (options?: cisService.tagging.tag.UpdateSpec): cisService.tagging.tag.UpdateSpec;
            };
         }
         tagAssociation: {
            detach(tagId: string, objectId: cisService.vapi.std.DynamicID): Promise<void>;
            listAttachedTags(objectId: cisService.vapi.std.DynamicID): Promise<Array<string>>;
            attach(tagId: string, objectId: cisService.vapi.std.DynamicID): Promise<void>;
            listAttachableTags(objectId: cisService.vapi.std.DynamicID): Promise<Array<string>>;
            listAttachedObjects(tagId: string): Promise<Array<cisService.vapi.std.DynamicID>>;
         }
         category: {
            listUsedCategories(usedByEntity: string): Promise<Array<string>>;
            update(categoryId: string, updateSpec: cisService.tagging.category.UpdateSpec): Promise<void>;
            removeFromUsedBy(categoryId: string, usedByEntity: string): Promise<void>;
            get(categoryId: string): Promise<cisService.tagging.CategoryModel>;
            revokePropagatingPermissions(categoryId: string): Promise<void>;
            addToUsedBy(categoryId: string, usedByEntity: string): Promise<void>;
            delete(categoryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(createSpec: cisService.tagging.category.CreateSpec): Promise<string>;
            CreateSpec: {
               (options?: cisService.tagging.category.CreateSpec): cisService.tagging.category.CreateSpec;
            };
            UpdateSpec: {
               (options?: cisService.tagging.category.UpdateSpec): cisService.tagging.category.UpdateSpec;
            };
         }
         CategoryModel: {
            (options?: cisService.tagging.CategoryModel): cisService.tagging.CategoryModel;
            Cardinality: {
               "SINGLE": string;
               "MULTIPLE": string;
            }
         };
         TagModel: {
            (options?: cisService.tagging.TagModel): cisService.tagging.TagModel;
         };
      }
      vapi: {
         metadata: {
            privilege: {
               service: {
                  get(serviceId: string): Promise<cisService.vapi.metadata.privilege.ServiceInfo>;
                  list(): Promise<Array<string>>;
                  operation: {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.privilege.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
               }
               component: {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.privilege.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               package: {
                  get(packageId: string): Promise<cisService.vapi.metadata.privilege.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               ServiceInfo: {
                  (options?: cisService.vapi.metadata.privilege.ServiceInfo): cisService.vapi.metadata.privilege.ServiceInfo;
               };
               ComponentInfo: {
                  (options?: cisService.vapi.metadata.privilege.ComponentInfo): cisService.vapi.metadata.privilege.ComponentInfo;
               };
               PrivilegeInfo: {
                  (options?: cisService.vapi.metadata.privilege.PrivilegeInfo): cisService.vapi.metadata.privilege.PrivilegeInfo;
               };
               ComponentData: {
                  (options?: cisService.vapi.metadata.privilege.ComponentData): cisService.vapi.metadata.privilege.ComponentData;
               };
               OperationInfo: {
                  (options?: cisService.vapi.metadata.privilege.OperationInfo): cisService.vapi.metadata.privilege.OperationInfo;
               };
               PackageInfo: {
                  (options?: cisService.vapi.metadata.privilege.PackageInfo): cisService.vapi.metadata.privilege.PackageInfo;
               };
            }
            metamodel: {
               service: {
                  operation: {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.metamodel.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
                  get(serviceId: string): Promise<cisService.vapi.metadata.metamodel.ServiceInfo>;
                  list(): Promise<Array<string>>;
               }
               resource: {
                  model: {
                     list(resourceId: string): Promise<Array<string>>;
                  }
                  list(): Promise<Array<string>>;
               }
               package: {
                  get(packageId: string): Promise<cisService.vapi.metadata.metamodel.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               component: {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.metamodel.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               structure: {
                  get(structureId: string): Promise<cisService.vapi.metadata.metamodel.StructureInfo>;
                  list(): Promise<Array<string>>;
               }
               enumeration: {
                  get(enumerationId: string): Promise<cisService.vapi.metadata.metamodel.EnumerationInfo>;
                  list(): Promise<Array<string>>;
               }
               ElementMap: {
                  (options?: cisService.vapi.metadata.metamodel.ElementMap): cisService.vapi.metadata.metamodel.ElementMap;
               };
               ComponentInfo: {
                  (options?: cisService.vapi.metadata.metamodel.ComponentInfo): cisService.vapi.metadata.metamodel.ComponentInfo;
               };
               PackageInfo: {
                  (options?: cisService.vapi.metadata.metamodel.PackageInfo): cisService.vapi.metadata.metamodel.PackageInfo;
               };
               GenericInstantiation: {
                  (options?: cisService.vapi.metadata.metamodel.GenericInstantiation): cisService.vapi.metadata.metamodel.GenericInstantiation;
                  GenericType: {
                     "LIST": string;
                     "MAP": string;
                     "OPTIONAL": string;
                     "SET": string;
                  }
               };
               FieldInfo: {
                  (options?: cisService.vapi.metadata.metamodel.FieldInfo): cisService.vapi.metadata.metamodel.FieldInfo;
               };
               ServiceInfo: {
                  (options?: cisService.vapi.metadata.metamodel.ServiceInfo): cisService.vapi.metadata.metamodel.ServiceInfo;
               };
               OperationResultInfo: {
                  (options?: cisService.vapi.metadata.metamodel.OperationResultInfo): cisService.vapi.metadata.metamodel.OperationResultInfo;
               };
               ConstantInfo: {
                  (options?: cisService.vapi.metadata.metamodel.ConstantInfo): cisService.vapi.metadata.metamodel.ConstantInfo;
               };
               ConstantValue: {
                  (options?: cisService.vapi.metadata.metamodel.ConstantValue): cisService.vapi.metadata.metamodel.ConstantValue;
                  Category: {
                     "PRIMITIVE": string;
                     "LIST": string;
                  }
               };
               ComponentData: {
                  (options?: cisService.vapi.metadata.metamodel.ComponentData): cisService.vapi.metadata.metamodel.ComponentData;
               };
               EnumerationValueInfo: {
                  (options?: cisService.vapi.metadata.metamodel.EnumerationValueInfo): cisService.vapi.metadata.metamodel.EnumerationValueInfo;
               };
               ErrorInfo: {
                  (options?: cisService.vapi.metadata.metamodel.ErrorInfo): cisService.vapi.metadata.metamodel.ErrorInfo;
               };
               StructureInfo: {
                  (options?: cisService.vapi.metadata.metamodel.StructureInfo): cisService.vapi.metadata.metamodel.StructureInfo;
                  Type: {
                     "STRUCTURE": string;
                     "ERROR": string;
                  }
               };
               ElementValue: {
                  (options?: cisService.vapi.metadata.metamodel.ElementValue): cisService.vapi.metadata.metamodel.ElementValue;
                  Type: {
                     "LONG": string;
                     "STRING": string;
                     "STRING_LIST": string;
                     "STRUCTURE_REFERENCE": string;
                     "STRUCTURE_REFERENCE_LIST": string;
                  }
               };
               EnumerationInfo: {
                  (options?: cisService.vapi.metadata.metamodel.EnumerationInfo): cisService.vapi.metadata.metamodel.EnumerationInfo;
               };
               Type: {
                  (options?: cisService.vapi.metadata.metamodel.Type): cisService.vapi.metadata.metamodel.Type;
                  Category: {
                     "BUILTIN": string;
                     "USER_DEFINED": string;
                     "GENERIC": string;
                  }
                  BuiltinType: {
                     "VOID": string;
                     "BOOLEAN": string;
                     "LONG": string;
                     "DOUBLE": string;
                     "STRING": string;
                     "BINARY": string;
                     "SECRET": string;
                     "DATE_TIME": string;
                     "ID": string;
                     "URI": string;
                     "ANY_ERROR": string;
                     "DYNAMIC_STRUCTURE": string;
                     "OPAQUE": string;
                  }
               };
               OperationInfo: {
                  (options?: cisService.vapi.metadata.metamodel.OperationInfo): cisService.vapi.metadata.metamodel.OperationInfo;
               };
               UserDefinedType: {
                  (options?: cisService.vapi.metadata.metamodel.UserDefinedType): cisService.vapi.metadata.metamodel.UserDefinedType;
               };
               PrimitiveValue: {
                  (options?: cisService.vapi.metadata.metamodel.PrimitiveValue): cisService.vapi.metadata.metamodel.PrimitiveValue;
                  Type: {
                     "BOOLEAN": string;
                     "DOUBLE": string;
                     "LONG": string;
                     "STRING": string;
                  }
               };
            }
            cli: {
               command: {
                  fingerprint(): Promise<string>;
                  get(identity: cisService.vapi.metadata.cli.command.Identity): Promise<cisService.vapi.metadata.cli.command.Info>;
                  list(path: string): Promise<Array<cisService.vapi.metadata.cli.command.Identity>>;
                  FormatterType: {
                     "SIMPLE": string;
                     "TABLE": string;
                     "JSON": string;
                     "XML": string;
                     "CSV": string;
                     "HTML": string;
                  };
                  GenericType: {
                     "NONE": string;
                     "OPTIONAL": string;
                     "LIST": string;
                  };
                  OptionInfo: {
                     (options?: cisService.vapi.metadata.cli.command.OptionInfo): cisService.vapi.metadata.cli.command.OptionInfo;
                  };
                  Info: {
                     (options?: cisService.vapi.metadata.cli.command.Info): cisService.vapi.metadata.cli.command.Info;
                  };
                  OutputInfo: {
                     (options?: cisService.vapi.metadata.cli.command.OutputInfo): cisService.vapi.metadata.cli.command.OutputInfo;
                  };
                  OutputFieldInfo: {
                     (options?: cisService.vapi.metadata.cli.command.OutputFieldInfo): cisService.vapi.metadata.cli.command.OutputFieldInfo;
                  };
                  Identity: {
                     (options?: cisService.vapi.metadata.cli.command.Identity): cisService.vapi.metadata.cli.command.Identity;
                  };
               }
               namespace: {
                  fingerprint(): Promise<string>;
                  get(identity: cisService.vapi.metadata.cli.namespace.Identity): Promise<cisService.vapi.metadata.cli.namespace.Info>;
                  list(): Promise<Array<cisService.vapi.metadata.cli.namespace.Identity>>;
                  Identity: {
                     (options?: cisService.vapi.metadata.cli.namespace.Identity): cisService.vapi.metadata.cli.namespace.Identity;
                  };
                  Info: {
                     (options?: cisService.vapi.metadata.cli.namespace.Info): cisService.vapi.metadata.cli.namespace.Info;
                  };
               }
            }
            authentication: {
               service: {
                  operation: {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.authentication.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
                  get(serviceId: string): Promise<cisService.vapi.metadata.authentication.ServiceInfo>;
                  list(): Promise<Array<string>>;
               }
               package: {
                  get(packageId: string): Promise<cisService.vapi.metadata.authentication.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               component: {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.authentication.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               PackageInfo: {
                  (options?: cisService.vapi.metadata.authentication.PackageInfo): cisService.vapi.metadata.authentication.PackageInfo;
               };
               AuthenticationInfo: {
                  (options?: cisService.vapi.metadata.authentication.AuthenticationInfo): cisService.vapi.metadata.authentication.AuthenticationInfo;
                  SchemeType: {
                     "SESSIONLESS": string;
                     "SESSION_AWARE": string;
                  }
               };
               ComponentInfo: {
                  (options?: cisService.vapi.metadata.authentication.ComponentInfo): cisService.vapi.metadata.authentication.ComponentInfo;
               };
               ComponentData: {
                  (options?: cisService.vapi.metadata.authentication.ComponentData): cisService.vapi.metadata.authentication.ComponentData;
               };
               OperationInfo: {
                  (options?: cisService.vapi.metadata.authentication.OperationInfo): cisService.vapi.metadata.authentication.OperationInfo;
               };
               ServiceInfo: {
                  (options?: cisService.vapi.metadata.authentication.ServiceInfo): cisService.vapi.metadata.authentication.ServiceInfo;
               };
            }
            SourceType: {
               "FILE": string;
               "REMOTE": string;
            };
            SourceInfo: {
               (options?: cisService.vapi.metadata.SourceInfo): cisService.vapi.metadata.SourceInfo;
            };
            SourceCreateSpec: {
               (options?: cisService.vapi.metadata.SourceCreateSpec): cisService.vapi.metadata.SourceCreateSpec;
            };
         }
         std: {
            DynamicID: {
               (options?: cisService.vapi.std.DynamicID): cisService.vapi.std.DynamicID;
            };
            AuthenticationScheme: {
               (options?: cisService.vapi.std.AuthenticationScheme): cisService.vapi.std.AuthenticationScheme;
               SAML_HOK_TOKEN: string;
               SESSION_ID: string;
               SAML_BEARER_TOKEN: string;
               USER_PASSWORD: string;
               NO_AUTHENTICATION: string;
            };
            LocalizableMessage: {
               (options?: cisService.vapi.std.LocalizableMessage): cisService.vapi.std.LocalizableMessage;
            };
            errors: {
               UnableToAllocateResource: {
                  (options?: cisService.vapi.std.errors.UnableToAllocateResource): cisService.vapi.std.errors.UnableToAllocateResource;
               };
               NotFound: {
                  (options?: cisService.vapi.std.errors.NotFound): cisService.vapi.std.errors.NotFound;
               };
               Unauthenticated: {
                  (options?: cisService.vapi.std.errors.Unauthenticated): cisService.vapi.std.errors.Unauthenticated;
               };
               AlreadyInDesiredState: {
                  (options?: cisService.vapi.std.errors.AlreadyInDesiredState): cisService.vapi.std.errors.AlreadyInDesiredState;
               };
               FeatureInUse: {
                  (options?: cisService.vapi.std.errors.FeatureInUse): cisService.vapi.std.errors.FeatureInUse;
               };
               OperationNotFound: {
                  (options?: cisService.vapi.std.errors.OperationNotFound): cisService.vapi.std.errors.OperationNotFound;
               };
               ServiceUnavailable: {
                  (options?: cisService.vapi.std.errors.ServiceUnavailable): cisService.vapi.std.errors.ServiceUnavailable;
               };
               InternalServerError: {
                  (options?: cisService.vapi.std.errors.InternalServerError): cisService.vapi.std.errors.InternalServerError;
               };
               ConcurrentChange: {
                  (options?: cisService.vapi.std.errors.ConcurrentChange): cisService.vapi.std.errors.ConcurrentChange;
               };
               InvalidElementConfiguration: {
                  (options?: cisService.vapi.std.errors.InvalidElementConfiguration): cisService.vapi.std.errors.InvalidElementConfiguration;
               };
               Error: {
                  (options?: cisService.vapi.std.errors.Error): cisService.vapi.std.errors.Error;
               };
               AlreadyExists: {
                  (options?: cisService.vapi.std.errors.AlreadyExists): cisService.vapi.std.errors.AlreadyExists;
               };
               ResourceInaccessible: {
                  (options?: cisService.vapi.std.errors.ResourceInaccessible): cisService.vapi.std.errors.ResourceInaccessible;
               };
               InvalidElementType: {
                  (options?: cisService.vapi.std.errors.InvalidElementType): cisService.vapi.std.errors.InvalidElementType;
               };
               FileLocations: {
                  (options?: cisService.vapi.std.errors.FileLocations): cisService.vapi.std.errors.FileLocations;
               };
               TimedOut: {
                  (options?: cisService.vapi.std.errors.TimedOut): cisService.vapi.std.errors.TimedOut;
               };
               ResourceBusy: {
                  (options?: cisService.vapi.std.errors.ResourceBusy): cisService.vapi.std.errors.ResourceBusy;
               };
               TransientIndication: {
                  (options?: cisService.vapi.std.errors.TransientIndication): cisService.vapi.std.errors.TransientIndication;
               };
               Unauthorized: {
                  (options?: cisService.vapi.std.errors.Unauthorized): cisService.vapi.std.errors.Unauthorized;
               };
               NotAllowedInCurrentState: {
                  (options?: cisService.vapi.std.errors.NotAllowedInCurrentState): cisService.vapi.std.errors.NotAllowedInCurrentState;
               };
               ArgumentLocations: {
                  (options?: cisService.vapi.std.errors.ArgumentLocations): cisService.vapi.std.errors.ArgumentLocations;
               };
               ResourceInUse: {
                  (options?: cisService.vapi.std.errors.ResourceInUse): cisService.vapi.std.errors.ResourceInUse;
               };
               InvalidArgument: {
                  (options?: cisService.vapi.std.errors.InvalidArgument): cisService.vapi.std.errors.InvalidArgument;
               };
               Unsupported: {
                  (options?: cisService.vapi.std.errors.Unsupported): cisService.vapi.std.errors.Unsupported;
               };
               UnexpectedInput: {
                  (options?: cisService.vapi.std.errors.UnexpectedInput): cisService.vapi.std.errors.UnexpectedInput;
               };
               InvalidRequest: {
                  (options?: cisService.vapi.std.errors.InvalidRequest): cisService.vapi.std.errors.InvalidRequest;
               };
               Canceled: {
                  (options?: cisService.vapi.std.errors.Canceled): cisService.vapi.std.errors.Canceled;
               };
            }
         }
      }
      content: {
         library: {
            item: {
               updatesession: {
                  file: {
                     get(updateSessionId: string, fileName: string): Promise<cisService.content.library.item.updatesession.file.Info>;
                     remove(updateSessionId: string, fileName: string): Promise<void>;
                     list(updateSessionId: string): Promise<Array<cisService.content.library.item.updatesession.file.Info>>;
                     add(updateSessionId: string, fileSpec: cisService.content.library.item.updatesession.file.AddSpec): Promise<cisService.content.library.item.updatesession.file.Info>;
                     validate(updateSessionId: string): Promise<cisService.content.library.item.updatesession.file.ValidationResult>;
                     SourceType: {
                        "NONE": string;
                        "PUSH": string;
                        "PULL": string;
                     };
                     ValidationResult: {
                        (options?: cisService.content.library.item.updatesession.file.ValidationResult): cisService.content.library.item.updatesession.file.ValidationResult;
                     };
                     Info: {
                        (options?: cisService.content.library.item.updatesession.file.Info): cisService.content.library.item.updatesession.file.Info;
                     };
                     AddSpec: {
                        (options?: cisService.content.library.item.updatesession.file.AddSpec): cisService.content.library.item.updatesession.file.AddSpec;
                     };
                     ValidationError: {
                        (options?: cisService.content.library.item.updatesession.file.ValidationError): cisService.content.library.item.updatesession.file.ValidationError;
                     };
                  }
               }
               file: {
                  get(libraryItemId: string, name: string): Promise<cisService.content.library.item.file.Info>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.file.Info>>;
                  ChecksumAlgorithm: {
                     "SHA1": string;
                     "MD5": string;
                  };
                  ChecksumInfo: {
                     (options?: cisService.content.library.item.file.ChecksumInfo): cisService.content.library.item.file.ChecksumInfo;
                  };
                  Info: {
                     (options?: cisService.content.library.item.file.Info): cisService.content.library.item.file.Info;
                  };
               }
               downloadSession: {
                  fail(downloadSessionId: string, clientErrorMessage: string): Promise<void>;
                  get(downloadSessionId: string): Promise<cisService.content.library.item.DownloadSessionModel>;
                  delete(downloadSessionId: string): Promise<void>;
                  keepAlive(downloadSessionId: string, progress: number): Promise<void>;
                  cancel(downloadSessionId: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<string>>;
                  create(clientToken: string, createSpec: cisService.content.library.item.DownloadSessionModel): Promise<string>;
               }
               updateSession: {
                  fail(updateSessionId: string, clientErrorMessage: string): Promise<void>;
                  get(updateSessionId: string): Promise<cisService.content.library.item.UpdateSessionModel>;
                  complete(updateSessionId: string): Promise<void>;
                  delete(updateSessionId: string): Promise<void>;
                  keepAlive(updateSessionId: string, clientProgress: number): Promise<void>;
                  cancel(updateSessionId: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<string>>;
                  create(clientToken: string, createSpec: cisService.content.library.item.UpdateSessionModel): Promise<string>;
               }
               storage: {
                  get(libraryItemId: string, fileName: string): Promise<Array<cisService.content.library.item.storage.Info>>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.storage.Info>>;
                  Info: {
                     (options?: cisService.content.library.item.storage.Info): cisService.content.library.item.storage.Info;
                  };
               }
               metadata: {
                  get(libraryItemId: string, key: string): Promise<string>;
                  delete(libraryItemId: string, key: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.metadata.Info>>;
                  create(libraryItemId: string, key: string, value: string): Promise<void>;
                  Info: {
                     (options?: cisService.content.library.item.metadata.Info): cisService.content.library.item.metadata.Info;
                  };
               }
               update(libraryItemId: string, updateSpec: cisService.content.library.ItemModel): Promise<void>;
               get(libraryItemId: string): Promise<cisService.content.library.ItemModel>;
               delete(libraryItemId: string): Promise<void>;
               list(libraryId: string): Promise<Array<string>>;
               create(clientToken: string, createSpec: cisService.content.library.ItemModel): Promise<string>;
               find(spec: cisService.content.library.item.FindSpec): Promise<Array<string>>;
               copy(clientToken: string, sourceLibraryItemId: string, destinationCreateSpec: cisService.content.library.ItemModel): Promise<string>;
               downloadsession: {
                  file: {
                     get(downloadSessionId: string, fileName: string): Promise<cisService.content.library.item.downloadsession.file.Info>;
                     list(downloadSessionId: string): Promise<Array<cisService.content.library.item.downloadsession.file.Info>>;
                     prepare(downloadSessionId: string, fileName: string, endpointType: cisService.content.library.item.downloadsession.file.EndpointType): Promise<cisService.content.library.item.downloadsession.file.Info>;
                     PrepareStatus: {
                        "UNPREPARED": string;
                        "PREPARE_REQUESTED": string;
                        "PREPARING": string;
                        "PREPARED": string;
                        "ERROR": string;
                     };
                     EndpointType: {
                        "HTTPS": string;
                        "DIRECT": string;
                     };
                     Info: {
                        (options?: cisService.content.library.item.downloadsession.file.Info): cisService.content.library.item.downloadsession.file.Info;
                     };
                  }
               }
               TransferStatus: {
                  "WAITING_FOR_TRANSFER": string;
                  "TRANSFERRING": string;
                  "READY": string;
                  "VALIDATING": string;
                  "ERROR": string;
               };
               TransferEndpoint: {
                  (options?: cisService.content.library.item.TransferEndpoint): cisService.content.library.item.TransferEndpoint;
               };
               UpdateSessionModel: {
                  (options?: cisService.content.library.item.UpdateSessionModel): cisService.content.library.item.UpdateSessionModel;
                  State: {
                     "ACTIVE": string;
                     "DONE": string;
                     "ERROR": string;
                     "CANCELED": string;
                  }
               };
               DownloadSessionModel: {
                  (options?: cisService.content.library.item.DownloadSessionModel): cisService.content.library.item.DownloadSessionModel;
                  State: {
                     "ACTIVE": string;
                     "CANCELED": string;
                     "ERROR": string;
                  }
               };
               FindSpec: {
                  (options?: cisService.content.library.item.FindSpec): cisService.content.library.item.FindSpec;
               };
            }
            subscribedItem: {
               evict(libraryItemId: string): Promise<void>;
               sync(libraryItemId: string, forceSyncContent: boolean): Promise<void>;
            }
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            list(): Promise<Array<string>>;
            find(spec: cisService.content.library.FindSpec): Promise<Array<string>>;
            SubscriptionInfo: {
               (options?: cisService.content.library.SubscriptionInfo): cisService.content.library.SubscriptionInfo;
               AuthenticationMethod: {
                  "BASIC": string;
                  "NONE": string;
               }
            };
            ItemModel: {
               (options?: cisService.content.library.ItemModel): cisService.content.library.ItemModel;
            };
            StorageBacking: {
               (options?: cisService.content.library.StorageBacking): cisService.content.library.StorageBacking;
               Type: {
                  "DATASTORE": string;
                  "OTHER": string;
               }
            };
            PublishInfo: {
               (options?: cisService.content.library.PublishInfo): cisService.content.library.PublishInfo;
               AuthenticationMethod: {
                  "BASIC": string;
                  "NONE": string;
               }
            };
            FindSpec: {
               (options?: cisService.content.library.FindSpec): cisService.content.library.FindSpec;
            };
         }
         diagnostics: {
            clsDiagnosticService: {
               clear(opId: string): Promise<void>;
               testVirtualCenterConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               garbageCollect(): Promise<void>;
               get(opId: string): Promise<cisService.content.diagnostics.model.ApiCallDiagnostics>;
               testEcho(msg: string): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               testDatabaseConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               clearAll(): Promise<void>;
               list(): Promise<{ [K: string]: cisService.content.diagnostics.model.SampledValue }>;
               testComponentManagerConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               testInventoryServiceConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               getDiagnosticsValues(): Promise<string>;
               testActivityFramework(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               TestResult: {
                  (options?: cisService.content.diagnostics.clsDiagnosticService.TestResult): cisService.content.diagnostics.clsDiagnosticService.TestResult;
               };
            }
            model: {
               ApiCallDiagnostics: {
                  (options?: cisService.content.diagnostics.model.ApiCallDiagnostics): cisService.content.diagnostics.model.ApiCallDiagnostics;
               };
               SampledValue: {
                  (options?: cisService.content.diagnostics.model.SampledValue): cisService.content.diagnostics.model.SampledValue;
               };
               Sample: {
                  (options?: cisService.content.diagnostics.model.Sample): cisService.content.diagnostics.model.Sample;
               };
            }
         }
         clsConfigurationService: {
            get(configName: string): Promise<string>;
            set(configName: string, configValue: string): Promise<void>;
            list(): Promise<{ [K: string]: string }>;
         }
         clsStressService: {
            get(key: string): Promise<string>;
            set(key: string, value: string): Promise<void>;
            reset(): Promise<void>;
            setAll(settings: { [K: string]: string }): Promise<void>;
            getAll(): Promise<{ [K: string]: string }>;
         }
         type: {
            list(): Promise<Array<cisService.content.type.Info>>;
            ovf: {
               policy: {
                  StoragePolicyGroup: {
                     (options?: cisService.content.type.ovf.policy.StoragePolicyGroup): cisService.content.type.ovf.policy.StoragePolicyGroup;
                  };
                  StoragePolicy: {
                     (options?: cisService.content.type.ovf.policy.StoragePolicy): cisService.content.type.ovf.policy.StoragePolicy;
                  };
               }
               VideoCard: {
                  (options?: cisService.content.type.ovf.VideoCard): cisService.content.type.ovf.VideoCard;
               };
               VAppTemplate: {
                  (options?: cisService.content.type.ovf.VAppTemplate): cisService.content.type.ovf.VAppTemplate;
               };
               USBController: {
                  (options?: cisService.content.type.ovf.USBController): cisService.content.type.ovf.USBController;
               };
               Cpu: {
                  (options?: cisService.content.type.ovf.Cpu): cisService.content.type.ovf.Cpu;
               };
               DiskController: {
                  (options?: cisService.content.type.ovf.DiskController): cisService.content.type.ovf.DiskController;
               };
               Nic: {
                  (options?: cisService.content.type.ovf.Nic): cisService.content.type.ovf.Nic;
               };
               Drive: {
                  (options?: cisService.content.type.ovf.Drive): cisService.content.type.ovf.Drive;
               };
               Memory: {
                  (options?: cisService.content.type.ovf.Memory): cisService.content.type.ovf.Memory;
               };
               VmTemplate: {
                  (options?: cisService.content.type.ovf.VmTemplate): cisService.content.type.ovf.VmTemplate;
               };
               Floppy: {
                  (options?: cisService.content.type.ovf.Floppy): cisService.content.type.ovf.Floppy;
               };
               OvfTemplate: {
                  (options?: cisService.content.type.ovf.OvfTemplate): cisService.content.type.ovf.OvfTemplate;
               };
               Disk: {
                  (options?: cisService.content.type.ovf.Disk): cisService.content.type.ovf.Disk;
               };
               Network: {
                  (options?: cisService.content.type.ovf.Network): cisService.content.type.ovf.Network;
               };
            }
            Info: {
               (options?: cisService.content.type.Info): cisService.content.type.Info;
            };
         }
         invQueryService: {
            synchronizedQuery(id: string, bindingClass: string): Promise<Array<cisService.builtin.DYNAMICSTRUCTURE>>;
            queryXml(id: string, bindingClass: string): Promise<string>;
            query(id: string, bindingClass: string): Promise<Array<cisService.builtin.DYNAMICSTRUCTURE>>;
            synchronizedQueryXml(id: string, bindingClass: string): Promise<string>;
            ChangeTypeEnum: {
               "CREATE": string;
               "MODIFY": string;
               "DELETE": string;
            };
         }
         subscribedLibrary: {
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            evict(libraryId: string): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            sync(libraryId: string): Promise<void>;
            delete(libraryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(clientToken: string, createSpec: cisService.content.LibraryModel): Promise<string>;
            probe(subscriptionInfo: cisService.content.library.SubscriptionInfo): Promise<cisService.content.subscribedLibrary.ProbeResult>;
            ProbeResult: {
               (options?: cisService.content.subscribedLibrary.ProbeResult): cisService.content.subscribedLibrary.ProbeResult;
               Status: {
                  "SUCCESS": string;
                  "INVALID_URL": string;
                  "TIMED_OUT": string;
                  "HOST_NOT_FOUND": string;
                  "RESOURCE_NOT_FOUND": string;
                  "INVALID_CREDENTIALS": string;
                  "CERTIFICATE_ERROR": string;
                  "UNKNOWN_ERROR": string;
               }
            };
         }
         localLibrary: {
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            delete(libraryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(clientToken: string, createSpec: cisService.content.LibraryModel): Promise<string>;
         }
         configuration: {
            update(model: cisService.content.ConfigurationModel): Promise<void>;
            get(): Promise<cisService.content.ConfigurationModel>;
         }
         clsActivationService: {
            cancel(activationId: string): Promise<void>;
         }
         ConfigurationModel: {
            (options?: cisService.content.ConfigurationModel): cisService.content.ConfigurationModel;
         };
         LibraryModel: {
            (options?: cisService.content.LibraryModel): cisService.content.LibraryModel;
            LibraryType: {
               "LOCAL": string;
               "SUBSCRIBED": string;
            }
         };
      }
      ovf: {
         importSession: {
            createForResourcePool(clientToken: string, resourcePool: string, hostSystem: string, folder: string, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
            instantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<void>;
            get(id: string): Promise<cisService.ovf.importSession.Info>;
            delete(id: string): Promise<void>;
            tryInstantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<cisService.ovf.importSession.OvfValidationResult>;
            State: {
               "IMPORT_OVF_TRANSFER": string;
               "IMPORT_MSG_BUNDLES_TRANSFER": string;
               "IMPORT_SELECTING_OVF_PARAMS": string;
               "IMPORT_FILE_TRANSFER": string;
               "IMPORT_INSTANTIATING": string;
               "IMPORT_COMPLETED": string;
               "IMPORT_ERROR": string;
            };
            SourceType: {
               "PUSH_SOURCE": string;
               "PULL_SOURCE": string;
               "CONTENT_LIBRARY_SOURCE": string;
            };
            CreateSpec: {
               (options?: cisService.ovf.importSession.CreateSpec): cisService.ovf.importSession.CreateSpec;
            };
            OvfValidationResult: {
               (options?: cisService.ovf.importSession.OvfValidationResult): cisService.ovf.importSession.OvfValidationResult;
            };
            Info: {
               (options?: cisService.ovf.importSession.Info): cisService.ovf.importSession.Info;
            };
         }
         exportSession: {
            progress(id: string, percent: number): Promise<void>;
            preview(source: cisService.ovf.exportSession.SourceInfo, previewSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<cisService.ovf.exportSession.Preview>;
            get(id: string): Promise<cisService.ovf.exportSession.Info>;
            delete(id: string): Promise<void>;
            create(clientToken: string, source: cisService.ovf.exportSession.SourceInfo, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
            TargetType: {
               "DOWNLOAD_TARGET": string;
               "CONTENT_LIBRARY_TARGET": string;
            };
            State: {
               "EXPORT_PREPARING": string;
               "EXPORT_READY": string;
               "EXPORT_IN_PROGRESS": string;
               "EXPORT_COMPLETED": string;
               "EXPORT_ERROR": string;
            };
            CreateSpec: {
               (options?: cisService.ovf.exportSession.CreateSpec): cisService.ovf.exportSession.CreateSpec;
            };
            SourceInfo: {
               (options?: cisService.ovf.exportSession.SourceInfo): cisService.ovf.exportSession.SourceInfo;
            };
            PreviewFile: {
               (options?: cisService.ovf.exportSession.PreviewFile): cisService.ovf.exportSession.PreviewFile;
            };
            Info: {
               (options?: cisService.ovf.exportSession.Info): cisService.ovf.exportSession.Info;
            };
            Preview: {
               (options?: cisService.ovf.exportSession.Preview): cisService.ovf.exportSession.Preview;
            };
            PreviewSpec: {
               (options?: cisService.ovf.exportSession.PreviewSpec): cisService.ovf.exportSession.PreviewSpec;
            };
         }
         exportFlag: {
            list(): Promise<Array<cisService.ovf.exportFlag.Info>>;
            Info: {
               (options?: cisService.ovf.exportFlag.Info): cisService.ovf.exportFlag.Info;
            };
         }
         probeImportSession: {
            createProbeImportSession(clientToken: string, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
            get(id: string): Promise<cisService.ovf.probeImportSession.Info>;
            delete(id: string): Promise<void>;
            tryInstantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<cisService.ovf.importSession.OvfValidationResult>;
            State: {
               "PROBE_IMPORT_OVF_TRANSFER": string;
               "PROBE_IMPORT_MSG_BUNDLES_TRANSFER": string;
               "PROBE_IMPORT_SELECTING_OVF_PARAMS": string;
               "PROBE_IMPORT_ERROR": string;
            };
            Info: {
               (options?: cisService.ovf.probeImportSession.Info): cisService.ovf.probeImportSession.Info;
            };
         }
         importFlag: {
            list(rp: string): Promise<Array<cisService.ovf.importFlag.Info>>;
            Info: {
               (options?: cisService.ovf.importFlag.Info): cisService.ovf.importFlag.Info;
            };
         }
         libraryItem: {
            deploy(clientToken: string, ovfLibraryItemId: string, target: cisService.ovf.libraryItem.DeploymentTarget, deploymentSpec: cisService.ovf.libraryItem.ResourcePoolDeploymentSpec): Promise<cisService.ovf.libraryItem.DeploymentResult>;
            create(clientToken: string, source: cisService.ovf.libraryItem.DeployableIdentity, target: cisService.ovf.libraryItem.CreateTarget, createSpec: cisService.ovf.libraryItem.CreateSpec): Promise<cisService.ovf.libraryItem.CreateResult>;
            filter(ovfLibraryItemId: string, target: cisService.ovf.libraryItem.DeploymentTarget): Promise<cisService.ovf.libraryItem.OvfSummary>;
            CreateResult: {
               (options?: cisService.ovf.libraryItem.CreateResult): cisService.ovf.libraryItem.CreateResult;
            };
            DeployableIdentity: {
               (options?: cisService.ovf.libraryItem.DeployableIdentity): cisService.ovf.libraryItem.DeployableIdentity;
            };
            CreateTarget: {
               (options?: cisService.ovf.libraryItem.CreateTarget): cisService.ovf.libraryItem.CreateTarget;
            };
            OvfSummary: {
               (options?: cisService.ovf.libraryItem.OvfSummary): cisService.ovf.libraryItem.OvfSummary;
            };
            DeploymentTarget: {
               (options?: cisService.ovf.libraryItem.DeploymentTarget): cisService.ovf.libraryItem.DeploymentTarget;
            };
            DeploymentResult: {
               (options?: cisService.ovf.libraryItem.DeploymentResult): cisService.ovf.libraryItem.DeploymentResult;
            };
            CreateSpec: {
               (options?: cisService.ovf.libraryItem.CreateSpec): cisService.ovf.libraryItem.CreateSpec;
            };
            ResultInfo: {
               (options?: cisService.ovf.libraryItem.ResultInfo): cisService.ovf.libraryItem.ResultInfo;
            };
            StorageGroupMapping: {
               (options?: cisService.ovf.libraryItem.StorageGroupMapping): cisService.ovf.libraryItem.StorageGroupMapping;
               Type: {
                  "DATASTORE": string;
                  "STORAGE_PROFILE": string;
               }
            };
            ResourcePoolDeploymentSpec: {
               (options?: cisService.ovf.libraryItem.ResourcePoolDeploymentSpec): cisService.ovf.libraryItem.ResourcePoolDeploymentSpec;
            };
         }
         DiskProvisioningType: {
            "thin": string;
            "thick": string;
            "eagerZeroedThick": string;
         };
         DatastoreTarget: {
            (options?: cisService.ovf.DatastoreTarget): cisService.ovf.DatastoreTarget;
            InaccessibleReason: {
               "NOT_CONNECTED": string;
               "MAINTENANCE_MODE": string;
               "READ_ONLY": string;
               "NO_ALLOCATE_RIGHT": string;
            }
         };
         DeploymentOption: {
            (options?: cisService.ovf.DeploymentOption): cisService.ovf.DeploymentOption;
         };
         TargetNetwork: {
            (options?: cisService.ovf.TargetNetwork): cisService.ovf.TargetNetwork;
            InaccessibleReason: {
               "NO_ASSIGN_RIGHT": string;
            }
         };
         StorageProfileTarget: {
            (options?: cisService.ovf.StorageProfileTarget): cisService.ovf.StorageProfileTarget;
         };
         Property: {
            (options?: cisService.ovf.Property): cisService.ovf.Property;
         };
         OvfWarning: {
            (options?: cisService.ovf.OvfWarning): cisService.ovf.OvfWarning;
         };
         SizeParams: {
            (options?: cisService.ovf.SizeParams): cisService.ovf.SizeParams;
         };
         UnknownSectionParams: {
            (options?: cisService.ovf.UnknownSectionParams): cisService.ovf.UnknownSectionParams;
         };
         VcenterExtensionParams: {
            (options?: cisService.ovf.VcenterExtensionParams): cisService.ovf.VcenterExtensionParams;
         };
         OvfInfo: {
            (options?: cisService.ovf.OvfInfo): cisService.ovf.OvfInfo;
         };
         DeploymentOptionParams: {
            (options?: cisService.ovf.DeploymentOptionParams): cisService.ovf.DeploymentOptionParams;
         };
         ExtraConfigParams: {
            (options?: cisService.ovf.ExtraConfigParams): cisService.ovf.ExtraConfigParams;
         };
         IpAllocationParams: {
            (options?: cisService.ovf.IpAllocationParams): cisService.ovf.IpAllocationParams;
            IpAllocationScheme: {
               "DHCP": string;
               "OVF_ENVIRONMENT": string;
            }
            IpProtocol: {
               "IPV4": string;
               "IPV6": string;
            }
            IpAllocationPolicy: {
               "DHCP": string;
               "TRANSIENT_IPPOOL": string;
               "STATIC_MANUAL": string;
               "STATIC_IPPOOL": string;
            }
         };
         DatastoreDiskGroup: {
            (options?: cisService.ovf.DatastoreDiskGroup): cisService.ovf.DatastoreDiskGroup;
         };
         ScaleOutGroup: {
            (options?: cisService.ovf.ScaleOutGroup): cisService.ovf.ScaleOutGroup;
         };
         CertificateParams: {
            (options?: cisService.ovf.CertificateParams): cisService.ovf.CertificateParams;
         };
         NetworkMappingParams: {
            (options?: cisService.ovf.NetworkMappingParams): cisService.ovf.NetworkMappingParams;
         };
         OvfMessage: {
            (options?: cisService.ovf.OvfMessage): cisService.ovf.OvfMessage;
            Category: {
               "VALIDATION": string;
               "INPUT": string;
               "SERVER": string;
            }
         };
         NameAndProductParams: {
            (options?: cisService.ovf.NameAndProductParams): cisService.ovf.NameAndProductParams;
         };
         DatastoreMappingParams: {
            (options?: cisService.ovf.DatastoreMappingParams): cisService.ovf.DatastoreMappingParams;
         };
         OvfError: {
            (options?: cisService.ovf.OvfError): cisService.ovf.OvfError;
         };
         SourceNetwork: {
            (options?: cisService.ovf.SourceNetwork): cisService.ovf.SourceNetwork;
         };
         ScaleOutParams: {
            (options?: cisService.ovf.ScaleOutParams): cisService.ovf.ScaleOutParams;
         };
         ParseIssue: {
            (options?: cisService.ovf.ParseIssue): cisService.ovf.ParseIssue;
            Category: {
               "VALUE_ILLEGAL": string;
               "ATTRIBUTE_REQUIRED": string;
               "ATTRIBUTE_ILLEGAL": string;
               "ELEMENT_REQUIRED": string;
               "ELEMENT_ILLEGAL": string;
               "ELEMENT_UNKNOWN": string;
               "SECTION_UNKNOWN": string;
               "SECTION_RESTRICTION": string;
               "PARSE_ERROR": string;
               "GENERATE_ERROR": string;
               "VALIDATION_ERROR": string;
               "EXPORT_ERROR": string;
               "INTERNAL_ERROR": string;
            }
         };
         PropertyParams: {
            (options?: cisService.ovf.PropertyParams): cisService.ovf.PropertyParams;
         };
         EulaParams: {
            (options?: cisService.ovf.EulaParams): cisService.ovf.EulaParams;
         };
         UnknownSection: {
            (options?: cisService.ovf.UnknownSection): cisService.ovf.UnknownSection;
         };
         OvfParams: {
            (options?: cisService.ovf.OvfParams): cisService.ovf.OvfParams;
         };
         OvfFileInfo: {
            (options?: cisService.ovf.OvfFileInfo): cisService.ovf.OvfFileInfo;
            FileType: {
               "OVF": string;
               "MANIFEST": string;
               "CERT": string;
               "MSG_BUNDLE": string;
               "DISK": string;
               "CONTENT": string;
            }
         };
         StorageMappingParams: {
            (options?: cisService.ovf.StorageMappingParams): cisService.ovf.StorageMappingParams;
         };
         ExtraConfig: {
            (options?: cisService.ovf.ExtraConfig): cisService.ovf.ExtraConfig;
         };
         StorageDiskGroup: {
            (options?: cisService.ovf.StorageDiskGroup): cisService.ovf.StorageDiskGroup;
         };
      }
   }
   namespace cisService {
      interface builtin {
      }
      namespace builtin {
         interface ANYERROR {
            value: string;
         }
         interface BINARY {
            value: string;
         }
         interface BOOLEAN {
            value: string;
         }
         interface DATETIME {
            value: string;
         }
         interface DOUBLE {
            value: string;
         }
         interface DYNAMICSTRUCTURE {
            value: string;
         }
         interface ID {
            value: string;
         }
         interface LONG {
            value: string;
         }
         interface OPAQUE {
            value: string;
         }
         interface SECRET {
            value: string;
         }
         interface STRING {
            value: string;
         }
         interface URI {
            value: string;
         }
         interface VOID {
            value: string;
         }
      }
      interface cis {
         session: cis.session;
      }
      namespace cis {
         interface session {
            get(): Promise<cisService.cis.session.Info>;
            delete(): Promise<void>;
            create(): Promise<string>;
         }
         namespace session {
            interface Info {
               user: string;
               createdTime: Date;
               lastAccessedTime: Date;
            }
         }
      }
      interface tagging {
         sessions: tagging.sessions;
         tag: tagging.tag;
         tagAssociation: tagging.tagAssociation;
         category: tagging.category;
      }
      namespace tagging {
         interface sessions {
            sessionManager: sessions.sessionManager;
         }
         namespace sessions {
            interface sessionManager {
               logout(): Promise<void>;
               keepAlive(): Promise<void>;
               login(): Promise<string>;
            }
            namespace sessionManager {
            }
         }
         interface tag {
            listTagsForCategory(categoryId: string): Promise<Array<string>>;
            update(tagId: string, updateSpec: cisService.tagging.tag.UpdateSpec): Promise<void>;
            listUsedTags(usedByEntity: string): Promise<Array<string>>;
            removeFromUsedBy(tagId: string, usedByEntity: string): Promise<void>;
            get(tagId: string): Promise<cisService.tagging.TagModel>;
            revokePropagatingPermissions(tagId: string): Promise<void>;
            addToUsedBy(tagId: string, usedByEntity: string): Promise<void>;
            delete(tagId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(createSpec: cisService.tagging.tag.CreateSpec): Promise<string>;
         }
         namespace tag {
            interface CreateSpec {
               name: string;
               description: string;
               categoryId: string;
            }
            interface UpdateSpec {
               name?: string;
               description?: string;
            }
         }
         interface tagAssociation {
            detach(tagId: string, objectId: cisService.vapi.std.DynamicID): Promise<void>;
            listAttachedTags(objectId: cisService.vapi.std.DynamicID): Promise<Array<string>>;
            attach(tagId: string, objectId: cisService.vapi.std.DynamicID): Promise<void>;
            listAttachableTags(objectId: cisService.vapi.std.DynamicID): Promise<Array<string>>;
            listAttachedObjects(tagId: string): Promise<Array<cisService.vapi.std.DynamicID>>;
         }
         namespace tagAssociation {
         }
         interface category {
            listUsedCategories(usedByEntity: string): Promise<Array<string>>;
            update(categoryId: string, updateSpec: cisService.tagging.category.UpdateSpec): Promise<void>;
            removeFromUsedBy(categoryId: string, usedByEntity: string): Promise<void>;
            get(categoryId: string): Promise<cisService.tagging.CategoryModel>;
            revokePropagatingPermissions(categoryId: string): Promise<void>;
            addToUsedBy(categoryId: string, usedByEntity: string): Promise<void>;
            delete(categoryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(createSpec: cisService.tagging.category.CreateSpec): Promise<string>;
         }
         namespace category {
            interface CreateSpec {
               name: string;
               description: string;
               cardinality: cisService.tagging.CategoryModel.Cardinality;
               associableTypes: Array<string>;
            }
            interface UpdateSpec {
               name?: string;
               description?: string;
               cardinality?: cisService.tagging.CategoryModel.Cardinality;
               associableTypes?: Array<string>;
            }
         }
         interface CategoryModel {
            id: string;
            name: string;
            description: string;
            cardinality: cisService.tagging.CategoryModel.Cardinality;
            associableTypes: Array<string>;
            usedBy: Array<string>;
         }
         namespace CategoryModel {
            enum Cardinality {
               "SINGLE", "MULTIPLE"
            }
         }
         interface TagModel {
            id: string;
            categoryId: string;
            name: string;
            description: string;
            usedBy: Array<string>;
         }
      }
      interface vapi {
         metadata: vapi.metadata;
         std: vapi.std;
      }
      namespace vapi {
         interface metadata {
            privilege: metadata.privilege;
            metamodel: metadata.metamodel;
            cli: metadata.cli;
            authentication: metadata.authentication;
         }
         namespace metadata {
            interface privilege {
               service: privilege.service;
               component: privilege.component;
               package: privilege.package;
            }
            namespace privilege {
               interface service {
                  get(serviceId: string): Promise<cisService.vapi.metadata.privilege.ServiceInfo>;
                  list(): Promise<Array<string>>;
                  operation: service.operation;
               }
               namespace service {
                  interface operation {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.privilege.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
                  namespace operation {
                  }
               }
               interface component {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.privilege.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               namespace component {
               }
               interface package {
                  get(packageId: string): Promise<cisService.vapi.metadata.privilege.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace package {
               }
               interface ServiceInfo {
                  operations: { [K: string]: cisService.vapi.metadata.privilege.OperationInfo };
               }
               interface ComponentInfo {
                  packages: { [K: string]: cisService.vapi.metadata.privilege.PackageInfo };
               }
               interface PrivilegeInfo {
                  propertyPath: string;
                  privileges: Array<string>;
               }
               interface ComponentData {
                  info: cisService.vapi.metadata.privilege.ComponentInfo;
                  fingerprint: string;
               }
               interface OperationInfo {
                  privileges: Array<string>;
                  privilegeInfo: Array<cisService.vapi.metadata.privilege.PrivilegeInfo>;
               }
               interface PackageInfo {
                  privileges: Array<string>;
                  services: { [K: string]: cisService.vapi.metadata.privilege.ServiceInfo };
               }
            }
            interface metamodel {
               service: metamodel.service;
               resource: metamodel.resource;
               package: metamodel.package;
               component: metamodel.component;
               structure: metamodel.structure;
               enumeration: metamodel.enumeration;
            }
            namespace metamodel {
               interface service {
                  operation: service.operation;
                  get(serviceId: string): Promise<cisService.vapi.metadata.metamodel.ServiceInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace service {
                  interface operation {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.metamodel.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
                  namespace operation {
                  }
               }
               interface resource {
                  model: resource.model;
                  list(): Promise<Array<string>>;
               }
               namespace resource {
                  interface model {
                     list(resourceId: string): Promise<Array<string>>;
                  }
                  namespace model {
                  }
               }
               interface package {
                  get(packageId: string): Promise<cisService.vapi.metadata.metamodel.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace package {
               }
               interface component {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.metamodel.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               namespace component {
               }
               interface structure {
                  get(structureId: string): Promise<cisService.vapi.metadata.metamodel.StructureInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace structure {
               }
               interface enumeration {
                  get(enumerationId: string): Promise<cisService.vapi.metadata.metamodel.EnumerationInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace enumeration {
               }
               interface ElementMap {
                  elements: { [K: string]: cisService.vapi.metadata.metamodel.ElementValue };
               }
               interface ComponentInfo {
                  name: string;
                  packages: { [K: string]: cisService.vapi.metadata.metamodel.PackageInfo };
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface PackageInfo {
                  name: string;
                  structures: { [K: string]: cisService.vapi.metadata.metamodel.StructureInfo };
                  enumerations: { [K: string]: cisService.vapi.metadata.metamodel.EnumerationInfo };
                  services: { [K: string]: cisService.vapi.metadata.metamodel.ServiceInfo };
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface GenericInstantiation {
                  genericType: cisService.vapi.metadata.metamodel.GenericInstantiation.GenericType;
                  elementType?: cisService.vapi.metadata.metamodel.Type;
                  mapKeyType?: cisService.vapi.metadata.metamodel.Type;
                  mapValueType?: cisService.vapi.metadata.metamodel.Type;
               }
               namespace GenericInstantiation {
                  enum GenericType {
                     "LIST", "MAP", "OPTIONAL", "SET"
                  }
               }
               interface FieldInfo {
                  name: string;
                  type: cisService.vapi.metadata.metamodel.Type;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface ServiceInfo {
                  name: string;
                  operations: { [K: string]: cisService.vapi.metadata.metamodel.OperationInfo };
                  structures: { [K: string]: cisService.vapi.metadata.metamodel.StructureInfo };
                  enumerations: { [K: string]: cisService.vapi.metadata.metamodel.EnumerationInfo };
                  constants: { [K: string]: cisService.vapi.metadata.metamodel.ConstantInfo };
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface OperationResultInfo {
                  type: cisService.vapi.metadata.metamodel.Type;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface ConstantInfo {
                  type: cisService.vapi.metadata.metamodel.Type;
                  value: cisService.vapi.metadata.metamodel.ConstantValue;
                  documentation: string;
               }
               interface ConstantValue {
                  category: cisService.vapi.metadata.metamodel.ConstantValue.Category;
                  primitiveValue?: cisService.vapi.metadata.metamodel.PrimitiveValue;
                  listValue?: Array<cisService.vapi.metadata.metamodel.PrimitiveValue>;
               }
               namespace ConstantValue {
                  enum Category {
                     "PRIMITIVE", "LIST"
                  }
               }
               interface ComponentData {
                  info: cisService.vapi.metadata.metamodel.ComponentInfo;
                  fingerprint: string;
               }
               interface EnumerationValueInfo {
                  value: string;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface ErrorInfo {
                  structureId: string;
                  documentation: string;
               }
               interface StructureInfo {
                  name: string;
                  type: cisService.vapi.metadata.metamodel.StructureInfo.Type;
                  enumerations: { [K: string]: cisService.vapi.metadata.metamodel.EnumerationInfo };
                  constants: { [K: string]: cisService.vapi.metadata.metamodel.ConstantInfo };
                  fields: Array<cisService.vapi.metadata.metamodel.FieldInfo>;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               namespace StructureInfo {
                  enum Type {
                     "STRUCTURE", "ERROR"
                  }
               }
               interface ElementValue {
                  type: cisService.vapi.metadata.metamodel.ElementValue.Type;
                  longValue?: number;
                  stringValue?: string;
                  listValue?: Array<string>;
                  structureId?: string;
                  structureIds?: Array<string>;
               }
               namespace ElementValue {
                  enum Type {
                     "LONG", "STRING", "STRING_LIST", "STRUCTURE_REFERENCE", "STRUCTURE_REFERENCE_LIST"
                  }
               }
               interface EnumerationInfo {
                  name: string;
                  values: Array<cisService.vapi.metadata.metamodel.EnumerationValueInfo>;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface Type {
                  category: cisService.vapi.metadata.metamodel.Type.Category;
                  builtinType?: cisService.vapi.metadata.metamodel.Type.BuiltinType;
                  userDefinedType?: cisService.vapi.metadata.metamodel.UserDefinedType;
                  genericInstantiation?: cisService.vapi.metadata.metamodel.GenericInstantiation;
               }
               namespace Type {
                  enum Category {
                     "BUILTIN", "USER_DEFINED", "GENERIC"
                  }
                  enum BuiltinType {
                     "VOID", "BOOLEAN", "LONG", "DOUBLE", "STRING", "BINARY", "SECRET", "DATE_TIME", "ID", "URI", "ANY_ERROR", "DYNAMIC_STRUCTURE", "OPAQUE"
                  }
               }
               interface OperationInfo {
                  name: string;
                  params: Array<cisService.vapi.metadata.metamodel.FieldInfo>;
                  output: cisService.vapi.metadata.metamodel.OperationResultInfo;
                  errors: Array<cisService.vapi.metadata.metamodel.ErrorInfo>;
                  metadata: { [K: string]: cisService.vapi.metadata.metamodel.ElementMap };
                  documentation: string;
               }
               interface UserDefinedType {
                  resourceType: string;
                  resourceId: string;
               }
               interface PrimitiveValue {
                  type: cisService.vapi.metadata.metamodel.PrimitiveValue.Type;
                  booleanValue?: boolean;
                  doubleValue?: number;
                  longValue?: number;
                  stringValue?: string;
               }
               namespace PrimitiveValue {
                  enum Type {
                     "BOOLEAN", "DOUBLE", "LONG", "STRING"
                  }
               }
            }
            interface cli {
               command: cli.command;
               namespace: cli.namespace;
            }
            namespace cli {
               interface command {
                  fingerprint(): Promise<string>;
                  get(identity: cisService.vapi.metadata.cli.command.Identity): Promise<cisService.vapi.metadata.cli.command.Info>;
                  list(path: string): Promise<Array<cisService.vapi.metadata.cli.command.Identity>>;
               }
               namespace command {
                  enum FormatterType {
                     "SIMPLE",
                     "TABLE",
                     "JSON",
                     "XML",
                     "CSV",
                     "HTML",
                  }
                  enum GenericType {
                     "NONE",
                     "OPTIONAL",
                     "LIST",
                  }
                  interface OptionInfo {
                     longOption: string;
                     shortOption?: string;
                     fieldName: string;
                     description: string;
                     type: string;
                     generic: cisService.vapi.metadata.cli.command.GenericType;
                  }
                  interface Info {
                     identity: cisService.vapi.metadata.cli.command.Identity;
                     description: string;
                     serviceId: string;
                     operationId: string;
                     options: Array<cisService.vapi.metadata.cli.command.OptionInfo>;
                     formatter?: cisService.vapi.metadata.cli.command.FormatterType;
                     outputFieldList: Array<cisService.vapi.metadata.cli.command.OutputInfo>;
                  }
                  interface OutputInfo {
                     structureId: string;
                     outputFields: Array<cisService.vapi.metadata.cli.command.OutputFieldInfo>;
                  }
                  interface OutputFieldInfo {
                     fieldName: string;
                     displayName: string;
                  }
                  interface Identity {
                     path: string;
                     name: string;
                  }
               }
               interface namespace {
                  fingerprint(): Promise<string>;
                  get(identity: cisService.vapi.metadata.cli.namespace.Identity): Promise<cisService.vapi.metadata.cli.namespace.Info>;
                  list(): Promise<Array<cisService.vapi.metadata.cli.namespace.Identity>>;
               }
               namespace namespace {
                  interface Identity {
                     path: string;
                     name: string;
                  }
                  interface Info {
                     identity: cisService.vapi.metadata.cli.namespace.Identity;
                     description: string;
                     children: Array<cisService.vapi.metadata.cli.namespace.Identity>;
                  }
               }
            }
            interface authentication {
               service: authentication.service;
               package: authentication.package;
               component: authentication.component;
            }
            namespace authentication {
               interface service {
                  operation: service.operation;
                  get(serviceId: string): Promise<cisService.vapi.metadata.authentication.ServiceInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace service {
                  interface operation {
                     get(serviceId: string, operationId: string): Promise<cisService.vapi.metadata.authentication.OperationInfo>;
                     list(serviceId: string): Promise<Array<string>>;
                  }
                  namespace operation {
                  }
               }
               interface package {
                  get(packageId: string): Promise<cisService.vapi.metadata.authentication.PackageInfo>;
                  list(): Promise<Array<string>>;
               }
               namespace package {
               }
               interface component {
                  fingerprint(componentId: string): Promise<string>;
                  get(componentId: string): Promise<cisService.vapi.metadata.authentication.ComponentData>;
                  list(): Promise<Array<string>>;
               }
               namespace component {
               }
               interface PackageInfo {
                  schemes: Array<cisService.vapi.metadata.authentication.AuthenticationInfo>;
                  services: { [K: string]: cisService.vapi.metadata.authentication.ServiceInfo };
               }
               interface AuthenticationInfo {
                  schemeType: cisService.vapi.metadata.authentication.AuthenticationInfo.SchemeType;
                  sessionManager?: string;
                  scheme: string;
               }
               namespace AuthenticationInfo {
                  enum SchemeType {
                     "SESSIONLESS", "SESSION_AWARE"
                  }
               }
               interface ComponentInfo {
                  packages: { [K: string]: cisService.vapi.metadata.authentication.PackageInfo };
               }
               interface ComponentData {
                  info: cisService.vapi.metadata.authentication.ComponentInfo;
                  fingerprint: string;
               }
               interface OperationInfo {
                  schemes: Array<cisService.vapi.metadata.authentication.AuthenticationInfo>;
               }
               interface ServiceInfo {
                  schemes: Array<cisService.vapi.metadata.authentication.AuthenticationInfo>;
                  operations: { [K: string]: cisService.vapi.metadata.authentication.OperationInfo };
               }
            }
            enum SourceType {
               "FILE",
               "REMOTE",
            }
            interface SourceInfo {
               type: cisService.vapi.metadata.SourceType;
               fileName?: string;
               remoteAddr?: string;
               msgProtocol?: string;
            }
            interface SourceCreateSpec {
               description: string;
               type: cisService.vapi.metadata.SourceType;
               filepath?: string;
               address?: string;
            }
         }
         interface std {
            errors: std.errors;
         }
         namespace std {
            interface DynamicID {
               type: string;
               id: string;
            }
            interface AuthenticationScheme {
               SAML_HOK_TOKEN: string;
               SESSION_ID: string;
               SAML_BEARER_TOKEN: string;
               USER_PASSWORD: string;
               NO_AUTHENTICATION: string;
            }
            interface LocalizableMessage {
               id: string;
               defaultMessage: string;
               args: Array<string>;
            }
            interface errors {
            }
            namespace errors {
               interface UnableToAllocateResource {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface NotFound {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface Unauthenticated {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface AlreadyInDesiredState {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface FeatureInUse {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface OperationNotFound {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface ServiceUnavailable {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface InternalServerError {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface ConcurrentChange {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface InvalidElementConfiguration {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface Error {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface AlreadyExists {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface ResourceInaccessible {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface InvalidElementType {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface FileLocations {
                  primary: string;
                  secondary: Array<string>;
               }
               interface TimedOut {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface ResourceBusy {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface TransientIndication {
                  isTransient: boolean;
               }
               interface Unauthorized {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface NotAllowedInCurrentState {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface ArgumentLocations {
                  primary: string;
                  secondary: Array<string>;
               }
               interface ResourceInUse {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface InvalidArgument {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface Unsupported {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface UnexpectedInput {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface InvalidRequest {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
               interface Canceled {
                  messages: Array<cisService.vapi.std.LocalizableMessage>;
                  data?: cisService.builtin.DYNAMICSTRUCTURE;
               }
            }
         }
      }
      interface content {
         library: content.library;
         diagnostics: content.diagnostics;
         clsConfigurationService: content.clsConfigurationService;
         clsStressService: content.clsStressService;
         type: content.type;
         invQueryService: content.invQueryService;
         subscribedLibrary: content.subscribedLibrary;
         localLibrary: content.localLibrary;
         configuration: content.configuration;
         clsActivationService: content.clsActivationService;
      }
      namespace content {
         interface library {
            item: library.item;
            subscribedItem: library.subscribedItem;
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            list(): Promise<Array<string>>;
            find(spec: cisService.content.library.FindSpec): Promise<Array<string>>;
         }
         namespace library {
            interface item {
               updatesession: item.updatesession;
               file: item.file;
               downloadSession: item.downloadSession;
               updateSession: item.updateSession;
               storage: item.storage;
               metadata: item.metadata;
               update(libraryItemId: string, updateSpec: cisService.content.library.ItemModel): Promise<void>;
               get(libraryItemId: string): Promise<cisService.content.library.ItemModel>;
               delete(libraryItemId: string): Promise<void>;
               list(libraryId: string): Promise<Array<string>>;
               create(clientToken: string, createSpec: cisService.content.library.ItemModel): Promise<string>;
               find(spec: cisService.content.library.item.FindSpec): Promise<Array<string>>;
               copy(clientToken: string, sourceLibraryItemId: string, destinationCreateSpec: cisService.content.library.ItemModel): Promise<string>;
               downloadsession: item.downloadsession;
            }
            namespace item {
               interface updatesession {
                  file: updatesession.file;
               }
               namespace updatesession {
                  interface file {
                     get(updateSessionId: string, fileName: string): Promise<cisService.content.library.item.updatesession.file.Info>;
                     remove(updateSessionId: string, fileName: string): Promise<void>;
                     list(updateSessionId: string): Promise<Array<cisService.content.library.item.updatesession.file.Info>>;
                     add(updateSessionId: string, fileSpec: cisService.content.library.item.updatesession.file.AddSpec): Promise<cisService.content.library.item.updatesession.file.Info>;
                     validate(updateSessionId: string): Promise<cisService.content.library.item.updatesession.file.ValidationResult>;
                  }
                  namespace file {
                     enum SourceType {
                        "NONE",
                        "PUSH",
                        "PULL",
                     }
                     interface ValidationResult {
                        hasErrors: boolean;
                        missingFiles: Array<string>;
                        invalidFiles: Array<cisService.content.library.item.updatesession.file.ValidationError>;
                     }
                     interface Info {
                        name: string;
                        sourceType: cisService.content.library.item.updatesession.file.SourceType;
                        size?: number;
                        checksumInfo?: cisService.content.library.item.file.ChecksumInfo;
                        sourceEndpoint?: cisService.content.library.item.TransferEndpoint;
                        uploadEndpoint?: cisService.content.library.item.TransferEndpoint;
                        bytesTransferred: number;
                        status: cisService.content.library.item.TransferStatus;
                        errorMessage?: cisService.vapi.std.LocalizableMessage;
                     }
                     interface AddSpec {
                        name: string;
                        sourceType: cisService.content.library.item.updatesession.file.SourceType;
                        sourceEndpoint?: cisService.content.library.item.TransferEndpoint;
                        size?: number;
                        checksumInfo?: cisService.content.library.item.file.ChecksumInfo;
                     }
                     interface ValidationError {
                        name: string;
                        errorMessage: cisService.vapi.std.LocalizableMessage;
                     }
                  }
               }
               interface file {
                  get(libraryItemId: string, name: string): Promise<cisService.content.library.item.file.Info>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.file.Info>>;
               }
               namespace file {
                  enum ChecksumAlgorithm {
                     "SHA1",
                     "MD5",
                  }
                  interface ChecksumInfo {
                     algorithm?: cisService.content.library.item.file.ChecksumAlgorithm;
                     checksum: string;
                  }
                  interface Info {
                     checksumInfo?: cisService.content.library.item.file.ChecksumInfo;
                     name: string;
                     size: number;
                     cached: boolean;
                     version: string;
                  }
               }
               interface downloadSession {
                  fail(downloadSessionId: string, clientErrorMessage: string): Promise<void>;
                  get(downloadSessionId: string): Promise<cisService.content.library.item.DownloadSessionModel>;
                  delete(downloadSessionId: string): Promise<void>;
                  keepAlive(downloadSessionId: string, progress: number): Promise<void>;
                  cancel(downloadSessionId: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<string>>;
                  create(clientToken: string, createSpec: cisService.content.library.item.DownloadSessionModel): Promise<string>;
               }
               namespace downloadSession {
               }
               interface updateSession {
                  fail(updateSessionId: string, clientErrorMessage: string): Promise<void>;
                  get(updateSessionId: string): Promise<cisService.content.library.item.UpdateSessionModel>;
                  complete(updateSessionId: string): Promise<void>;
                  delete(updateSessionId: string): Promise<void>;
                  keepAlive(updateSessionId: string, clientProgress: number): Promise<void>;
                  cancel(updateSessionId: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<string>>;
                  create(clientToken: string, createSpec: cisService.content.library.item.UpdateSessionModel): Promise<string>;
               }
               namespace updateSession {
               }
               interface storage {
                  get(libraryItemId: string, fileName: string): Promise<Array<cisService.content.library.item.storage.Info>>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.storage.Info>>;
               }
               namespace storage {
                  interface Info {
                     storageBacking: cisService.content.library.StorageBacking;
                     storageUris: Array<string>;
                     checksumInfo?: cisService.content.library.item.file.ChecksumInfo;
                     name: string;
                     size: number;
                     cached: boolean;
                     version: string;
                  }
               }
               interface metadata {
                  get(libraryItemId: string, key: string): Promise<string>;
                  delete(libraryItemId: string, key: string): Promise<void>;
                  list(libraryItemId: string): Promise<Array<cisService.content.library.item.metadata.Info>>;
                  create(libraryItemId: string, key: string, value: string): Promise<void>;
               }
               namespace metadata {
                  interface Info {
                     key: string;
                     value?: string;
                  }
               }
               interface downloadsession {
                  file: downloadsession.file;
               }
               namespace downloadsession {
                  interface file {
                     get(downloadSessionId: string, fileName: string): Promise<cisService.content.library.item.downloadsession.file.Info>;
                     list(downloadSessionId: string): Promise<Array<cisService.content.library.item.downloadsession.file.Info>>;
                     prepare(downloadSessionId: string, fileName: string, endpointType: cisService.content.library.item.downloadsession.file.EndpointType): Promise<cisService.content.library.item.downloadsession.file.Info>;
                  }
                  namespace file {
                     enum PrepareStatus {
                        "UNPREPARED",
                        "PREPARE_REQUESTED",
                        "PREPARING",
                        "PREPARED",
                        "ERROR",
                     }
                     enum EndpointType {
                        "HTTPS",
                        "DIRECT",
                     }
                     interface Info {
                        name: string;
                        size?: number;
                        bytesTransferred: number;
                        status: cisService.content.library.item.downloadsession.file.PrepareStatus;
                        downloadEndpoint?: cisService.content.library.item.TransferEndpoint;
                        checksumInfo?: cisService.content.library.item.file.ChecksumInfo;
                        errorMessage?: cisService.vapi.std.LocalizableMessage;
                     }
                  }
               }
               enum TransferStatus {
                  "WAITING_FOR_TRANSFER",
                  "TRANSFERRING",
                  "READY",
                  "VALIDATING",
                  "ERROR",
               }
               interface TransferEndpoint {
                  uri: string;
                  sslCertificateThumbprint?: string;
               }
               interface UpdateSessionModel {
                  id?: string;
                  libraryItemId?: string;
                  libraryItemContentVersion?: string;
                  errorMessage?: cisService.vapi.std.LocalizableMessage;
                  clientProgress?: number;
                  state?: cisService.content.library.item.UpdateSessionModel.State;
                  expirationTime?: Date;
               }
               namespace UpdateSessionModel {
                  enum State {
                     "ACTIVE", "DONE", "ERROR", "CANCELED"
                  }
               }
               interface DownloadSessionModel {
                  id?: string;
                  libraryItemId?: string;
                  libraryItemContentVersion?: string;
                  errorMessage?: cisService.vapi.std.LocalizableMessage;
                  clientProgress?: number;
                  state?: cisService.content.library.item.DownloadSessionModel.State;
                  expirationTime?: Date;
               }
               namespace DownloadSessionModel {
                  enum State {
                     "ACTIVE", "CANCELED", "ERROR"
                  }
               }
               interface FindSpec {
                  name?: string;
                  libraryId?: string;
                  sourceId?: string;
                  type?: string;
                  cached?: boolean;
               }
            }
            interface subscribedItem {
               evict(libraryItemId: string): Promise<void>;
               sync(libraryItemId: string, forceSyncContent: boolean): Promise<void>;
            }
            namespace subscribedItem {
            }
            interface SubscriptionInfo {
               authenticationMethod?: cisService.content.library.SubscriptionInfo.AuthenticationMethod;
               automaticSyncEnabled?: boolean;
               onDemand?: boolean;
               password?: string;
               sslThumbprint?: string;
               subscriptionUrl?: string;
               userName?: string;
            }
            namespace SubscriptionInfo {
               enum AuthenticationMethod {
                  "BASIC", "NONE"
               }
            }
            interface ItemModel {
               id?: string;
               libraryId?: string;
               contentVersion?: string;
               creationTime?: Date;
               description?: string;
               lastModifiedTime?: Date;
               lastSyncTime?: Date;
               metadataVersion?: string;
               name?: string;
               cached?: boolean;
               size?: number;
               type?: string;
               version?: string;
               sourceId?: string;
            }
            interface StorageBacking {
               type?: cisService.content.library.StorageBacking.Type;
               datastoreId?: string;
               storageUri?: string;
            }
            namespace StorageBacking {
               enum Type {
                  "DATASTORE", "OTHER"
               }
            }
            interface PublishInfo {
               authenticationMethod?: cisService.content.library.PublishInfo.AuthenticationMethod;
               published?: boolean;
               publishUrl?: string;
               userName?: string;
               password?: string;
               persistJsonEnabled?: boolean;
            }
            namespace PublishInfo {
               enum AuthenticationMethod {
                  "BASIC", "NONE"
               }
            }
            interface FindSpec {
               name?: string;
               type?: cisService.content.LibraryModel.LibraryType;
            }
         }
         interface diagnostics {
            clsDiagnosticService: diagnostics.clsDiagnosticService;
            model: diagnostics.model;
         }
         namespace diagnostics {
            interface clsDiagnosticService {
               clear(opId: string): Promise<void>;
               testVirtualCenterConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               garbageCollect(): Promise<void>;
               get(opId: string): Promise<cisService.content.diagnostics.model.ApiCallDiagnostics>;
               testEcho(msg: string): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               testDatabaseConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               clearAll(): Promise<void>;
               list(): Promise<{ [K: string]: cisService.content.diagnostics.model.SampledValue }>;
               testComponentManagerConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               testInventoryServiceConnectivity(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
               getDiagnosticsValues(): Promise<string>;
               testActivityFramework(): Promise<cisService.content.diagnostics.clsDiagnosticService.TestResult>;
            }
            namespace clsDiagnosticService {
               interface TestResult {
                  success?: boolean;
                  msg?: string;
                  error?: cisService.vapi.std.errors.Error;
               }
            }
            interface model {
            }
            namespace model {
               interface ApiCallDiagnostics {
                  apiName: string;
                  opId: string;
                  componentCounters: { [K: string]: string };
               }
               interface SampledValue {
                  key: string;
                  mean: number;
                  avg: number;
                  sum: number;
                  count: number;
                  max: number;
                  min: number;
                  latest: cisService.content.diagnostics.model.Sample;
               }
               interface Sample {
                  value: number;
                  info: string;
                  timestamp: number;
               }
            }
         }
         interface clsConfigurationService {
            get(configName: string): Promise<string>;
            set(configName: string, configValue: string): Promise<void>;
            list(): Promise<{ [K: string]: string }>;
         }
         namespace clsConfigurationService {
         }
         interface clsStressService {
            get(key: string): Promise<string>;
            set(key: string, value: string): Promise<void>;
            reset(): Promise<void>;
            setAll(settings: { [K: string]: string }): Promise<void>;
            getAll(): Promise<{ [K: string]: string }>;
         }
         namespace clsStressService {
         }
         interface type {
            list(): Promise<Array<cisService.content.type.Info>>;
            ovf: type.ovf;
         }
         namespace type {
            interface ovf {
               policy: ovf.policy;
            }
            namespace ovf {
               interface policy {
               }
               namespace policy {
                  interface StoragePolicyGroup {
                     id: string;
                     name: string;
                     description?: string;
                  }
                  interface StoragePolicy {
                     groupId: string;
                  }
               }
               interface VideoCard {
                  renderType?: string;
                  videoRamSize?: number;
                  graphicsMemorySize?: number;
                  enable3d?: boolean;
                  numDisplays?: number;
                  useAutoDetect?: boolean;
               }
               interface VAppTemplate {
                  vappName?: string;
                  vmTemplates?: Array<cisService.content.type.ovf.VmTemplate>;
                  storagePolicies?: Array<cisService.content.type.ovf.policy.StoragePolicy>;
               }
               interface USBController {
                  type?: string;
                  autoConnect?: boolean;
                  ehciPciSlotNumber?: number;
                  pciSlotNumber?: number;
               }
               interface Cpu {
                  numCpus: number;
                  reservation?: number;
                  limit?: number;
                  shares?: number;
               }
               interface DiskController {
                  name: string;
                  type?: string;
                  subType?: string;
               }
               interface Nic {
                  name: string;
                  networkName?: string;
                  macAddress?: string;
                  startConnected?: boolean;
               }
               interface Drive {
                  name: string;
                  type?: string;
                  subType?: string;
               }
               interface Memory {
                  size: number;
                  reservation?: number;
                  limit?: number;
                  shares?: number;
               }
               interface VmTemplate {
                  vmName: string;
                  osType?: string;
                  osDescription?: string;
                  cpu?: cisService.content.type.ovf.Cpu;
                  memory?: cisService.content.type.ovf.Memory;
                  disks?: Array<cisService.content.type.ovf.Disk>;
                  nics?: Array<cisService.content.type.ovf.Nic>;
                  videoCards?: Array<cisService.content.type.ovf.VideoCard>;
                  drives?: Array<cisService.content.type.ovf.Drive>;
                  floppies?: Array<cisService.content.type.ovf.Floppy>;
                  diskControllers?: Array<cisService.content.type.ovf.DiskController>;
                  usbControllers?: Array<cisService.content.type.ovf.USBController>;
                  storagePolicies?: Array<cisService.content.type.ovf.policy.StoragePolicy>;
               }
               interface Floppy {
                  name: string;
                  connected?: boolean;
                  type?: string;
               }
               interface OvfTemplate {
                  id: string;
                  vmCount: number;
                  version: string;
                  libraryIdParent: string;
                  isVappTemplate: boolean;
                  vmTemplate?: cisService.content.type.ovf.VmTemplate;
                  vappTemplate?: cisService.content.type.ovf.VAppTemplate;
                  networks: Array<cisService.content.type.ovf.Network>;
                  storagePolicyGroups?: Array<cisService.content.type.ovf.policy.StoragePolicyGroup>;
               }
               interface Disk {
                  name: string;
                  diskCapacity: number;
                  storagePolicy?: cisService.content.type.ovf.policy.StoragePolicy;
               }
               interface Network {
                  name: string;
                  description?: string;
               }
            }
            interface Info {
               description: string;
               name: string;
               type: string;
               vendor: string;
               version: string;
            }
         }
         interface invQueryService {
            synchronizedQuery(id: string, bindingClass: string): Promise<Array<cisService.builtin.DYNAMICSTRUCTURE>>;
            queryXml(id: string, bindingClass: string): Promise<string>;
            query(id: string, bindingClass: string): Promise<Array<cisService.builtin.DYNAMICSTRUCTURE>>;
            synchronizedQueryXml(id: string, bindingClass: string): Promise<string>;
         }
         namespace invQueryService {
            enum ChangeTypeEnum {
               "CREATE",
               "MODIFY",
               "DELETE",
            }
         }
         interface subscribedLibrary {
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            evict(libraryId: string): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            sync(libraryId: string): Promise<void>;
            delete(libraryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(clientToken: string, createSpec: cisService.content.LibraryModel): Promise<string>;
            probe(subscriptionInfo: cisService.content.library.SubscriptionInfo): Promise<cisService.content.subscribedLibrary.ProbeResult>;
         }
         namespace subscribedLibrary {
            interface ProbeResult {
               status: cisService.content.subscribedLibrary.ProbeResult.Status;
               sslThumbprint?: string;
               errorMessages: Array<cisService.vapi.std.LocalizableMessage>;
            }
            namespace ProbeResult {
               enum Status {
                  "SUCCESS", "INVALID_URL", "TIMED_OUT", "HOST_NOT_FOUND", "RESOURCE_NOT_FOUND", "INVALID_CREDENTIALS", "CERTIFICATE_ERROR", "UNKNOWN_ERROR"
               }
            }
         }
         interface localLibrary {
            update(libraryId: string, updateSpec: cisService.content.LibraryModel): Promise<void>;
            get(libraryId: string): Promise<cisService.content.LibraryModel>;
            delete(libraryId: string): Promise<void>;
            list(): Promise<Array<string>>;
            create(clientToken: string, createSpec: cisService.content.LibraryModel): Promise<string>;
         }
         namespace localLibrary {
         }
         interface configuration {
            update(model: cisService.content.ConfigurationModel): Promise<void>;
            get(): Promise<cisService.content.ConfigurationModel>;
         }
         namespace configuration {
         }
         interface clsActivationService {
            cancel(activationId: string): Promise<void>;
         }
         namespace clsActivationService {
         }
         interface ConfigurationModel {
            automaticSyncEnabled?: boolean;
            automaticSyncStartHour?: number;
            automaticSyncStopHour?: number;
            maximumConcurrentItemSyncs?: number;
         }
         interface LibraryModel {
            id?: string;
            creationTime?: Date;
            description?: string;
            lastModifiedTime?: Date;
            lastSyncTime?: Date;
            name?: string;
            storageBackings?: Array<cisService.content.library.StorageBacking>;
            type?: cisService.content.LibraryModel.LibraryType;
            version?: string;
            publishInfo?: cisService.content.library.PublishInfo;
            subscriptionInfo?: cisService.content.library.SubscriptionInfo;
            serverGuid?: string;
         }
         namespace LibraryModel {
            enum LibraryType {
               "LOCAL", "SUBSCRIBED"
            }
         }
      }
      interface ovf {
         importSession: ovf.importSession;
         exportSession: ovf.exportSession;
         exportFlag: ovf.exportFlag;
         probeImportSession: ovf.probeImportSession;
         importFlag: ovf.importFlag;
         libraryItem: ovf.libraryItem;
      }
      namespace ovf {
         interface importSession {
            createForResourcePool(clientToken: string, resourcePool: string, hostSystem: string, folder: string, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
            instantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<void>;
            get(id: string): Promise<cisService.ovf.importSession.Info>;
            delete(id: string): Promise<void>;
            tryInstantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<cisService.ovf.importSession.OvfValidationResult>;
         }
         namespace importSession {
            enum State {
               "IMPORT_OVF_TRANSFER",
               "IMPORT_MSG_BUNDLES_TRANSFER",
               "IMPORT_SELECTING_OVF_PARAMS",
               "IMPORT_FILE_TRANSFER",
               "IMPORT_INSTANTIATING",
               "IMPORT_COMPLETED",
               "IMPORT_ERROR",
            }
            enum SourceType {
               "PUSH_SOURCE",
               "PULL_SOURCE",
               "CONTENT_LIBRARY_SOURCE",
            }
            interface CreateSpec {
               locale?: string;
               importFlags: Array<string>;
               sourceType: cisService.ovf.importSession.SourceType;
               pullSource?: string;
               contentLibraryItem?: string;
            }
            interface OvfValidationResult {
               parameters: Array<cisService.builtin.DYNAMICSTRUCTURE>;
               errors: Array<cisService.ovf.OvfError>;
               warnings: Array<cisService.ovf.OvfWarning>;
               information: Array<cisService.ovf.OvfInfo>;
            }
            interface Info {
               state: cisService.ovf.importSession.State;
               progress: number;
               files: Array<cisService.ovf.OvfFileInfo>;
               errors: Array<cisService.ovf.OvfError>;
               warnings: Array<cisService.ovf.OvfWarning>;
               information: Array<cisService.ovf.OvfInfo>;
               vappId?: string;
               vmId?: string;
            }
         }
         interface exportSession {
            progress(id: string, percent: number): Promise<void>;
            preview(source: cisService.ovf.exportSession.SourceInfo, previewSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<cisService.ovf.exportSession.Preview>;
            get(id: string): Promise<cisService.ovf.exportSession.Info>;
            delete(id: string): Promise<void>;
            create(clientToken: string, source: cisService.ovf.exportSession.SourceInfo, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
         }
         namespace exportSession {
            enum TargetType {
               "DOWNLOAD_TARGET",
               "CONTENT_LIBRARY_TARGET",
            }
            enum State {
               "EXPORT_PREPARING",
               "EXPORT_READY",
               "EXPORT_IN_PROGRESS",
               "EXPORT_COMPLETED",
               "EXPORT_ERROR",
            }
            interface CreateSpec {
               targetType: cisService.ovf.exportSession.TargetType;
               exportFlags?: Array<string>;
               name?: string;
               description?: string;
               contentLibrary?: string;
               contentLibraryItem?: string;
            }
            interface SourceInfo {
               vappId?: string;
               vmId?: string;
            }
            interface PreviewFile {
               name: string;
            }
            interface Info {
               state: cisService.ovf.exportSession.State;
               progress?: number;
               files: Array<cisService.ovf.OvfFileInfo>;
               errors: Array<cisService.ovf.OvfError>;
               warnings: Array<cisService.ovf.OvfWarning>;
               information: Array<cisService.ovf.OvfInfo>;
               libraryItemId?: string;
            }
            interface Preview {
               files: Array<cisService.ovf.exportSession.PreviewFile>;
            }
            interface PreviewSpec {
               exportFlags?: Array<string>;
            }
         }
         interface exportFlag {
            list(): Promise<Array<cisService.ovf.exportFlag.Info>>;
         }
         namespace exportFlag {
            interface Info {
               option: string;
               description: cisService.vapi.std.LocalizableMessage;
            }
         }
         interface probeImportSession {
            createProbeImportSession(clientToken: string, createSpec: cisService.builtin.DYNAMICSTRUCTURE): Promise<string>;
            get(id: string): Promise<cisService.ovf.probeImportSession.Info>;
            delete(id: string): Promise<void>;
            tryInstantiate(id: string, instantiationParameters: Array<cisService.builtin.DYNAMICSTRUCTURE>): Promise<cisService.ovf.importSession.OvfValidationResult>;
         }
         namespace probeImportSession {
            enum State {
               "PROBE_IMPORT_OVF_TRANSFER",
               "PROBE_IMPORT_MSG_BUNDLES_TRANSFER",
               "PROBE_IMPORT_SELECTING_OVF_PARAMS",
               "PROBE_IMPORT_ERROR",
            }
            interface Info {
               state: cisService.ovf.probeImportSession.State;
               files: Array<cisService.ovf.OvfFileInfo>;
               errors: Array<cisService.ovf.OvfError>;
               warnings: Array<cisService.ovf.OvfWarning>;
               information: Array<cisService.ovf.OvfInfo>;
            }
         }
         interface importFlag {
            list(rp: string): Promise<Array<cisService.ovf.importFlag.Info>>;
         }
         namespace importFlag {
            interface Info {
               option: string;
               description: cisService.vapi.std.LocalizableMessage;
            }
         }
         interface libraryItem {
            deploy(clientToken: string, ovfLibraryItemId: string, target: cisService.ovf.libraryItem.DeploymentTarget, deploymentSpec: cisService.ovf.libraryItem.ResourcePoolDeploymentSpec): Promise<cisService.ovf.libraryItem.DeploymentResult>;
            create(clientToken: string, source: cisService.ovf.libraryItem.DeployableIdentity, target: cisService.ovf.libraryItem.CreateTarget, createSpec: cisService.ovf.libraryItem.CreateSpec): Promise<cisService.ovf.libraryItem.CreateResult>;
            filter(ovfLibraryItemId: string, target: cisService.ovf.libraryItem.DeploymentTarget): Promise<cisService.ovf.libraryItem.OvfSummary>;
         }
         namespace libraryItem {
            interface CreateResult {
               succeeded: boolean;
               ovfLibraryItemId?: string;
               error?: cisService.ovf.libraryItem.ResultInfo;
            }
            interface DeployableIdentity {
               type: string;
               id: string;
            }
            interface CreateTarget {
               libraryId?: string;
               libraryItemId?: string;
            }
            interface OvfSummary {
               name?: string;
               annotation?: string;
               eULAs: Array<string>;
               networks?: Array<string>;
               storageGroups?: Array<string>;
               additionalParams?: Array<cisService.builtin.DYNAMICSTRUCTURE>;
            }
            interface DeploymentTarget {
               resourcePoolId: string;
               hostId?: string;
               folderId?: string;
            }
            interface DeploymentResult {
               succeeded: boolean;
               resourceId?: cisService.ovf.libraryItem.DeployableIdentity;
               error?: cisService.ovf.libraryItem.ResultInfo;
            }
            interface CreateSpec {
               name?: string;
               description?: string;
               flags?: Array<string>;
            }
            interface ResultInfo {
               errors: Array<cisService.ovf.OvfError>;
               warnings: Array<cisService.ovf.OvfWarning>;
               information: Array<cisService.ovf.OvfInfo>;
            }
            interface StorageGroupMapping {
               type: cisService.ovf.libraryItem.StorageGroupMapping.Type;
               datastoreId?: string;
               storageProfileId?: string;
               provisioning?: cisService.ovf.DiskProvisioningType;
            }
            namespace StorageGroupMapping {
               enum Type {
                  "DATASTORE", "STORAGE_PROFILE"
               }
            }
            interface ResourcePoolDeploymentSpec {
               name?: string;
               annotation?: string;
               acceptAllEULA: boolean;
               networkMappings?: { [K: string]: string };
               storageMappings?: { [K: string]: cisService.ovf.libraryItem.StorageGroupMapping };
               storageProvisioning?: cisService.ovf.DiskProvisioningType;
               storageProfileId?: string;
               locale?: string;
               flags?: Array<string>;
               additionalParameters?: Array<cisService.builtin.DYNAMICSTRUCTURE>;
               defaultDatastoreId?: string;
            }
         }
         enum DiskProvisioningType {
            "thin",
            "thick",
            "eagerZeroedThick",
         }
         interface DatastoreTarget {
            id?: string;
            name?: string;
            accessible?: boolean;
            inaccessibleReasons?: Array<cisService.ovf.DatastoreTarget.InaccessibleReason>;
            storageProfiles?: Array<string>;
         }
         namespace DatastoreTarget {
            enum InaccessibleReason {
               "NOT_CONNECTED", "MAINTENANCE_MODE", "READ_ONLY", "NO_ALLOCATE_RIGHT"
            }
         }
         interface DeploymentOption {
            key?: string;
            label?: string;
            description?: string;
            defaultChoice?: boolean;
         }
         interface TargetNetwork {
            id?: string;
            accessible?: boolean;
            inaccessibleReasons?: Array<cisService.ovf.TargetNetwork.InaccessibleReason>;
            name?: string;
         }
         namespace TargetNetwork {
            enum InaccessibleReason {
               "NO_ASSIGN_RIGHT"
            }
         }
         interface StorageProfileTarget {
            id?: string;
            name?: string;
         }
         interface Property {
            classId?: string;
            id?: string;
            instanceId?: string;
            category?: string;
            uiOptional?: boolean;
            label?: string;
            description?: string;
            type?: string;
            value?: string;
         }
         interface OvfWarning {
            category: cisService.ovf.OvfMessage.Category;
            issues?: Array<cisService.ovf.ParseIssue>;
            name?: string;
            value?: string;
            message?: cisService.vapi.std.LocalizableMessage;
            error?: cisService.builtin.DYNAMICSTRUCTURE;
         }
         interface SizeParams {
            approximateDownloadSize?: number;
            approximateFlatDeploymentSize?: number;
            approximateSparseDeploymentSize?: number;
            variableDiskSize?: boolean;
            type?: string;
         }
         interface UnknownSectionParams {
            unknownSections?: Array<cisService.ovf.UnknownSection>;
            type?: string;
         }
         interface VcenterExtensionParams {
            required?: boolean;
            registrationAccepted?: boolean;
            type?: string;
         }
         interface OvfInfo {
            messages: Array<cisService.vapi.std.LocalizableMessage>;
         }
         interface DeploymentOptionParams {
            deploymentOptions?: Array<cisService.ovf.DeploymentOption>;
            selectedKey?: string;
            type?: string;
         }
         interface ExtraConfigParams {
            extraConfigs?: Array<cisService.ovf.ExtraConfig>;
            excludeKeys?: Array<string>;
            includeKeys?: Array<string>;
            type?: string;
         }
         interface IpAllocationParams {
            supportedAllocationScheme?: Array<cisService.ovf.IpAllocationParams.IpAllocationScheme>;
            supportedIpAllocationPolicy?: Array<cisService.ovf.IpAllocationParams.IpAllocationPolicy>;
            ipAllocationPolicy?: cisService.ovf.IpAllocationParams.IpAllocationPolicy;
            supportedIpProtocol?: Array<cisService.ovf.IpAllocationParams.IpProtocol>;
            ipProtocol?: cisService.ovf.IpAllocationParams.IpProtocol;
            type?: string;
         }
         namespace IpAllocationParams {
            enum IpAllocationScheme {
               "DHCP", "OVF_ENVIRONMENT"
            }
            enum IpProtocol {
               "IPV4", "IPV6"
            }
            enum IpAllocationPolicy {
               "DHCP", "TRANSIENT_IPPOOL", "STATIC_MANUAL", "STATIC_IPPOOL"
            }
         }
         interface DatastoreDiskGroup {
            id?: string;
            name?: string;
            description?: string;
            targetProfile?: string;
            targetDatastore?: string;
            targetProvisioningType?: cisService.ovf.DiskProvisioningType;
         }
         interface ScaleOutGroup {
            id?: string;
            description?: string;
            instanceCount?: number;
            minimumInstanceCount?: number;
            maximumInstanceCount?: number;
         }
         interface CertificateParams {
            issuer?: string;
            subject?: string;
            isValid?: boolean;
            isSelfSigned?: boolean;
            x509?: string;
            type?: string;
         }
         interface NetworkMappingParams {
            sourceNetworks?: Array<cisService.ovf.SourceNetwork>;
            targetNetworks?: Array<cisService.ovf.TargetNetwork>;
            type?: string;
         }
         interface OvfMessage {
            category: cisService.ovf.OvfMessage.Category;
            issues?: Array<cisService.ovf.ParseIssue>;
            name?: string;
            value?: string;
            message?: cisService.vapi.std.LocalizableMessage;
            error?: cisService.builtin.DYNAMICSTRUCTURE;
         }
         namespace OvfMessage {
            enum Category {
               "VALIDATION", "INPUT", "SERVER"
            }
         }
         interface NameAndProductParams {
            name?: string;
            annotation?: string;
            virtualApp?: boolean;
            productName?: string;
            vendor?: string;
            version?: string;
            fullVersion?: string;
            vendorUrl?: string;
            productUrl?: string;
            type?: string;
         }
         interface DatastoreMappingParams {
            availableStorageProfiles?: Array<cisService.ovf.StorageProfileTarget>;
            storageProfilesEnabled?: boolean;
            availableDatastores?: Array<cisService.ovf.DatastoreTarget>;
            availableDiskProvisioningTypes?: Array<cisService.ovf.DiskProvisioningType>;
            targetProfile?: string;
            targetDatastore?: string;
            targetProvisioningType?: cisService.ovf.DiskProvisioningType;
            diskGroups?: Array<cisService.ovf.DatastoreDiskGroup>;
            type?: string;
         }
         interface OvfError {
            category: cisService.ovf.OvfMessage.Category;
            issues?: Array<cisService.ovf.ParseIssue>;
            name?: string;
            value?: string;
            message?: cisService.vapi.std.LocalizableMessage;
            error?: cisService.builtin.DYNAMICSTRUCTURE;
         }
         interface SourceNetwork {
            name?: string;
            description?: string;
            target?: string;
         }
         interface ScaleOutParams {
            groups?: Array<cisService.ovf.ScaleOutGroup>;
            type?: string;
         }
         interface ParseIssue {
            category: cisService.ovf.ParseIssue.Category;
            file: string;
            lineNumber: number;
            columnNumber: number;
            message: cisService.vapi.std.LocalizableMessage;
         }
         namespace ParseIssue {
            enum Category {
               "VALUE_ILLEGAL", "ATTRIBUTE_REQUIRED", "ATTRIBUTE_ILLEGAL", "ELEMENT_REQUIRED", "ELEMENT_ILLEGAL", "ELEMENT_UNKNOWN", "SECTION_UNKNOWN", "SECTION_RESTRICTION", "PARSE_ERROR", "GENERATE_ERROR", "VALIDATION_ERROR", "EXPORT_ERROR", "INTERNAL_ERROR"
            }
         }
         interface PropertyParams {
            properties?: Array<cisService.ovf.Property>;
            type?: string;
         }
         interface EulaParams {
            eulas?: Array<string>;
            allEULAAccepted?: boolean;
            type?: string;
         }
         interface UnknownSection {
            tag: string;
            info: string;
         }
         interface OvfParams {
            type?: string;
         }
         interface OvfFileInfo {
            name: string;
            fileType: cisService.ovf.OvfFileInfo.FileType;
            optionalUpload: boolean;
            fileUrl: string;
            size: number;
            bytesTransferred: number;
            sha256: string;
         }
         namespace OvfFileInfo {
            enum FileType {
               "OVF", "MANIFEST", "CERT", "MSG_BUNDLE", "DISK", "CONTENT"
            }
         }
         interface StorageMappingParams {
            availableStorageProfiles?: Array<cisService.ovf.StorageProfileTarget>;
            availableDiskProvisioningTypes?: Array<cisService.ovf.DiskProvisioningType>;
            targetProfile?: string;
            targetProvisioningType?: cisService.ovf.DiskProvisioningType;
            diskGroups?: Array<cisService.ovf.StorageDiskGroup>;
            type?: string;
         }
         interface ExtraConfig {
            key?: string;
            value?: string;
            virtualSystemId?: string;
         }
         interface StorageDiskGroup {
            id?: string;
            name?: string;
            description?: string;
            targetProfile?: string;
            targetProvisioningType?: cisService.ovf.DiskProvisioningType;
         }
      }
   }
   function srmService(hostname: string, options?: {definition?: boolean; debug?: boolean; endpoint?: string, key?: string, port?: number, prefixes?: boolean;proxy?: boolean;proxyHeader?: string;}): Promise<vsphere.srmService>;
   interface srmService {
      addHandler(handler: Function): void;
      removeHandler(handler: Function): void;
      serializeObject(obj: Object, name: string): Node;
      deserializeObject(obj: Node): Object;
      serviceInstance: srmService.vim.ManagedObjectReference;
      serviceContent: srmService.srm.SrmServiceInstanceContent;
      xs: {
         AnyType: {
            (options?: srmService.xs.AnyType): srmService.xs.AnyType;
         };
         AnyURI: {
            (options?: srmService.xs.AnyURI): srmService.xs.AnyURI;
         };
         Base64Binary: {
            (options?: srmService.xs.Base64Binary): srmService.xs.Base64Binary;
         };
         Boolean: {
            (options?: srmService.xs.Boolean): srmService.xs.Boolean;
         };
         Byte: {
            (options?: srmService.xs.Byte): srmService.xs.Byte;
         };
         DateTime: {
            (options?: srmService.xs.DateTime): srmService.xs.DateTime;
         };
         Double: {
            (options?: srmService.xs.Double): srmService.xs.Double;
         };
         Float: {
            (options?: srmService.xs.Float): srmService.xs.Float;
         };
         ID: {
            (options?: srmService.xs.ID): srmService.xs.ID;
         };
         Int: {
            (options?: srmService.xs.Int): srmService.xs.Int;
         };
         Integer: {
            (options?: srmService.xs.Integer): srmService.xs.Integer;
         };
         Long: {
            (options?: srmService.xs.Long): srmService.xs.Long;
         };
         NCName: {
            (options?: srmService.xs.NCName): srmService.xs.NCName;
         };
         NegativeInteger: {
            (options?: srmService.xs.NegativeInteger): srmService.xs.NegativeInteger;
         };
         NonNegativeInteger: {
            (options?: srmService.xs.NonNegativeInteger): srmService.xs.NonNegativeInteger;
         };
         NonPositiveInteger: {
            (options?: srmService.xs.NonPositiveInteger): srmService.xs.NonPositiveInteger;
         };
         PositiveInteger: {
            (options?: srmService.xs.PositiveInteger): srmService.xs.PositiveInteger;
         };
         QName: {
            (options?: srmService.xs.QName): srmService.xs.QName;
         };
         Short: {
            (options?: srmService.xs.Short): srmService.xs.Short;
         };
         String: {
            (options?: srmService.xs.String): srmService.xs.String;
         };
         UnsignedLong: {
            (options?: srmService.xs.UnsignedLong): srmService.xs.UnsignedLong;
         };
      }
      srm: {
         SrmCallout: {
            (options?: srmService.srm.SrmCallout): srmService.srm.SrmCallout;
         };
         ArrayOfSrmCallout: {
            (options?: srmService.srm.ArrayOfSrmCallout): srmService.srm.ArrayOfSrmCallout;
         };
         SrmCommand: {
            (options?: srmService.srm.SrmCommand): srmService.srm.SrmCommand;
         };
         SrmApiRecoveryMode: {
            "recovery": string;
            "test": string;
            "migration": string;
         };
         SrmApiRecoveryState: {
            "uninitialized": string;
            "running": string;
            "cancelled": string;
            "paused": string;
            "prompting": string;
            "completed": string;
            "error": string;
         };
         SrmApiSettings: {
            (options?: srmService.srm.SrmApiSettings): srmService.srm.SrmApiSettings;
         };
         SrmPrompt: {
            (options?: srmService.srm.SrmPrompt): srmService.srm.SrmPrompt;
         };
         SrmProtectionInventoryMappingInfo: {
            (options?: srmService.srm.SrmProtectionInventoryMappingInfo): srmService.srm.SrmProtectionInventoryMappingInfo;
         };
         SrmProtectionGroupProtectionState: {
            "ready": string;
            "failedOver": string;
            "partiallyRecovered": string;
            "recovering": string;
            "recovered": string;
            "testing": string;
            "shadowing": string;
         };
         SrmProtectionGroupReplicationType: {
            "san": string;
            "vr": string;
         };
         SrmProtectionGroupInfo: {
            (options?: srmService.srm.SrmProtectionGroupInfo): srmService.srm.SrmProtectionGroupInfo;
         };
         SrmProtectionGroupProtectedVm: {
            (options?: srmService.srm.SrmProtectionGroupProtectedVm): srmService.srm.SrmProtectionGroupProtectedVm;
         };
         ArrayOfSrmProtectionGroupProtectedVm: {
            (options?: srmService.srm.ArrayOfSrmProtectionGroupProtectedVm): srmService.srm.ArrayOfSrmProtectionGroupProtectedVm;
         };
         SrmProtectionGroupVmProtectionInfoProtectionStatus: {
            "isProtected": string;
            "canBeProtected": string;
            "canNotBeProtected": string;
            "needsConfiguration": string;
         };
         SrmProtectionGroupVmProtectionInfo: {
            (options?: srmService.srm.SrmProtectionGroupVmProtectionInfo): srmService.srm.SrmProtectionGroupVmProtectionInfo;
         };
         ArrayOfSrmProtectionGroupVmProtectionInfo: {
            (options?: srmService.srm.ArrayOfSrmProtectionGroupVmProtectionInfo): srmService.srm.ArrayOfSrmProtectionGroupVmProtectionInfo;
         };
         SrmProtectionGroupVmProtectionSpec: {
            (options?: srmService.srm.SrmProtectionGroupVmProtectionSpec): srmService.srm.SrmProtectionGroupVmProtectionSpec;
         };
         ArrayOfSrmProtectionGroupVmProtectionSpec: {
            (options?: srmService.srm.ArrayOfSrmProtectionGroupVmProtectionSpec): srmService.srm.ArrayOfSrmProtectionGroupVmProtectionSpec;
         };
         SrmProtectionGroupPeer: {
            (options?: srmService.srm.SrmProtectionGroupPeer): srmService.srm.SrmProtectionGroupPeer;
         };
         SrmProtectionGroupOperationalLocation: {
            "inProtectedSite": string;
            "notInProtectedSite": string;
            "unknownLocation": string;
         };
         SrmProtectionTaskVmTask: {
            (options?: srmService.srm.SrmProtectionTaskVmTask): srmService.srm.SrmProtectionTaskVmTask;
         };
         ArrayOfSrmProtectionTaskVmTask: {
            (options?: srmService.srm.ArrayOfSrmProtectionTaskVmTask): srmService.srm.ArrayOfSrmProtectionTaskVmTask;
         };
         SrmRecoveryPlanRecoveryMode: {
            "failover": string;
            "test": string;
            "cleanupTest": string;
            "reprotect": string;
            "revert": string;
            "migrate": string;
         };
         SrmRecoveryPlanRecoveryState: {
            "ready": string;
            "protecting": string;
            "running": string;
            "cancelling": string;
            "prompting": string;
            "failedOver": string;
            "needsCleanup": string;
            "needsFailover": string;
            "needsRollback": string;
            "needsReprotect": string;
            "error": string;
         };
         SrmRecoveryPlanRecoveryPlanLocation: {
            "localToRecoverySite": string;
            "notLocalToRecoverySite": string;
            "unknownLocationNoPgs": string;
            "unknownLocation": string;
         };
         SrmRecoveryPlanRecoveryPrompt: {
            (options?: srmService.srm.SrmRecoveryPlanRecoveryPrompt): srmService.srm.SrmRecoveryPlanRecoveryPrompt;
         };
         ArrayOfSrmRecoveryPlanRecoveryPrompt: {
            (options?: srmService.srm.ArrayOfSrmRecoveryPlanRecoveryPrompt): srmService.srm.ArrayOfSrmRecoveryPlanRecoveryPrompt;
         };
         SrmRecoveryPlanInfo: {
            (options?: srmService.srm.SrmRecoveryPlanInfo): srmService.srm.SrmRecoveryPlanInfo;
         };
         SrmRecoveryPlanPeer: {
            (options?: srmService.srm.SrmRecoveryPlanPeer): srmService.srm.SrmRecoveryPlanPeer;
         };
         SrmRecoveryResultResultState: {
            "success": string;
            "warnings": string;
            "errors": string;
            "cancelled": string;
         };
         SrmRecoveryResult: {
            (options?: srmService.srm.SrmRecoveryResult): srmService.srm.SrmRecoveryResult;
         };
         ArrayOfSrmRecoveryResult: {
            (options?: srmService.srm.ArrayOfSrmRecoveryResult): srmService.srm.ArrayOfSrmRecoveryResult;
         };
         SrmRecoverySettingsStatus: {
            "ok": string;
            "syncConflict": string;
         };
         SrmRecoverySettingsRecoveryPriority: {
            "highest": string;
            "higher": string;
            "normal": string;
            "lower": string;
            "lowest": string;
         };
         SrmRecoverySettings: {
            (options?: srmService.srm.SrmRecoverySettings): srmService.srm.SrmRecoverySettings;
         };
         SrmRemoteSite: {
            (options?: srmService.srm.SrmRemoteSite): srmService.srm.SrmRemoteSite;
         };
         SrmServiceInstanceContent: {
            (options?: srmService.srm.SrmServiceInstanceContent): srmService.srm.SrmServiceInstanceContent;
         };
         SrmSolutionUserInfo: {
            (options?: srmService.srm.SrmSolutionUserInfo): srmService.srm.SrmSolutionUserInfo;
         };
         SrmFaultAlreadyLoggedInFault: {
            (options?: srmService.srm.SrmFaultAlreadyLoggedInFault): srmService.srm.SrmFaultAlreadyLoggedInFault;
         };
         SrmFaultConnectionDownFault: {
            (options?: srmService.srm.SrmFaultConnectionDownFault): srmService.srm.SrmFaultConnectionDownFault;
         };
         SrmFaultConnectionLimitReached: {
            (options?: srmService.srm.SrmFaultConnectionLimitReached): srmService.srm.SrmFaultConnectionLimitReached;
         };
         SrmFaultDependencyConflict: {
            (options?: srmService.srm.SrmFaultDependencyConflict): srmService.srm.SrmFaultDependencyConflict;
         };
         SrmFaultDuplicateName: {
            (options?: srmService.srm.SrmFaultDuplicateName): srmService.srm.SrmFaultDuplicateName;
         };
         SrmFaultInsufficientLicensesFault: {
            (options?: srmService.srm.SrmFaultInsufficientLicensesFault): srmService.srm.SrmFaultInsufficientLicensesFault;
         };
         SrmFaultInternalError: {
            (options?: srmService.srm.SrmFaultInternalError): srmService.srm.SrmFaultInternalError;
         };
         SrmFaultInvalidArgument: {
            (options?: srmService.srm.SrmFaultInvalidArgument): srmService.srm.SrmFaultInvalidArgument;
         };
         SrmFaultInvalidLogin: {
            (options?: srmService.srm.SrmFaultInvalidLogin): srmService.srm.SrmFaultInvalidLogin;
         };
         SrmFaultInvalidPrimaryFolder: {
            (options?: srmService.srm.SrmFaultInvalidPrimaryFolder): srmService.srm.SrmFaultInvalidPrimaryFolder;
         };
         SrmFaultInvalidPrimaryNetwork: {
            (options?: srmService.srm.SrmFaultInvalidPrimaryNetwork): srmService.srm.SrmFaultInvalidPrimaryNetwork;
         };
         SrmFaultInvalidSecondaryFolder: {
            (options?: srmService.srm.SrmFaultInvalidSecondaryFolder): srmService.srm.SrmFaultInvalidSecondaryFolder;
         };
         SrmFaultInvalidSecondaryNetwork: {
            (options?: srmService.srm.SrmFaultInvalidSecondaryNetwork): srmService.srm.SrmFaultInvalidSecondaryNetwork;
         };
         SrmFaultInvalidState: {
            (options?: srmService.srm.SrmFaultInvalidState): srmService.srm.SrmFaultInvalidState;
         };
         SrmFaultNoPermission: {
            (options?: srmService.srm.SrmFaultNoPermission): srmService.srm.SrmFaultNoPermission;
         };
         SrmFaultNotAuthenticated: {
            (options?: srmService.srm.SrmFaultNotAuthenticated): srmService.srm.SrmFaultNotAuthenticated;
         };
         SrmFaultPromptNotFound: {
            (options?: srmService.srm.SrmFaultPromptNotFound): srmService.srm.SrmFaultPromptNotFound;
         };
         SrmFaultProtectionGroupNotEmpty: {
            (options?: srmService.srm.SrmFaultProtectionGroupNotEmpty): srmService.srm.SrmFaultProtectionGroupNotEmpty;
         };
         SrmFaultProtectionGroupNotFound: {
            (options?: srmService.srm.SrmFaultProtectionGroupNotFound): srmService.srm.SrmFaultProtectionGroupNotFound;
         };
         SrmFaultRecoveryPlanLocked: {
            (options?: srmService.srm.SrmFaultRecoveryPlanLocked): srmService.srm.SrmFaultRecoveryPlanLocked;
         };
         SrmFaultRecoveryPlanNotFound: {
            (options?: srmService.srm.SrmFaultRecoveryPlanNotFound): srmService.srm.SrmFaultRecoveryPlanNotFound;
         };
         SrmFaultRecoveryResultNotFound: {
            (options?: srmService.srm.SrmFaultRecoveryResultNotFound): srmService.srm.SrmFaultRecoveryResultNotFound;
         };
         SrmFaultRemoteSiteNotEnabled: {
            (options?: srmService.srm.SrmFaultRemoteSiteNotEnabled): srmService.srm.SrmFaultRemoteSiteNotEnabled;
         };
         SrmFaultReplicationProviderFault: {
            (options?: srmService.srm.SrmFaultReplicationProviderFault): srmService.srm.SrmFaultReplicationProviderFault;
         };
         SrmFaultStringArgumentTooLong: {
            (options?: srmService.srm.SrmFaultStringArgumentTooLong): srmService.srm.SrmFaultStringArgumentTooLong;
         };
         SrmFaultUnknownPrimaryFolder: {
            (options?: srmService.srm.SrmFaultUnknownPrimaryFolder): srmService.srm.SrmFaultUnknownPrimaryFolder;
         };
         SrmFaultUnknownPrimaryNetwork: {
            (options?: srmService.srm.SrmFaultUnknownPrimaryNetwork): srmService.srm.SrmFaultUnknownPrimaryNetwork;
         };
         SrmFaultUnknownPrimaryResourcePool: {
            (options?: srmService.srm.SrmFaultUnknownPrimaryResourcePool): srmService.srm.SrmFaultUnknownPrimaryResourcePool;
         };
         SrmFaultUnknownSecondaryFolder: {
            (options?: srmService.srm.SrmFaultUnknownSecondaryFolder): srmService.srm.SrmFaultUnknownSecondaryFolder;
         };
         SrmFaultUnknownSecondaryNetwork: {
            (options?: srmService.srm.SrmFaultUnknownSecondaryNetwork): srmService.srm.SrmFaultUnknownSecondaryNetwork;
         };
         SrmFaultUnknownSecondaryResourcePool: {
            (options?: srmService.srm.SrmFaultUnknownSecondaryResourcePool): srmService.srm.SrmFaultUnknownSecondaryResourcePool;
         };
         SrmFaultVersionConflict: {
            (options?: srmService.srm.SrmFaultVersionConflict): srmService.srm.SrmFaultVersionConflict;
         };
         SrmFaultVmNotFoundInRecoveryPlan: {
            (options?: srmService.srm.SrmFaultVmNotFoundInRecoveryPlan): srmService.srm.SrmFaultVmNotFoundInRecoveryPlan;
         };
      }
      srmPort: {
         isCreateProtectionGroupComplete(_this: srmService.vim.ManagedObjectReference): Promise<boolean>;
         getCreateProtectionGroupResult(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.TaskInfo>;
         getNewProtectionGroup(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         srmLogin(_this: srmService.vim.ManagedObjectReference, username: string, password: string): Promise<void>;
         srmLoginByToken(_this: srmService.vim.ManagedObjectReference, samlToken: string): Promise<void>;
         srmLogout(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         getApiVersion(_this: srmService.vim.ManagedObjectReference): Promise<string>;
         listRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<string>>;
         recoveryPlanSettings(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.srm.SrmApiSettings>;
         recoveryPlanStart(_this: srmService.vim.ManagedObjectReference, name: string, mode: srmService.srm.SrmApiRecoveryMode): Promise<void>;
         recoveryPlanPause(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanResume(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanCancel(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanAnswerPrompt(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         getFinalStatus(_this: srmService.vim.ManagedObjectReference, name: string, offset: number, maxLines: number): Promise<Array<string>>;
         getName(_this: srmService.vim.ManagedObjectReference): Promise<string>;
         getParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         addFolderMapping(_this: srmService.vim.ManagedObjectReference, primaryFolder: srmService.vim.ManagedObjectReference, secondaryFolder: srmService.vim.ManagedObjectReference): Promise<void>;
         addNetworkMapping(_this: srmService.vim.ManagedObjectReference, primaryNetwork: srmService.vim.ManagedObjectReference, secondaryNetwork: srmService.vim.ManagedObjectReference): Promise<void>;
         addResourcePoolMapping(_this: srmService.vim.ManagedObjectReference, primaryPool: srmService.vim.ManagedObjectReference, secondaryPool: srmService.vim.ManagedObjectReference): Promise<void>;
         getProtectionGroupRootFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listReplicatedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listUnassignedReplicatedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionListProtectedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listProtectionGroups(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listInventoryMappings(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionInventoryMappingInfo>;
         listUnassignedReplicatedVms(_this: srmService.vim.ManagedObjectReference, replicationType: string): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionListProtectedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         createAbrProtectionGroup(_this: srmService.vim.ManagedObjectReference, location: srmService.vim.ManagedObjectReference, name: string, description: string, datastores: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         createHbrProtectionGroup(_this: srmService.vim.ManagedObjectReference, location: srmService.vim.ManagedObjectReference, name: string, description: string, vms: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         getInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupInfo>;
         getPeer(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupPeer>;
         protectionGroupGetParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listProtectedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionGroupProtectedVm>>;
         listProtectedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listAssociatedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getProtectionState(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupProtectionState>;
         protectionGroupListRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionGroupQueryVmProtection(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<Array<srmService.srm.SrmProtectionGroupVmProtectionInfo>>;
         protectVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.srm.SrmProtectionGroupVmProtectionSpec>): Promise<srmService.vim.ManagedObjectReference>;
         unprotectVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         associateVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<void>;
         unassociateVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<void>;
         listChildProtectionGroupFolders(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listChildProtectionGroups(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getProtectionGroup(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.vim.ManagedObjectReference>;
         getTasks(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionTaskVmTask>>;
         isComplete(_this: srmService.vim.ManagedObjectReference): Promise<boolean>;
         getResult(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.TaskInfo>>;
         getProtectionStatus(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionGroupVmProtectionInfo>>;
         getRecoveryPlanRootFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getHistory(_this: srmService.vim.ManagedObjectReference, plan: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         recoveryPlanGetInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoveryPlanInfo>;
         recoveryPlanGetParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         recoveryPlanGetPeer(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoveryPlanPeer>;
         start(_this: srmService.vim.ManagedObjectReference, mode: srmService.srm.SrmRecoveryPlanRecoveryMode): Promise<void>;
         cancel(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         listPrompts(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmRecoveryPlanRecoveryPrompt>>;
         answerPrompt(_this: srmService.vim.ManagedObjectReference, key: string, cancelVmRecovery: boolean, response: string): Promise<void>;
         getRecoverySettings(_this: srmService.vim.ManagedObjectReference, vm: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoverySettings>;
         setRecoverySettings(_this: srmService.vim.ManagedObjectReference, vm: srmService.vim.ManagedObjectReference, settings: srmService.srm.SrmRecoverySettings): Promise<void>;
         addProtectionGroup(_this: srmService.vim.ManagedObjectReference, group: srmService.vim.ManagedObjectReference): Promise<void>;
         listChildRecoveryPlanFolders(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listChildRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getRecoveryPlan(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.vim.ManagedObjectReference>;
         getResultCount(_this: srmService.vim.ManagedObjectReference): Promise<number>;
         getRecoveryResult(_this: srmService.vim.ManagedObjectReference, length: number): Promise<Array<srmService.srm.SrmRecoveryResult>>;
         getResultLength(_this: srmService.vim.ManagedObjectReference, key: number): Promise<number>;
         retrieveStatus(_this: srmService.vim.ManagedObjectReference, key: number, offset: number, maxLines: number): Promise<Array<string>>;
         retrieveContent(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmServiceInstanceContent>;
         srmLoginLocale(_this: srmService.vim.ManagedObjectReference, username: string, password: string, locale: string): Promise<void>;
         srmLoginByTokenLocale(_this: srmService.vim.ManagedObjectReference, samlToken: string, locale: string): Promise<void>;
         srmLoginSites(_this: srmService.vim.ManagedObjectReference, username: string, password: string, remoteUsername: string, remotePassword: string, locale: string): Promise<void>;
         srmLoginSitesByToken(_this: srmService.vim.ManagedObjectReference, samlToken: string, remoteSamlToken: string, locale: string): Promise<void>;
         srmLoginRemoteSite(_this: srmService.vim.ManagedObjectReference, remoteUsername: string, remotePassword: string, locale: string): Promise<void>;
         srmLoginRemoteSiteByToken(_this: srmService.vim.ManagedObjectReference, remoteSamlToken: string, locale: string): Promise<void>;
         srmLogoutLocale(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         getSolutionUserInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmSolutionUserInfo>;
         getPairedSite(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRemoteSite>;
         getPairedSiteSolutionUserInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmSolutionUserInfo>;
         getSiteName(_this: srmService.vim.ManagedObjectReference): Promise<string>;
      }
      vim: {
         DynamicArray: {
            (options?: srmService.vim.DynamicArray): srmService.vim.DynamicArray;
         };
         DynamicData: {
            (options?: srmService.vim.DynamicData): srmService.vim.DynamicData;
         };
         DynamicProperty: {
            (options?: srmService.vim.DynamicProperty): srmService.vim.DynamicProperty;
         };
         ArrayOfDynamicProperty: {
            (options?: srmService.vim.ArrayOfDynamicProperty): srmService.vim.ArrayOfDynamicProperty;
         };
         KeyAnyValue: {
            (options?: srmService.vim.KeyAnyValue): srmService.vim.KeyAnyValue;
         };
         ArrayOfKeyAnyValue: {
            (options?: srmService.vim.ArrayOfKeyAnyValue): srmService.vim.ArrayOfKeyAnyValue;
         };
         LocalizableMessage: {
            (options?: srmService.vim.LocalizableMessage): srmService.vim.LocalizableMessage;
         };
         ArrayOfLocalizableMessage: {
            (options?: srmService.vim.ArrayOfLocalizableMessage): srmService.vim.ArrayOfLocalizableMessage;
         };
         LocalizedMethodFault: {
            (options?: srmService.vim.LocalizedMethodFault): srmService.vim.LocalizedMethodFault;
         };
         MethodFault: {
            (options?: srmService.vim.MethodFault): srmService.vim.MethodFault;
         };
         ArrayOfMethodFault: {
            (options?: srmService.vim.ArrayOfMethodFault): srmService.vim.ArrayOfMethodFault;
         };
         RuntimeFault: {
            (options?: srmService.vim.RuntimeFault): srmService.vim.RuntimeFault;
         };
         HostCommunication: {
            (options?: srmService.vim.HostCommunication): srmService.vim.HostCommunication;
         };
         HostNotConnected: {
            (options?: srmService.vim.HostNotConnected): srmService.vim.HostNotConnected;
         };
         HostNotReachable: {
            (options?: srmService.vim.HostNotReachable): srmService.vim.HostNotReachable;
         };
         InvalidArgument: {
            (options?: srmService.vim.InvalidArgument): srmService.vim.InvalidArgument;
         };
         InvalidRequest: {
            (options?: srmService.vim.InvalidRequest): srmService.vim.InvalidRequest;
         };
         InvalidType: {
            (options?: srmService.vim.InvalidType): srmService.vim.InvalidType;
         };
         ManagedObjectNotFound: {
            (options?: srmService.vim.ManagedObjectNotFound): srmService.vim.ManagedObjectNotFound;
         };
         MethodNotFound: {
            (options?: srmService.vim.MethodNotFound): srmService.vim.MethodNotFound;
         };
         NotEnoughLicenses: {
            (options?: srmService.vim.NotEnoughLicenses): srmService.vim.NotEnoughLicenses;
         };
         NotImplemented: {
            (options?: srmService.vim.NotImplemented): srmService.vim.NotImplemented;
         };
         NotSupported: {
            (options?: srmService.vim.NotSupported): srmService.vim.NotSupported;
         };
         RequestCanceled: {
            (options?: srmService.vim.RequestCanceled): srmService.vim.RequestCanceled;
         };
         SecurityError: {
            (options?: srmService.vim.SecurityError): srmService.vim.SecurityError;
         };
         SystemError: {
            (options?: srmService.vim.SystemError): srmService.vim.SystemError;
         };
         UnexpectedFault: {
            (options?: srmService.vim.UnexpectedFault): srmService.vim.UnexpectedFault;
         };
         ManagedObjectReference: {
            (options?: srmService.vim.ManagedObjectReference): srmService.vim.ManagedObjectReference;
         };
         ArrayOfString: {
            (options?: srmService.vim.ArrayOfString): srmService.vim.ArrayOfString;
         };
         ArrayOfAnyType: {
            (options?: srmService.vim.ArrayOfAnyType): srmService.vim.ArrayOfAnyType;
         };
         ArrayOfManagedObjectReference: {
            (options?: srmService.vim.ArrayOfManagedObjectReference): srmService.vim.ArrayOfManagedObjectReference;
         };
         ArrayOfBoolean: {
            (options?: srmService.vim.ArrayOfBoolean): srmService.vim.ArrayOfBoolean;
         };
         ArrayOfByte: {
            (options?: srmService.vim.ArrayOfByte): srmService.vim.ArrayOfByte;
         };
         ArrayOfDouble: {
            (options?: srmService.vim.ArrayOfDouble): srmService.vim.ArrayOfDouble;
         };
         ArrayOfInt: {
            (options?: srmService.vim.ArrayOfInt): srmService.vim.ArrayOfInt;
         };
         ArrayOfLong: {
            (options?: srmService.vim.ArrayOfLong): srmService.vim.ArrayOfLong;
         };
         ArrayOfShort: {
            (options?: srmService.vim.ArrayOfShort): srmService.vim.ArrayOfShort;
         };
         AboutInfo: {
            (options?: srmService.vim.AboutInfo): srmService.vim.AboutInfo;
         };
         AuthorizationDescription: {
            (options?: srmService.vim.AuthorizationDescription): srmService.vim.AuthorizationDescription;
         };
         Permission: {
            (options?: srmService.vim.Permission): srmService.vim.Permission;
         };
         ArrayOfPermission: {
            (options?: srmService.vim.ArrayOfPermission): srmService.vim.ArrayOfPermission;
         };
         AuthorizationRole: {
            (options?: srmService.vim.AuthorizationRole): srmService.vim.AuthorizationRole;
         };
         ArrayOfAuthorizationRole: {
            (options?: srmService.vim.ArrayOfAuthorizationRole): srmService.vim.ArrayOfAuthorizationRole;
         };
         AuthorizationPrivilege: {
            (options?: srmService.vim.AuthorizationPrivilege): srmService.vim.AuthorizationPrivilege;
         };
         ArrayOfAuthorizationPrivilege: {
            (options?: srmService.vim.ArrayOfAuthorizationPrivilege): srmService.vim.ArrayOfAuthorizationPrivilege;
         };
         PrivilegeAvailability: {
            (options?: srmService.vim.PrivilegeAvailability): srmService.vim.PrivilegeAvailability;
         };
         ArrayOfPrivilegeAvailability: {
            (options?: srmService.vim.ArrayOfPrivilegeAvailability): srmService.vim.ArrayOfPrivilegeAvailability;
         };
         EntityPrivilege: {
            (options?: srmService.vim.EntityPrivilege): srmService.vim.EntityPrivilege;
         };
         ArrayOfEntityPrivilege: {
            (options?: srmService.vim.ArrayOfEntityPrivilege): srmService.vim.ArrayOfEntityPrivilege;
         };
         BoolPolicy: {
            (options?: srmService.vim.BoolPolicy): srmService.vim.BoolPolicy;
         };
         Capability: {
            (options?: srmService.vim.Capability): srmService.vim.Capability;
         };
         ClusterComputeResourceSummary: {
            (options?: srmService.vim.ClusterComputeResourceSummary): srmService.vim.ClusterComputeResourceSummary;
         };
         ComputeResourceSummary: {
            (options?: srmService.vim.ComputeResourceSummary): srmService.vim.ComputeResourceSummary;
         };
         ComputeResourceConfigInfo: {
            (options?: srmService.vim.ComputeResourceConfigInfo): srmService.vim.ComputeResourceConfigInfo;
         };
         ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: {
            "licensed": string;
            "unlicensed": string;
            "unknown": string;
         };
         ComputeResourceHostSPBMLicenseInfo: {
            (options?: srmService.vim.ComputeResourceHostSPBMLicenseInfo): srmService.vim.ComputeResourceHostSPBMLicenseInfo;
         };
         ArrayOfComputeResourceHostSPBMLicenseInfo: {
            (options?: srmService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo): srmService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo;
         };
         ComputeResourceConfigSpec: {
            (options?: srmService.vim.ComputeResourceConfigSpec): srmService.vim.ComputeResourceConfigSpec;
         };
         ConfigSpecOperation: {
            "add": string;
            "edit": string;
            "remove": string;
         };
         CustomFieldDef: {
            (options?: srmService.vim.CustomFieldDef): srmService.vim.CustomFieldDef;
         };
         ArrayOfCustomFieldDef: {
            (options?: srmService.vim.ArrayOfCustomFieldDef): srmService.vim.ArrayOfCustomFieldDef;
         };
         CustomFieldValue: {
            (options?: srmService.vim.CustomFieldValue): srmService.vim.CustomFieldValue;
         };
         ArrayOfCustomFieldValue: {
            (options?: srmService.vim.ArrayOfCustomFieldValue): srmService.vim.ArrayOfCustomFieldValue;
         };
         CustomFieldStringValue: {
            (options?: srmService.vim.CustomFieldStringValue): srmService.vim.CustomFieldStringValue;
         };
         CustomizationSpecInfo: {
            (options?: srmService.vim.CustomizationSpecInfo): srmService.vim.CustomizationSpecInfo;
         };
         ArrayOfCustomizationSpecInfo: {
            (options?: srmService.vim.ArrayOfCustomizationSpecInfo): srmService.vim.ArrayOfCustomizationSpecInfo;
         };
         CustomizationSpecItem: {
            (options?: srmService.vim.CustomizationSpecItem): srmService.vim.CustomizationSpecItem;
         };
         DatacenterConfigInfo: {
            (options?: srmService.vim.DatacenterConfigInfo): srmService.vim.DatacenterConfigInfo;
         };
         DatacenterConfigSpec: {
            (options?: srmService.vim.DatacenterConfigSpec): srmService.vim.DatacenterConfigSpec;
         };
         DatastoreAccessible: {
            "True": string;
            "False": string;
         };
         DatastoreSummaryMaintenanceModeState: {
            "normal": string;
            "enteringMaintenance": string;
            "inMaintenance": string;
         };
         DatastoreSummary: {
            (options?: srmService.vim.DatastoreSummary): srmService.vim.DatastoreSummary;
         };
         DatastoreInfo: {
            (options?: srmService.vim.DatastoreInfo): srmService.vim.DatastoreInfo;
         };
         DatastoreCapability: {
            (options?: srmService.vim.DatastoreCapability): srmService.vim.DatastoreCapability;
         };
         DatastoreHostMount: {
            (options?: srmService.vim.DatastoreHostMount): srmService.vim.DatastoreHostMount;
         };
         ArrayOfDatastoreHostMount: {
            (options?: srmService.vim.ArrayOfDatastoreHostMount): srmService.vim.ArrayOfDatastoreHostMount;
         };
         DatastoreMountPathDatastorePair: {
            (options?: srmService.vim.DatastoreMountPathDatastorePair): srmService.vim.DatastoreMountPathDatastorePair;
         };
         ArrayOfDatastoreMountPathDatastorePair: {
            (options?: srmService.vim.ArrayOfDatastoreMountPathDatastorePair): srmService.vim.ArrayOfDatastoreMountPathDatastorePair;
         };
         Description: {
            (options?: srmService.vim.Description): srmService.vim.Description;
         };
         DiagnosticManagerLogCreator: {
            "vpxd": string;
            "vpxa": string;
            "hostd": string;
            "serverd": string;
            "install": string;
            "vpxClient": string;
            "recordLog": string;
         };
         DiagnosticManagerLogFormat: {
            "plain": string;
         };
         DiagnosticManagerLogDescriptor: {
            (options?: srmService.vim.DiagnosticManagerLogDescriptor): srmService.vim.DiagnosticManagerLogDescriptor;
         };
         ArrayOfDiagnosticManagerLogDescriptor: {
            (options?: srmService.vim.ArrayOfDiagnosticManagerLogDescriptor): srmService.vim.ArrayOfDiagnosticManagerLogDescriptor;
         };
         DiagnosticManagerLogHeader: {
            (options?: srmService.vim.DiagnosticManagerLogHeader): srmService.vim.DiagnosticManagerLogHeader;
         };
         DiagnosticManagerBundleInfo: {
            (options?: srmService.vim.DiagnosticManagerBundleInfo): srmService.vim.DiagnosticManagerBundleInfo;
         };
         ArrayOfDiagnosticManagerBundleInfo: {
            (options?: srmService.vim.ArrayOfDiagnosticManagerBundleInfo): srmService.vim.ArrayOfDiagnosticManagerBundleInfo;
         };
         DistributedVirtualSwitchProductSpecOperationType: {
            "preInstall": string;
            "upgrade": string;
            "notifyAvailableUpgrade": string;
            "proceedWithUpgrade": string;
            "updateBundleInfo": string;
         };
         DVSContactInfo: {
            (options?: srmService.vim.DVSContactInfo): srmService.vim.DVSContactInfo;
         };
         DistributedVirtualSwitchNicTeamingPolicyMode: {
            "loadbalance_ip": string;
            "loadbalance_srcmac": string;
            "loadbalance_srcid": string;
            "failover_explicit": string;
            "loadbalance_loadbased": string;
         };
         DVSNetworkResourceManagementCapability: {
            (options?: srmService.vim.DVSNetworkResourceManagementCapability): srmService.vim.DVSNetworkResourceManagementCapability;
         };
         DVSRollbackCapability: {
            (options?: srmService.vim.DVSRollbackCapability): srmService.vim.DVSRollbackCapability;
         };
         DVSBackupRestoreCapability: {
            (options?: srmService.vim.DVSBackupRestoreCapability): srmService.vim.DVSBackupRestoreCapability;
         };
         DVSFeatureCapability: {
            (options?: srmService.vim.DVSFeatureCapability): srmService.vim.DVSFeatureCapability;
         };
         DVSHealthCheckCapability: {
            (options?: srmService.vim.DVSHealthCheckCapability): srmService.vim.DVSHealthCheckCapability;
         };
         DVSCapability: {
            (options?: srmService.vim.DVSCapability): srmService.vim.DVSCapability;
         };
         DVSSummary: {
            (options?: srmService.vim.DVSSummary): srmService.vim.DVSSummary;
         };
         DVSPolicy: {
            (options?: srmService.vim.DVSPolicy): srmService.vim.DVSPolicy;
         };
         DVSUplinkPortPolicy: {
            (options?: srmService.vim.DVSUplinkPortPolicy): srmService.vim.DVSUplinkPortPolicy;
         };
         DVSNameArrayUplinkPortPolicy: {
            (options?: srmService.vim.DVSNameArrayUplinkPortPolicy): srmService.vim.DVSNameArrayUplinkPortPolicy;
         };
         DVSConfigSpec: {
            (options?: srmService.vim.DVSConfigSpec): srmService.vim.DVSConfigSpec;
         };
         DVSCreateSpec: {
            (options?: srmService.vim.DVSCreateSpec): srmService.vim.DVSCreateSpec;
         };
         DVSConfigInfo: {
            (options?: srmService.vim.DVSConfigInfo): srmService.vim.DVSConfigInfo;
         };
         DistributedVirtualSwitchHostInfrastructureTrafficClass: {
            "management": string;
            "faultTolerance": string;
            "vmotion": string;
            "virtualMachine": string;
            "iSCSI": string;
            "nfs": string;
            "hbr": string;
            "vsan": string;
         };
         DVSHealthCheckConfig: {
            (options?: srmService.vim.DVSHealthCheckConfig): srmService.vim.DVSHealthCheckConfig;
         };
         ArrayOfDVSHealthCheckConfig: {
            (options?: srmService.vim.ArrayOfDVSHealthCheckConfig): srmService.vim.ArrayOfDVSHealthCheckConfig;
         };
         DVSRuntimeInfo: {
            (options?: srmService.vim.DVSRuntimeInfo): srmService.vim.DVSRuntimeInfo;
         };
         DrsInjectorWorkloadCorrelationState: {
            "Correlated": string;
            "Uncorrelated": string;
         };
         EVCMode: {
            (options?: srmService.vim.EVCMode): srmService.vim.EVCMode;
         };
         ArrayOfEVCMode: {
            (options?: srmService.vim.ArrayOfEVCMode): srmService.vim.ArrayOfEVCMode;
         };
         ElementDescription: {
            (options?: srmService.vim.ElementDescription): srmService.vim.ElementDescription;
         };
         ArrayOfElementDescription: {
            (options?: srmService.vim.ArrayOfElementDescription): srmService.vim.ArrayOfElementDescription;
         };
         EnumDescription: {
            (options?: srmService.vim.EnumDescription): srmService.vim.EnumDescription;
         };
         ArrayOfEnumDescription: {
            (options?: srmService.vim.ArrayOfEnumDescription): srmService.vim.ArrayOfEnumDescription;
         };
         ExtendedDescription: {
            (options?: srmService.vim.ExtendedDescription): srmService.vim.ExtendedDescription;
         };
         ExtendedElementDescription: {
            (options?: srmService.vim.ExtendedElementDescription): srmService.vim.ExtendedElementDescription;
         };
         ExtensionServerInfo: {
            (options?: srmService.vim.ExtensionServerInfo): srmService.vim.ExtensionServerInfo;
         };
         ArrayOfExtensionServerInfo: {
            (options?: srmService.vim.ArrayOfExtensionServerInfo): srmService.vim.ArrayOfExtensionServerInfo;
         };
         ExtensionClientInfo: {
            (options?: srmService.vim.ExtensionClientInfo): srmService.vim.ExtensionClientInfo;
         };
         ArrayOfExtensionClientInfo: {
            (options?: srmService.vim.ArrayOfExtensionClientInfo): srmService.vim.ArrayOfExtensionClientInfo;
         };
         ExtensionTaskTypeInfo: {
            (options?: srmService.vim.ExtensionTaskTypeInfo): srmService.vim.ExtensionTaskTypeInfo;
         };
         ArrayOfExtensionTaskTypeInfo: {
            (options?: srmService.vim.ArrayOfExtensionTaskTypeInfo): srmService.vim.ArrayOfExtensionTaskTypeInfo;
         };
         ExtensionEventTypeInfo: {
            (options?: srmService.vim.ExtensionEventTypeInfo): srmService.vim.ExtensionEventTypeInfo;
         };
         ArrayOfExtensionEventTypeInfo: {
            (options?: srmService.vim.ArrayOfExtensionEventTypeInfo): srmService.vim.ArrayOfExtensionEventTypeInfo;
         };
         ExtensionFaultTypeInfo: {
            (options?: srmService.vim.ExtensionFaultTypeInfo): srmService.vim.ExtensionFaultTypeInfo;
         };
         ArrayOfExtensionFaultTypeInfo: {
            (options?: srmService.vim.ArrayOfExtensionFaultTypeInfo): srmService.vim.ArrayOfExtensionFaultTypeInfo;
         };
         ExtensionPrivilegeInfo: {
            (options?: srmService.vim.ExtensionPrivilegeInfo): srmService.vim.ExtensionPrivilegeInfo;
         };
         ArrayOfExtensionPrivilegeInfo: {
            (options?: srmService.vim.ArrayOfExtensionPrivilegeInfo): srmService.vim.ArrayOfExtensionPrivilegeInfo;
         };
         ExtensionResourceInfo: {
            (options?: srmService.vim.ExtensionResourceInfo): srmService.vim.ExtensionResourceInfo;
         };
         ArrayOfExtensionResourceInfo: {
            (options?: srmService.vim.ArrayOfExtensionResourceInfo): srmService.vim.ArrayOfExtensionResourceInfo;
         };
         ExtensionHealthInfo: {
            (options?: srmService.vim.ExtensionHealthInfo): srmService.vim.ExtensionHealthInfo;
         };
         ExtensionOvfConsumerInfo: {
            (options?: srmService.vim.ExtensionOvfConsumerInfo): srmService.vim.ExtensionOvfConsumerInfo;
         };
         Extension: {
            (options?: srmService.vim.Extension): srmService.vim.Extension;
         };
         ArrayOfExtension: {
            (options?: srmService.vim.ArrayOfExtension): srmService.vim.ArrayOfExtension;
         };
         ExtensionManagerIpAllocationUsage: {
            (options?: srmService.vim.ExtensionManagerIpAllocationUsage): srmService.vim.ExtensionManagerIpAllocationUsage;
         };
         ArrayOfExtensionManagerIpAllocationUsage: {
            (options?: srmService.vim.ArrayOfExtensionManagerIpAllocationUsage): srmService.vim.ArrayOfExtensionManagerIpAllocationUsage;
         };
         ReplicationVmState: {
            "none": string;
            "paused": string;
            "syncing": string;
            "idle": string;
            "active": string;
            "error": string;
         };
         ReplicationVmProgressInfo: {
            (options?: srmService.vim.ReplicationVmProgressInfo): srmService.vim.ReplicationVmProgressInfo;
         };
         HbrManagerReplicationVmInfo: {
            (options?: srmService.vim.HbrManagerReplicationVmInfo): srmService.vim.HbrManagerReplicationVmInfo;
         };
         HostServiceTicket: {
            (options?: srmService.vim.HostServiceTicket): srmService.vim.HostServiceTicket;
         };
         HostSystemConnectionState: {
            "connected": string;
            "notResponding": string;
            "disconnected": string;
         };
         HostSystemPowerState: {
            "poweredOn": string;
            "poweredOff": string;
            "standBy": string;
            "unknown": string;
         };
         HostStandbyMode: {
            "entering": string;
            "exiting": string;
            "in": string;
            "none": string;
         };
         HostSystemReconnectSpec: {
            (options?: srmService.vim.HostSystemReconnectSpec): srmService.vim.HostSystemReconnectSpec;
         };
         HttpNfcLeaseState: {
            "initializing": string;
            "ready": string;
            "done": string;
            "error": string;
         };
         HttpNfcLeaseDatastoreLeaseInfo: {
            (options?: srmService.vim.HttpNfcLeaseDatastoreLeaseInfo): srmService.vim.HttpNfcLeaseDatastoreLeaseInfo;
         };
         ArrayOfHttpNfcLeaseDatastoreLeaseInfo: {
            (options?: srmService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo): srmService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo;
         };
         HttpNfcLeaseHostInfo: {
            (options?: srmService.vim.HttpNfcLeaseHostInfo): srmService.vim.HttpNfcLeaseHostInfo;
         };
         ArrayOfHttpNfcLeaseHostInfo: {
            (options?: srmService.vim.ArrayOfHttpNfcLeaseHostInfo): srmService.vim.ArrayOfHttpNfcLeaseHostInfo;
         };
         HttpNfcLeaseInfo: {
            (options?: srmService.vim.HttpNfcLeaseInfo): srmService.vim.HttpNfcLeaseInfo;
         };
         HttpNfcLeaseDeviceUrl: {
            (options?: srmService.vim.HttpNfcLeaseDeviceUrl): srmService.vim.HttpNfcLeaseDeviceUrl;
         };
         ArrayOfHttpNfcLeaseDeviceUrl: {
            (options?: srmService.vim.ArrayOfHttpNfcLeaseDeviceUrl): srmService.vim.ArrayOfHttpNfcLeaseDeviceUrl;
         };
         HttpNfcLeaseManifestEntry: {
            (options?: srmService.vim.HttpNfcLeaseManifestEntry): srmService.vim.HttpNfcLeaseManifestEntry;
         };
         ArrayOfHttpNfcLeaseManifestEntry: {
            (options?: srmService.vim.ArrayOfHttpNfcLeaseManifestEntry): srmService.vim.ArrayOfHttpNfcLeaseManifestEntry;
         };
         ImportSpec: {
            (options?: srmService.vim.ImportSpec): srmService.vim.ImportSpec;
         };
         ArrayOfImportSpec: {
            (options?: srmService.vim.ArrayOfImportSpec): srmService.vim.ArrayOfImportSpec;
         };
         InheritablePolicy: {
            (options?: srmService.vim.InheritablePolicy): srmService.vim.InheritablePolicy;
         };
         IntExpression: {
            (options?: srmService.vim.IntExpression): srmService.vim.IntExpression;
         };
         IntPolicy: {
            (options?: srmService.vim.IntPolicy): srmService.vim.IntPolicy;
         };
         IpAddress: {
            (options?: srmService.vim.IpAddress): srmService.vim.IpAddress;
         };
         IpPoolManagerIpAllocation: {
            (options?: srmService.vim.IpPoolManagerIpAllocation): srmService.vim.IpPoolManagerIpAllocation;
         };
         ArrayOfIpPoolManagerIpAllocation: {
            (options?: srmService.vim.ArrayOfIpPoolManagerIpAllocation): srmService.vim.ArrayOfIpPoolManagerIpAllocation;
         };
         IpRange: {
            (options?: srmService.vim.IpRange): srmService.vim.IpRange;
         };
         KeyValue: {
            (options?: srmService.vim.KeyValue): srmService.vim.KeyValue;
         };
         ArrayOfKeyValue: {
            (options?: srmService.vim.ArrayOfKeyValue): srmService.vim.ArrayOfKeyValue;
         };
         LatencySensitivitySensitivityLevel: {
            "low": string;
            "normal": string;
            "medium": string;
            "high": string;
            "custom": string;
         };
         LatencySensitivity: {
            (options?: srmService.vim.LatencySensitivity): srmService.vim.LatencySensitivity;
         };
         LicenseAssignmentManagerLicenseAssignment: {
            (options?: srmService.vim.LicenseAssignmentManagerLicenseAssignment): srmService.vim.LicenseAssignmentManagerLicenseAssignment;
         };
         ArrayOfLicenseAssignmentManagerLicenseAssignment: {
            (options?: srmService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment): srmService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment;
         };
         LicenseManagerState: {
            "initializing": string;
            "normal": string;
            "marginal": string;
            "fault": string;
         };
         LicenseManagerLicenseKey: {
            "esxFull": string;
            "esxVmtn": string;
            "esxExpress": string;
            "san": string;
            "iscsi": string;
            "nas": string;
            "vsmp": string;
            "backup": string;
            "vc": string;
            "vcExpress": string;
            "esxHost": string;
            "gsxHost": string;
            "serverHost": string;
            "drsPower": string;
            "vmotion": string;
            "drs": string;
            "das": string;
         };
         LicenseSource: {
            (options?: srmService.vim.LicenseSource): srmService.vim.LicenseSource;
         };
         LicenseServerSource: {
            (options?: srmService.vim.LicenseServerSource): srmService.vim.LicenseServerSource;
         };
         LocalLicenseSource: {
            (options?: srmService.vim.LocalLicenseSource): srmService.vim.LocalLicenseSource;
         };
         EvaluationLicenseSource: {
            (options?: srmService.vim.EvaluationLicenseSource): srmService.vim.EvaluationLicenseSource;
         };
         LicenseFeatureInfoUnit: {
            "host": string;
            "cpuCore": string;
            "cpuPackage": string;
            "server": string;
            "vm": string;
         };
         LicenseFeatureInfoState: {
            "enabled": string;
            "disabled": string;
            "optional": string;
         };
         LicenseFeatureInfoSourceRestriction: {
            "unrestricted": string;
            "served": string;
            "file": string;
         };
         LicenseFeatureInfo: {
            (options?: srmService.vim.LicenseFeatureInfo): srmService.vim.LicenseFeatureInfo;
         };
         ArrayOfLicenseFeatureInfo: {
            (options?: srmService.vim.ArrayOfLicenseFeatureInfo): srmService.vim.ArrayOfLicenseFeatureInfo;
         };
         LicenseReservationInfoState: {
            "notUsed": string;
            "noLicense": string;
            "unlicensedUse": string;
            "licensed": string;
         };
         LicenseReservationInfo: {
            (options?: srmService.vim.LicenseReservationInfo): srmService.vim.LicenseReservationInfo;
         };
         ArrayOfLicenseReservationInfo: {
            (options?: srmService.vim.ArrayOfLicenseReservationInfo): srmService.vim.ArrayOfLicenseReservationInfo;
         };
         LicenseAvailabilityInfo: {
            (options?: srmService.vim.LicenseAvailabilityInfo): srmService.vim.LicenseAvailabilityInfo;
         };
         ArrayOfLicenseAvailabilityInfo: {
            (options?: srmService.vim.ArrayOfLicenseAvailabilityInfo): srmService.vim.ArrayOfLicenseAvailabilityInfo;
         };
         LicenseDiagnostics: {
            (options?: srmService.vim.LicenseDiagnostics): srmService.vim.LicenseDiagnostics;
         };
         LicenseUsageInfo: {
            (options?: srmService.vim.LicenseUsageInfo): srmService.vim.LicenseUsageInfo;
         };
         LicenseManagerEvaluationInfo: {
            (options?: srmService.vim.LicenseManagerEvaluationInfo): srmService.vim.LicenseManagerEvaluationInfo;
         };
         HostLicensableResourceKey: {
            "numCpuPackages": string;
            "numCpuCores": string;
            "memorySize": string;
            "memoryForVms": string;
            "numVmsStarted": string;
            "numVmsStarting": string;
         };
         HostLicensableResourceInfo: {
            (options?: srmService.vim.HostLicensableResourceInfo): srmService.vim.HostLicensableResourceInfo;
         };
         LicenseManagerLicenseInfo: {
            (options?: srmService.vim.LicenseManagerLicenseInfo): srmService.vim.LicenseManagerLicenseInfo;
         };
         ArrayOfLicenseManagerLicenseInfo: {
            (options?: srmService.vim.ArrayOfLicenseManagerLicenseInfo): srmService.vim.ArrayOfLicenseManagerLicenseInfo;
         };
         LocalizationManagerMessageCatalog: {
            (options?: srmService.vim.LocalizationManagerMessageCatalog): srmService.vim.LocalizationManagerMessageCatalog;
         };
         ArrayOfLocalizationManagerMessageCatalog: {
            (options?: srmService.vim.ArrayOfLocalizationManagerMessageCatalog): srmService.vim.ArrayOfLocalizationManagerMessageCatalog;
         };
         LongPolicy: {
            (options?: srmService.vim.LongPolicy): srmService.vim.LongPolicy;
         };
         MacAddress: {
            (options?: srmService.vim.MacAddress): srmService.vim.MacAddress;
         };
         MacRange: {
            (options?: srmService.vim.MacRange): srmService.vim.MacRange;
         };
         ManagedEntityStatus: {
            "gray": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         MethodDescription: {
            (options?: srmService.vim.MethodDescription): srmService.vim.MethodDescription;
         };
         NegatableExpression: {
            (options?: srmService.vim.NegatableExpression): srmService.vim.NegatableExpression;
         };
         NetworkSummary: {
            (options?: srmService.vim.NetworkSummary): srmService.vim.NetworkSummary;
         };
         NumericRange: {
            (options?: srmService.vim.NumericRange): srmService.vim.NumericRange;
         };
         ArrayOfNumericRange: {
            (options?: srmService.vim.ArrayOfNumericRange): srmService.vim.ArrayOfNumericRange;
         };
         OpaqueNetworkSummary: {
            (options?: srmService.vim.OpaqueNetworkSummary): srmService.vim.OpaqueNetworkSummary;
         };
         OvfConsumerOvfSection: {
            (options?: srmService.vim.OvfConsumerOvfSection): srmService.vim.OvfConsumerOvfSection;
         };
         ArrayOfOvfConsumerOvfSection: {
            (options?: srmService.vim.ArrayOfOvfConsumerOvfSection): srmService.vim.ArrayOfOvfConsumerOvfSection;
         };
         OvfConsumerOstNodeType: {
            "envelope": string;
            "virtualSystem": string;
            "virtualSystemCollection": string;
         };
         OvfConsumerOstNode: {
            (options?: srmService.vim.OvfConsumerOstNode): srmService.vim.OvfConsumerOstNode;
         };
         ArrayOfOvfConsumerOstNode: {
            (options?: srmService.vim.ArrayOfOvfConsumerOstNode): srmService.vim.ArrayOfOvfConsumerOstNode;
         };
         OvfOptionInfo: {
            (options?: srmService.vim.OvfOptionInfo): srmService.vim.OvfOptionInfo;
         };
         ArrayOfOvfOptionInfo: {
            (options?: srmService.vim.ArrayOfOvfOptionInfo): srmService.vim.ArrayOfOvfOptionInfo;
         };
         OvfDeploymentOption: {
            (options?: srmService.vim.OvfDeploymentOption): srmService.vim.OvfDeploymentOption;
         };
         ArrayOfOvfDeploymentOption: {
            (options?: srmService.vim.ArrayOfOvfDeploymentOption): srmService.vim.ArrayOfOvfDeploymentOption;
         };
         OvfManagerCommonParams: {
            (options?: srmService.vim.OvfManagerCommonParams): srmService.vim.OvfManagerCommonParams;
         };
         OvfValidateHostParams: {
            (options?: srmService.vim.OvfValidateHostParams): srmService.vim.OvfValidateHostParams;
         };
         OvfValidateHostResult: {
            (options?: srmService.vim.OvfValidateHostResult): srmService.vim.OvfValidateHostResult;
         };
         OvfParseDescriptorParams: {
            (options?: srmService.vim.OvfParseDescriptorParams): srmService.vim.OvfParseDescriptorParams;
         };
         OvfParseDescriptorResult: {
            (options?: srmService.vim.OvfParseDescriptorResult): srmService.vim.OvfParseDescriptorResult;
         };
         OvfNetworkInfo: {
            (options?: srmService.vim.OvfNetworkInfo): srmService.vim.OvfNetworkInfo;
         };
         ArrayOfOvfNetworkInfo: {
            (options?: srmService.vim.ArrayOfOvfNetworkInfo): srmService.vim.ArrayOfOvfNetworkInfo;
         };
         OvfCreateImportSpecParamsDiskProvisioningType: {
            "monolithicSparse": string;
            "monolithicFlat": string;
            "twoGbMaxExtentSparse": string;
            "twoGbMaxExtentFlat": string;
            "thin": string;
            "thick": string;
            "seSparse": string;
            "eagerZeroedThick": string;
            "sparse": string;
            "flat": string;
         };
         OvfCreateImportSpecParams: {
            (options?: srmService.vim.OvfCreateImportSpecParams): srmService.vim.OvfCreateImportSpecParams;
         };
         OvfResourceMap: {
            (options?: srmService.vim.OvfResourceMap): srmService.vim.OvfResourceMap;
         };
         ArrayOfOvfResourceMap: {
            (options?: srmService.vim.ArrayOfOvfResourceMap): srmService.vim.ArrayOfOvfResourceMap;
         };
         OvfNetworkMapping: {
            (options?: srmService.vim.OvfNetworkMapping): srmService.vim.OvfNetworkMapping;
         };
         ArrayOfOvfNetworkMapping: {
            (options?: srmService.vim.ArrayOfOvfNetworkMapping): srmService.vim.ArrayOfOvfNetworkMapping;
         };
         OvfCreateImportSpecResult: {
            (options?: srmService.vim.OvfCreateImportSpecResult): srmService.vim.OvfCreateImportSpecResult;
         };
         OvfFileItem: {
            (options?: srmService.vim.OvfFileItem): srmService.vim.OvfFileItem;
         };
         ArrayOfOvfFileItem: {
            (options?: srmService.vim.ArrayOfOvfFileItem): srmService.vim.ArrayOfOvfFileItem;
         };
         OvfCreateDescriptorParams: {
            (options?: srmService.vim.OvfCreateDescriptorParams): srmService.vim.OvfCreateDescriptorParams;
         };
         OvfCreateDescriptorResult: {
            (options?: srmService.vim.OvfCreateDescriptorResult): srmService.vim.OvfCreateDescriptorResult;
         };
         OvfFile: {
            (options?: srmService.vim.OvfFile): srmService.vim.OvfFile;
         };
         ArrayOfOvfFile: {
            (options?: srmService.vim.ArrayOfOvfFile): srmService.vim.ArrayOfOvfFile;
         };
         PasswordField: {
            (options?: srmService.vim.PasswordField): srmService.vim.PasswordField;
         };
         PerformanceDescription: {
            (options?: srmService.vim.PerformanceDescription): srmService.vim.PerformanceDescription;
         };
         PerfFormat: {
            "normal": string;
            "csv": string;
         };
         PerfProviderSummary: {
            (options?: srmService.vim.PerfProviderSummary): srmService.vim.PerfProviderSummary;
         };
         PerfSummaryType: {
            "average": string;
            "maximum": string;
            "minimum": string;
            "latest": string;
            "summation": string;
            "none": string;
         };
         PerfStatsType: {
            "absolute": string;
            "delta": string;
            "rate": string;
         };
         PerformanceManagerUnit: {
            "percent": string;
            "kiloBytes": string;
            "megaBytes": string;
            "megaHertz": string;
            "number": string;
            "microsecond": string;
            "millisecond": string;
            "second": string;
            "kiloBytesPerSecond": string;
            "megaBytesPerSecond": string;
            "watt": string;
            "joule": string;
         };
         PerfCounterInfo: {
            (options?: srmService.vim.PerfCounterInfo): srmService.vim.PerfCounterInfo;
         };
         ArrayOfPerfCounterInfo: {
            (options?: srmService.vim.ArrayOfPerfCounterInfo): srmService.vim.ArrayOfPerfCounterInfo;
         };
         PerfMetricId: {
            (options?: srmService.vim.PerfMetricId): srmService.vim.PerfMetricId;
         };
         ArrayOfPerfMetricId: {
            (options?: srmService.vim.ArrayOfPerfMetricId): srmService.vim.ArrayOfPerfMetricId;
         };
         PerfQuerySpec: {
            (options?: srmService.vim.PerfQuerySpec): srmService.vim.PerfQuerySpec;
         };
         ArrayOfPerfQuerySpec: {
            (options?: srmService.vim.ArrayOfPerfQuerySpec): srmService.vim.ArrayOfPerfQuerySpec;
         };
         PerfSampleInfo: {
            (options?: srmService.vim.PerfSampleInfo): srmService.vim.PerfSampleInfo;
         };
         ArrayOfPerfSampleInfo: {
            (options?: srmService.vim.ArrayOfPerfSampleInfo): srmService.vim.ArrayOfPerfSampleInfo;
         };
         PerfMetricSeries: {
            (options?: srmService.vim.PerfMetricSeries): srmService.vim.PerfMetricSeries;
         };
         ArrayOfPerfMetricSeries: {
            (options?: srmService.vim.ArrayOfPerfMetricSeries): srmService.vim.ArrayOfPerfMetricSeries;
         };
         PerfMetricIntSeries: {
            (options?: srmService.vim.PerfMetricIntSeries): srmService.vim.PerfMetricIntSeries;
         };
         PerfMetricSeriesCSV: {
            (options?: srmService.vim.PerfMetricSeriesCSV): srmService.vim.PerfMetricSeriesCSV;
         };
         ArrayOfPerfMetricSeriesCSV: {
            (options?: srmService.vim.ArrayOfPerfMetricSeriesCSV): srmService.vim.ArrayOfPerfMetricSeriesCSV;
         };
         PerfEntityMetricBase: {
            (options?: srmService.vim.PerfEntityMetricBase): srmService.vim.PerfEntityMetricBase;
         };
         ArrayOfPerfEntityMetricBase: {
            (options?: srmService.vim.ArrayOfPerfEntityMetricBase): srmService.vim.ArrayOfPerfEntityMetricBase;
         };
         PerfEntityMetric: {
            (options?: srmService.vim.PerfEntityMetric): srmService.vim.PerfEntityMetric;
         };
         PerfEntityMetricCSV: {
            (options?: srmService.vim.PerfEntityMetricCSV): srmService.vim.PerfEntityMetricCSV;
         };
         PerfCompositeMetric: {
            (options?: srmService.vim.PerfCompositeMetric): srmService.vim.PerfCompositeMetric;
         };
         PerformanceManagerCounterLevelMapping: {
            (options?: srmService.vim.PerformanceManagerCounterLevelMapping): srmService.vim.PerformanceManagerCounterLevelMapping;
         };
         ArrayOfPerformanceManagerCounterLevelMapping: {
            (options?: srmService.vim.ArrayOfPerformanceManagerCounterLevelMapping): srmService.vim.ArrayOfPerformanceManagerCounterLevelMapping;
         };
         PerfInterval: {
            (options?: srmService.vim.PerfInterval): srmService.vim.PerfInterval;
         };
         ArrayOfPerfInterval: {
            (options?: srmService.vim.ArrayOfPerfInterval): srmService.vim.ArrayOfPerfInterval;
         };
         PosixUserSearchResult: {
            (options?: srmService.vim.PosixUserSearchResult): srmService.vim.PosixUserSearchResult;
         };
         PrivilegePolicyDef: {
            (options?: srmService.vim.PrivilegePolicyDef): srmService.vim.PrivilegePolicyDef;
         };
         ResourceAllocationInfo: {
            (options?: srmService.vim.ResourceAllocationInfo): srmService.vim.ResourceAllocationInfo;
         };
         ResourceAllocationOption: {
            (options?: srmService.vim.ResourceAllocationOption): srmService.vim.ResourceAllocationOption;
         };
         ResourceConfigOption: {
            (options?: srmService.vim.ResourceConfigOption): srmService.vim.ResourceConfigOption;
         };
         ResourceConfigSpec: {
            (options?: srmService.vim.ResourceConfigSpec): srmService.vim.ResourceConfigSpec;
         };
         ArrayOfResourceConfigSpec: {
            (options?: srmService.vim.ArrayOfResourceConfigSpec): srmService.vim.ArrayOfResourceConfigSpec;
         };
         DatabaseSizeParam: {
            (options?: srmService.vim.DatabaseSizeParam): srmService.vim.DatabaseSizeParam;
         };
         InventoryDescription: {
            (options?: srmService.vim.InventoryDescription): srmService.vim.InventoryDescription;
         };
         PerformanceStatisticsDescription: {
            (options?: srmService.vim.PerformanceStatisticsDescription): srmService.vim.PerformanceStatisticsDescription;
         };
         DatabaseSizeEstimate: {
            (options?: srmService.vim.DatabaseSizeEstimate): srmService.vim.DatabaseSizeEstimate;
         };
         ResourcePoolResourceUsage: {
            (options?: srmService.vim.ResourcePoolResourceUsage): srmService.vim.ResourcePoolResourceUsage;
         };
         ResourcePoolRuntimeInfo: {
            (options?: srmService.vim.ResourcePoolRuntimeInfo): srmService.vim.ResourcePoolRuntimeInfo;
         };
         ResourcePoolQuickStats: {
            (options?: srmService.vim.ResourcePoolQuickStats): srmService.vim.ResourcePoolQuickStats;
         };
         ResourcePoolSummary: {
            (options?: srmService.vim.ResourcePoolSummary): srmService.vim.ResourcePoolSummary;
         };
         SelectionSet: {
            (options?: srmService.vim.SelectionSet): srmService.vim.SelectionSet;
         };
         ArrayOfSelectionSet: {
            (options?: srmService.vim.ArrayOfSelectionSet): srmService.vim.ArrayOfSelectionSet;
         };
         ServiceManagerServiceInfo: {
            (options?: srmService.vim.ServiceManagerServiceInfo): srmService.vim.ServiceManagerServiceInfo;
         };
         ArrayOfServiceManagerServiceInfo: {
            (options?: srmService.vim.ArrayOfServiceManagerServiceInfo): srmService.vim.ArrayOfServiceManagerServiceInfo;
         };
         SessionManagerLocalTicket: {
            (options?: srmService.vim.SessionManagerLocalTicket): srmService.vim.SessionManagerLocalTicket;
         };
         SessionManagerGenericServiceTicket: {
            (options?: srmService.vim.SessionManagerGenericServiceTicket): srmService.vim.SessionManagerGenericServiceTicket;
         };
         SessionManagerServiceRequestSpec: {
            (options?: srmService.vim.SessionManagerServiceRequestSpec): srmService.vim.SessionManagerServiceRequestSpec;
         };
         SessionManagerVmomiServiceRequestSpec: {
            (options?: srmService.vim.SessionManagerVmomiServiceRequestSpec): srmService.vim.SessionManagerVmomiServiceRequestSpec;
         };
         SessionManagerHttpServiceRequestSpecMethod: {
            "httpOptions": string;
            "httpGet": string;
            "httpHead": string;
            "httpPost": string;
            "httpPut": string;
            "httpDelete": string;
            "httpTrace": string;
            "httpConnect": string;
         };
         SessionManagerHttpServiceRequestSpec: {
            (options?: srmService.vim.SessionManagerHttpServiceRequestSpec): srmService.vim.SessionManagerHttpServiceRequestSpec;
         };
         SharesLevel: {
            "low": string;
            "normal": string;
            "high": string;
            "custom": string;
         };
         SharesInfo: {
            (options?: srmService.vim.SharesInfo): srmService.vim.SharesInfo;
         };
         SharesOption: {
            (options?: srmService.vim.SharesOption): srmService.vim.SharesOption;
         };
         SimpleCommandEncoding: {
            "CSV": string;
            "HEX": string;
            "STRING": string;
         };
         SingleIp: {
            (options?: srmService.vim.SingleIp): srmService.vim.SingleIp;
         };
         SingleMac: {
            (options?: srmService.vim.SingleMac): srmService.vim.SingleMac;
         };
         StoragePodSummary: {
            (options?: srmService.vim.StoragePodSummary): srmService.vim.StoragePodSummary;
         };
         StorageIOAllocationInfo: {
            (options?: srmService.vim.StorageIOAllocationInfo): srmService.vim.StorageIOAllocationInfo;
         };
         StorageIOAllocationOption: {
            (options?: srmService.vim.StorageIOAllocationOption): srmService.vim.StorageIOAllocationOption;
         };
         StorageIORMThresholdMode: {
            "automatic": string;
            "manual": string;
         };
         StorageIORMInfo: {
            (options?: srmService.vim.StorageIORMInfo): srmService.vim.StorageIORMInfo;
         };
         StorageIORMConfigSpec: {
            (options?: srmService.vim.StorageIORMConfigSpec): srmService.vim.StorageIORMConfigSpec;
         };
         StorageIORMConfigOption: {
            (options?: srmService.vim.StorageIORMConfigOption): srmService.vim.StorageIORMConfigOption;
         };
         StoragePerformanceSummary: {
            (options?: srmService.vim.StoragePerformanceSummary): srmService.vim.StoragePerformanceSummary;
         };
         ArrayOfStoragePerformanceSummary: {
            (options?: srmService.vim.ArrayOfStoragePerformanceSummary): srmService.vim.ArrayOfStoragePerformanceSummary;
         };
         PodStorageDrsEntry: {
            (options?: srmService.vim.PodStorageDrsEntry): srmService.vim.PodStorageDrsEntry;
         };
         StringExpression: {
            (options?: srmService.vim.StringExpression): srmService.vim.StringExpression;
         };
         StringPolicy: {
            (options?: srmService.vim.StringPolicy): srmService.vim.StringPolicy;
         };
         Tag: {
            (options?: srmService.vim.Tag): srmService.vim.Tag;
         };
         ArrayOfTag: {
            (options?: srmService.vim.ArrayOfTag): srmService.vim.ArrayOfTag;
         };
         TaskDescription: {
            (options?: srmService.vim.TaskDescription): srmService.vim.TaskDescription;
         };
         TaskFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         TaskFilterSpecTimeOption: {
            "queuedTime": string;
            "startedTime": string;
            "completedTime": string;
         };
         TaskFilterSpecByEntity: {
            (options?: srmService.vim.TaskFilterSpecByEntity): srmService.vim.TaskFilterSpecByEntity;
         };
         TaskFilterSpecByTime: {
            (options?: srmService.vim.TaskFilterSpecByTime): srmService.vim.TaskFilterSpecByTime;
         };
         TaskFilterSpecByUsername: {
            (options?: srmService.vim.TaskFilterSpecByUsername): srmService.vim.TaskFilterSpecByUsername;
         };
         TaskFilterSpec: {
            (options?: srmService.vim.TaskFilterSpec): srmService.vim.TaskFilterSpec;
         };
         TaskInfoState: {
            "queued": string;
            "running": string;
            "success": string;
            "error": string;
         };
         ArrayOfTaskInfoState: {
            (options?: srmService.vim.ArrayOfTaskInfoState): srmService.vim.ArrayOfTaskInfoState;
         };
         TaskInfo: {
            (options?: srmService.vim.TaskInfo): srmService.vim.TaskInfo;
         };
         ArrayOfTaskInfo: {
            (options?: srmService.vim.ArrayOfTaskInfo): srmService.vim.ArrayOfTaskInfo;
         };
         TaskReason: {
            (options?: srmService.vim.TaskReason): srmService.vim.TaskReason;
         };
         TaskReasonSystem: {
            (options?: srmService.vim.TaskReasonSystem): srmService.vim.TaskReasonSystem;
         };
         TaskReasonUser: {
            (options?: srmService.vim.TaskReasonUser): srmService.vim.TaskReasonUser;
         };
         TaskReasonAlarm: {
            (options?: srmService.vim.TaskReasonAlarm): srmService.vim.TaskReasonAlarm;
         };
         TaskReasonSchedule: {
            (options?: srmService.vim.TaskReasonSchedule): srmService.vim.TaskReasonSchedule;
         };
         TypeDescription: {
            (options?: srmService.vim.TypeDescription): srmService.vim.TypeDescription;
         };
         ArrayOfTypeDescription: {
            (options?: srmService.vim.ArrayOfTypeDescription): srmService.vim.ArrayOfTypeDescription;
         };
         UpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: srmService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo): srmService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: srmService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo): srmService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         UpdateVirtualMachineFilesResult: {
            (options?: srmService.vim.UpdateVirtualMachineFilesResult): srmService.vim.UpdateVirtualMachineFilesResult;
         };
         UserSearchResult: {
            (options?: srmService.vim.UserSearchResult): srmService.vim.UserSearchResult;
         };
         ArrayOfUserSearchResult: {
            (options?: srmService.vim.ArrayOfUserSearchResult): srmService.vim.ArrayOfUserSearchResult;
         };
         UserSession: {
            (options?: srmService.vim.UserSession): srmService.vim.UserSession;
         };
         ArrayOfUserSession: {
            (options?: srmService.vim.ArrayOfUserSession): srmService.vim.ArrayOfUserSession;
         };
         VirtualAppVAppState: {
            "started": string;
            "stopped": string;
            "starting": string;
            "stopping": string;
         };
         VirtualAppSummary: {
            (options?: srmService.vim.VirtualAppSummary): srmService.vim.VirtualAppSummary;
         };
         VirtualAppLinkInfo: {
            (options?: srmService.vim.VirtualAppLinkInfo): srmService.vim.VirtualAppLinkInfo;
         };
         ArrayOfVirtualAppLinkInfo: {
            (options?: srmService.vim.ArrayOfVirtualAppLinkInfo): srmService.vim.ArrayOfVirtualAppLinkInfo;
         };
         VirtualDiskType: {
            "preallocated": string;
            "thin": string;
            "seSparse": string;
            "rdm": string;
            "rdmp": string;
            "raw": string;
            "delta": string;
            "sparse2Gb": string;
            "thick2Gb": string;
            "eagerZeroedThick": string;
            "sparseMonolithic": string;
            "flatMonolithic": string;
            "thick": string;
         };
         VirtualDiskAdapterType: {
            "ide": string;
            "busLogic": string;
            "lsiLogic": string;
         };
         VirtualDiskSpec: {
            (options?: srmService.vim.VirtualDiskSpec): srmService.vim.VirtualDiskSpec;
         };
         FileBackedVirtualDiskSpec: {
            (options?: srmService.vim.FileBackedVirtualDiskSpec): srmService.vim.FileBackedVirtualDiskSpec;
         };
         SeSparseVirtualDiskSpec: {
            (options?: srmService.vim.SeSparseVirtualDiskSpec): srmService.vim.SeSparseVirtualDiskSpec;
         };
         DeviceBackedVirtualDiskSpec: {
            (options?: srmService.vim.DeviceBackedVirtualDiskSpec): srmService.vim.DeviceBackedVirtualDiskSpec;
         };
         StorageRequirement: {
            (options?: srmService.vim.StorageRequirement): srmService.vim.StorageRequirement;
         };
         ArrayOfStorageRequirement: {
            (options?: srmService.vim.ArrayOfStorageRequirement): srmService.vim.ArrayOfStorageRequirement;
         };
         VirtualMachinePowerState: {
            "poweredOff": string;
            "poweredOn": string;
            "suspended": string;
         };
         VirtualMachineAppHeartbeatStatusType: {
            "appStatusGray": string;
            "appStatusGreen": string;
            "appStatusRed": string;
         };
         VirtualMachineConnectionState: {
            "connected": string;
            "disconnected": string;
            "orphaned": string;
            "inaccessible": string;
            "invalid": string;
         };
         VirtualMachineMovePriority: {
            "lowPriority": string;
            "highPriority": string;
            "defaultPriority": string;
         };
         VirtualMachineTicket: {
            (options?: srmService.vim.VirtualMachineTicket): srmService.vim.VirtualMachineTicket;
         };
         VirtualMachineMksTicket: {
            (options?: srmService.vim.VirtualMachineMksTicket): srmService.vim.VirtualMachineMksTicket;
         };
         VirtualMachineFaultToleranceState: {
            "notConfigured": string;
            "disabled": string;
            "enabled": string;
            "needSecondary": string;
            "starting": string;
            "running": string;
         };
         VirtualMachineRecordReplayState: {
            "recording": string;
            "replaying": string;
            "inactive": string;
         };
         VirtualMachineNeedSecondaryReason: {
            "initializing": string;
            "divergence": string;
            "lostConnection": string;
            "partialHardwareFailure": string;
            "userAction": string;
            "other": string;
         };
         VirtualMachineTicketType: {
            "mks": string;
            "device": string;
            "guestControl": string;
         };
         VirtualMachineDisplayTopology: {
            (options?: srmService.vim.VirtualMachineDisplayTopology): srmService.vim.VirtualMachineDisplayTopology;
         };
         ArrayOfVirtualMachineDisplayTopology: {
            (options?: srmService.vim.ArrayOfVirtualMachineDisplayTopology): srmService.vim.ArrayOfVirtualMachineDisplayTopology;
         };
         DiskChangeExtent: {
            (options?: srmService.vim.DiskChangeExtent): srmService.vim.DiskChangeExtent;
         };
         ArrayOfDiskChangeExtent: {
            (options?: srmService.vim.ArrayOfDiskChangeExtent): srmService.vim.ArrayOfDiskChangeExtent;
         };
         DiskChangeInfo: {
            (options?: srmService.vim.DiskChangeInfo): srmService.vim.DiskChangeInfo;
         };
         VirtualMachineWipeResult: {
            (options?: srmService.vim.VirtualMachineWipeResult): srmService.vim.VirtualMachineWipeResult;
         };
         ActionParameter: {
            "targetName": string;
            "alarmName": string;
            "oldStatus": string;
            "newStatus": string;
            "triggeringSummary": string;
            "declaringSummary": string;
            "eventDescription": string;
            "target": string;
            "alarm": string;
         };
         Action: {
            (options?: srmService.vim.Action): srmService.vim.Action;
         };
         MethodActionArgument: {
            (options?: srmService.vim.MethodActionArgument): srmService.vim.MethodActionArgument;
         };
         ArrayOfMethodActionArgument: {
            (options?: srmService.vim.ArrayOfMethodActionArgument): srmService.vim.ArrayOfMethodActionArgument;
         };
         MethodAction: {
            (options?: srmService.vim.MethodAction): srmService.vim.MethodAction;
         };
         SendEmailAction: {
            (options?: srmService.vim.SendEmailAction): srmService.vim.SendEmailAction;
         };
         SendSNMPAction: {
            (options?: srmService.vim.SendSNMPAction): srmService.vim.SendSNMPAction;
         };
         RunScriptAction: {
            (options?: srmService.vim.RunScriptAction): srmService.vim.RunScriptAction;
         };
         CreateTaskAction: {
            (options?: srmService.vim.CreateTaskAction): srmService.vim.CreateTaskAction;
         };
         AlarmAction: {
            (options?: srmService.vim.AlarmAction): srmService.vim.AlarmAction;
         };
         ArrayOfAlarmAction: {
            (options?: srmService.vim.ArrayOfAlarmAction): srmService.vim.ArrayOfAlarmAction;
         };
         AlarmTriggeringActionTransitionSpec: {
            (options?: srmService.vim.AlarmTriggeringActionTransitionSpec): srmService.vim.AlarmTriggeringActionTransitionSpec;
         };
         ArrayOfAlarmTriggeringActionTransitionSpec: {
            (options?: srmService.vim.ArrayOfAlarmTriggeringActionTransitionSpec): srmService.vim.ArrayOfAlarmTriggeringActionTransitionSpec;
         };
         AlarmTriggeringAction: {
            (options?: srmService.vim.AlarmTriggeringAction): srmService.vim.AlarmTriggeringAction;
         };
         GroupAlarmAction: {
            (options?: srmService.vim.GroupAlarmAction): srmService.vim.GroupAlarmAction;
         };
         AlarmDescription: {
            (options?: srmService.vim.AlarmDescription): srmService.vim.AlarmDescription;
         };
         AlarmExpression: {
            (options?: srmService.vim.AlarmExpression): srmService.vim.AlarmExpression;
         };
         ArrayOfAlarmExpression: {
            (options?: srmService.vim.ArrayOfAlarmExpression): srmService.vim.ArrayOfAlarmExpression;
         };
         AndAlarmExpression: {
            (options?: srmService.vim.AndAlarmExpression): srmService.vim.AndAlarmExpression;
         };
         OrAlarmExpression: {
            (options?: srmService.vim.OrAlarmExpression): srmService.vim.OrAlarmExpression;
         };
         StateAlarmOperator: {
            "isEqual": string;
            "isUnequal": string;
         };
         StateAlarmExpression: {
            (options?: srmService.vim.StateAlarmExpression): srmService.vim.StateAlarmExpression;
         };
         EventAlarmExpressionComparisonOperator: {
            "equals": string;
            "notEqualTo": string;
            "startsWith": string;
            "doesNotStartWith": string;
            "endsWith": string;
            "doesNotEndWith": string;
         };
         EventAlarmExpressionComparison: {
            (options?: srmService.vim.EventAlarmExpressionComparison): srmService.vim.EventAlarmExpressionComparison;
         };
         ArrayOfEventAlarmExpressionComparison: {
            (options?: srmService.vim.ArrayOfEventAlarmExpressionComparison): srmService.vim.ArrayOfEventAlarmExpressionComparison;
         };
         EventAlarmExpression: {
            (options?: srmService.vim.EventAlarmExpression): srmService.vim.EventAlarmExpression;
         };
         MetricAlarmOperator: {
            "isAbove": string;
            "isBelow": string;
         };
         MetricAlarmExpression: {
            (options?: srmService.vim.MetricAlarmExpression): srmService.vim.MetricAlarmExpression;
         };
         AlarmInfo: {
            (options?: srmService.vim.AlarmInfo): srmService.vim.AlarmInfo;
         };
         AlarmSetting: {
            (options?: srmService.vim.AlarmSetting): srmService.vim.AlarmSetting;
         };
         AlarmSpec: {
            (options?: srmService.vim.AlarmSpec): srmService.vim.AlarmSpec;
         };
         AlarmState: {
            (options?: srmService.vim.AlarmState): srmService.vim.AlarmState;
         };
         ArrayOfAlarmState: {
            (options?: srmService.vim.ArrayOfAlarmState): srmService.vim.ArrayOfAlarmState;
         };
         ActionType: {
            "MigrationV1": string;
            "VmPowerV1": string;
            "HostPowerV1": string;
            "HostMaintenanceV1": string;
            "StorageMigrationV1": string;
            "StoragePlacementV1": string;
         };
         ClusterAction: {
            (options?: srmService.vim.ClusterAction): srmService.vim.ClusterAction;
         };
         ArrayOfClusterAction: {
            (options?: srmService.vim.ArrayOfClusterAction): srmService.vim.ArrayOfClusterAction;
         };
         ClusterActionHistory: {
            (options?: srmService.vim.ClusterActionHistory): srmService.vim.ClusterActionHistory;
         };
         ArrayOfClusterActionHistory: {
            (options?: srmService.vim.ArrayOfClusterActionHistory): srmService.vim.ArrayOfClusterActionHistory;
         };
         ClusterAffinityRuleSpec: {
            (options?: srmService.vim.ClusterAffinityRuleSpec): srmService.vim.ClusterAffinityRuleSpec;
         };
         ClusterAntiAffinityRuleSpec: {
            (options?: srmService.vim.ClusterAntiAffinityRuleSpec): srmService.vim.ClusterAntiAffinityRuleSpec;
         };
         ClusterAttemptedVmInfo: {
            (options?: srmService.vim.ClusterAttemptedVmInfo): srmService.vim.ClusterAttemptedVmInfo;
         };
         ArrayOfClusterAttemptedVmInfo: {
            (options?: srmService.vim.ArrayOfClusterAttemptedVmInfo): srmService.vim.ArrayOfClusterAttemptedVmInfo;
         };
         ClusterConfigInfo: {
            (options?: srmService.vim.ClusterConfigInfo): srmService.vim.ClusterConfigInfo;
         };
         DrsBehavior: {
            "manual": string;
            "partiallyAutomated": string;
            "fullyAutomated": string;
         };
         ClusterDrsConfigInfo: {
            (options?: srmService.vim.ClusterDrsConfigInfo): srmService.vim.ClusterDrsConfigInfo;
         };
         ClusterDrsVmConfigInfo: {
            (options?: srmService.vim.ClusterDrsVmConfigInfo): srmService.vim.ClusterDrsVmConfigInfo;
         };
         ArrayOfClusterDrsVmConfigInfo: {
            (options?: srmService.vim.ArrayOfClusterDrsVmConfigInfo): srmService.vim.ArrayOfClusterDrsVmConfigInfo;
         };
         ClusterConfigInfoEx: {
            (options?: srmService.vim.ClusterConfigInfoEx): srmService.vim.ClusterConfigInfoEx;
         };
         DpmBehavior: {
            "manual": string;
            "automated": string;
         };
         ClusterDpmConfigInfo: {
            (options?: srmService.vim.ClusterDpmConfigInfo): srmService.vim.ClusterDpmConfigInfo;
         };
         ClusterDpmHostConfigInfo: {
            (options?: srmService.vim.ClusterDpmHostConfigInfo): srmService.vim.ClusterDpmHostConfigInfo;
         };
         ArrayOfClusterDpmHostConfigInfo: {
            (options?: srmService.vim.ArrayOfClusterDpmHostConfigInfo): srmService.vim.ArrayOfClusterDpmHostConfigInfo;
         };
         ClusterConfigSpec: {
            (options?: srmService.vim.ClusterConfigSpec): srmService.vim.ClusterConfigSpec;
         };
         ClusterDasVmConfigSpec: {
            (options?: srmService.vim.ClusterDasVmConfigSpec): srmService.vim.ClusterDasVmConfigSpec;
         };
         ArrayOfClusterDasVmConfigSpec: {
            (options?: srmService.vim.ArrayOfClusterDasVmConfigSpec): srmService.vim.ArrayOfClusterDasVmConfigSpec;
         };
         ClusterDrsVmConfigSpec: {
            (options?: srmService.vim.ClusterDrsVmConfigSpec): srmService.vim.ClusterDrsVmConfigSpec;
         };
         ArrayOfClusterDrsVmConfigSpec: {
            (options?: srmService.vim.ArrayOfClusterDrsVmConfigSpec): srmService.vim.ArrayOfClusterDrsVmConfigSpec;
         };
         ClusterConfigSpecEx: {
            (options?: srmService.vim.ClusterConfigSpecEx): srmService.vim.ClusterConfigSpecEx;
         };
         ClusterDpmHostConfigSpec: {
            (options?: srmService.vim.ClusterDpmHostConfigSpec): srmService.vim.ClusterDpmHostConfigSpec;
         };
         ArrayOfClusterDpmHostConfigSpec: {
            (options?: srmService.vim.ArrayOfClusterDpmHostConfigSpec): srmService.vim.ArrayOfClusterDpmHostConfigSpec;
         };
         ClusterGroupSpec: {
            (options?: srmService.vim.ClusterGroupSpec): srmService.vim.ClusterGroupSpec;
         };
         ArrayOfClusterGroupSpec: {
            (options?: srmService.vim.ArrayOfClusterGroupSpec): srmService.vim.ArrayOfClusterGroupSpec;
         };
         ClusterDasAamHostInfo: {
            (options?: srmService.vim.ClusterDasAamHostInfo): srmService.vim.ClusterDasAamHostInfo;
         };
         ClusterDasAamNodeStateDasState: {
            "uninitialized": string;
            "initialized": string;
            "configuring": string;
            "unconfiguring": string;
            "running": string;
            "error": string;
            "agentShutdown": string;
            "nodeFailed": string;
         };
         ClusterDasAamNodeState: {
            (options?: srmService.vim.ClusterDasAamNodeState): srmService.vim.ClusterDasAamNodeState;
         };
         ArrayOfClusterDasAamNodeState: {
            (options?: srmService.vim.ArrayOfClusterDasAamNodeState): srmService.vim.ArrayOfClusterDasAamNodeState;
         };
         ClusterDasAdmissionControlInfo: {
            (options?: srmService.vim.ClusterDasAdmissionControlInfo): srmService.vim.ClusterDasAdmissionControlInfo;
         };
         ClusterDasAdmissionControlPolicy: {
            (options?: srmService.vim.ClusterDasAdmissionControlPolicy): srmService.vim.ClusterDasAdmissionControlPolicy;
         };
         DasHeartbeatDatastoreInfo: {
            (options?: srmService.vim.DasHeartbeatDatastoreInfo): srmService.vim.DasHeartbeatDatastoreInfo;
         };
         ArrayOfDasHeartbeatDatastoreInfo: {
            (options?: srmService.vim.ArrayOfDasHeartbeatDatastoreInfo): srmService.vim.ArrayOfDasHeartbeatDatastoreInfo;
         };
         ClusterDasAdvancedRuntimeInfo: {
            (options?: srmService.vim.ClusterDasAdvancedRuntimeInfo): srmService.vim.ClusterDasAdvancedRuntimeInfo;
         };
         ClusterDasConfigInfoServiceState: {
            "disabled": string;
            "enabled": string;
         };
         ClusterDasConfigInfoVmMonitoringState: {
            "vmMonitoringDisabled": string;
            "vmMonitoringOnly": string;
            "vmAndAppMonitoring": string;
         };
         ClusterDasConfigInfoHBDatastoreCandidate: {
            "userSelectedDs": string;
            "allFeasibleDs": string;
            "allFeasibleDsWithUserPreference": string;
         };
         ClusterDasConfigInfo: {
            (options?: srmService.vim.ClusterDasConfigInfo): srmService.vim.ClusterDasConfigInfo;
         };
         ClusterDasData: {
            (options?: srmService.vim.ClusterDasData): srmService.vim.ClusterDasData;
         };
         ClusterDasDataSummary: {
            (options?: srmService.vim.ClusterDasDataSummary): srmService.vim.ClusterDasDataSummary;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo: {
            (options?: srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo): srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: srmService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): srmService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: srmService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): srmService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfo: {
            (options?: srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo): srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo;
         };
         ClusterDasFdmAvailabilityState: {
            "uninitialized": string;
            "election": string;
            "master": string;
            "connectedToMaster": string;
            "networkPartitionedFromMaster": string;
            "networkIsolated": string;
            "hostDown": string;
            "initializationError": string;
            "uninitializationError": string;
            "fdmUnreachable": string;
         };
         ClusterDasFdmHostState: {
            (options?: srmService.vim.ClusterDasFdmHostState): srmService.vim.ClusterDasFdmHostState;
         };
         ClusterDasHostInfo: {
            (options?: srmService.vim.ClusterDasHostInfo): srmService.vim.ClusterDasHostInfo;
         };
         ClusterDasHostRecommendation: {
            (options?: srmService.vim.ClusterDasHostRecommendation): srmService.vim.ClusterDasHostRecommendation;
         };
         DasVmPriority: {
            "disabled": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         ClusterDasVmConfigInfo: {
            (options?: srmService.vim.ClusterDasVmConfigInfo): srmService.vim.ClusterDasVmConfigInfo;
         };
         ArrayOfClusterDasVmConfigInfo: {
            (options?: srmService.vim.ArrayOfClusterDasVmConfigInfo): srmService.vim.ArrayOfClusterDasVmConfigInfo;
         };
         ClusterDasVmSettingsRestartPriority: {
            "disabled": string;
            "low": string;
            "medium": string;
            "high": string;
            "clusterRestartPriority": string;
         };
         ClusterDasVmSettingsIsolationResponse: {
            "none": string;
            "powerOff": string;
            "shutdown": string;
            "clusterIsolationResponse": string;
         };
         ClusterDasVmSettings: {
            (options?: srmService.vim.ClusterDasVmSettings): srmService.vim.ClusterDasVmSettings;
         };
         ClusterDrsFaultsFaultsByVm: {
            (options?: srmService.vim.ClusterDrsFaultsFaultsByVm): srmService.vim.ClusterDrsFaultsFaultsByVm;
         };
         ArrayOfClusterDrsFaultsFaultsByVm: {
            (options?: srmService.vim.ArrayOfClusterDrsFaultsFaultsByVm): srmService.vim.ArrayOfClusterDrsFaultsFaultsByVm;
         };
         ClusterDrsFaultsFaultsByVirtualDisk: {
            (options?: srmService.vim.ClusterDrsFaultsFaultsByVirtualDisk): srmService.vim.ClusterDrsFaultsFaultsByVirtualDisk;
         };
         ClusterDrsFaults: {
            (options?: srmService.vim.ClusterDrsFaults): srmService.vim.ClusterDrsFaults;
         };
         ArrayOfClusterDrsFaults: {
            (options?: srmService.vim.ArrayOfClusterDrsFaults): srmService.vim.ArrayOfClusterDrsFaults;
         };
         ClusterDrsMigration: {
            (options?: srmService.vim.ClusterDrsMigration): srmService.vim.ClusterDrsMigration;
         };
         ArrayOfClusterDrsMigration: {
            (options?: srmService.vim.ArrayOfClusterDrsMigration): srmService.vim.ArrayOfClusterDrsMigration;
         };
         DrsRecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
         };
         ClusterDrsRecommendation: {
            (options?: srmService.vim.ClusterDrsRecommendation): srmService.vim.ClusterDrsRecommendation;
         };
         ArrayOfClusterDrsRecommendation: {
            (options?: srmService.vim.ArrayOfClusterDrsRecommendation): srmService.vim.ArrayOfClusterDrsRecommendation;
         };
         ClusterEnterMaintenanceResult: {
            (options?: srmService.vim.ClusterEnterMaintenanceResult): srmService.vim.ClusterEnterMaintenanceResult;
         };
         ClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: srmService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus): srmService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: srmService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus): srmService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ClusterFailoverHostAdmissionControlInfo: {
            (options?: srmService.vim.ClusterFailoverHostAdmissionControlInfo): srmService.vim.ClusterFailoverHostAdmissionControlInfo;
         };
         ClusterFailoverHostAdmissionControlPolicy: {
            (options?: srmService.vim.ClusterFailoverHostAdmissionControlPolicy): srmService.vim.ClusterFailoverHostAdmissionControlPolicy;
         };
         ClusterFailoverLevelAdmissionControlInfo: {
            (options?: srmService.vim.ClusterFailoverLevelAdmissionControlInfo): srmService.vim.ClusterFailoverLevelAdmissionControlInfo;
         };
         ClusterFailoverLevelAdmissionControlPolicy: {
            (options?: srmService.vim.ClusterFailoverLevelAdmissionControlPolicy): srmService.vim.ClusterFailoverLevelAdmissionControlPolicy;
         };
         ClusterFailoverResourcesAdmissionControlInfo: {
            (options?: srmService.vim.ClusterFailoverResourcesAdmissionControlInfo): srmService.vim.ClusterFailoverResourcesAdmissionControlInfo;
         };
         ClusterFailoverResourcesAdmissionControlPolicy: {
            (options?: srmService.vim.ClusterFailoverResourcesAdmissionControlPolicy): srmService.vim.ClusterFailoverResourcesAdmissionControlPolicy;
         };
         ClusterGroupInfo: {
            (options?: srmService.vim.ClusterGroupInfo): srmService.vim.ClusterGroupInfo;
         };
         ArrayOfClusterGroupInfo: {
            (options?: srmService.vim.ArrayOfClusterGroupInfo): srmService.vim.ArrayOfClusterGroupInfo;
         };
         ClusterHostGroup: {
            (options?: srmService.vim.ClusterHostGroup): srmService.vim.ClusterHostGroup;
         };
         HostPowerOperationType: {
            "powerOn": string;
            "powerOff": string;
         };
         ClusterHostPowerAction: {
            (options?: srmService.vim.ClusterHostPowerAction): srmService.vim.ClusterHostPowerAction;
         };
         ClusterHostRecommendation: {
            (options?: srmService.vim.ClusterHostRecommendation): srmService.vim.ClusterHostRecommendation;
         };
         ArrayOfClusterHostRecommendation: {
            (options?: srmService.vim.ArrayOfClusterHostRecommendation): srmService.vim.ArrayOfClusterHostRecommendation;
         };
         ClusterInitialPlacementAction: {
            (options?: srmService.vim.ClusterInitialPlacementAction): srmService.vim.ClusterInitialPlacementAction;
         };
         ClusterMigrationAction: {
            (options?: srmService.vim.ClusterMigrationAction): srmService.vim.ClusterMigrationAction;
         };
         ClusterNotAttemptedVmInfo: {
            (options?: srmService.vim.ClusterNotAttemptedVmInfo): srmService.vim.ClusterNotAttemptedVmInfo;
         };
         ArrayOfClusterNotAttemptedVmInfo: {
            (options?: srmService.vim.ArrayOfClusterNotAttemptedVmInfo): srmService.vim.ArrayOfClusterNotAttemptedVmInfo;
         };
         ClusterPowerOnVmOption: {
            "OverrideAutomationLevel": string;
            "ReserveResources": string;
         };
         ClusterPowerOnVmResult: {
            (options?: srmService.vim.ClusterPowerOnVmResult): srmService.vim.ClusterPowerOnVmResult;
         };
         RecommendationType: {
            "V1": string;
         };
         RecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
            "enterStandby": string;
            "reservationCpu": string;
            "reservationMem": string;
            "powerOnVm": string;
            "powerSaving": string;
            "increaseCapacity": string;
            "checkResource": string;
            "unreservedCapacity": string;
            "vmHostHardAffinity": string;
            "vmHostSoftAffinity": string;
            "balanceDatastoreSpaceUsage": string;
            "balanceDatastoreIOLoad": string;
            "datastoreMaint": string;
            "virtualDiskJointAffin": string;
            "virtualDiskAntiAffin": string;
            "datastoreSpaceOutage": string;
            "storagePlacement": string;
            "iolbDisabledInternal": string;
         };
         ClusterRecommendation: {
            (options?: srmService.vim.ClusterRecommendation): srmService.vim.ClusterRecommendation;
         };
         ArrayOfClusterRecommendation: {
            (options?: srmService.vim.ArrayOfClusterRecommendation): srmService.vim.ArrayOfClusterRecommendation;
         };
         ClusterRuleInfo: {
            (options?: srmService.vim.ClusterRuleInfo): srmService.vim.ClusterRuleInfo;
         };
         ArrayOfClusterRuleInfo: {
            (options?: srmService.vim.ArrayOfClusterRuleInfo): srmService.vim.ArrayOfClusterRuleInfo;
         };
         ClusterRuleSpec: {
            (options?: srmService.vim.ClusterRuleSpec): srmService.vim.ClusterRuleSpec;
         };
         ArrayOfClusterRuleSpec: {
            (options?: srmService.vim.ArrayOfClusterRuleSpec): srmService.vim.ArrayOfClusterRuleSpec;
         };
         ClusterSlotPolicy: {
            (options?: srmService.vim.ClusterSlotPolicy): srmService.vim.ClusterSlotPolicy;
         };
         ClusterFixedSizeSlotPolicy: {
            (options?: srmService.vim.ClusterFixedSizeSlotPolicy): srmService.vim.ClusterFixedSizeSlotPolicy;
         };
         ClusterVmGroup: {
            (options?: srmService.vim.ClusterVmGroup): srmService.vim.ClusterVmGroup;
         };
         ClusterVmHostRuleInfo: {
            (options?: srmService.vim.ClusterVmHostRuleInfo): srmService.vim.ClusterVmHostRuleInfo;
         };
         ClusterVmToolsMonitoringSettings: {
            (options?: srmService.vim.ClusterVmToolsMonitoringSettings): srmService.vim.ClusterVmToolsMonitoringSettings;
         };
         DVPortConfigSpec: {
            (options?: srmService.vim.DVPortConfigSpec): srmService.vim.DVPortConfigSpec;
         };
         ArrayOfDVPortConfigSpec: {
            (options?: srmService.vim.ArrayOfDVPortConfigSpec): srmService.vim.ArrayOfDVPortConfigSpec;
         };
         DVPortConfigInfo: {
            (options?: srmService.vim.DVPortConfigInfo): srmService.vim.DVPortConfigInfo;
         };
         DVSTrafficShapingPolicy: {
            (options?: srmService.vim.DVSTrafficShapingPolicy): srmService.vim.DVSTrafficShapingPolicy;
         };
         DVSHostLocalPortInfo: {
            (options?: srmService.vim.DVSHostLocalPortInfo): srmService.vim.DVSHostLocalPortInfo;
         };
         DVSVendorSpecificConfig: {
            (options?: srmService.vim.DVSVendorSpecificConfig): srmService.vim.DVSVendorSpecificConfig;
         };
         DvsFilterParameter: {
            (options?: srmService.vim.DvsFilterParameter): srmService.vim.DvsFilterParameter;
         };
         DvsFilterOnFailure: {
            "failOpen": string;
            "failClosed": string;
         };
         DvsFilterConfig: {
            (options?: srmService.vim.DvsFilterConfig): srmService.vim.DvsFilterConfig;
         };
         ArrayOfDvsFilterConfig: {
            (options?: srmService.vim.ArrayOfDvsFilterConfig): srmService.vim.ArrayOfDvsFilterConfig;
         };
         DvsTrafficFilterConfig: {
            (options?: srmService.vim.DvsTrafficFilterConfig): srmService.vim.DvsTrafficFilterConfig;
         };
         DvsFilterConfigSpec: {
            (options?: srmService.vim.DvsFilterConfigSpec): srmService.vim.DvsFilterConfigSpec;
         };
         DvsTrafficFilterConfigSpec: {
            (options?: srmService.vim.DvsTrafficFilterConfigSpec): srmService.vim.DvsTrafficFilterConfigSpec;
         };
         DvsFilterPolicy: {
            (options?: srmService.vim.DvsFilterPolicy): srmService.vim.DvsFilterPolicy;
         };
         DVPortSetting: {
            (options?: srmService.vim.DVPortSetting): srmService.vim.DVPortSetting;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonNetwork: {
            "portNptIncompatibleDvs": string;
            "portNptNoCompatibleNics": string;
            "portNptNoVirtualFunctionsAvailable": string;
            "portNptDisabledForPort": string;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonOther: {
            "portNptIncompatibleHost": string;
            "portNptIncompatibleConnectee": string;
         };
         DVPortStatus: {
            (options?: srmService.vim.DVPortStatus): srmService.vim.DVPortStatus;
         };
         DVPortState: {
            (options?: srmService.vim.DVPortState): srmService.vim.DVPortState;
         };
         DistributedVirtualPort: {
            (options?: srmService.vim.DistributedVirtualPort): srmService.vim.DistributedVirtualPort;
         };
         ArrayOfDistributedVirtualPort: {
            (options?: srmService.vim.ArrayOfDistributedVirtualPort): srmService.vim.ArrayOfDistributedVirtualPort;
         };
         DistributedVirtualPortgroupPortgroupType: {
            "earlyBinding": string;
            "lateBinding": string;
            "ephemeral": string;
         };
         DVPortgroupPolicy: {
            (options?: srmService.vim.DVPortgroupPolicy): srmService.vim.DVPortgroupPolicy;
         };
         DistributedVirtualPortgroupMetaTagName: {
            "dvsName": string;
            "portgroupName": string;
            "portIndex": string;
         };
         DVPortgroupConfigSpec: {
            (options?: srmService.vim.DVPortgroupConfigSpec): srmService.vim.DVPortgroupConfigSpec;
         };
         ArrayOfDVPortgroupConfigSpec: {
            (options?: srmService.vim.ArrayOfDVPortgroupConfigSpec): srmService.vim.ArrayOfDVPortgroupConfigSpec;
         };
         DVPortgroupConfigInfo: {
            (options?: srmService.vim.DVPortgroupConfigInfo): srmService.vim.DVPortgroupConfigInfo;
         };
         DistributedVirtualPortgroupInfo: {
            (options?: srmService.vim.DistributedVirtualPortgroupInfo): srmService.vim.DistributedVirtualPortgroupInfo;
         };
         ArrayOfDistributedVirtualPortgroupInfo: {
            (options?: srmService.vim.ArrayOfDistributedVirtualPortgroupInfo): srmService.vim.ArrayOfDistributedVirtualPortgroupInfo;
         };
         DVPortgroupSelection: {
            (options?: srmService.vim.DVPortgroupSelection): srmService.vim.DVPortgroupSelection;
         };
         DistributedVirtualSwitchInfo: {
            (options?: srmService.vim.DistributedVirtualSwitchInfo): srmService.vim.DistributedVirtualSwitchInfo;
         };
         ArrayOfDistributedVirtualSwitchInfo: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchInfo): srmService.vim.ArrayOfDistributedVirtualSwitchInfo;
         };
         DVSManagerDvsConfigTarget: {
            (options?: srmService.vim.DVSManagerDvsConfigTarget): srmService.vim.DVSManagerDvsConfigTarget;
         };
         DistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerCompatibilityResult): srmService.vim.DistributedVirtualSwitchManagerCompatibilityResult;
         };
         ArrayOfDistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult): srmService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult;
         };
         DistributedVirtualSwitchManagerHostContainer: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerHostContainer): srmService.vim.DistributedVirtualSwitchManagerHostContainer;
         };
         DistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec): srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec): srmService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         DistributedVirtualSwitchManagerHostArrayFilter: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerHostArrayFilter): srmService.vim.DistributedVirtualSwitchManagerHostArrayFilter;
         };
         DistributedVirtualSwitchManagerHostContainerFilter: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerHostContainerFilter): srmService.vim.DistributedVirtualSwitchManagerHostContainerFilter;
         };
         DistributedVirtualSwitchManagerHostDvsMembershipFilter: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter): srmService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter;
         };
         DistributedVirtualSwitchManagerDvsProductSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerDvsProductSpec): srmService.vim.DistributedVirtualSwitchManagerDvsProductSpec;
         };
         DistributedVirtualSwitchManagerImportResult: {
            (options?: srmService.vim.DistributedVirtualSwitchManagerImportResult): srmService.vim.DistributedVirtualSwitchManagerImportResult;
         };
         DVSSelection: {
            (options?: srmService.vim.DVSSelection): srmService.vim.DVSSelection;
         };
         EntityBackupConfig: {
            (options?: srmService.vim.EntityBackupConfig): srmService.vim.EntityBackupConfig;
         };
         ArrayOfEntityBackupConfig: {
            (options?: srmService.vim.ArrayOfEntityBackupConfig): srmService.vim.ArrayOfEntityBackupConfig;
         };
         EntityType: {
            "distributedVirtualSwitch": string;
            "distributedVirtualPortgroup": string;
         };
         EntityImportType: {
            "createEntityWithNewIdentifier": string;
            "createEntityWithOriginalIdentifier": string;
            "applyToEntitySpecified": string;
         };
         EntityBackup: {
            (options?: srmService.vim.EntityBackup): srmService.vim.EntityBackup;
         };
         DistributedVirtualSwitchHostMemberHostComponentState: {
            "up": string;
            "pending": string;
            "outOfSync": string;
            "warning": string;
            "disconnected": string;
            "down": string;
         };
         DistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberConfigSpec): srmService.vim.DistributedVirtualSwitchHostMemberConfigSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec): srmService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec;
         };
         DistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberPnicSpec): srmService.vim.DistributedVirtualSwitchHostMemberPnicSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec): srmService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec;
         };
         DistributedVirtualSwitchHostMemberBacking: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberBacking): srmService.vim.DistributedVirtualSwitchHostMemberBacking;
         };
         DistributedVirtualSwitchHostMemberPnicBacking: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberPnicBacking): srmService.vim.DistributedVirtualSwitchHostMemberPnicBacking;
         };
         DistributedVirtualSwitchHostMemberRuntimeState: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberRuntimeState): srmService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
         };
         DistributedVirtualSwitchHostMemberConfigInfo: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMemberConfigInfo): srmService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
         };
         HostMemberRuntimeInfo: {
            (options?: srmService.vim.HostMemberRuntimeInfo): srmService.vim.HostMemberRuntimeInfo;
         };
         ArrayOfHostMemberRuntimeInfo: {
            (options?: srmService.vim.ArrayOfHostMemberRuntimeInfo): srmService.vim.ArrayOfHostMemberRuntimeInfo;
         };
         HostMemberHealthCheckResult: {
            (options?: srmService.vim.HostMemberHealthCheckResult): srmService.vim.HostMemberHealthCheckResult;
         };
         ArrayOfHostMemberHealthCheckResult: {
            (options?: srmService.vim.ArrayOfHostMemberHealthCheckResult): srmService.vim.ArrayOfHostMemberHealthCheckResult;
         };
         HostMemberUplinkHealthCheckResult: {
            (options?: srmService.vim.HostMemberUplinkHealthCheckResult): srmService.vim.HostMemberUplinkHealthCheckResult;
         };
         DistributedVirtualSwitchHostMember: {
            (options?: srmService.vim.DistributedVirtualSwitchHostMember): srmService.vim.DistributedVirtualSwitchHostMember;
         };
         ArrayOfDistributedVirtualSwitchHostMember: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchHostMember): srmService.vim.ArrayOfDistributedVirtualSwitchHostMember;
         };
         DistributedVirtualSwitchHostProductSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchHostProductSpec): srmService.vim.DistributedVirtualSwitchHostProductSpec;
         };
         ArrayOfDistributedVirtualSwitchHostProductSpec: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec): srmService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec;
         };
         DistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob): srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob;
         };
         ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob): srmService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob;
         };
         DVSNetworkResourcePoolAllocationInfo: {
            (options?: srmService.vim.DVSNetworkResourcePoolAllocationInfo): srmService.vim.DVSNetworkResourcePoolAllocationInfo;
         };
         DVSNetworkResourcePoolConfigSpec: {
            (options?: srmService.vim.DVSNetworkResourcePoolConfigSpec): srmService.vim.DVSNetworkResourcePoolConfigSpec;
         };
         ArrayOfDVSNetworkResourcePoolConfigSpec: {
            (options?: srmService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec): srmService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec;
         };
         DVSNetworkResourcePool: {
            (options?: srmService.vim.DVSNetworkResourcePool): srmService.vim.DVSNetworkResourcePool;
         };
         ArrayOfDVSNetworkResourcePool: {
            (options?: srmService.vim.ArrayOfDVSNetworkResourcePool): srmService.vim.ArrayOfDVSNetworkResourcePool;
         };
         DistributedVirtualSwitchPortConnecteeConnecteeType: {
            "pnic": string;
            "vmVnic": string;
            "hostConsoleVnic": string;
            "hostVmkVnic": string;
         };
         DistributedVirtualSwitchPortConnectee: {
            (options?: srmService.vim.DistributedVirtualSwitchPortConnectee): srmService.vim.DistributedVirtualSwitchPortConnectee;
         };
         DistributedVirtualSwitchPortConnection: {
            (options?: srmService.vim.DistributedVirtualSwitchPortConnection): srmService.vim.DistributedVirtualSwitchPortConnection;
         };
         DistributedVirtualSwitchPortCriteria: {
            (options?: srmService.vim.DistributedVirtualSwitchPortCriteria): srmService.vim.DistributedVirtualSwitchPortCriteria;
         };
         DistributedVirtualSwitchPortStatistics: {
            (options?: srmService.vim.DistributedVirtualSwitchPortStatistics): srmService.vim.DistributedVirtualSwitchPortStatistics;
         };
         DistributedVirtualSwitchProductSpec: {
            (options?: srmService.vim.DistributedVirtualSwitchProductSpec): srmService.vim.DistributedVirtualSwitchProductSpec;
         };
         ArrayOfDistributedVirtualSwitchProductSpec: {
            (options?: srmService.vim.ArrayOfDistributedVirtualSwitchProductSpec): srmService.vim.ArrayOfDistributedVirtualSwitchProductSpec;
         };
         DvsNetworkRuleQualifier: {
            (options?: srmService.vim.DvsNetworkRuleQualifier): srmService.vim.DvsNetworkRuleQualifier;
         };
         ArrayOfDvsNetworkRuleQualifier: {
            (options?: srmService.vim.ArrayOfDvsNetworkRuleQualifier): srmService.vim.ArrayOfDvsNetworkRuleQualifier;
         };
         DvsNetworkRuleAction: {
            (options?: srmService.vim.DvsNetworkRuleAction): srmService.vim.DvsNetworkRuleAction;
         };
         DvsNetworkRuleDirectionType: {
            "incomingPackets": string;
            "outgoingPackets": string;
            "both": string;
         };
         DvsIpNetworkRuleQualifier: {
            (options?: srmService.vim.DvsIpNetworkRuleQualifier): srmService.vim.DvsIpNetworkRuleQualifier;
         };
         DvsIpPort: {
            (options?: srmService.vim.DvsIpPort): srmService.vim.DvsIpPort;
         };
         DvsSingleIpPort: {
            (options?: srmService.vim.DvsSingleIpPort): srmService.vim.DvsSingleIpPort;
         };
         DvsIpPortRange: {
            (options?: srmService.vim.DvsIpPortRange): srmService.vim.DvsIpPortRange;
         };
         DvsMacNetworkRuleQualifier: {
            (options?: srmService.vim.DvsMacNetworkRuleQualifier): srmService.vim.DvsMacNetworkRuleQualifier;
         };
         DvsSystemTrafficNetworkRuleQualifier: {
            (options?: srmService.vim.DvsSystemTrafficNetworkRuleQualifier): srmService.vim.DvsSystemTrafficNetworkRuleQualifier;
         };
         DvsDropNetworkRuleAction: {
            (options?: srmService.vim.DvsDropNetworkRuleAction): srmService.vim.DvsDropNetworkRuleAction;
         };
         DvsAcceptNetworkRuleAction: {
            (options?: srmService.vim.DvsAcceptNetworkRuleAction): srmService.vim.DvsAcceptNetworkRuleAction;
         };
         DvsUpdateTagNetworkRuleAction: {
            (options?: srmService.vim.DvsUpdateTagNetworkRuleAction): srmService.vim.DvsUpdateTagNetworkRuleAction;
         };
         DvsRateLimitNetworkRuleAction: {
            (options?: srmService.vim.DvsRateLimitNetworkRuleAction): srmService.vim.DvsRateLimitNetworkRuleAction;
         };
         DvsLogNetworkRuleAction: {
            (options?: srmService.vim.DvsLogNetworkRuleAction): srmService.vim.DvsLogNetworkRuleAction;
         };
         DvsGreEncapNetworkRuleAction: {
            (options?: srmService.vim.DvsGreEncapNetworkRuleAction): srmService.vim.DvsGreEncapNetworkRuleAction;
         };
         DvsMacRewriteNetworkRuleAction: {
            (options?: srmService.vim.DvsMacRewriteNetworkRuleAction): srmService.vim.DvsMacRewriteNetworkRuleAction;
         };
         DvsPuntNetworkRuleAction: {
            (options?: srmService.vim.DvsPuntNetworkRuleAction): srmService.vim.DvsPuntNetworkRuleAction;
         };
         DvsCopyNetworkRuleAction: {
            (options?: srmService.vim.DvsCopyNetworkRuleAction): srmService.vim.DvsCopyNetworkRuleAction;
         };
         DvsTrafficRule: {
            (options?: srmService.vim.DvsTrafficRule): srmService.vim.DvsTrafficRule;
         };
         ArrayOfDvsTrafficRule: {
            (options?: srmService.vim.ArrayOfDvsTrafficRule): srmService.vim.ArrayOfDvsTrafficRule;
         };
         DvsTrafficRuleset: {
            (options?: srmService.vim.DvsTrafficRuleset): srmService.vim.DvsTrafficRuleset;
         };
         VMwareDVSFeatureCapability: {
            (options?: srmService.vim.VMwareDVSFeatureCapability): srmService.vim.VMwareDVSFeatureCapability;
         };
         VMwareDvsLacpCapability: {
            (options?: srmService.vim.VMwareDvsLacpCapability): srmService.vim.VMwareDvsLacpCapability;
         };
         VMwareDVSHealthCheckCapability: {
            (options?: srmService.vim.VMwareDVSHealthCheckCapability): srmService.vim.VMwareDVSHealthCheckCapability;
         };
         VMwareDVSVspanCapability: {
            (options?: srmService.vim.VMwareDVSVspanCapability): srmService.vim.VMwareDVSVspanCapability;
         };
         VMwareVspanPort: {
            (options?: srmService.vim.VMwareVspanPort): srmService.vim.VMwareVspanPort;
         };
         VMwareVspanSession: {
            (options?: srmService.vim.VMwareVspanSession): srmService.vim.VMwareVspanSession;
         };
         ArrayOfVMwareVspanSession: {
            (options?: srmService.vim.ArrayOfVMwareVspanSession): srmService.vim.ArrayOfVMwareVspanSession;
         };
         VMwareIpfixConfig: {
            (options?: srmService.vim.VMwareIpfixConfig): srmService.vim.VMwareIpfixConfig;
         };
         VMwareDVSConfigInfo: {
            (options?: srmService.vim.VMwareDVSConfigInfo): srmService.vim.VMwareDVSConfigInfo;
         };
         VMwareDVSConfigSpec: {
            (options?: srmService.vim.VMwareDVSConfigSpec): srmService.vim.VMwareDVSConfigSpec;
         };
         VMwareUplinkPortOrderPolicy: {
            (options?: srmService.vim.VMwareUplinkPortOrderPolicy): srmService.vim.VMwareUplinkPortOrderPolicy;
         };
         DVSFailureCriteria: {
            (options?: srmService.vim.DVSFailureCriteria): srmService.vim.DVSFailureCriteria;
         };
         VmwareUplinkPortTeamingPolicy: {
            (options?: srmService.vim.VmwareUplinkPortTeamingPolicy): srmService.vim.VmwareUplinkPortTeamingPolicy;
         };
         VmwareDistributedVirtualSwitchVlanSpec: {
            (options?: srmService.vim.VmwareDistributedVirtualSwitchVlanSpec): srmService.vim.VmwareDistributedVirtualSwitchVlanSpec;
         };
         VmwareDistributedVirtualSwitchPvlanSpec: {
            (options?: srmService.vim.VmwareDistributedVirtualSwitchPvlanSpec): srmService.vim.VmwareDistributedVirtualSwitchPvlanSpec;
         };
         VmwareDistributedVirtualSwitchVlanIdSpec: {
            (options?: srmService.vim.VmwareDistributedVirtualSwitchVlanIdSpec): srmService.vim.VmwareDistributedVirtualSwitchVlanIdSpec;
         };
         VmwareDistributedVirtualSwitchTrunkVlanSpec: {
            (options?: srmService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec): srmService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec;
         };
         DVSSecurityPolicy: {
            (options?: srmService.vim.DVSSecurityPolicy): srmService.vim.DVSSecurityPolicy;
         };
         VMwareDVSPortSetting: {
            (options?: srmService.vim.VMwareDVSPortSetting): srmService.vim.VMwareDVSPortSetting;
         };
         VMwareDVSPortgroupPolicy: {
            (options?: srmService.vim.VMwareDVSPortgroupPolicy): srmService.vim.VMwareDVSPortgroupPolicy;
         };
         VmwareDistributedVirtualSwitchPvlanPortType: {
            "promiscuous": string;
            "isolated": string;
            "community": string;
         };
         VMwareDVSPvlanConfigSpec: {
            (options?: srmService.vim.VMwareDVSPvlanConfigSpec): srmService.vim.VMwareDVSPvlanConfigSpec;
         };
         ArrayOfVMwareDVSPvlanConfigSpec: {
            (options?: srmService.vim.ArrayOfVMwareDVSPvlanConfigSpec): srmService.vim.ArrayOfVMwareDVSPvlanConfigSpec;
         };
         VMwareDVSPvlanMapEntry: {
            (options?: srmService.vim.VMwareDVSPvlanMapEntry): srmService.vim.VMwareDVSPvlanMapEntry;
         };
         ArrayOfVMwareDVSPvlanMapEntry: {
            (options?: srmService.vim.ArrayOfVMwareDVSPvlanMapEntry): srmService.vim.ArrayOfVMwareDVSPvlanMapEntry;
         };
         VMwareDVSVspanConfigSpec: {
            (options?: srmService.vim.VMwareDVSVspanConfigSpec): srmService.vim.VMwareDVSVspanConfigSpec;
         };
         ArrayOfVMwareDVSVspanConfigSpec: {
            (options?: srmService.vim.ArrayOfVMwareDVSVspanConfigSpec): srmService.vim.ArrayOfVMwareDVSVspanConfigSpec;
         };
         VMwareDVSVspanSessionType: {
            "mixedDestMirror": string;
            "dvPortMirror": string;
            "remoteMirrorSource": string;
            "remoteMirrorDest": string;
            "encapsulatedRemoteMirrorSource": string;
         };
         VMwareDVSHealthCheckConfig: {
            (options?: srmService.vim.VMwareDVSHealthCheckConfig): srmService.vim.VMwareDVSHealthCheckConfig;
         };
         VMwareDVSVlanMtuHealthCheckConfig: {
            (options?: srmService.vim.VMwareDVSVlanMtuHealthCheckConfig): srmService.vim.VMwareDVSVlanMtuHealthCheckConfig;
         };
         VMwareDVSTeamingHealthCheckConfig: {
            (options?: srmService.vim.VMwareDVSTeamingHealthCheckConfig): srmService.vim.VMwareDVSTeamingHealthCheckConfig;
         };
         VMwareDVSVlanHealthCheckResult: {
            (options?: srmService.vim.VMwareDVSVlanHealthCheckResult): srmService.vim.VMwareDVSVlanHealthCheckResult;
         };
         VMwareDVSMtuHealthCheckResult: {
            (options?: srmService.vim.VMwareDVSMtuHealthCheckResult): srmService.vim.VMwareDVSMtuHealthCheckResult;
         };
         VMwareDVSTeamingMatchStatus: {
            "iphashMatch": string;
            "nonIphashMatch": string;
            "iphashMismatch": string;
            "nonIphashMismatch": string;
         };
         VMwareDVSTeamingHealthCheckResult: {
            (options?: srmService.vim.VMwareDVSTeamingHealthCheckResult): srmService.vim.VMwareDVSTeamingHealthCheckResult;
         };
         VMwareUplinkLacpPolicy: {
            (options?: srmService.vim.VMwareUplinkLacpPolicy): srmService.vim.VMwareUplinkLacpPolicy;
         };
         VMwareDvsLacpGroupConfig: {
            (options?: srmService.vim.VMwareDvsLacpGroupConfig): srmService.vim.VMwareDvsLacpGroupConfig;
         };
         ArrayOfVMwareDvsLacpGroupConfig: {
            (options?: srmService.vim.ArrayOfVMwareDvsLacpGroupConfig): srmService.vim.ArrayOfVMwareDvsLacpGroupConfig;
         };
         VMwareDvsLagVlanConfig: {
            (options?: srmService.vim.VMwareDvsLagVlanConfig): srmService.vim.VMwareDvsLagVlanConfig;
         };
         VMwareDvsLagIpfixConfig: {
            (options?: srmService.vim.VMwareDvsLagIpfixConfig): srmService.vim.VMwareDvsLagIpfixConfig;
         };
         VMwareUplinkLacpMode: {
            "active": string;
            "passive": string;
         };
         VMwareDvsLacpGroupSpec: {
            (options?: srmService.vim.VMwareDvsLacpGroupSpec): srmService.vim.VMwareDvsLacpGroupSpec;
         };
         ArrayOfVMwareDvsLacpGroupSpec: {
            (options?: srmService.vim.ArrayOfVMwareDvsLacpGroupSpec): srmService.vim.ArrayOfVMwareDvsLacpGroupSpec;
         };
         VMwareDvsLacpLoadBalanceAlgorithm: {
            "srcMac": string;
            "destMac": string;
            "srcDestMac": string;
            "destIpVlan": string;
            "srcIpVlan": string;
            "srcDestIpVlan": string;
            "destTcpUdpPort": string;
            "srcTcpUdpPort": string;
            "srcDestTcpUdpPort": string;
            "destIpTcpUdpPort": string;
            "srcIpTcpUdpPort": string;
            "srcDestIpTcpUdpPort": string;
            "destIpTcpUdpPortVlan": string;
            "srcIpTcpUdpPortVlan": string;
            "srcDestIpTcpUdpPortVlan": string;
            "destIp": string;
            "srcIp": string;
            "srcDestIp": string;
            "vlan": string;
            "srcPortId": string;
         };
         VMwareDvsLacpApiVersion: {
            "singleLag": string;
            "multipleLag": string;
         };
         EventEventSeverity: {
            "error": string;
            "warning": string;
            "info": string;
            "user": string;
         };
         Event: {
            (options?: srmService.vim.Event): srmService.vim.Event;
         };
         ArrayOfEvent: {
            (options?: srmService.vim.ArrayOfEvent): srmService.vim.ArrayOfEvent;
         };
         GeneralEvent: {
            (options?: srmService.vim.GeneralEvent): srmService.vim.GeneralEvent;
         };
         GeneralHostInfoEvent: {
            (options?: srmService.vim.GeneralHostInfoEvent): srmService.vim.GeneralHostInfoEvent;
         };
         GeneralHostWarningEvent: {
            (options?: srmService.vim.GeneralHostWarningEvent): srmService.vim.GeneralHostWarningEvent;
         };
         GeneralHostErrorEvent: {
            (options?: srmService.vim.GeneralHostErrorEvent): srmService.vim.GeneralHostErrorEvent;
         };
         GeneralVmInfoEvent: {
            (options?: srmService.vim.GeneralVmInfoEvent): srmService.vim.GeneralVmInfoEvent;
         };
         GeneralVmWarningEvent: {
            (options?: srmService.vim.GeneralVmWarningEvent): srmService.vim.GeneralVmWarningEvent;
         };
         GeneralVmErrorEvent: {
            (options?: srmService.vim.GeneralVmErrorEvent): srmService.vim.GeneralVmErrorEvent;
         };
         GeneralUserEvent: {
            (options?: srmService.vim.GeneralUserEvent): srmService.vim.GeneralUserEvent;
         };
         ExtendedEventPair: {
            (options?: srmService.vim.ExtendedEventPair): srmService.vim.ExtendedEventPair;
         };
         ArrayOfExtendedEventPair: {
            (options?: srmService.vim.ArrayOfExtendedEventPair): srmService.vim.ArrayOfExtendedEventPair;
         };
         ExtendedEvent: {
            (options?: srmService.vim.ExtendedEvent): srmService.vim.ExtendedEvent;
         };
         HealthStatusChangedEvent: {
            (options?: srmService.vim.HealthStatusChangedEvent): srmService.vim.HealthStatusChangedEvent;
         };
         HostInventoryUnreadableEvent: {
            (options?: srmService.vim.HostInventoryUnreadableEvent): srmService.vim.HostInventoryUnreadableEvent;
         };
         DatacenterEvent: {
            (options?: srmService.vim.DatacenterEvent): srmService.vim.DatacenterEvent;
         };
         DatacenterCreatedEvent: {
            (options?: srmService.vim.DatacenterCreatedEvent): srmService.vim.DatacenterCreatedEvent;
         };
         DatacenterRenamedEvent: {
            (options?: srmService.vim.DatacenterRenamedEvent): srmService.vim.DatacenterRenamedEvent;
         };
         SessionEvent: {
            (options?: srmService.vim.SessionEvent): srmService.vim.SessionEvent;
         };
         ServerStartedSessionEvent: {
            (options?: srmService.vim.ServerStartedSessionEvent): srmService.vim.ServerStartedSessionEvent;
         };
         UserLoginSessionEvent: {
            (options?: srmService.vim.UserLoginSessionEvent): srmService.vim.UserLoginSessionEvent;
         };
         UserLogoutSessionEvent: {
            (options?: srmService.vim.UserLogoutSessionEvent): srmService.vim.UserLogoutSessionEvent;
         };
         BadUsernameSessionEvent: {
            (options?: srmService.vim.BadUsernameSessionEvent): srmService.vim.BadUsernameSessionEvent;
         };
         AlreadyAuthenticatedSessionEvent: {
            (options?: srmService.vim.AlreadyAuthenticatedSessionEvent): srmService.vim.AlreadyAuthenticatedSessionEvent;
         };
         NoAccessUserEvent: {
            (options?: srmService.vim.NoAccessUserEvent): srmService.vim.NoAccessUserEvent;
         };
         SessionTerminatedEvent: {
            (options?: srmService.vim.SessionTerminatedEvent): srmService.vim.SessionTerminatedEvent;
         };
         GlobalMessageChangedEvent: {
            (options?: srmService.vim.GlobalMessageChangedEvent): srmService.vim.GlobalMessageChangedEvent;
         };
         UpgradeEvent: {
            (options?: srmService.vim.UpgradeEvent): srmService.vim.UpgradeEvent;
         };
         InfoUpgradeEvent: {
            (options?: srmService.vim.InfoUpgradeEvent): srmService.vim.InfoUpgradeEvent;
         };
         WarningUpgradeEvent: {
            (options?: srmService.vim.WarningUpgradeEvent): srmService.vim.WarningUpgradeEvent;
         };
         ErrorUpgradeEvent: {
            (options?: srmService.vim.ErrorUpgradeEvent): srmService.vim.ErrorUpgradeEvent;
         };
         UserUpgradeEvent: {
            (options?: srmService.vim.UserUpgradeEvent): srmService.vim.UserUpgradeEvent;
         };
         HostEvent: {
            (options?: srmService.vim.HostEvent): srmService.vim.HostEvent;
         };
         HostDasEvent: {
            (options?: srmService.vim.HostDasEvent): srmService.vim.HostDasEvent;
         };
         HostConnectedEvent: {
            (options?: srmService.vim.HostConnectedEvent): srmService.vim.HostConnectedEvent;
         };
         HostDisconnectedEventReasonCode: {
            "sslThumbprintVerifyFailed": string;
            "licenseExpired": string;
            "agentUpgrade": string;
            "userRequest": string;
            "insufficientLicenses": string;
            "agentOutOfDate": string;
            "passwordDecryptFailure": string;
            "unknown": string;
            "vcVRAMCapacityExceeded": string;
         };
         HostDisconnectedEvent: {
            (options?: srmService.vim.HostDisconnectedEvent): srmService.vim.HostDisconnectedEvent;
         };
         HostSyncFailedEvent: {
            (options?: srmService.vim.HostSyncFailedEvent): srmService.vim.HostSyncFailedEvent;
         };
         HostConnectionLostEvent: {
            (options?: srmService.vim.HostConnectionLostEvent): srmService.vim.HostConnectionLostEvent;
         };
         HostReconnectionFailedEvent: {
            (options?: srmService.vim.HostReconnectionFailedEvent): srmService.vim.HostReconnectionFailedEvent;
         };
         HostCnxFailedNoConnectionEvent: {
            (options?: srmService.vim.HostCnxFailedNoConnectionEvent): srmService.vim.HostCnxFailedNoConnectionEvent;
         };
         HostCnxFailedBadUsernameEvent: {
            (options?: srmService.vim.HostCnxFailedBadUsernameEvent): srmService.vim.HostCnxFailedBadUsernameEvent;
         };
         HostCnxFailedBadVersionEvent: {
            (options?: srmService.vim.HostCnxFailedBadVersionEvent): srmService.vim.HostCnxFailedBadVersionEvent;
         };
         HostCnxFailedAlreadyManagedEvent: {
            (options?: srmService.vim.HostCnxFailedAlreadyManagedEvent): srmService.vim.HostCnxFailedAlreadyManagedEvent;
         };
         HostCnxFailedNoLicenseEvent: {
            (options?: srmService.vim.HostCnxFailedNoLicenseEvent): srmService.vim.HostCnxFailedNoLicenseEvent;
         };
         HostCnxFailedNetworkErrorEvent: {
            (options?: srmService.vim.HostCnxFailedNetworkErrorEvent): srmService.vim.HostCnxFailedNetworkErrorEvent;
         };
         HostRemovedEvent: {
            (options?: srmService.vim.HostRemovedEvent): srmService.vim.HostRemovedEvent;
         };
         HostCnxFailedCcagentUpgradeEvent: {
            (options?: srmService.vim.HostCnxFailedCcagentUpgradeEvent): srmService.vim.HostCnxFailedCcagentUpgradeEvent;
         };
         HostCnxFailedBadCcagentEvent: {
            (options?: srmService.vim.HostCnxFailedBadCcagentEvent): srmService.vim.HostCnxFailedBadCcagentEvent;
         };
         HostCnxFailedEvent: {
            (options?: srmService.vim.HostCnxFailedEvent): srmService.vim.HostCnxFailedEvent;
         };
         HostCnxFailedAccountFailedEvent: {
            (options?: srmService.vim.HostCnxFailedAccountFailedEvent): srmService.vim.HostCnxFailedAccountFailedEvent;
         };
         HostCnxFailedNoAccessEvent: {
            (options?: srmService.vim.HostCnxFailedNoAccessEvent): srmService.vim.HostCnxFailedNoAccessEvent;
         };
         HostShutdownEvent: {
            (options?: srmService.vim.HostShutdownEvent): srmService.vim.HostShutdownEvent;
         };
         HostCnxFailedNotFoundEvent: {
            (options?: srmService.vim.HostCnxFailedNotFoundEvent): srmService.vim.HostCnxFailedNotFoundEvent;
         };
         HostCnxFailedTimeoutEvent: {
            (options?: srmService.vim.HostCnxFailedTimeoutEvent): srmService.vim.HostCnxFailedTimeoutEvent;
         };
         HostUpgradeFailedEvent: {
            (options?: srmService.vim.HostUpgradeFailedEvent): srmService.vim.HostUpgradeFailedEvent;
         };
         EnteringMaintenanceModeEvent: {
            (options?: srmService.vim.EnteringMaintenanceModeEvent): srmService.vim.EnteringMaintenanceModeEvent;
         };
         EnteredMaintenanceModeEvent: {
            (options?: srmService.vim.EnteredMaintenanceModeEvent): srmService.vim.EnteredMaintenanceModeEvent;
         };
         ExitMaintenanceModeEvent: {
            (options?: srmService.vim.ExitMaintenanceModeEvent): srmService.vim.ExitMaintenanceModeEvent;
         };
         CanceledHostOperationEvent: {
            (options?: srmService.vim.CanceledHostOperationEvent): srmService.vim.CanceledHostOperationEvent;
         };
         TimedOutHostOperationEvent: {
            (options?: srmService.vim.TimedOutHostOperationEvent): srmService.vim.TimedOutHostOperationEvent;
         };
         HostDasEnabledEvent: {
            (options?: srmService.vim.HostDasEnabledEvent): srmService.vim.HostDasEnabledEvent;
         };
         HostDasDisabledEvent: {
            (options?: srmService.vim.HostDasDisabledEvent): srmService.vim.HostDasDisabledEvent;
         };
         HostDasEnablingEvent: {
            (options?: srmService.vim.HostDasEnablingEvent): srmService.vim.HostDasEnablingEvent;
         };
         HostDasDisablingEvent: {
            (options?: srmService.vim.HostDasDisablingEvent): srmService.vim.HostDasDisablingEvent;
         };
         HostDasErrorEventHostDasErrorReason: {
            "configFailed": string;
            "timeout": string;
            "communicationInitFailed": string;
            "healthCheckScriptFailed": string;
            "agentFailed": string;
            "agentShutdown": string;
            "isolationAddressUnpingable": string;
            "other": string;
         };
         HostDasErrorEvent: {
            (options?: srmService.vim.HostDasErrorEvent): srmService.vim.HostDasErrorEvent;
         };
         HostDasOkEvent: {
            (options?: srmService.vim.HostDasOkEvent): srmService.vim.HostDasOkEvent;
         };
         VcAgentUpgradedEvent: {
            (options?: srmService.vim.VcAgentUpgradedEvent): srmService.vim.VcAgentUpgradedEvent;
         };
         VcAgentUninstalledEvent: {
            (options?: srmService.vim.VcAgentUninstalledEvent): srmService.vim.VcAgentUninstalledEvent;
         };
         VcAgentUpgradeFailedEvent: {
            (options?: srmService.vim.VcAgentUpgradeFailedEvent): srmService.vim.VcAgentUpgradeFailedEvent;
         };
         VcAgentUninstallFailedEvent: {
            (options?: srmService.vim.VcAgentUninstallFailedEvent): srmService.vim.VcAgentUninstallFailedEvent;
         };
         HostAddedEvent: {
            (options?: srmService.vim.HostAddedEvent): srmService.vim.HostAddedEvent;
         };
         HostAddFailedEvent: {
            (options?: srmService.vim.HostAddFailedEvent): srmService.vim.HostAddFailedEvent;
         };
         HostIpChangedEvent: {
            (options?: srmService.vim.HostIpChangedEvent): srmService.vim.HostIpChangedEvent;
         };
         EnteringStandbyModeEvent: {
            (options?: srmService.vim.EnteringStandbyModeEvent): srmService.vim.EnteringStandbyModeEvent;
         };
         DrsEnteringStandbyModeEvent: {
            (options?: srmService.vim.DrsEnteringStandbyModeEvent): srmService.vim.DrsEnteringStandbyModeEvent;
         };
         EnteredStandbyModeEvent: {
            (options?: srmService.vim.EnteredStandbyModeEvent): srmService.vim.EnteredStandbyModeEvent;
         };
         DrsEnteredStandbyModeEvent: {
            (options?: srmService.vim.DrsEnteredStandbyModeEvent): srmService.vim.DrsEnteredStandbyModeEvent;
         };
         ExitingStandbyModeEvent: {
            (options?: srmService.vim.ExitingStandbyModeEvent): srmService.vim.ExitingStandbyModeEvent;
         };
         DrsExitingStandbyModeEvent: {
            (options?: srmService.vim.DrsExitingStandbyModeEvent): srmService.vim.DrsExitingStandbyModeEvent;
         };
         ExitedStandbyModeEvent: {
            (options?: srmService.vim.ExitedStandbyModeEvent): srmService.vim.ExitedStandbyModeEvent;
         };
         DrsExitedStandbyModeEvent: {
            (options?: srmService.vim.DrsExitedStandbyModeEvent): srmService.vim.DrsExitedStandbyModeEvent;
         };
         ExitStandbyModeFailedEvent: {
            (options?: srmService.vim.ExitStandbyModeFailedEvent): srmService.vim.ExitStandbyModeFailedEvent;
         };
         DrsExitStandbyModeFailedEvent: {
            (options?: srmService.vim.DrsExitStandbyModeFailedEvent): srmService.vim.DrsExitStandbyModeFailedEvent;
         };
         UpdatedAgentBeingRestartedEvent: {
            (options?: srmService.vim.UpdatedAgentBeingRestartedEvent): srmService.vim.UpdatedAgentBeingRestartedEvent;
         };
         AccountCreatedEvent: {
            (options?: srmService.vim.AccountCreatedEvent): srmService.vim.AccountCreatedEvent;
         };
         AccountRemovedEvent: {
            (options?: srmService.vim.AccountRemovedEvent): srmService.vim.AccountRemovedEvent;
         };
         UserPasswordChanged: {
            (options?: srmService.vim.UserPasswordChanged): srmService.vim.UserPasswordChanged;
         };
         AccountUpdatedEvent: {
            (options?: srmService.vim.AccountUpdatedEvent): srmService.vim.AccountUpdatedEvent;
         };
         UserAssignedToGroup: {
            (options?: srmService.vim.UserAssignedToGroup): srmService.vim.UserAssignedToGroup;
         };
         UserUnassignedFromGroup: {
            (options?: srmService.vim.UserUnassignedFromGroup): srmService.vim.UserUnassignedFromGroup;
         };
         DatastorePrincipalConfigured: {
            (options?: srmService.vim.DatastorePrincipalConfigured): srmService.vim.DatastorePrincipalConfigured;
         };
         VMFSDatastoreCreatedEvent: {
            (options?: srmService.vim.VMFSDatastoreCreatedEvent): srmService.vim.VMFSDatastoreCreatedEvent;
         };
         NASDatastoreCreatedEvent: {
            (options?: srmService.vim.NASDatastoreCreatedEvent): srmService.vim.NASDatastoreCreatedEvent;
         };
         LocalDatastoreCreatedEvent: {
            (options?: srmService.vim.LocalDatastoreCreatedEvent): srmService.vim.LocalDatastoreCreatedEvent;
         };
         VMFSDatastoreExtendedEvent: {
            (options?: srmService.vim.VMFSDatastoreExtendedEvent): srmService.vim.VMFSDatastoreExtendedEvent;
         };
         VMFSDatastoreExpandedEvent: {
            (options?: srmService.vim.VMFSDatastoreExpandedEvent): srmService.vim.VMFSDatastoreExpandedEvent;
         };
         DatastoreRemovedOnHostEvent: {
            (options?: srmService.vim.DatastoreRemovedOnHostEvent): srmService.vim.DatastoreRemovedOnHostEvent;
         };
         DatastoreRenamedOnHostEvent: {
            (options?: srmService.vim.DatastoreRenamedOnHostEvent): srmService.vim.DatastoreRenamedOnHostEvent;
         };
         DuplicateIpDetectedEvent: {
            (options?: srmService.vim.DuplicateIpDetectedEvent): srmService.vim.DuplicateIpDetectedEvent;
         };
         DatastoreDiscoveredEvent: {
            (options?: srmService.vim.DatastoreDiscoveredEvent): srmService.vim.DatastoreDiscoveredEvent;
         };
         DrsResourceConfigureFailedEvent: {
            (options?: srmService.vim.DrsResourceConfigureFailedEvent): srmService.vim.DrsResourceConfigureFailedEvent;
         };
         DrsResourceConfigureSyncedEvent: {
            (options?: srmService.vim.DrsResourceConfigureSyncedEvent): srmService.vim.DrsResourceConfigureSyncedEvent;
         };
         HostGetShortNameFailedEvent: {
            (options?: srmService.vim.HostGetShortNameFailedEvent): srmService.vim.HostGetShortNameFailedEvent;
         };
         HostShortNameToIpFailedEvent: {
            (options?: srmService.vim.HostShortNameToIpFailedEvent): srmService.vim.HostShortNameToIpFailedEvent;
         };
         HostIpToShortNameFailedEvent: {
            (options?: srmService.vim.HostIpToShortNameFailedEvent): srmService.vim.HostIpToShortNameFailedEvent;
         };
         HostPrimaryAgentNotShortNameEvent: {
            (options?: srmService.vim.HostPrimaryAgentNotShortNameEvent): srmService.vim.HostPrimaryAgentNotShortNameEvent;
         };
         HostNotInClusterEvent: {
            (options?: srmService.vim.HostNotInClusterEvent): srmService.vim.HostNotInClusterEvent;
         };
         HostIsolationIpPingFailedEvent: {
            (options?: srmService.vim.HostIsolationIpPingFailedEvent): srmService.vim.HostIsolationIpPingFailedEvent;
         };
         HostIpInconsistentEvent: {
            (options?: srmService.vim.HostIpInconsistentEvent): srmService.vim.HostIpInconsistentEvent;
         };
         HostUserWorldSwapNotEnabledEvent: {
            (options?: srmService.vim.HostUserWorldSwapNotEnabledEvent): srmService.vim.HostUserWorldSwapNotEnabledEvent;
         };
         HostNonCompliantEvent: {
            (options?: srmService.vim.HostNonCompliantEvent): srmService.vim.HostNonCompliantEvent;
         };
         HostCompliantEvent: {
            (options?: srmService.vim.HostCompliantEvent): srmService.vim.HostCompliantEvent;
         };
         HostComplianceCheckedEvent: {
            (options?: srmService.vim.HostComplianceCheckedEvent): srmService.vim.HostComplianceCheckedEvent;
         };
         ClusterComplianceCheckedEvent: {
            (options?: srmService.vim.ClusterComplianceCheckedEvent): srmService.vim.ClusterComplianceCheckedEvent;
         };
         ProfileEvent: {
            (options?: srmService.vim.ProfileEvent): srmService.vim.ProfileEvent;
         };
         ProfileCreatedEvent: {
            (options?: srmService.vim.ProfileCreatedEvent): srmService.vim.ProfileCreatedEvent;
         };
         ProfileRemovedEvent: {
            (options?: srmService.vim.ProfileRemovedEvent): srmService.vim.ProfileRemovedEvent;
         };
         ProfileAssociatedEvent: {
            (options?: srmService.vim.ProfileAssociatedEvent): srmService.vim.ProfileAssociatedEvent;
         };
         ProfileDissociatedEvent: {
            (options?: srmService.vim.ProfileDissociatedEvent): srmService.vim.ProfileDissociatedEvent;
         };
         HostConfigAppliedEvent: {
            (options?: srmService.vim.HostConfigAppliedEvent): srmService.vim.HostConfigAppliedEvent;
         };
         ProfileReferenceHostChangedEvent: {
            (options?: srmService.vim.ProfileReferenceHostChangedEvent): srmService.vim.ProfileReferenceHostChangedEvent;
         };
         ProfileChangedEvent: {
            (options?: srmService.vim.ProfileChangedEvent): srmService.vim.ProfileChangedEvent;
         };
         HostProfileAppliedEvent: {
            (options?: srmService.vim.HostProfileAppliedEvent): srmService.vim.HostProfileAppliedEvent;
         };
         HostShortNameInconsistentEvent: {
            (options?: srmService.vim.HostShortNameInconsistentEvent): srmService.vim.HostShortNameInconsistentEvent;
         };
         HostNoRedundantManagementNetworkEvent: {
            (options?: srmService.vim.HostNoRedundantManagementNetworkEvent): srmService.vim.HostNoRedundantManagementNetworkEvent;
         };
         HostNoAvailableNetworksEvent: {
            (options?: srmService.vim.HostNoAvailableNetworksEvent): srmService.vim.HostNoAvailableNetworksEvent;
         };
         HostExtraNetworksEvent: {
            (options?: srmService.vim.HostExtraNetworksEvent): srmService.vim.HostExtraNetworksEvent;
         };
         HostNoHAEnabledPortGroupsEvent: {
            (options?: srmService.vim.HostNoHAEnabledPortGroupsEvent): srmService.vim.HostNoHAEnabledPortGroupsEvent;
         };
         HostMissingNetworksEvent: {
            (options?: srmService.vim.HostMissingNetworksEvent): srmService.vim.HostMissingNetworksEvent;
         };
         VnicPortArgument: {
            (options?: srmService.vim.VnicPortArgument): srmService.vim.VnicPortArgument;
         };
         ArrayOfVnicPortArgument: {
            (options?: srmService.vim.ArrayOfVnicPortArgument): srmService.vim.ArrayOfVnicPortArgument;
         };
         HostVnicConnectedToCustomizedDVPortEvent: {
            (options?: srmService.vim.HostVnicConnectedToCustomizedDVPortEvent): srmService.vim.HostVnicConnectedToCustomizedDVPortEvent;
         };
         GhostDvsProxySwitchDetectedEvent: {
            (options?: srmService.vim.GhostDvsProxySwitchDetectedEvent): srmService.vim.GhostDvsProxySwitchDetectedEvent;
         };
         GhostDvsProxySwitchRemovedEvent: {
            (options?: srmService.vim.GhostDvsProxySwitchRemovedEvent): srmService.vim.GhostDvsProxySwitchRemovedEvent;
         };
         VmEvent: {
            (options?: srmService.vim.VmEvent): srmService.vim.VmEvent;
         };
         VmPoweredOffEvent: {
            (options?: srmService.vim.VmPoweredOffEvent): srmService.vim.VmPoweredOffEvent;
         };
         VmPoweredOnEvent: {
            (options?: srmService.vim.VmPoweredOnEvent): srmService.vim.VmPoweredOnEvent;
         };
         VmSuspendedEvent: {
            (options?: srmService.vim.VmSuspendedEvent): srmService.vim.VmSuspendedEvent;
         };
         VmStartingEvent: {
            (options?: srmService.vim.VmStartingEvent): srmService.vim.VmStartingEvent;
         };
         VmStoppingEvent: {
            (options?: srmService.vim.VmStoppingEvent): srmService.vim.VmStoppingEvent;
         };
         VmSuspendingEvent: {
            (options?: srmService.vim.VmSuspendingEvent): srmService.vim.VmSuspendingEvent;
         };
         VmResumingEvent: {
            (options?: srmService.vim.VmResumingEvent): srmService.vim.VmResumingEvent;
         };
         VmDisconnectedEvent: {
            (options?: srmService.vim.VmDisconnectedEvent): srmService.vim.VmDisconnectedEvent;
         };
         VmRemoteConsoleConnectedEvent: {
            (options?: srmService.vim.VmRemoteConsoleConnectedEvent): srmService.vim.VmRemoteConsoleConnectedEvent;
         };
         VmRemoteConsoleDisconnectedEvent: {
            (options?: srmService.vim.VmRemoteConsoleDisconnectedEvent): srmService.vim.VmRemoteConsoleDisconnectedEvent;
         };
         VmDiscoveredEvent: {
            (options?: srmService.vim.VmDiscoveredEvent): srmService.vim.VmDiscoveredEvent;
         };
         VmOrphanedEvent: {
            (options?: srmService.vim.VmOrphanedEvent): srmService.vim.VmOrphanedEvent;
         };
         VmBeingCreatedEvent: {
            (options?: srmService.vim.VmBeingCreatedEvent): srmService.vim.VmBeingCreatedEvent;
         };
         VmCreatedEvent: {
            (options?: srmService.vim.VmCreatedEvent): srmService.vim.VmCreatedEvent;
         };
         VmStartRecordingEvent: {
            (options?: srmService.vim.VmStartRecordingEvent): srmService.vim.VmStartRecordingEvent;
         };
         VmEndRecordingEvent: {
            (options?: srmService.vim.VmEndRecordingEvent): srmService.vim.VmEndRecordingEvent;
         };
         VmStartReplayingEvent: {
            (options?: srmService.vim.VmStartReplayingEvent): srmService.vim.VmStartReplayingEvent;
         };
         VmEndReplayingEvent: {
            (options?: srmService.vim.VmEndReplayingEvent): srmService.vim.VmEndReplayingEvent;
         };
         VmRegisteredEvent: {
            (options?: srmService.vim.VmRegisteredEvent): srmService.vim.VmRegisteredEvent;
         };
         VmAutoRenameEvent: {
            (options?: srmService.vim.VmAutoRenameEvent): srmService.vim.VmAutoRenameEvent;
         };
         VmBeingHotMigratedEvent: {
            (options?: srmService.vim.VmBeingHotMigratedEvent): srmService.vim.VmBeingHotMigratedEvent;
         };
         VmResettingEvent: {
            (options?: srmService.vim.VmResettingEvent): srmService.vim.VmResettingEvent;
         };
         VmStaticMacConflictEvent: {
            (options?: srmService.vim.VmStaticMacConflictEvent): srmService.vim.VmStaticMacConflictEvent;
         };
         VmMacConflictEvent: {
            (options?: srmService.vim.VmMacConflictEvent): srmService.vim.VmMacConflictEvent;
         };
         VmBeingDeployedEvent: {
            (options?: srmService.vim.VmBeingDeployedEvent): srmService.vim.VmBeingDeployedEvent;
         };
         VmDeployFailedEvent: {
            (options?: srmService.vim.VmDeployFailedEvent): srmService.vim.VmDeployFailedEvent;
         };
         VmDeployedEvent: {
            (options?: srmService.vim.VmDeployedEvent): srmService.vim.VmDeployedEvent;
         };
         VmMacChangedEvent: {
            (options?: srmService.vim.VmMacChangedEvent): srmService.vim.VmMacChangedEvent;
         };
         VmMacAssignedEvent: {
            (options?: srmService.vim.VmMacAssignedEvent): srmService.vim.VmMacAssignedEvent;
         };
         VmUuidConflictEvent: {
            (options?: srmService.vim.VmUuidConflictEvent): srmService.vim.VmUuidConflictEvent;
         };
         VmInstanceUuidConflictEvent: {
            (options?: srmService.vim.VmInstanceUuidConflictEvent): srmService.vim.VmInstanceUuidConflictEvent;
         };
         VmBeingMigratedEvent: {
            (options?: srmService.vim.VmBeingMigratedEvent): srmService.vim.VmBeingMigratedEvent;
         };
         VmFailedMigrateEvent: {
            (options?: srmService.vim.VmFailedMigrateEvent): srmService.vim.VmFailedMigrateEvent;
         };
         VmMigratedEvent: {
            (options?: srmService.vim.VmMigratedEvent): srmService.vim.VmMigratedEvent;
         };
         VmUnsupportedStartingEvent: {
            (options?: srmService.vim.VmUnsupportedStartingEvent): srmService.vim.VmUnsupportedStartingEvent;
         };
         DrsVmMigratedEvent: {
            (options?: srmService.vim.DrsVmMigratedEvent): srmService.vim.DrsVmMigratedEvent;
         };
         DrsVmPoweredOnEvent: {
            (options?: srmService.vim.DrsVmPoweredOnEvent): srmService.vim.DrsVmPoweredOnEvent;
         };
         DrsRuleViolationEvent: {
            (options?: srmService.vim.DrsRuleViolationEvent): srmService.vim.DrsRuleViolationEvent;
         };
         DrsRuleComplianceEvent: {
            (options?: srmService.vim.DrsRuleComplianceEvent): srmService.vim.DrsRuleComplianceEvent;
         };
         VmRelocateSpecEvent: {
            (options?: srmService.vim.VmRelocateSpecEvent): srmService.vim.VmRelocateSpecEvent;
         };
         VmBeingRelocatedEvent: {
            (options?: srmService.vim.VmBeingRelocatedEvent): srmService.vim.VmBeingRelocatedEvent;
         };
         VmRelocatedEvent: {
            (options?: srmService.vim.VmRelocatedEvent): srmService.vim.VmRelocatedEvent;
         };
         VmRelocateFailedEvent: {
            (options?: srmService.vim.VmRelocateFailedEvent): srmService.vim.VmRelocateFailedEvent;
         };
         VmEmigratingEvent: {
            (options?: srmService.vim.VmEmigratingEvent): srmService.vim.VmEmigratingEvent;
         };
         VmCloneEvent: {
            (options?: srmService.vim.VmCloneEvent): srmService.vim.VmCloneEvent;
         };
         VmBeingClonedEvent: {
            (options?: srmService.vim.VmBeingClonedEvent): srmService.vim.VmBeingClonedEvent;
         };
         VmBeingClonedNoFolderEvent: {
            (options?: srmService.vim.VmBeingClonedNoFolderEvent): srmService.vim.VmBeingClonedNoFolderEvent;
         };
         VmCloneFailedEvent: {
            (options?: srmService.vim.VmCloneFailedEvent): srmService.vim.VmCloneFailedEvent;
         };
         VmClonedEvent: {
            (options?: srmService.vim.VmClonedEvent): srmService.vim.VmClonedEvent;
         };
         VmResourceReallocatedEvent: {
            (options?: srmService.vim.VmResourceReallocatedEvent): srmService.vim.VmResourceReallocatedEvent;
         };
         VmRenamedEvent: {
            (options?: srmService.vim.VmRenamedEvent): srmService.vim.VmRenamedEvent;
         };
         VmDateRolledBackEvent: {
            (options?: srmService.vim.VmDateRolledBackEvent): srmService.vim.VmDateRolledBackEvent;
         };
         VmNoNetworkAccessEvent: {
            (options?: srmService.vim.VmNoNetworkAccessEvent): srmService.vim.VmNoNetworkAccessEvent;
         };
         VmDiskFailedEvent: {
            (options?: srmService.vim.VmDiskFailedEvent): srmService.vim.VmDiskFailedEvent;
         };
         VmFailedToPowerOnEvent: {
            (options?: srmService.vim.VmFailedToPowerOnEvent): srmService.vim.VmFailedToPowerOnEvent;
         };
         VmFailedToPowerOffEvent: {
            (options?: srmService.vim.VmFailedToPowerOffEvent): srmService.vim.VmFailedToPowerOffEvent;
         };
         VmFailedToSuspendEvent: {
            (options?: srmService.vim.VmFailedToSuspendEvent): srmService.vim.VmFailedToSuspendEvent;
         };
         VmFailedToResetEvent: {
            (options?: srmService.vim.VmFailedToResetEvent): srmService.vim.VmFailedToResetEvent;
         };
         VmFailedToShutdownGuestEvent: {
            (options?: srmService.vim.VmFailedToShutdownGuestEvent): srmService.vim.VmFailedToShutdownGuestEvent;
         };
         VmFailedToRebootGuestEvent: {
            (options?: srmService.vim.VmFailedToRebootGuestEvent): srmService.vim.VmFailedToRebootGuestEvent;
         };
         VmFailedToStandbyGuestEvent: {
            (options?: srmService.vim.VmFailedToStandbyGuestEvent): srmService.vim.VmFailedToStandbyGuestEvent;
         };
         VmRemovedEvent: {
            (options?: srmService.vim.VmRemovedEvent): srmService.vim.VmRemovedEvent;
         };
         VmGuestShutdownEvent: {
            (options?: srmService.vim.VmGuestShutdownEvent): srmService.vim.VmGuestShutdownEvent;
         };
         VmGuestRebootEvent: {
            (options?: srmService.vim.VmGuestRebootEvent): srmService.vim.VmGuestRebootEvent;
         };
         VmGuestStandbyEvent: {
            (options?: srmService.vim.VmGuestStandbyEvent): srmService.vim.VmGuestStandbyEvent;
         };
         VmUpgradingEvent: {
            (options?: srmService.vim.VmUpgradingEvent): srmService.vim.VmUpgradingEvent;
         };
         VmUpgradeCompleteEvent: {
            (options?: srmService.vim.VmUpgradeCompleteEvent): srmService.vim.VmUpgradeCompleteEvent;
         };
         VmUpgradeFailedEvent: {
            (options?: srmService.vim.VmUpgradeFailedEvent): srmService.vim.VmUpgradeFailedEvent;
         };
         VmRestartedOnAlternateHostEvent: {
            (options?: srmService.vim.VmRestartedOnAlternateHostEvent): srmService.vim.VmRestartedOnAlternateHostEvent;
         };
         VmReconfiguredEvent: {
            (options?: srmService.vim.VmReconfiguredEvent): srmService.vim.VmReconfiguredEvent;
         };
         VmMessageEvent: {
            (options?: srmService.vim.VmMessageEvent): srmService.vim.VmMessageEvent;
         };
         VmMessageWarningEvent: {
            (options?: srmService.vim.VmMessageWarningEvent): srmService.vim.VmMessageWarningEvent;
         };
         VmMessageErrorEvent: {
            (options?: srmService.vim.VmMessageErrorEvent): srmService.vim.VmMessageErrorEvent;
         };
         VmConfigMissingEvent: {
            (options?: srmService.vim.VmConfigMissingEvent): srmService.vim.VmConfigMissingEvent;
         };
         VmPowerOffOnIsolationEvent: {
            (options?: srmService.vim.VmPowerOffOnIsolationEvent): srmService.vim.VmPowerOffOnIsolationEvent;
         };
         VmShutdownOnIsolationEventOperation: {
            "shutdown": string;
            "poweredOff": string;
         };
         VmShutdownOnIsolationEvent: {
            (options?: srmService.vim.VmShutdownOnIsolationEvent): srmService.vim.VmShutdownOnIsolationEvent;
         };
         VmFailoverFailed: {
            (options?: srmService.vim.VmFailoverFailed): srmService.vim.VmFailoverFailed;
         };
         VmDasBeingResetEventReasonCode: {
            "vmtoolsHeartbeatFailure": string;
            "appHeartbeatFailure": string;
            "appImmediateResetRequest": string;
         };
         VmDasBeingResetEvent: {
            (options?: srmService.vim.VmDasBeingResetEvent): srmService.vim.VmDasBeingResetEvent;
         };
         VmDasResetFailedEvent: {
            (options?: srmService.vim.VmDasResetFailedEvent): srmService.vim.VmDasResetFailedEvent;
         };
         VmMaxRestartCountReached: {
            (options?: srmService.vim.VmMaxRestartCountReached): srmService.vim.VmMaxRestartCountReached;
         };
         VmMaxFTRestartCountReached: {
            (options?: srmService.vim.VmMaxFTRestartCountReached): srmService.vim.VmMaxFTRestartCountReached;
         };
         VmDasBeingResetWithScreenshotEvent: {
            (options?: srmService.vim.VmDasBeingResetWithScreenshotEvent): srmService.vim.VmDasBeingResetWithScreenshotEvent;
         };
         NotEnoughResourcesToStartVmEvent: {
            (options?: srmService.vim.NotEnoughResourcesToStartVmEvent): srmService.vim.NotEnoughResourcesToStartVmEvent;
         };
         VmUuidAssignedEvent: {
            (options?: srmService.vim.VmUuidAssignedEvent): srmService.vim.VmUuidAssignedEvent;
         };
         VmInstanceUuidAssignedEvent: {
            (options?: srmService.vim.VmInstanceUuidAssignedEvent): srmService.vim.VmInstanceUuidAssignedEvent;
         };
         VmUuidChangedEvent: {
            (options?: srmService.vim.VmUuidChangedEvent): srmService.vim.VmUuidChangedEvent;
         };
         VmInstanceUuidChangedEvent: {
            (options?: srmService.vim.VmInstanceUuidChangedEvent): srmService.vim.VmInstanceUuidChangedEvent;
         };
         VmWwnConflictEvent: {
            (options?: srmService.vim.VmWwnConflictEvent): srmService.vim.VmWwnConflictEvent;
         };
         VmAcquiredMksTicketEvent: {
            (options?: srmService.vim.VmAcquiredMksTicketEvent): srmService.vim.VmAcquiredMksTicketEvent;
         };
         VmAcquiredTicketEvent: {
            (options?: srmService.vim.VmAcquiredTicketEvent): srmService.vim.VmAcquiredTicketEvent;
         };
         HostWwnConflictEvent: {
            (options?: srmService.vim.HostWwnConflictEvent): srmService.vim.HostWwnConflictEvent;
         };
         VmWwnAssignedEvent: {
            (options?: srmService.vim.VmWwnAssignedEvent): srmService.vim.VmWwnAssignedEvent;
         };
         VmWwnChangedEvent: {
            (options?: srmService.vim.VmWwnChangedEvent): srmService.vim.VmWwnChangedEvent;
         };
         VmSecondaryAddedEvent: {
            (options?: srmService.vim.VmSecondaryAddedEvent): srmService.vim.VmSecondaryAddedEvent;
         };
         VmFaultToleranceTurnedOffEvent: {
            (options?: srmService.vim.VmFaultToleranceTurnedOffEvent): srmService.vim.VmFaultToleranceTurnedOffEvent;
         };
         VmFaultToleranceStateChangedEvent: {
            (options?: srmService.vim.VmFaultToleranceStateChangedEvent): srmService.vim.VmFaultToleranceStateChangedEvent;
         };
         VmSecondaryDisabledEvent: {
            (options?: srmService.vim.VmSecondaryDisabledEvent): srmService.vim.VmSecondaryDisabledEvent;
         };
         VmSecondaryDisabledBySystemEvent: {
            (options?: srmService.vim.VmSecondaryDisabledBySystemEvent): srmService.vim.VmSecondaryDisabledBySystemEvent;
         };
         VmSecondaryEnabledEvent: {
            (options?: srmService.vim.VmSecondaryEnabledEvent): srmService.vim.VmSecondaryEnabledEvent;
         };
         VmStartingSecondaryEvent: {
            (options?: srmService.vim.VmStartingSecondaryEvent): srmService.vim.VmStartingSecondaryEvent;
         };
         VmSecondaryStartedEvent: {
            (options?: srmService.vim.VmSecondaryStartedEvent): srmService.vim.VmSecondaryStartedEvent;
         };
         VmFailedUpdatingSecondaryConfig: {
            (options?: srmService.vim.VmFailedUpdatingSecondaryConfig): srmService.vim.VmFailedUpdatingSecondaryConfig;
         };
         VmFailedStartingSecondaryEventFailureReason: {
            "incompatibleHost": string;
            "loginFailed": string;
            "registerVmFailed": string;
            "migrateFailed": string;
         };
         VmFailedStartingSecondaryEvent: {
            (options?: srmService.vim.VmFailedStartingSecondaryEvent): srmService.vim.VmFailedStartingSecondaryEvent;
         };
         VmTimedoutStartingSecondaryEvent: {
            (options?: srmService.vim.VmTimedoutStartingSecondaryEvent): srmService.vim.VmTimedoutStartingSecondaryEvent;
         };
         VmNoCompatibleHostForSecondaryEvent: {
            (options?: srmService.vim.VmNoCompatibleHostForSecondaryEvent): srmService.vim.VmNoCompatibleHostForSecondaryEvent;
         };
         VmPrimaryFailoverEvent: {
            (options?: srmService.vim.VmPrimaryFailoverEvent): srmService.vim.VmPrimaryFailoverEvent;
         };
         VmFaultToleranceVmTerminatedEvent: {
            (options?: srmService.vim.VmFaultToleranceVmTerminatedEvent): srmService.vim.VmFaultToleranceVmTerminatedEvent;
         };
         HostWwnChangedEvent: {
            (options?: srmService.vim.HostWwnChangedEvent): srmService.vim.HostWwnChangedEvent;
         };
         HostAdminDisableEvent: {
            (options?: srmService.vim.HostAdminDisableEvent): srmService.vim.HostAdminDisableEvent;
         };
         HostAdminEnableEvent: {
            (options?: srmService.vim.HostAdminEnableEvent): srmService.vim.HostAdminEnableEvent;
         };
         HostEnableAdminFailedEvent: {
            (options?: srmService.vim.HostEnableAdminFailedEvent): srmService.vim.HostEnableAdminFailedEvent;
         };
         VmFailedRelayoutOnVmfs2DatastoreEvent: {
            (options?: srmService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent): srmService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent;
         };
         VmFailedRelayoutEvent: {
            (options?: srmService.vim.VmFailedRelayoutEvent): srmService.vim.VmFailedRelayoutEvent;
         };
         VmRelayoutSuccessfulEvent: {
            (options?: srmService.vim.VmRelayoutSuccessfulEvent): srmService.vim.VmRelayoutSuccessfulEvent;
         };
         VmRelayoutUpToDateEvent: {
            (options?: srmService.vim.VmRelayoutUpToDateEvent): srmService.vim.VmRelayoutUpToDateEvent;
         };
         VmConnectedEvent: {
            (options?: srmService.vim.VmConnectedEvent): srmService.vim.VmConnectedEvent;
         };
         VmPoweringOnWithCustomizedDVPortEvent: {
            (options?: srmService.vim.VmPoweringOnWithCustomizedDVPortEvent): srmService.vim.VmPoweringOnWithCustomizedDVPortEvent;
         };
         VmDasUpdateErrorEvent: {
            (options?: srmService.vim.VmDasUpdateErrorEvent): srmService.vim.VmDasUpdateErrorEvent;
         };
         NoMaintenanceModeDrsRecommendationForVM: {
            (options?: srmService.vim.NoMaintenanceModeDrsRecommendationForVM): srmService.vim.NoMaintenanceModeDrsRecommendationForVM;
         };
         VmDasUpdateOkEvent: {
            (options?: srmService.vim.VmDasUpdateOkEvent): srmService.vim.VmDasUpdateOkEvent;
         };
         ScheduledTaskEvent: {
            (options?: srmService.vim.ScheduledTaskEvent): srmService.vim.ScheduledTaskEvent;
         };
         ScheduledTaskCreatedEvent: {
            (options?: srmService.vim.ScheduledTaskCreatedEvent): srmService.vim.ScheduledTaskCreatedEvent;
         };
         ScheduledTaskStartedEvent: {
            (options?: srmService.vim.ScheduledTaskStartedEvent): srmService.vim.ScheduledTaskStartedEvent;
         };
         ScheduledTaskRemovedEvent: {
            (options?: srmService.vim.ScheduledTaskRemovedEvent): srmService.vim.ScheduledTaskRemovedEvent;
         };
         ScheduledTaskReconfiguredEvent: {
            (options?: srmService.vim.ScheduledTaskReconfiguredEvent): srmService.vim.ScheduledTaskReconfiguredEvent;
         };
         ScheduledTaskCompletedEvent: {
            (options?: srmService.vim.ScheduledTaskCompletedEvent): srmService.vim.ScheduledTaskCompletedEvent;
         };
         ScheduledTaskFailedEvent: {
            (options?: srmService.vim.ScheduledTaskFailedEvent): srmService.vim.ScheduledTaskFailedEvent;
         };
         ScheduledTaskEmailCompletedEvent: {
            (options?: srmService.vim.ScheduledTaskEmailCompletedEvent): srmService.vim.ScheduledTaskEmailCompletedEvent;
         };
         ScheduledTaskEmailFailedEvent: {
            (options?: srmService.vim.ScheduledTaskEmailFailedEvent): srmService.vim.ScheduledTaskEmailFailedEvent;
         };
         AlarmEvent: {
            (options?: srmService.vim.AlarmEvent): srmService.vim.AlarmEvent;
         };
         AlarmCreatedEvent: {
            (options?: srmService.vim.AlarmCreatedEvent): srmService.vim.AlarmCreatedEvent;
         };
         AlarmStatusChangedEvent: {
            (options?: srmService.vim.AlarmStatusChangedEvent): srmService.vim.AlarmStatusChangedEvent;
         };
         AlarmActionTriggeredEvent: {
            (options?: srmService.vim.AlarmActionTriggeredEvent): srmService.vim.AlarmActionTriggeredEvent;
         };
         AlarmEmailCompletedEvent: {
            (options?: srmService.vim.AlarmEmailCompletedEvent): srmService.vim.AlarmEmailCompletedEvent;
         };
         AlarmEmailFailedEvent: {
            (options?: srmService.vim.AlarmEmailFailedEvent): srmService.vim.AlarmEmailFailedEvent;
         };
         AlarmSnmpCompletedEvent: {
            (options?: srmService.vim.AlarmSnmpCompletedEvent): srmService.vim.AlarmSnmpCompletedEvent;
         };
         AlarmSnmpFailedEvent: {
            (options?: srmService.vim.AlarmSnmpFailedEvent): srmService.vim.AlarmSnmpFailedEvent;
         };
         AlarmScriptCompleteEvent: {
            (options?: srmService.vim.AlarmScriptCompleteEvent): srmService.vim.AlarmScriptCompleteEvent;
         };
         AlarmScriptFailedEvent: {
            (options?: srmService.vim.AlarmScriptFailedEvent): srmService.vim.AlarmScriptFailedEvent;
         };
         AlarmRemovedEvent: {
            (options?: srmService.vim.AlarmRemovedEvent): srmService.vim.AlarmRemovedEvent;
         };
         AlarmReconfiguredEvent: {
            (options?: srmService.vim.AlarmReconfiguredEvent): srmService.vim.AlarmReconfiguredEvent;
         };
         AlarmAcknowledgedEvent: {
            (options?: srmService.vim.AlarmAcknowledgedEvent): srmService.vim.AlarmAcknowledgedEvent;
         };
         AlarmClearedEvent: {
            (options?: srmService.vim.AlarmClearedEvent): srmService.vim.AlarmClearedEvent;
         };
         CustomFieldEvent: {
            (options?: srmService.vim.CustomFieldEvent): srmService.vim.CustomFieldEvent;
         };
         CustomFieldDefEvent: {
            (options?: srmService.vim.CustomFieldDefEvent): srmService.vim.CustomFieldDefEvent;
         };
         CustomFieldDefAddedEvent: {
            (options?: srmService.vim.CustomFieldDefAddedEvent): srmService.vim.CustomFieldDefAddedEvent;
         };
         CustomFieldDefRemovedEvent: {
            (options?: srmService.vim.CustomFieldDefRemovedEvent): srmService.vim.CustomFieldDefRemovedEvent;
         };
         CustomFieldDefRenamedEvent: {
            (options?: srmService.vim.CustomFieldDefRenamedEvent): srmService.vim.CustomFieldDefRenamedEvent;
         };
         CustomFieldValueChangedEvent: {
            (options?: srmService.vim.CustomFieldValueChangedEvent): srmService.vim.CustomFieldValueChangedEvent;
         };
         AuthorizationEvent: {
            (options?: srmService.vim.AuthorizationEvent): srmService.vim.AuthorizationEvent;
         };
         PermissionEvent: {
            (options?: srmService.vim.PermissionEvent): srmService.vim.PermissionEvent;
         };
         PermissionAddedEvent: {
            (options?: srmService.vim.PermissionAddedEvent): srmService.vim.PermissionAddedEvent;
         };
         PermissionUpdatedEvent: {
            (options?: srmService.vim.PermissionUpdatedEvent): srmService.vim.PermissionUpdatedEvent;
         };
         PermissionRemovedEvent: {
            (options?: srmService.vim.PermissionRemovedEvent): srmService.vim.PermissionRemovedEvent;
         };
         RoleEvent: {
            (options?: srmService.vim.RoleEvent): srmService.vim.RoleEvent;
         };
         RoleAddedEvent: {
            (options?: srmService.vim.RoleAddedEvent): srmService.vim.RoleAddedEvent;
         };
         RoleUpdatedEvent: {
            (options?: srmService.vim.RoleUpdatedEvent): srmService.vim.RoleUpdatedEvent;
         };
         RoleRemovedEvent: {
            (options?: srmService.vim.RoleRemovedEvent): srmService.vim.RoleRemovedEvent;
         };
         DatastoreEvent: {
            (options?: srmService.vim.DatastoreEvent): srmService.vim.DatastoreEvent;
         };
         DatastoreDestroyedEvent: {
            (options?: srmService.vim.DatastoreDestroyedEvent): srmService.vim.DatastoreDestroyedEvent;
         };
         DatastoreRenamedEvent: {
            (options?: srmService.vim.DatastoreRenamedEvent): srmService.vim.DatastoreRenamedEvent;
         };
         DatastoreCapacityIncreasedEvent: {
            (options?: srmService.vim.DatastoreCapacityIncreasedEvent): srmService.vim.DatastoreCapacityIncreasedEvent;
         };
         DatastoreDuplicatedEvent: {
            (options?: srmService.vim.DatastoreDuplicatedEvent): srmService.vim.DatastoreDuplicatedEvent;
         };
         DatastoreFileEvent: {
            (options?: srmService.vim.DatastoreFileEvent): srmService.vim.DatastoreFileEvent;
         };
         DatastoreFileCopiedEvent: {
            (options?: srmService.vim.DatastoreFileCopiedEvent): srmService.vim.DatastoreFileCopiedEvent;
         };
         DatastoreFileMovedEvent: {
            (options?: srmService.vim.DatastoreFileMovedEvent): srmService.vim.DatastoreFileMovedEvent;
         };
         DatastoreFileDeletedEvent: {
            (options?: srmService.vim.DatastoreFileDeletedEvent): srmService.vim.DatastoreFileDeletedEvent;
         };
         NonVIWorkloadDetectedOnDatastoreEvent: {
            (options?: srmService.vim.NonVIWorkloadDetectedOnDatastoreEvent): srmService.vim.NonVIWorkloadDetectedOnDatastoreEvent;
         };
         DatastoreIORMReconfiguredEvent: {
            (options?: srmService.vim.DatastoreIORMReconfiguredEvent): srmService.vim.DatastoreIORMReconfiguredEvent;
         };
         TaskEvent: {
            (options?: srmService.vim.TaskEvent): srmService.vim.TaskEvent;
         };
         TaskTimeoutEvent: {
            (options?: srmService.vim.TaskTimeoutEvent): srmService.vim.TaskTimeoutEvent;
         };
         LicenseEvent: {
            (options?: srmService.vim.LicenseEvent): srmService.vim.LicenseEvent;
         };
         ServerLicenseExpiredEvent: {
            (options?: srmService.vim.ServerLicenseExpiredEvent): srmService.vim.ServerLicenseExpiredEvent;
         };
         HostLicenseExpiredEvent: {
            (options?: srmService.vim.HostLicenseExpiredEvent): srmService.vim.HostLicenseExpiredEvent;
         };
         VMotionLicenseExpiredEvent: {
            (options?: srmService.vim.VMotionLicenseExpiredEvent): srmService.vim.VMotionLicenseExpiredEvent;
         };
         NoLicenseEvent: {
            (options?: srmService.vim.NoLicenseEvent): srmService.vim.NoLicenseEvent;
         };
         LicenseServerUnavailableEvent: {
            (options?: srmService.vim.LicenseServerUnavailableEvent): srmService.vim.LicenseServerUnavailableEvent;
         };
         LicenseServerAvailableEvent: {
            (options?: srmService.vim.LicenseServerAvailableEvent): srmService.vim.LicenseServerAvailableEvent;
         };
         LicenseExpiredEvent: {
            (options?: srmService.vim.LicenseExpiredEvent): srmService.vim.LicenseExpiredEvent;
         };
         InvalidEditionEvent: {
            (options?: srmService.vim.InvalidEditionEvent): srmService.vim.InvalidEditionEvent;
         };
         HostInventoryFullEvent: {
            (options?: srmService.vim.HostInventoryFullEvent): srmService.vim.HostInventoryFullEvent;
         };
         LicenseRestrictedEvent: {
            (options?: srmService.vim.LicenseRestrictedEvent): srmService.vim.LicenseRestrictedEvent;
         };
         IncorrectHostInformationEvent: {
            (options?: srmService.vim.IncorrectHostInformationEvent): srmService.vim.IncorrectHostInformationEvent;
         };
         UnlicensedVirtualMachinesEvent: {
            (options?: srmService.vim.UnlicensedVirtualMachinesEvent): srmService.vim.UnlicensedVirtualMachinesEvent;
         };
         UnlicensedVirtualMachinesFoundEvent: {
            (options?: srmService.vim.UnlicensedVirtualMachinesFoundEvent): srmService.vim.UnlicensedVirtualMachinesFoundEvent;
         };
         AllVirtualMachinesLicensedEvent: {
            (options?: srmService.vim.AllVirtualMachinesLicensedEvent): srmService.vim.AllVirtualMachinesLicensedEvent;
         };
         LicenseNonComplianceEvent: {
            (options?: srmService.vim.LicenseNonComplianceEvent): srmService.vim.LicenseNonComplianceEvent;
         };
         MigrationEvent: {
            (options?: srmService.vim.MigrationEvent): srmService.vim.MigrationEvent;
         };
         MigrationWarningEvent: {
            (options?: srmService.vim.MigrationWarningEvent): srmService.vim.MigrationWarningEvent;
         };
         MigrationErrorEvent: {
            (options?: srmService.vim.MigrationErrorEvent): srmService.vim.MigrationErrorEvent;
         };
         MigrationHostWarningEvent: {
            (options?: srmService.vim.MigrationHostWarningEvent): srmService.vim.MigrationHostWarningEvent;
         };
         MigrationHostErrorEvent: {
            (options?: srmService.vim.MigrationHostErrorEvent): srmService.vim.MigrationHostErrorEvent;
         };
         MigrationResourceWarningEvent: {
            (options?: srmService.vim.MigrationResourceWarningEvent): srmService.vim.MigrationResourceWarningEvent;
         };
         MigrationResourceErrorEvent: {
            (options?: srmService.vim.MigrationResourceErrorEvent): srmService.vim.MigrationResourceErrorEvent;
         };
         ClusterEvent: {
            (options?: srmService.vim.ClusterEvent): srmService.vim.ClusterEvent;
         };
         DasEnabledEvent: {
            (options?: srmService.vim.DasEnabledEvent): srmService.vim.DasEnabledEvent;
         };
         DasDisabledEvent: {
            (options?: srmService.vim.DasDisabledEvent): srmService.vim.DasDisabledEvent;
         };
         DasAdmissionControlDisabledEvent: {
            (options?: srmService.vim.DasAdmissionControlDisabledEvent): srmService.vim.DasAdmissionControlDisabledEvent;
         };
         DasAdmissionControlEnabledEvent: {
            (options?: srmService.vim.DasAdmissionControlEnabledEvent): srmService.vim.DasAdmissionControlEnabledEvent;
         };
         DasHostFailedEvent: {
            (options?: srmService.vim.DasHostFailedEvent): srmService.vim.DasHostFailedEvent;
         };
         DasHostIsolatedEvent: {
            (options?: srmService.vim.DasHostIsolatedEvent): srmService.vim.DasHostIsolatedEvent;
         };
         DasClusterIsolatedEvent: {
            (options?: srmService.vim.DasClusterIsolatedEvent): srmService.vim.DasClusterIsolatedEvent;
         };
         DasAgentUnavailableEvent: {
            (options?: srmService.vim.DasAgentUnavailableEvent): srmService.vim.DasAgentUnavailableEvent;
         };
         DasAgentFoundEvent: {
            (options?: srmService.vim.DasAgentFoundEvent): srmService.vim.DasAgentFoundEvent;
         };
         InsufficientFailoverResourcesEvent: {
            (options?: srmService.vim.InsufficientFailoverResourcesEvent): srmService.vim.InsufficientFailoverResourcesEvent;
         };
         FailoverLevelRestored: {
            (options?: srmService.vim.FailoverLevelRestored): srmService.vim.FailoverLevelRestored;
         };
         ClusterOvercommittedEvent: {
            (options?: srmService.vim.ClusterOvercommittedEvent): srmService.vim.ClusterOvercommittedEvent;
         };
         HostOvercommittedEvent: {
            (options?: srmService.vim.HostOvercommittedEvent): srmService.vim.HostOvercommittedEvent;
         };
         ClusterStatusChangedEvent: {
            (options?: srmService.vim.ClusterStatusChangedEvent): srmService.vim.ClusterStatusChangedEvent;
         };
         HostStatusChangedEvent: {
            (options?: srmService.vim.HostStatusChangedEvent): srmService.vim.HostStatusChangedEvent;
         };
         ClusterCreatedEvent: {
            (options?: srmService.vim.ClusterCreatedEvent): srmService.vim.ClusterCreatedEvent;
         };
         ClusterDestroyedEvent: {
            (options?: srmService.vim.ClusterDestroyedEvent): srmService.vim.ClusterDestroyedEvent;
         };
         DrsEnabledEvent: {
            (options?: srmService.vim.DrsEnabledEvent): srmService.vim.DrsEnabledEvent;
         };
         DrsDisabledEvent: {
            (options?: srmService.vim.DrsDisabledEvent): srmService.vim.DrsDisabledEvent;
         };
         ClusterReconfiguredEvent: {
            (options?: srmService.vim.ClusterReconfiguredEvent): srmService.vim.ClusterReconfiguredEvent;
         };
         HostMonitoringStateChangedEvent: {
            (options?: srmService.vim.HostMonitoringStateChangedEvent): srmService.vim.HostMonitoringStateChangedEvent;
         };
         VmHealthMonitoringStateChangedEvent: {
            (options?: srmService.vim.VmHealthMonitoringStateChangedEvent): srmService.vim.VmHealthMonitoringStateChangedEvent;
         };
         ResourcePoolEvent: {
            (options?: srmService.vim.ResourcePoolEvent): srmService.vim.ResourcePoolEvent;
         };
         ResourcePoolCreatedEvent: {
            (options?: srmService.vim.ResourcePoolCreatedEvent): srmService.vim.ResourcePoolCreatedEvent;
         };
         ResourcePoolDestroyedEvent: {
            (options?: srmService.vim.ResourcePoolDestroyedEvent): srmService.vim.ResourcePoolDestroyedEvent;
         };
         ResourcePoolMovedEvent: {
            (options?: srmService.vim.ResourcePoolMovedEvent): srmService.vim.ResourcePoolMovedEvent;
         };
         ResourcePoolReconfiguredEvent: {
            (options?: srmService.vim.ResourcePoolReconfiguredEvent): srmService.vim.ResourcePoolReconfiguredEvent;
         };
         ResourceViolatedEvent: {
            (options?: srmService.vim.ResourceViolatedEvent): srmService.vim.ResourceViolatedEvent;
         };
         VmResourcePoolMovedEvent: {
            (options?: srmService.vim.VmResourcePoolMovedEvent): srmService.vim.VmResourcePoolMovedEvent;
         };
         TemplateUpgradeEvent: {
            (options?: srmService.vim.TemplateUpgradeEvent): srmService.vim.TemplateUpgradeEvent;
         };
         TemplateBeingUpgradedEvent: {
            (options?: srmService.vim.TemplateBeingUpgradedEvent): srmService.vim.TemplateBeingUpgradedEvent;
         };
         TemplateUpgradeFailedEvent: {
            (options?: srmService.vim.TemplateUpgradeFailedEvent): srmService.vim.TemplateUpgradeFailedEvent;
         };
         TemplateUpgradedEvent: {
            (options?: srmService.vim.TemplateUpgradedEvent): srmService.vim.TemplateUpgradedEvent;
         };
         CustomizationEvent: {
            (options?: srmService.vim.CustomizationEvent): srmService.vim.CustomizationEvent;
         };
         CustomizationStartedEvent: {
            (options?: srmService.vim.CustomizationStartedEvent): srmService.vim.CustomizationStartedEvent;
         };
         CustomizationSucceeded: {
            (options?: srmService.vim.CustomizationSucceeded): srmService.vim.CustomizationSucceeded;
         };
         CustomizationFailed: {
            (options?: srmService.vim.CustomizationFailed): srmService.vim.CustomizationFailed;
         };
         CustomizationUnknownFailure: {
            (options?: srmService.vim.CustomizationUnknownFailure): srmService.vim.CustomizationUnknownFailure;
         };
         CustomizationSysprepFailed: {
            (options?: srmService.vim.CustomizationSysprepFailed): srmService.vim.CustomizationSysprepFailed;
         };
         CustomizationLinuxIdentityFailed: {
            (options?: srmService.vim.CustomizationLinuxIdentityFailed): srmService.vim.CustomizationLinuxIdentityFailed;
         };
         CustomizationNetworkSetupFailed: {
            (options?: srmService.vim.CustomizationNetworkSetupFailed): srmService.vim.CustomizationNetworkSetupFailed;
         };
         LockerMisconfiguredEvent: {
            (options?: srmService.vim.LockerMisconfiguredEvent): srmService.vim.LockerMisconfiguredEvent;
         };
         LockerReconfiguredEvent: {
            (options?: srmService.vim.LockerReconfiguredEvent): srmService.vim.LockerReconfiguredEvent;
         };
         NoDatastoresConfiguredEvent: {
            (options?: srmService.vim.NoDatastoresConfiguredEvent): srmService.vim.NoDatastoresConfiguredEvent;
         };
         AdminPasswordNotChangedEvent: {
            (options?: srmService.vim.AdminPasswordNotChangedEvent): srmService.vim.AdminPasswordNotChangedEvent;
         };
         HostInAuditModeEvent: {
            (options?: srmService.vim.HostInAuditModeEvent): srmService.vim.HostInAuditModeEvent;
         };
         LocalTSMEnabledEvent: {
            (options?: srmService.vim.LocalTSMEnabledEvent): srmService.vim.LocalTSMEnabledEvent;
         };
         RemoteTSMEnabledEvent: {
            (options?: srmService.vim.RemoteTSMEnabledEvent): srmService.vim.RemoteTSMEnabledEvent;
         };
         VimAccountPasswordChangedEvent: {
            (options?: srmService.vim.VimAccountPasswordChangedEvent): srmService.vim.VimAccountPasswordChangedEvent;
         };
         IScsiBootFailureEvent: {
            (options?: srmService.vim.IScsiBootFailureEvent): srmService.vim.IScsiBootFailureEvent;
         };
         DvsHealthStatusChangeEvent: {
            (options?: srmService.vim.DvsHealthStatusChangeEvent): srmService.vim.DvsHealthStatusChangeEvent;
         };
         NetworkRollbackEvent: {
            (options?: srmService.vim.NetworkRollbackEvent): srmService.vim.NetworkRollbackEvent;
         };
         UplinkPortVlanTrunkedEvent: {
            (options?: srmService.vim.UplinkPortVlanTrunkedEvent): srmService.vim.UplinkPortVlanTrunkedEvent;
         };
         UplinkPortVlanUntrunkedEvent: {
            (options?: srmService.vim.UplinkPortVlanUntrunkedEvent): srmService.vim.UplinkPortVlanUntrunkedEvent;
         };
         MtuMatchEvent: {
            (options?: srmService.vim.MtuMatchEvent): srmService.vim.MtuMatchEvent;
         };
         MtuMismatchEvent: {
            (options?: srmService.vim.MtuMismatchEvent): srmService.vim.MtuMismatchEvent;
         };
         UplinkPortMtuNotSupportEvent: {
            (options?: srmService.vim.UplinkPortMtuNotSupportEvent): srmService.vim.UplinkPortMtuNotSupportEvent;
         };
         UplinkPortMtuSupportEvent: {
            (options?: srmService.vim.UplinkPortMtuSupportEvent): srmService.vim.UplinkPortMtuSupportEvent;
         };
         TeamingMatchEvent: {
            (options?: srmService.vim.TeamingMatchEvent): srmService.vim.TeamingMatchEvent;
         };
         TeamingMisMatchEvent: {
            (options?: srmService.vim.TeamingMisMatchEvent): srmService.vim.TeamingMisMatchEvent;
         };
         DvsEvent: {
            (options?: srmService.vim.DvsEvent): srmService.vim.DvsEvent;
         };
         DvsCreatedEvent: {
            (options?: srmService.vim.DvsCreatedEvent): srmService.vim.DvsCreatedEvent;
         };
         DvsRenamedEvent: {
            (options?: srmService.vim.DvsRenamedEvent): srmService.vim.DvsRenamedEvent;
         };
         DvsReconfiguredEvent: {
            (options?: srmService.vim.DvsReconfiguredEvent): srmService.vim.DvsReconfiguredEvent;
         };
         DvsUpgradeAvailableEvent: {
            (options?: srmService.vim.DvsUpgradeAvailableEvent): srmService.vim.DvsUpgradeAvailableEvent;
         };
         DvsUpgradeInProgressEvent: {
            (options?: srmService.vim.DvsUpgradeInProgressEvent): srmService.vim.DvsUpgradeInProgressEvent;
         };
         DvsUpgradeRejectedEvent: {
            (options?: srmService.vim.DvsUpgradeRejectedEvent): srmService.vim.DvsUpgradeRejectedEvent;
         };
         DvsUpgradedEvent: {
            (options?: srmService.vim.DvsUpgradedEvent): srmService.vim.DvsUpgradedEvent;
         };
         DvsHostJoinedEvent: {
            (options?: srmService.vim.DvsHostJoinedEvent): srmService.vim.DvsHostJoinedEvent;
         };
         DvsHostLeftEvent: {
            (options?: srmService.vim.DvsHostLeftEvent): srmService.vim.DvsHostLeftEvent;
         };
         DvsOutOfSyncHostArgument: {
            (options?: srmService.vim.DvsOutOfSyncHostArgument): srmService.vim.DvsOutOfSyncHostArgument;
         };
         ArrayOfDvsOutOfSyncHostArgument: {
            (options?: srmService.vim.ArrayOfDvsOutOfSyncHostArgument): srmService.vim.ArrayOfDvsOutOfSyncHostArgument;
         };
         OutOfSyncDvsHost: {
            (options?: srmService.vim.OutOfSyncDvsHost): srmService.vim.OutOfSyncDvsHost;
         };
         DvsHostWentOutOfSyncEvent: {
            (options?: srmService.vim.DvsHostWentOutOfSyncEvent): srmService.vim.DvsHostWentOutOfSyncEvent;
         };
         DvsHostBackInSyncEvent: {
            (options?: srmService.vim.DvsHostBackInSyncEvent): srmService.vim.DvsHostBackInSyncEvent;
         };
         DvsHostStatusUpdated: {
            (options?: srmService.vim.DvsHostStatusUpdated): srmService.vim.DvsHostStatusUpdated;
         };
         DvsPortCreatedEvent: {
            (options?: srmService.vim.DvsPortCreatedEvent): srmService.vim.DvsPortCreatedEvent;
         };
         DvsPortReconfiguredEvent: {
            (options?: srmService.vim.DvsPortReconfiguredEvent): srmService.vim.DvsPortReconfiguredEvent;
         };
         DvsPortDeletedEvent: {
            (options?: srmService.vim.DvsPortDeletedEvent): srmService.vim.DvsPortDeletedEvent;
         };
         DvsPortConnectedEvent: {
            (options?: srmService.vim.DvsPortConnectedEvent): srmService.vim.DvsPortConnectedEvent;
         };
         DvsPortDisconnectedEvent: {
            (options?: srmService.vim.DvsPortDisconnectedEvent): srmService.vim.DvsPortDisconnectedEvent;
         };
         DvsPortVendorSpecificStateChangeEvent: {
            (options?: srmService.vim.DvsPortVendorSpecificStateChangeEvent): srmService.vim.DvsPortVendorSpecificStateChangeEvent;
         };
         DvsPortRuntimeChangeEvent: {
            (options?: srmService.vim.DvsPortRuntimeChangeEvent): srmService.vim.DvsPortRuntimeChangeEvent;
         };
         DvsPortLinkUpEvent: {
            (options?: srmService.vim.DvsPortLinkUpEvent): srmService.vim.DvsPortLinkUpEvent;
         };
         DvsPortLinkDownEvent: {
            (options?: srmService.vim.DvsPortLinkDownEvent): srmService.vim.DvsPortLinkDownEvent;
         };
         DvsPortJoinPortgroupEvent: {
            (options?: srmService.vim.DvsPortJoinPortgroupEvent): srmService.vim.DvsPortJoinPortgroupEvent;
         };
         DvsPortLeavePortgroupEvent: {
            (options?: srmService.vim.DvsPortLeavePortgroupEvent): srmService.vim.DvsPortLeavePortgroupEvent;
         };
         DvsPortBlockedEvent: {
            (options?: srmService.vim.DvsPortBlockedEvent): srmService.vim.DvsPortBlockedEvent;
         };
         DvsPortUnblockedEvent: {
            (options?: srmService.vim.DvsPortUnblockedEvent): srmService.vim.DvsPortUnblockedEvent;
         };
         DvsPortEnteredPassthruEvent: {
            (options?: srmService.vim.DvsPortEnteredPassthruEvent): srmService.vim.DvsPortEnteredPassthruEvent;
         };
         DvsPortExitedPassthruEvent: {
            (options?: srmService.vim.DvsPortExitedPassthruEvent): srmService.vim.DvsPortExitedPassthruEvent;
         };
         DvsDestroyedEvent: {
            (options?: srmService.vim.DvsDestroyedEvent): srmService.vim.DvsDestroyedEvent;
         };
         DvsMergedEvent: {
            (options?: srmService.vim.DvsMergedEvent): srmService.vim.DvsMergedEvent;
         };
         HostLocalPortCreatedEvent: {
            (options?: srmService.vim.HostLocalPortCreatedEvent): srmService.vim.HostLocalPortCreatedEvent;
         };
         RollbackEvent: {
            (options?: srmService.vim.RollbackEvent): srmService.vim.RollbackEvent;
         };
         RecoveryEvent: {
            (options?: srmService.vim.RecoveryEvent): srmService.vim.RecoveryEvent;
         };
         DvsImportEvent: {
            (options?: srmService.vim.DvsImportEvent): srmService.vim.DvsImportEvent;
         };
         DvsRestoreEvent: {
            (options?: srmService.vim.DvsRestoreEvent): srmService.vim.DvsRestoreEvent;
         };
         DVPortgroupEvent: {
            (options?: srmService.vim.DVPortgroupEvent): srmService.vim.DVPortgroupEvent;
         };
         DVPortgroupCreatedEvent: {
            (options?: srmService.vim.DVPortgroupCreatedEvent): srmService.vim.DVPortgroupCreatedEvent;
         };
         DVPortgroupRenamedEvent: {
            (options?: srmService.vim.DVPortgroupRenamedEvent): srmService.vim.DVPortgroupRenamedEvent;
         };
         DVPortgroupReconfiguredEvent: {
            (options?: srmService.vim.DVPortgroupReconfiguredEvent): srmService.vim.DVPortgroupReconfiguredEvent;
         };
         DVPortgroupDestroyedEvent: {
            (options?: srmService.vim.DVPortgroupDestroyedEvent): srmService.vim.DVPortgroupDestroyedEvent;
         };
         DvpgImportEvent: {
            (options?: srmService.vim.DvpgImportEvent): srmService.vim.DvpgImportEvent;
         };
         DvpgRestoreEvent: {
            (options?: srmService.vim.DvpgRestoreEvent): srmService.vim.DvpgRestoreEvent;
         };
         DrsInvocationFailedEvent: {
            (options?: srmService.vim.DrsInvocationFailedEvent): srmService.vim.DrsInvocationFailedEvent;
         };
         DrsRecoveredFromFailureEvent: {
            (options?: srmService.vim.DrsRecoveredFromFailureEvent): srmService.vim.DrsRecoveredFromFailureEvent;
         };
         VmReloadFromPathEvent: {
            (options?: srmService.vim.VmReloadFromPathEvent): srmService.vim.VmReloadFromPathEvent;
         };
         VmReloadFromPathFailedEvent: {
            (options?: srmService.vim.VmReloadFromPathFailedEvent): srmService.vim.VmReloadFromPathFailedEvent;
         };
         VmRequirementsExceedCurrentEVCModeEvent: {
            (options?: srmService.vim.VmRequirementsExceedCurrentEVCModeEvent): srmService.vim.VmRequirementsExceedCurrentEVCModeEvent;
         };
         EventArgument: {
            (options?: srmService.vim.EventArgument): srmService.vim.EventArgument;
         };
         RoleEventArgument: {
            (options?: srmService.vim.RoleEventArgument): srmService.vim.RoleEventArgument;
         };
         EntityEventArgument: {
            (options?: srmService.vim.EntityEventArgument): srmService.vim.EntityEventArgument;
         };
         ManagedEntityEventArgument: {
            (options?: srmService.vim.ManagedEntityEventArgument): srmService.vim.ManagedEntityEventArgument;
         };
         FolderEventArgument: {
            (options?: srmService.vim.FolderEventArgument): srmService.vim.FolderEventArgument;
         };
         DatacenterEventArgument: {
            (options?: srmService.vim.DatacenterEventArgument): srmService.vim.DatacenterEventArgument;
         };
         ComputeResourceEventArgument: {
            (options?: srmService.vim.ComputeResourceEventArgument): srmService.vim.ComputeResourceEventArgument;
         };
         ResourcePoolEventArgument: {
            (options?: srmService.vim.ResourcePoolEventArgument): srmService.vim.ResourcePoolEventArgument;
         };
         HostEventArgument: {
            (options?: srmService.vim.HostEventArgument): srmService.vim.HostEventArgument;
         };
         ArrayOfHostEventArgument: {
            (options?: srmService.vim.ArrayOfHostEventArgument): srmService.vim.ArrayOfHostEventArgument;
         };
         VmEventArgument: {
            (options?: srmService.vim.VmEventArgument): srmService.vim.VmEventArgument;
         };
         ArrayOfVmEventArgument: {
            (options?: srmService.vim.ArrayOfVmEventArgument): srmService.vim.ArrayOfVmEventArgument;
         };
         DatastoreEventArgument: {
            (options?: srmService.vim.DatastoreEventArgument): srmService.vim.DatastoreEventArgument;
         };
         NetworkEventArgument: {
            (options?: srmService.vim.NetworkEventArgument): srmService.vim.NetworkEventArgument;
         };
         AlarmEventArgument: {
            (options?: srmService.vim.AlarmEventArgument): srmService.vim.AlarmEventArgument;
         };
         ScheduledTaskEventArgument: {
            (options?: srmService.vim.ScheduledTaskEventArgument): srmService.vim.ScheduledTaskEventArgument;
         };
         ProfileEventArgument: {
            (options?: srmService.vim.ProfileEventArgument): srmService.vim.ProfileEventArgument;
         };
         DvsEventArgument: {
            (options?: srmService.vim.DvsEventArgument): srmService.vim.DvsEventArgument;
         };
         EventCategory: {
            "info": string;
            "warning": string;
            "error": string;
            "user": string;
         };
         EventArgDesc: {
            (options?: srmService.vim.EventArgDesc): srmService.vim.EventArgDesc;
         };
         ArrayOfEventArgDesc: {
            (options?: srmService.vim.ArrayOfEventArgDesc): srmService.vim.ArrayOfEventArgDesc;
         };
         EventDescriptionEventDetail: {
            (options?: srmService.vim.EventDescriptionEventDetail): srmService.vim.EventDescriptionEventDetail;
         };
         ArrayOfEventDescriptionEventDetail: {
            (options?: srmService.vim.ArrayOfEventDescriptionEventDetail): srmService.vim.ArrayOfEventDescriptionEventDetail;
         };
         EventDescription: {
            (options?: srmService.vim.EventDescription): srmService.vim.EventDescription;
         };
         EventEx: {
            (options?: srmService.vim.EventEx): srmService.vim.EventEx;
         };
         EventFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         EventFilterSpecByEntity: {
            (options?: srmService.vim.EventFilterSpecByEntity): srmService.vim.EventFilterSpecByEntity;
         };
         EventFilterSpecByTime: {
            (options?: srmService.vim.EventFilterSpecByTime): srmService.vim.EventFilterSpecByTime;
         };
         EventFilterSpecByUsername: {
            (options?: srmService.vim.EventFilterSpecByUsername): srmService.vim.EventFilterSpecByUsername;
         };
         EventFilterSpec: {
            (options?: srmService.vim.EventFilterSpec): srmService.vim.EventFilterSpec;
         };
         ExtExtendedProductInfo: {
            (options?: srmService.vim.ExtExtendedProductInfo): srmService.vim.ExtExtendedProductInfo;
         };
         ManagedByInfo: {
            (options?: srmService.vim.ManagedByInfo): srmService.vim.ManagedByInfo;
         };
         ExtManagedEntityInfo: {
            (options?: srmService.vim.ExtManagedEntityInfo): srmService.vim.ExtManagedEntityInfo;
         };
         ArrayOfExtManagedEntityInfo: {
            (options?: srmService.vim.ArrayOfExtManagedEntityInfo): srmService.vim.ArrayOfExtManagedEntityInfo;
         };
         ExtSolutionManagerInfoTabInfo: {
            (options?: srmService.vim.ExtSolutionManagerInfoTabInfo): srmService.vim.ExtSolutionManagerInfoTabInfo;
         };
         ArrayOfExtSolutionManagerInfoTabInfo: {
            (options?: srmService.vim.ArrayOfExtSolutionManagerInfoTabInfo): srmService.vim.ArrayOfExtSolutionManagerInfoTabInfo;
         };
         ExtSolutionManagerInfo: {
            (options?: srmService.vim.ExtSolutionManagerInfo): srmService.vim.ExtSolutionManagerInfo;
         };
         ActiveDirectoryFault: {
            (options?: srmService.vim.ActiveDirectoryFault): srmService.vim.ActiveDirectoryFault;
         };
         AdminDisabled: {
            (options?: srmService.vim.AdminDisabled): srmService.vim.AdminDisabled;
         };
         AdminNotDisabled: {
            (options?: srmService.vim.AdminNotDisabled): srmService.vim.AdminNotDisabled;
         };
         AffinityType: {
            "memory": string;
            "cpu": string;
         };
         AffinityConfigured: {
            (options?: srmService.vim.AffinityConfigured): srmService.vim.AffinityConfigured;
         };
         AgentInstallFailedReason: {
            "NotEnoughSpaceOnDevice": string;
            "PrepareToUpgradeFailed": string;
            "AgentNotRunning": string;
            "AgentNotReachable": string;
            "InstallTimedout": string;
            "SignatureVerificationFailed": string;
            "AgentUploadFailed": string;
            "AgentUploadTimedout": string;
            "UnknownInstallerError": string;
         };
         AgentInstallFailed: {
            (options?: srmService.vim.AgentInstallFailed): srmService.vim.AgentInstallFailed;
         };
         AlreadyBeingManaged: {
            (options?: srmService.vim.AlreadyBeingManaged): srmService.vim.AlreadyBeingManaged;
         };
         AlreadyConnected: {
            (options?: srmService.vim.AlreadyConnected): srmService.vim.AlreadyConnected;
         };
         AlreadyExists: {
            (options?: srmService.vim.AlreadyExists): srmService.vim.AlreadyExists;
         };
         AlreadyUpgraded: {
            (options?: srmService.vim.AlreadyUpgraded): srmService.vim.AlreadyUpgraded;
         };
         AnswerFileUpdateFailure: {
            (options?: srmService.vim.AnswerFileUpdateFailure): srmService.vim.AnswerFileUpdateFailure;
         };
         ArrayOfAnswerFileUpdateFailure: {
            (options?: srmService.vim.ArrayOfAnswerFileUpdateFailure): srmService.vim.ArrayOfAnswerFileUpdateFailure;
         };
         AnswerFileUpdateFailed: {
            (options?: srmService.vim.AnswerFileUpdateFailed): srmService.vim.AnswerFileUpdateFailed;
         };
         ApplicationQuiesceFault: {
            (options?: srmService.vim.ApplicationQuiesceFault): srmService.vim.ApplicationQuiesceFault;
         };
         AuthMinimumAdminPermission: {
            (options?: srmService.vim.AuthMinimumAdminPermission): srmService.vim.AuthMinimumAdminPermission;
         };
         BackupBlobReadFailure: {
            (options?: srmService.vim.BackupBlobReadFailure): srmService.vim.BackupBlobReadFailure;
         };
         BackupBlobWriteFailure: {
            (options?: srmService.vim.BackupBlobWriteFailure): srmService.vim.BackupBlobWriteFailure;
         };
         BlockedByFirewall: {
            (options?: srmService.vim.BlockedByFirewall): srmService.vim.BlockedByFirewall;
         };
         CAMServerRefusedConnection: {
            (options?: srmService.vim.CAMServerRefusedConnection): srmService.vim.CAMServerRefusedConnection;
         };
         CannotAccessFile: {
            (options?: srmService.vim.CannotAccessFile): srmService.vim.CannotAccessFile;
         };
         CannotAccessLocalSource: {
            (options?: srmService.vim.CannotAccessLocalSource): srmService.vim.CannotAccessLocalSource;
         };
         CannotAccessNetwork: {
            (options?: srmService.vim.CannotAccessNetwork): srmService.vim.CannotAccessNetwork;
         };
         CannotAccessVmComponent: {
            (options?: srmService.vim.CannotAccessVmComponent): srmService.vim.CannotAccessVmComponent;
         };
         CannotAccessVmConfig: {
            (options?: srmService.vim.CannotAccessVmConfig): srmService.vim.CannotAccessVmConfig;
         };
         CannotAccessVmDevice: {
            (options?: srmService.vim.CannotAccessVmDevice): srmService.vim.CannotAccessVmDevice;
         };
         CannotAccessVmDisk: {
            (options?: srmService.vim.CannotAccessVmDisk): srmService.vim.CannotAccessVmDisk;
         };
         CannotAddHostWithFTVmAsStandalone: {
            (options?: srmService.vim.CannotAddHostWithFTVmAsStandalone): srmService.vim.CannotAddHostWithFTVmAsStandalone;
         };
         CannotAddHostWithFTVmToDifferentCluster: {
            (options?: srmService.vim.CannotAddHostWithFTVmToDifferentCluster): srmService.vim.CannotAddHostWithFTVmToDifferentCluster;
         };
         CannotAddHostWithFTVmToNonHACluster: {
            (options?: srmService.vim.CannotAddHostWithFTVmToNonHACluster): srmService.vim.CannotAddHostWithFTVmToNonHACluster;
         };
         CannotChangeDrsBehaviorForFtSecondary: {
            (options?: srmService.vim.CannotChangeDrsBehaviorForFtSecondary): srmService.vim.CannotChangeDrsBehaviorForFtSecondary;
         };
         CannotChangeHaSettingsForFtSecondary: {
            (options?: srmService.vim.CannotChangeHaSettingsForFtSecondary): srmService.vim.CannotChangeHaSettingsForFtSecondary;
         };
         CannotChangeVsanClusterUuid: {
            (options?: srmService.vim.CannotChangeVsanClusterUuid): srmService.vim.CannotChangeVsanClusterUuid;
         };
         CannotChangeVsanNodeUuid: {
            (options?: srmService.vim.CannotChangeVsanNodeUuid): srmService.vim.CannotChangeVsanNodeUuid;
         };
         CannotCreateFile: {
            (options?: srmService.vim.CannotCreateFile): srmService.vim.CannotCreateFile;
         };
         CannotDecryptPasswords: {
            (options?: srmService.vim.CannotDecryptPasswords): srmService.vim.CannotDecryptPasswords;
         };
         CannotDeleteFile: {
            (options?: srmService.vim.CannotDeleteFile): srmService.vim.CannotDeleteFile;
         };
         CannotDisableDrsOnClustersWithVApps: {
            (options?: srmService.vim.CannotDisableDrsOnClustersWithVApps): srmService.vim.CannotDisableDrsOnClustersWithVApps;
         };
         CannotDisableSnapshot: {
            (options?: srmService.vim.CannotDisableSnapshot): srmService.vim.CannotDisableSnapshot;
         };
         CannotDisconnectHostWithFaultToleranceVm: {
            (options?: srmService.vim.CannotDisconnectHostWithFaultToleranceVm): srmService.vim.CannotDisconnectHostWithFaultToleranceVm;
         };
         CannotModifyConfigCpuRequirements: {
            (options?: srmService.vim.CannotModifyConfigCpuRequirements): srmService.vim.CannotModifyConfigCpuRequirements;
         };
         CannotMoveFaultToleranceVmMoveType: {
            "resourcePool": string;
            "cluster": string;
         };
         CannotMoveFaultToleranceVm: {
            (options?: srmService.vim.CannotMoveFaultToleranceVm): srmService.vim.CannotMoveFaultToleranceVm;
         };
         CannotMoveHostWithFaultToleranceVm: {
            (options?: srmService.vim.CannotMoveHostWithFaultToleranceVm): srmService.vim.CannotMoveHostWithFaultToleranceVm;
         };
         CannotMoveVmWithDeltaDisk: {
            (options?: srmService.vim.CannotMoveVmWithDeltaDisk): srmService.vim.CannotMoveVmWithDeltaDisk;
         };
         CannotMoveVmWithNativeDeltaDisk: {
            (options?: srmService.vim.CannotMoveVmWithNativeDeltaDisk): srmService.vim.CannotMoveVmWithNativeDeltaDisk;
         };
         CannotMoveVsanEnabledHost: {
            (options?: srmService.vim.CannotMoveVsanEnabledHost): srmService.vim.CannotMoveVsanEnabledHost;
         };
         CannotPlaceWithoutPrerequisiteMoves: {
            (options?: srmService.vim.CannotPlaceWithoutPrerequisiteMoves): srmService.vim.CannotPlaceWithoutPrerequisiteMoves;
         };
         CannotPowerOffVmInClusterOperation: {
            "suspend": string;
            "powerOff": string;
            "guestShutdown": string;
            "guestSuspend": string;
         };
         CannotPowerOffVmInCluster: {
            (options?: srmService.vim.CannotPowerOffVmInCluster): srmService.vim.CannotPowerOffVmInCluster;
         };
         CannotReconfigureVsanWhenHaEnabled: {
            (options?: srmService.vim.CannotReconfigureVsanWhenHaEnabled): srmService.vim.CannotReconfigureVsanWhenHaEnabled;
         };
         CannotUseNetworkReason: {
            "NetworkReservationNotSupported": string;
            "MismatchedNetworkPolicies": string;
            "MismatchedDvsVersionOrVendor": string;
            "VMotionToUnsupportedNetworkType": string;
         };
         CannotUseNetwork: {
            (options?: srmService.vim.CannotUseNetwork): srmService.vim.CannotUseNetwork;
         };
         ClockSkew: {
            (options?: srmService.vim.ClockSkew): srmService.vim.ClockSkew;
         };
         CloneFromSnapshotNotSupported: {
            (options?: srmService.vim.CloneFromSnapshotNotSupported): srmService.vim.CloneFromSnapshotNotSupported;
         };
         CollectorAddressUnset: {
            (options?: srmService.vim.CollectorAddressUnset): srmService.vim.CollectorAddressUnset;
         };
         ConcurrentAccess: {
            (options?: srmService.vim.ConcurrentAccess): srmService.vim.ConcurrentAccess;
         };
         ConflictingConfigurationConfig: {
            (options?: srmService.vim.ConflictingConfigurationConfig): srmService.vim.ConflictingConfigurationConfig;
         };
         ArrayOfConflictingConfigurationConfig: {
            (options?: srmService.vim.ArrayOfConflictingConfigurationConfig): srmService.vim.ArrayOfConflictingConfigurationConfig;
         };
         ConflictingConfiguration: {
            (options?: srmService.vim.ConflictingConfiguration): srmService.vim.ConflictingConfiguration;
         };
         ConflictingDatastoreFound: {
            (options?: srmService.vim.ConflictingDatastoreFound): srmService.vim.ConflictingDatastoreFound;
         };
         ConnectedIso: {
            (options?: srmService.vim.ConnectedIso): srmService.vim.ConnectedIso;
         };
         CpuCompatibilityUnknown: {
            (options?: srmService.vim.CpuCompatibilityUnknown): srmService.vim.CpuCompatibilityUnknown;
         };
         CpuHotPlugNotSupported: {
            (options?: srmService.vim.CpuHotPlugNotSupported): srmService.vim.CpuHotPlugNotSupported;
         };
         CpuIncompatible: {
            (options?: srmService.vim.CpuIncompatible): srmService.vim.CpuIncompatible;
         };
         CpuIncompatible1ECX: {
            (options?: srmService.vim.CpuIncompatible1ECX): srmService.vim.CpuIncompatible1ECX;
         };
         CpuIncompatible81EDX: {
            (options?: srmService.vim.CpuIncompatible81EDX): srmService.vim.CpuIncompatible81EDX;
         };
         CustomizationFault: {
            (options?: srmService.vim.CustomizationFault): srmService.vim.CustomizationFault;
         };
         CustomizationPending: {
            (options?: srmService.vim.CustomizationPending): srmService.vim.CustomizationPending;
         };
         DVPortNotSupported: {
            (options?: srmService.vim.DVPortNotSupported): srmService.vim.DVPortNotSupported;
         };
         DasConfigFaultDasConfigFaultReason: {
            "HostNetworkMisconfiguration": string;
            "HostMisconfiguration": string;
            "InsufficientPrivileges": string;
            "NoPrimaryAgentAvailable": string;
            "Other": string;
            "NoDatastoresConfigured": string;
            "VSanNotSupportedOnHost": string;
         };
         DasConfigFault: {
            (options?: srmService.vim.DasConfigFault): srmService.vim.DasConfigFault;
         };
         DatabaseError: {
            (options?: srmService.vim.DatabaseError): srmService.vim.DatabaseError;
         };
         DatacenterMismatchArgument: {
            (options?: srmService.vim.DatacenterMismatchArgument): srmService.vim.DatacenterMismatchArgument;
         };
         ArrayOfDatacenterMismatchArgument: {
            (options?: srmService.vim.ArrayOfDatacenterMismatchArgument): srmService.vim.ArrayOfDatacenterMismatchArgument;
         };
         DatacenterMismatch: {
            (options?: srmService.vim.DatacenterMismatch): srmService.vim.DatacenterMismatch;
         };
         DatastoreNotWritableOnHost: {
            (options?: srmService.vim.DatastoreNotWritableOnHost): srmService.vim.DatastoreNotWritableOnHost;
         };
         DeltaDiskFormatNotSupported: {
            (options?: srmService.vim.DeltaDiskFormatNotSupported): srmService.vim.DeltaDiskFormatNotSupported;
         };
         DestinationSwitchFull: {
            (options?: srmService.vim.DestinationSwitchFull): srmService.vim.DestinationSwitchFull;
         };
         DestinationVsanDisabled: {
            (options?: srmService.vim.DestinationVsanDisabled): srmService.vim.DestinationVsanDisabled;
         };
         DeviceBackingNotSupported: {
            (options?: srmService.vim.DeviceBackingNotSupported): srmService.vim.DeviceBackingNotSupported;
         };
         DeviceControllerNotSupported: {
            (options?: srmService.vim.DeviceControllerNotSupported): srmService.vim.DeviceControllerNotSupported;
         };
         DeviceHotPlugNotSupported: {
            (options?: srmService.vim.DeviceHotPlugNotSupported): srmService.vim.DeviceHotPlugNotSupported;
         };
         DeviceNotFound: {
            (options?: srmService.vim.DeviceNotFound): srmService.vim.DeviceNotFound;
         };
         DeviceNotSupportedReason: {
            "host": string;
            "guest": string;
         };
         DeviceNotSupported: {
            (options?: srmService.vim.DeviceNotSupported): srmService.vim.DeviceNotSupported;
         };
         DeviceUnsupportedForVmPlatform: {
            (options?: srmService.vim.DeviceUnsupportedForVmPlatform): srmService.vim.DeviceUnsupportedForVmPlatform;
         };
         DeviceUnsupportedForVmVersion: {
            (options?: srmService.vim.DeviceUnsupportedForVmVersion): srmService.vim.DeviceUnsupportedForVmVersion;
         };
         DirectoryNotEmpty: {
            (options?: srmService.vim.DirectoryNotEmpty): srmService.vim.DirectoryNotEmpty;
         };
         DisableAdminNotSupported: {
            (options?: srmService.vim.DisableAdminNotSupported): srmService.vim.DisableAdminNotSupported;
         };
         DisallowedChangeByServiceDisallowedChange: {
            "hotExtendDisk": string;
         };
         DisallowedChangeByService: {
            (options?: srmService.vim.DisallowedChangeByService): srmService.vim.DisallowedChangeByService;
         };
         DisallowedDiskModeChange: {
            (options?: srmService.vim.DisallowedDiskModeChange): srmService.vim.DisallowedDiskModeChange;
         };
         DisallowedMigrationDeviceAttached: {
            (options?: srmService.vim.DisallowedMigrationDeviceAttached): srmService.vim.DisallowedMigrationDeviceAttached;
         };
         DisallowedOperationOnFailoverHost: {
            (options?: srmService.vim.DisallowedOperationOnFailoverHost): srmService.vim.DisallowedOperationOnFailoverHost;
         };
         DiskHasPartitions: {
            (options?: srmService.vim.DiskHasPartitions): srmService.vim.DiskHasPartitions;
         };
         DiskIsLastRemainingNonSSD: {
            (options?: srmService.vim.DiskIsLastRemainingNonSSD): srmService.vim.DiskIsLastRemainingNonSSD;
         };
         DiskIsNonLocal: {
            (options?: srmService.vim.DiskIsNonLocal): srmService.vim.DiskIsNonLocal;
         };
         DiskIsUSB: {
            (options?: srmService.vim.DiskIsUSB): srmService.vim.DiskIsUSB;
         };
         DiskMoveTypeNotSupported: {
            (options?: srmService.vim.DiskMoveTypeNotSupported): srmService.vim.DiskMoveTypeNotSupported;
         };
         DiskNotSupported: {
            (options?: srmService.vim.DiskNotSupported): srmService.vim.DiskNotSupported;
         };
         DiskTooSmall: {
            (options?: srmService.vim.DiskTooSmall): srmService.vim.DiskTooSmall;
         };
         DomainNotFound: {
            (options?: srmService.vim.DomainNotFound): srmService.vim.DomainNotFound;
         };
         DrsDisabledOnVm: {
            (options?: srmService.vim.DrsDisabledOnVm): srmService.vim.DrsDisabledOnVm;
         };
         DrsVmotionIncompatibleFault: {
            (options?: srmService.vim.DrsVmotionIncompatibleFault): srmService.vim.DrsVmotionIncompatibleFault;
         };
         DuplicateDisks: {
            (options?: srmService.vim.DuplicateDisks): srmService.vim.DuplicateDisks;
         };
         DuplicateName: {
            (options?: srmService.vim.DuplicateName): srmService.vim.DuplicateName;
         };
         DuplicateVsanNetworkInterface: {
            (options?: srmService.vim.DuplicateVsanNetworkInterface): srmService.vim.DuplicateVsanNetworkInterface;
         };
         DvsApplyOperationFaultFaultOnObject: {
            (options?: srmService.vim.DvsApplyOperationFaultFaultOnObject): srmService.vim.DvsApplyOperationFaultFaultOnObject;
         };
         ArrayOfDvsApplyOperationFaultFaultOnObject: {
            (options?: srmService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject): srmService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject;
         };
         DvsApplyOperationFault: {
            (options?: srmService.vim.DvsApplyOperationFault): srmService.vim.DvsApplyOperationFault;
         };
         DvsFault: {
            (options?: srmService.vim.DvsFault): srmService.vim.DvsFault;
         };
         DvsNotAuthorized: {
            (options?: srmService.vim.DvsNotAuthorized): srmService.vim.DvsNotAuthorized;
         };
         DvsOperationBulkFaultFaultOnHost: {
            (options?: srmService.vim.DvsOperationBulkFaultFaultOnHost): srmService.vim.DvsOperationBulkFaultFaultOnHost;
         };
         ArrayOfDvsOperationBulkFaultFaultOnHost: {
            (options?: srmService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost): srmService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost;
         };
         DvsOperationBulkFault: {
            (options?: srmService.vim.DvsOperationBulkFault): srmService.vim.DvsOperationBulkFault;
         };
         DvsScopeViolated: {
            (options?: srmService.vim.DvsScopeViolated): srmService.vim.DvsScopeViolated;
         };
         EVCAdmissionFailed: {
            (options?: srmService.vim.EVCAdmissionFailed): srmService.vim.EVCAdmissionFailed;
         };
         EVCAdmissionFailedCPUFeaturesForMode: {
            (options?: srmService.vim.EVCAdmissionFailedCPUFeaturesForMode): srmService.vim.EVCAdmissionFailedCPUFeaturesForMode;
         };
         EVCAdmissionFailedCPUModel: {
            (options?: srmService.vim.EVCAdmissionFailedCPUModel): srmService.vim.EVCAdmissionFailedCPUModel;
         };
         EVCAdmissionFailedCPUModelForMode: {
            (options?: srmService.vim.EVCAdmissionFailedCPUModelForMode): srmService.vim.EVCAdmissionFailedCPUModelForMode;
         };
         EVCAdmissionFailedCPUVendor: {
            (options?: srmService.vim.EVCAdmissionFailedCPUVendor): srmService.vim.EVCAdmissionFailedCPUVendor;
         };
         EVCAdmissionFailedCPUVendorUnknown: {
            (options?: srmService.vim.EVCAdmissionFailedCPUVendorUnknown): srmService.vim.EVCAdmissionFailedCPUVendorUnknown;
         };
         EVCAdmissionFailedHostDisconnected: {
            (options?: srmService.vim.EVCAdmissionFailedHostDisconnected): srmService.vim.EVCAdmissionFailedHostDisconnected;
         };
         EVCAdmissionFailedHostSoftware: {
            (options?: srmService.vim.EVCAdmissionFailedHostSoftware): srmService.vim.EVCAdmissionFailedHostSoftware;
         };
         EVCAdmissionFailedHostSoftwareForMode: {
            (options?: srmService.vim.EVCAdmissionFailedHostSoftwareForMode): srmService.vim.EVCAdmissionFailedHostSoftwareForMode;
         };
         EVCAdmissionFailedVmActive: {
            (options?: srmService.vim.EVCAdmissionFailedVmActive): srmService.vim.EVCAdmissionFailedVmActive;
         };
         EightHostLimitViolated: {
            (options?: srmService.vim.EightHostLimitViolated): srmService.vim.EightHostLimitViolated;
         };
         ExpiredAddonLicense: {
            (options?: srmService.vim.ExpiredAddonLicense): srmService.vim.ExpiredAddonLicense;
         };
         ExpiredEditionLicense: {
            (options?: srmService.vim.ExpiredEditionLicense): srmService.vim.ExpiredEditionLicense;
         };
         ExpiredFeatureLicense: {
            (options?: srmService.vim.ExpiredFeatureLicense): srmService.vim.ExpiredFeatureLicense;
         };
         ExtendedFault: {
            (options?: srmService.vim.ExtendedFault): srmService.vim.ExtendedFault;
         };
         FailToEnableSPBM: {
            (options?: srmService.vim.FailToEnableSPBM): srmService.vim.FailToEnableSPBM;
         };
         FailToLockFaultToleranceVMs: {
            (options?: srmService.vim.FailToLockFaultToleranceVMs): srmService.vim.FailToLockFaultToleranceVMs;
         };
         FaultToleranceAntiAffinityViolated: {
            (options?: srmService.vim.FaultToleranceAntiAffinityViolated): srmService.vim.FaultToleranceAntiAffinityViolated;
         };
         FaultToleranceCannotEditMem: {
            (options?: srmService.vim.FaultToleranceCannotEditMem): srmService.vim.FaultToleranceCannotEditMem;
         };
         FaultToleranceCpuIncompatible: {
            (options?: srmService.vim.FaultToleranceCpuIncompatible): srmService.vim.FaultToleranceCpuIncompatible;
         };
         FaultToleranceNeedsThickDisk: {
            (options?: srmService.vim.FaultToleranceNeedsThickDisk): srmService.vim.FaultToleranceNeedsThickDisk;
         };
         FaultToleranceNotLicensed: {
            (options?: srmService.vim.FaultToleranceNotLicensed): srmService.vim.FaultToleranceNotLicensed;
         };
         FaultToleranceNotSameBuild: {
            (options?: srmService.vim.FaultToleranceNotSameBuild): srmService.vim.FaultToleranceNotSameBuild;
         };
         FaultTolerancePrimaryPowerOnNotAttempted: {
            (options?: srmService.vim.FaultTolerancePrimaryPowerOnNotAttempted): srmService.vim.FaultTolerancePrimaryPowerOnNotAttempted;
         };
         FaultToleranceVmNotDasProtected: {
            (options?: srmService.vim.FaultToleranceVmNotDasProtected): srmService.vim.FaultToleranceVmNotDasProtected;
         };
         FcoeFault: {
            (options?: srmService.vim.FcoeFault): srmService.vim.FcoeFault;
         };
         FcoeFaultPnicHasNoPortSet: {
            (options?: srmService.vim.FcoeFaultPnicHasNoPortSet): srmService.vim.FcoeFaultPnicHasNoPortSet;
         };
         FeatureRequirementsNotMet: {
            (options?: srmService.vim.FeatureRequirementsNotMet): srmService.vim.FeatureRequirementsNotMet;
         };
         FileAlreadyExists: {
            (options?: srmService.vim.FileAlreadyExists): srmService.vim.FileAlreadyExists;
         };
         FileBackedPortNotSupported: {
            (options?: srmService.vim.FileBackedPortNotSupported): srmService.vim.FileBackedPortNotSupported;
         };
         FileFault: {
            (options?: srmService.vim.FileFault): srmService.vim.FileFault;
         };
         FileLocked: {
            (options?: srmService.vim.FileLocked): srmService.vim.FileLocked;
         };
         FileNameTooLong: {
            (options?: srmService.vim.FileNameTooLong): srmService.vim.FileNameTooLong;
         };
         FileNotFound: {
            (options?: srmService.vim.FileNotFound): srmService.vim.FileNotFound;
         };
         FileNotWritable: {
            (options?: srmService.vim.FileNotWritable): srmService.vim.FileNotWritable;
         };
         FileTooLarge: {
            (options?: srmService.vim.FileTooLarge): srmService.vim.FileTooLarge;
         };
         FilesystemQuiesceFault: {
            (options?: srmService.vim.FilesystemQuiesceFault): srmService.vim.FilesystemQuiesceFault;
         };
         FtIssuesOnHostHostSelectionType: {
            "user": string;
            "vc": string;
            "drs": string;
         };
         FtIssuesOnHost: {
            (options?: srmService.vim.FtIssuesOnHost): srmService.vim.FtIssuesOnHost;
         };
         FullStorageVMotionNotSupported: {
            (options?: srmService.vim.FullStorageVMotionNotSupported): srmService.vim.FullStorageVMotionNotSupported;
         };
         GenericDrsFault: {
            (options?: srmService.vim.GenericDrsFault): srmService.vim.GenericDrsFault;
         };
         GenericVmConfigFault: {
            (options?: srmService.vim.GenericVmConfigFault): srmService.vim.GenericVmConfigFault;
         };
         GuestAuthenticationChallenge: {
            (options?: srmService.vim.GuestAuthenticationChallenge): srmService.vim.GuestAuthenticationChallenge;
         };
         GuestComponentsOutOfDate: {
            (options?: srmService.vim.GuestComponentsOutOfDate): srmService.vim.GuestComponentsOutOfDate;
         };
         GuestOperationsFault: {
            (options?: srmService.vim.GuestOperationsFault): srmService.vim.GuestOperationsFault;
         };
         GuestOperationsUnavailable: {
            (options?: srmService.vim.GuestOperationsUnavailable): srmService.vim.GuestOperationsUnavailable;
         };
         GuestPermissionDenied: {
            (options?: srmService.vim.GuestPermissionDenied): srmService.vim.GuestPermissionDenied;
         };
         GuestProcessNotFound: {
            (options?: srmService.vim.GuestProcessNotFound): srmService.vim.GuestProcessNotFound;
         };
         HAErrorsAtDest: {
            (options?: srmService.vim.HAErrorsAtDest): srmService.vim.HAErrorsAtDest;
         };
         HostAccessRestrictedToManagementServer: {
            (options?: srmService.vim.HostAccessRestrictedToManagementServer): srmService.vim.HostAccessRestrictedToManagementServer;
         };
         HostConfigFailed: {
            (options?: srmService.vim.HostConfigFailed): srmService.vim.HostConfigFailed;
         };
         HostConfigFault: {
            (options?: srmService.vim.HostConfigFault): srmService.vim.HostConfigFault;
         };
         HostConnectFault: {
            (options?: srmService.vim.HostConnectFault): srmService.vim.HostConnectFault;
         };
         HostInDomain: {
            (options?: srmService.vim.HostInDomain): srmService.vim.HostInDomain;
         };
         HostIncompatibleForFaultToleranceReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForFaultTolerance: {
            (options?: srmService.vim.HostIncompatibleForFaultTolerance): srmService.vim.HostIncompatibleForFaultTolerance;
         };
         HostIncompatibleForRecordReplayReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForRecordReplay: {
            (options?: srmService.vim.HostIncompatibleForRecordReplay): srmService.vim.HostIncompatibleForRecordReplay;
         };
         HostInventoryFull: {
            (options?: srmService.vim.HostInventoryFull): srmService.vim.HostInventoryFull;
         };
         HostPowerOpFailed: {
            (options?: srmService.vim.HostPowerOpFailed): srmService.vim.HostPowerOpFailed;
         };
         HotSnapshotMoveNotSupported: {
            (options?: srmService.vim.HotSnapshotMoveNotSupported): srmService.vim.HotSnapshotMoveNotSupported;
         };
         IDEDiskNotSupported: {
            (options?: srmService.vim.IDEDiskNotSupported): srmService.vim.IDEDiskNotSupported;
         };
         IORMNotSupportedHostOnDatastore: {
            (options?: srmService.vim.IORMNotSupportedHostOnDatastore): srmService.vim.IORMNotSupportedHostOnDatastore;
         };
         ImportHostAddFailure: {
            (options?: srmService.vim.ImportHostAddFailure): srmService.vim.ImportHostAddFailure;
         };
         ImportOperationBulkFaultFaultOnImport: {
            (options?: srmService.vim.ImportOperationBulkFaultFaultOnImport): srmService.vim.ImportOperationBulkFaultFaultOnImport;
         };
         ArrayOfImportOperationBulkFaultFaultOnImport: {
            (options?: srmService.vim.ArrayOfImportOperationBulkFaultFaultOnImport): srmService.vim.ArrayOfImportOperationBulkFaultFaultOnImport;
         };
         ImportOperationBulkFault: {
            (options?: srmService.vim.ImportOperationBulkFault): srmService.vim.ImportOperationBulkFault;
         };
         InUseFeatureManipulationDisallowed: {
            (options?: srmService.vim.InUseFeatureManipulationDisallowed): srmService.vim.InUseFeatureManipulationDisallowed;
         };
         InaccessibleDatastore: {
            (options?: srmService.vim.InaccessibleDatastore): srmService.vim.InaccessibleDatastore;
         };
         InaccessibleVFlashSource: {
            (options?: srmService.vim.InaccessibleVFlashSource): srmService.vim.InaccessibleVFlashSource;
         };
         IncompatibleDefaultDevice: {
            (options?: srmService.vim.IncompatibleDefaultDevice): srmService.vim.IncompatibleDefaultDevice;
         };
         IncompatibleHostForFtSecondary: {
            (options?: srmService.vim.IncompatibleHostForFtSecondary): srmService.vim.IncompatibleHostForFtSecondary;
         };
         IncompatibleSetting: {
            (options?: srmService.vim.IncompatibleSetting): srmService.vim.IncompatibleSetting;
         };
         IncorrectFileType: {
            (options?: srmService.vim.IncorrectFileType): srmService.vim.IncorrectFileType;
         };
         IncorrectHostInformation: {
            (options?: srmService.vim.IncorrectHostInformation): srmService.vim.IncorrectHostInformation;
         };
         IndependentDiskVMotionNotSupported: {
            (options?: srmService.vim.IndependentDiskVMotionNotSupported): srmService.vim.IndependentDiskVMotionNotSupported;
         };
         InsufficientAgentVmsDeployed: {
            (options?: srmService.vim.InsufficientAgentVmsDeployed): srmService.vim.InsufficientAgentVmsDeployed;
         };
         InsufficientCpuResourcesFault: {
            (options?: srmService.vim.InsufficientCpuResourcesFault): srmService.vim.InsufficientCpuResourcesFault;
         };
         InsufficientDisks: {
            (options?: srmService.vim.InsufficientDisks): srmService.vim.InsufficientDisks;
         };
         InsufficientFailoverResourcesFault: {
            (options?: srmService.vim.InsufficientFailoverResourcesFault): srmService.vim.InsufficientFailoverResourcesFault;
         };
         InsufficientHostCapacityFault: {
            (options?: srmService.vim.InsufficientHostCapacityFault): srmService.vim.InsufficientHostCapacityFault;
         };
         InsufficientHostCpuCapacityFault: {
            (options?: srmService.vim.InsufficientHostCpuCapacityFault): srmService.vim.InsufficientHostCpuCapacityFault;
         };
         InsufficientHostMemoryCapacityFault: {
            (options?: srmService.vim.InsufficientHostMemoryCapacityFault): srmService.vim.InsufficientHostMemoryCapacityFault;
         };
         InsufficientMemoryResourcesFault: {
            (options?: srmService.vim.InsufficientMemoryResourcesFault): srmService.vim.InsufficientMemoryResourcesFault;
         };
         InsufficientPerCpuCapacity: {
            (options?: srmService.vim.InsufficientPerCpuCapacity): srmService.vim.InsufficientPerCpuCapacity;
         };
         InsufficientResourcesFault: {
            (options?: srmService.vim.InsufficientResourcesFault): srmService.vim.InsufficientResourcesFault;
         };
         InsufficientStandbyCpuResource: {
            (options?: srmService.vim.InsufficientStandbyCpuResource): srmService.vim.InsufficientStandbyCpuResource;
         };
         InsufficientStandbyMemoryResource: {
            (options?: srmService.vim.InsufficientStandbyMemoryResource): srmService.vim.InsufficientStandbyMemoryResource;
         };
         InsufficientStandbyResource: {
            (options?: srmService.vim.InsufficientStandbyResource): srmService.vim.InsufficientStandbyResource;
         };
         InsufficientStorageSpace: {
            (options?: srmService.vim.InsufficientStorageSpace): srmService.vim.InsufficientStorageSpace;
         };
         InsufficientVFlashResourcesFault: {
            (options?: srmService.vim.InsufficientVFlashResourcesFault): srmService.vim.InsufficientVFlashResourcesFault;
         };
         InvalidAffinitySettingFault: {
            (options?: srmService.vim.InvalidAffinitySettingFault): srmService.vim.InvalidAffinitySettingFault;
         };
         InvalidBmcRole: {
            (options?: srmService.vim.InvalidBmcRole): srmService.vim.InvalidBmcRole;
         };
         InvalidBundle: {
            (options?: srmService.vim.InvalidBundle): srmService.vim.InvalidBundle;
         };
         InvalidCAMCertificate: {
            (options?: srmService.vim.InvalidCAMCertificate): srmService.vim.InvalidCAMCertificate;
         };
         InvalidCAMServer: {
            (options?: srmService.vim.InvalidCAMServer): srmService.vim.InvalidCAMServer;
         };
         InvalidClientCertificate: {
            (options?: srmService.vim.InvalidClientCertificate): srmService.vim.InvalidClientCertificate;
         };
         InvalidController: {
            (options?: srmService.vim.InvalidController): srmService.vim.InvalidController;
         };
         InvalidDasConfigArgumentEntryForInvalidArgument: {
            "admissionControl": string;
            "userHeartbeatDs": string;
            "vmConfig": string;
         };
         InvalidDasConfigArgument: {
            (options?: srmService.vim.InvalidDasConfigArgument): srmService.vim.InvalidDasConfigArgument;
         };
         InvalidDasRestartPriorityForFtVm: {
            (options?: srmService.vim.InvalidDasRestartPriorityForFtVm): srmService.vim.InvalidDasRestartPriorityForFtVm;
         };
         InvalidDatastore: {
            (options?: srmService.vim.InvalidDatastore): srmService.vim.InvalidDatastore;
         };
         InvalidDatastorePath: {
            (options?: srmService.vim.InvalidDatastorePath): srmService.vim.InvalidDatastorePath;
         };
         InvalidDatastoreState: {
            (options?: srmService.vim.InvalidDatastoreState): srmService.vim.InvalidDatastoreState;
         };
         InvalidDeviceBacking: {
            (options?: srmService.vim.InvalidDeviceBacking): srmService.vim.InvalidDeviceBacking;
         };
         InvalidDeviceOperation: {
            (options?: srmService.vim.InvalidDeviceOperation): srmService.vim.InvalidDeviceOperation;
         };
         InvalidDeviceSpec: {
            (options?: srmService.vim.InvalidDeviceSpec): srmService.vim.InvalidDeviceSpec;
         };
         InvalidDiskFormat: {
            (options?: srmService.vim.InvalidDiskFormat): srmService.vim.InvalidDiskFormat;
         };
         InvalidDrsBehaviorForFtVm: {
            (options?: srmService.vim.InvalidDrsBehaviorForFtVm): srmService.vim.InvalidDrsBehaviorForFtVm;
         };
         InvalidEditionLicense: {
            (options?: srmService.vim.InvalidEditionLicense): srmService.vim.InvalidEditionLicense;
         };
         InvalidEvent: {
            (options?: srmService.vim.InvalidEvent): srmService.vim.InvalidEvent;
         };
         InvalidFolder: {
            (options?: srmService.vim.InvalidFolder): srmService.vim.InvalidFolder;
         };
         InvalidFormat: {
            (options?: srmService.vim.InvalidFormat): srmService.vim.InvalidFormat;
         };
         InvalidGuestLogin: {
            (options?: srmService.vim.InvalidGuestLogin): srmService.vim.InvalidGuestLogin;
         };
         InvalidHostConnectionState: {
            (options?: srmService.vim.InvalidHostConnectionState): srmService.vim.InvalidHostConnectionState;
         };
         InvalidHostName: {
            (options?: srmService.vim.InvalidHostName): srmService.vim.InvalidHostName;
         };
         InvalidHostState: {
            (options?: srmService.vim.InvalidHostState): srmService.vim.InvalidHostState;
         };
         InvalidIndexArgument: {
            (options?: srmService.vim.InvalidIndexArgument): srmService.vim.InvalidIndexArgument;
         };
         InvalidIpfixConfig: {
            (options?: srmService.vim.InvalidIpfixConfig): srmService.vim.InvalidIpfixConfig;
         };
         InvalidIpmiLoginInfo: {
            (options?: srmService.vim.InvalidIpmiLoginInfo): srmService.vim.InvalidIpmiLoginInfo;
         };
         InvalidIpmiMacAddress: {
            (options?: srmService.vim.InvalidIpmiMacAddress): srmService.vim.InvalidIpmiMacAddress;
         };
         InvalidLicense: {
            (options?: srmService.vim.InvalidLicense): srmService.vim.InvalidLicense;
         };
         InvalidLocale: {
            (options?: srmService.vim.InvalidLocale): srmService.vim.InvalidLocale;
         };
         InvalidLogin: {
            (options?: srmService.vim.InvalidLogin): srmService.vim.InvalidLogin;
         };
         InvalidName: {
            (options?: srmService.vim.InvalidName): srmService.vim.InvalidName;
         };
         InvalidNasCredentials: {
            (options?: srmService.vim.InvalidNasCredentials): srmService.vim.InvalidNasCredentials;
         };
         InvalidNetworkInType: {
            (options?: srmService.vim.InvalidNetworkInType): srmService.vim.InvalidNetworkInType;
         };
         InvalidNetworkResource: {
            (options?: srmService.vim.InvalidNetworkResource): srmService.vim.InvalidNetworkResource;
         };
         InvalidOperationOnSecondaryVm: {
            (options?: srmService.vim.InvalidOperationOnSecondaryVm): srmService.vim.InvalidOperationOnSecondaryVm;
         };
         InvalidPowerState: {
            (options?: srmService.vim.InvalidPowerState): srmService.vim.InvalidPowerState;
         };
         InvalidPrivilege: {
            (options?: srmService.vim.InvalidPrivilege): srmService.vim.InvalidPrivilege;
         };
         InvalidProfileReferenceHostReason: {
            "incompatibleVersion": string;
            "missingReferenceHost": string;
         };
         InvalidProfileReferenceHost: {
            (options?: srmService.vim.InvalidProfileReferenceHost): srmService.vim.InvalidProfileReferenceHost;
         };
         InvalidPropertyType: {
            (options?: srmService.vim.InvalidPropertyType): srmService.vim.InvalidPropertyType;
         };
         InvalidPropertyValue: {
            (options?: srmService.vim.InvalidPropertyValue): srmService.vim.InvalidPropertyValue;
         };
         InvalidResourcePoolStructureFault: {
            (options?: srmService.vim.InvalidResourcePoolStructureFault): srmService.vim.InvalidResourcePoolStructureFault;
         };
         InvalidSnapshotFormat: {
            (options?: srmService.vim.InvalidSnapshotFormat): srmService.vim.InvalidSnapshotFormat;
         };
         InvalidState: {
            (options?: srmService.vim.InvalidState): srmService.vim.InvalidState;
         };
         InvalidVmConfig: {
            (options?: srmService.vim.InvalidVmConfig): srmService.vim.InvalidVmConfig;
         };
         InventoryHasStandardAloneHosts: {
            (options?: srmService.vim.InventoryHasStandardAloneHosts): srmService.vim.InventoryHasStandardAloneHosts;
         };
         IpHostnameGeneratorError: {
            (options?: srmService.vim.IpHostnameGeneratorError): srmService.vim.IpHostnameGeneratorError;
         };
         IscsiFault: {
            (options?: srmService.vim.IscsiFault): srmService.vim.IscsiFault;
         };
         IscsiFaultInvalidVnic: {
            (options?: srmService.vim.IscsiFaultInvalidVnic): srmService.vim.IscsiFaultInvalidVnic;
         };
         IscsiFaultPnicInUse: {
            (options?: srmService.vim.IscsiFaultPnicInUse): srmService.vim.IscsiFaultPnicInUse;
         };
         IscsiFaultVnicAlreadyBound: {
            (options?: srmService.vim.IscsiFaultVnicAlreadyBound): srmService.vim.IscsiFaultVnicAlreadyBound;
         };
         IscsiFaultVnicHasActivePaths: {
            (options?: srmService.vim.IscsiFaultVnicHasActivePaths): srmService.vim.IscsiFaultVnicHasActivePaths;
         };
         IscsiFaultVnicHasMultipleUplinks: {
            (options?: srmService.vim.IscsiFaultVnicHasMultipleUplinks): srmService.vim.IscsiFaultVnicHasMultipleUplinks;
         };
         IscsiFaultVnicHasNoUplinks: {
            (options?: srmService.vim.IscsiFaultVnicHasNoUplinks): srmService.vim.IscsiFaultVnicHasNoUplinks;
         };
         IscsiFaultVnicHasWrongUplink: {
            (options?: srmService.vim.IscsiFaultVnicHasWrongUplink): srmService.vim.IscsiFaultVnicHasWrongUplink;
         };
         IscsiFaultVnicInUse: {
            (options?: srmService.vim.IscsiFaultVnicInUse): srmService.vim.IscsiFaultVnicInUse;
         };
         IscsiFaultVnicIsLastPath: {
            (options?: srmService.vim.IscsiFaultVnicIsLastPath): srmService.vim.IscsiFaultVnicIsLastPath;
         };
         IscsiFaultVnicNotBound: {
            (options?: srmService.vim.IscsiFaultVnicNotBound): srmService.vim.IscsiFaultVnicNotBound;
         };
         IscsiFaultVnicNotFound: {
            (options?: srmService.vim.IscsiFaultVnicNotFound): srmService.vim.IscsiFaultVnicNotFound;
         };
         LargeRDMConversionNotSupported: {
            (options?: srmService.vim.LargeRDMConversionNotSupported): srmService.vim.LargeRDMConversionNotSupported;
         };
         LargeRDMNotSupportedOnDatastore: {
            (options?: srmService.vim.LargeRDMNotSupportedOnDatastore): srmService.vim.LargeRDMNotSupportedOnDatastore;
         };
         LegacyNetworkInterfaceInUse: {
            (options?: srmService.vim.LegacyNetworkInterfaceInUse): srmService.vim.LegacyNetworkInterfaceInUse;
         };
         LicenseAssignmentFailedReason: {
            "keyEntityMismatch": string;
            "downgradeDisallowed": string;
            "inventoryNotManageableByVirtualCenter": string;
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer": string;
         };
         LicenseAssignmentFailed: {
            (options?: srmService.vim.LicenseAssignmentFailed): srmService.vim.LicenseAssignmentFailed;
         };
         LicenseDowngradeDisallowed: {
            (options?: srmService.vim.LicenseDowngradeDisallowed): srmService.vim.LicenseDowngradeDisallowed;
         };
         LicenseEntityNotFound: {
            (options?: srmService.vim.LicenseEntityNotFound): srmService.vim.LicenseEntityNotFound;
         };
         LicenseExpired: {
            (options?: srmService.vim.LicenseExpired): srmService.vim.LicenseExpired;
         };
         LicenseKeyEntityMismatch: {
            (options?: srmService.vim.LicenseKeyEntityMismatch): srmService.vim.LicenseKeyEntityMismatch;
         };
         LicenseRestricted: {
            (options?: srmService.vim.LicenseRestricted): srmService.vim.LicenseRestricted;
         };
         LicenseServerUnavailable: {
            (options?: srmService.vim.LicenseServerUnavailable): srmService.vim.LicenseServerUnavailable;
         };
         LicenseSourceUnavailable: {
            (options?: srmService.vim.LicenseSourceUnavailable): srmService.vim.LicenseSourceUnavailable;
         };
         LimitExceeded: {
            (options?: srmService.vim.LimitExceeded): srmService.vim.LimitExceeded;
         };
         LinuxVolumeNotClean: {
            (options?: srmService.vim.LinuxVolumeNotClean): srmService.vim.LinuxVolumeNotClean;
         };
         LogBundlingFailed: {
            (options?: srmService.vim.LogBundlingFailed): srmService.vim.LogBundlingFailed;
         };
         MaintenanceModeFileMove: {
            (options?: srmService.vim.MaintenanceModeFileMove): srmService.vim.MaintenanceModeFileMove;
         };
         MemoryHotPlugNotSupported: {
            (options?: srmService.vim.MemoryHotPlugNotSupported): srmService.vim.MemoryHotPlugNotSupported;
         };
         MemorySizeNotRecommended: {
            (options?: srmService.vim.MemorySizeNotRecommended): srmService.vim.MemorySizeNotRecommended;
         };
         MemorySizeNotSupported: {
            (options?: srmService.vim.MemorySizeNotSupported): srmService.vim.MemorySizeNotSupported;
         };
         MemorySizeNotSupportedByDatastore: {
            (options?: srmService.vim.MemorySizeNotSupportedByDatastore): srmService.vim.MemorySizeNotSupportedByDatastore;
         };
         MemorySnapshotOnIndependentDisk: {
            (options?: srmService.vim.MemorySnapshotOnIndependentDisk): srmService.vim.MemorySnapshotOnIndependentDisk;
         };
         MethodAlreadyDisabledFault: {
            (options?: srmService.vim.MethodAlreadyDisabledFault): srmService.vim.MethodAlreadyDisabledFault;
         };
         MethodDisabled: {
            (options?: srmService.vim.MethodDisabled): srmService.vim.MethodDisabled;
         };
         MigrationDisabled: {
            (options?: srmService.vim.MigrationDisabled): srmService.vim.MigrationDisabled;
         };
         MigrationFault: {
            (options?: srmService.vim.MigrationFault): srmService.vim.MigrationFault;
         };
         MigrationFeatureNotSupported: {
            (options?: srmService.vim.MigrationFeatureNotSupported): srmService.vim.MigrationFeatureNotSupported;
         };
         MigrationNotReady: {
            (options?: srmService.vim.MigrationNotReady): srmService.vim.MigrationNotReady;
         };
         MismatchedBundle: {
            (options?: srmService.vim.MismatchedBundle): srmService.vim.MismatchedBundle;
         };
         MismatchedNetworkPolicies: {
            (options?: srmService.vim.MismatchedNetworkPolicies): srmService.vim.MismatchedNetworkPolicies;
         };
         MismatchedVMotionNetworkNames: {
            (options?: srmService.vim.MismatchedVMotionNetworkNames): srmService.vim.MismatchedVMotionNetworkNames;
         };
         MissingBmcSupport: {
            (options?: srmService.vim.MissingBmcSupport): srmService.vim.MissingBmcSupport;
         };
         MissingController: {
            (options?: srmService.vim.MissingController): srmService.vim.MissingController;
         };
         MissingIpPool: {
            (options?: srmService.vim.MissingIpPool): srmService.vim.MissingIpPool;
         };
         MissingLinuxCustResources: {
            (options?: srmService.vim.MissingLinuxCustResources): srmService.vim.MissingLinuxCustResources;
         };
         MissingNetworkIpConfig: {
            (options?: srmService.vim.MissingNetworkIpConfig): srmService.vim.MissingNetworkIpConfig;
         };
         MissingPowerOffConfiguration: {
            (options?: srmService.vim.MissingPowerOffConfiguration): srmService.vim.MissingPowerOffConfiguration;
         };
         MissingPowerOnConfiguration: {
            (options?: srmService.vim.MissingPowerOnConfiguration): srmService.vim.MissingPowerOnConfiguration;
         };
         MissingWindowsCustResources: {
            (options?: srmService.vim.MissingWindowsCustResources): srmService.vim.MissingWindowsCustResources;
         };
         MksConnectionLimitReached: {
            (options?: srmService.vim.MksConnectionLimitReached): srmService.vim.MksConnectionLimitReached;
         };
         MountError: {
            (options?: srmService.vim.MountError): srmService.vim.MountError;
         };
         MultipleCertificatesVerifyFaultThumbprintData: {
            (options?: srmService.vim.MultipleCertificatesVerifyFaultThumbprintData): srmService.vim.MultipleCertificatesVerifyFaultThumbprintData;
         };
         ArrayOfMultipleCertificatesVerifyFaultThumbprintData: {
            (options?: srmService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData): srmService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData;
         };
         MultipleCertificatesVerifyFault: {
            (options?: srmService.vim.MultipleCertificatesVerifyFault): srmService.vim.MultipleCertificatesVerifyFault;
         };
         MultipleSnapshotsNotSupported: {
            (options?: srmService.vim.MultipleSnapshotsNotSupported): srmService.vim.MultipleSnapshotsNotSupported;
         };
         NamespaceFull: {
            (options?: srmService.vim.NamespaceFull): srmService.vim.NamespaceFull;
         };
         NamespaceLimitReached: {
            (options?: srmService.vim.NamespaceLimitReached): srmService.vim.NamespaceLimitReached;
         };
         NamespaceWriteProtected: {
            (options?: srmService.vim.NamespaceWriteProtected): srmService.vim.NamespaceWriteProtected;
         };
         NasConfigFault: {
            (options?: srmService.vim.NasConfigFault): srmService.vim.NasConfigFault;
         };
         NasConnectionLimitReached: {
            (options?: srmService.vim.NasConnectionLimitReached): srmService.vim.NasConnectionLimitReached;
         };
         NasSessionCredentialConflict: {
            (options?: srmService.vim.NasSessionCredentialConflict): srmService.vim.NasSessionCredentialConflict;
         };
         NasVolumeNotMounted: {
            (options?: srmService.vim.NasVolumeNotMounted): srmService.vim.NasVolumeNotMounted;
         };
         NetworkCopyFault: {
            (options?: srmService.vim.NetworkCopyFault): srmService.vim.NetworkCopyFault;
         };
         NetworkDisruptedAndConfigRolledBack: {
            (options?: srmService.vim.NetworkDisruptedAndConfigRolledBack): srmService.vim.NetworkDisruptedAndConfigRolledBack;
         };
         NetworkInaccessible: {
            (options?: srmService.vim.NetworkInaccessible): srmService.vim.NetworkInaccessible;
         };
         NetworksMayNotBeTheSame: {
            (options?: srmService.vim.NetworksMayNotBeTheSame): srmService.vim.NetworksMayNotBeTheSame;
         };
         NicSettingMismatch: {
            (options?: srmService.vim.NicSettingMismatch): srmService.vim.NicSettingMismatch;
         };
         NoActiveHostInCluster: {
            (options?: srmService.vim.NoActiveHostInCluster): srmService.vim.NoActiveHostInCluster;
         };
         NoAvailableIp: {
            (options?: srmService.vim.NoAvailableIp): srmService.vim.NoAvailableIp;
         };
         NoClientCertificate: {
            (options?: srmService.vim.NoClientCertificate): srmService.vim.NoClientCertificate;
         };
         NoCompatibleDatastore: {
            (options?: srmService.vim.NoCompatibleDatastore): srmService.vim.NoCompatibleDatastore;
         };
         NoCompatibleHardAffinityHost: {
            (options?: srmService.vim.NoCompatibleHardAffinityHost): srmService.vim.NoCompatibleHardAffinityHost;
         };
         NoCompatibleHost: {
            (options?: srmService.vim.NoCompatibleHost): srmService.vim.NoCompatibleHost;
         };
         NoCompatibleHostWithAccessToDevice: {
            (options?: srmService.vim.NoCompatibleHostWithAccessToDevice): srmService.vim.NoCompatibleHostWithAccessToDevice;
         };
         NoCompatibleSoftAffinityHost: {
            (options?: srmService.vim.NoCompatibleSoftAffinityHost): srmService.vim.NoCompatibleSoftAffinityHost;
         };
         NoConnectedDatastore: {
            (options?: srmService.vim.NoConnectedDatastore): srmService.vim.NoConnectedDatastore;
         };
         NoDiskFound: {
            (options?: srmService.vim.NoDiskFound): srmService.vim.NoDiskFound;
         };
         NoDiskSpace: {
            (options?: srmService.vim.NoDiskSpace): srmService.vim.NoDiskSpace;
         };
         NoDisksToCustomize: {
            (options?: srmService.vim.NoDisksToCustomize): srmService.vim.NoDisksToCustomize;
         };
         NoGateway: {
            (options?: srmService.vim.NoGateway): srmService.vim.NoGateway;
         };
         NoGuestHeartbeat: {
            (options?: srmService.vim.NoGuestHeartbeat): srmService.vim.NoGuestHeartbeat;
         };
         NoHost: {
            (options?: srmService.vim.NoHost): srmService.vim.NoHost;
         };
         NoHostSuitableForFtSecondary: {
            (options?: srmService.vim.NoHostSuitableForFtSecondary): srmService.vim.NoHostSuitableForFtSecondary;
         };
         NoLicenseServerConfigured: {
            (options?: srmService.vim.NoLicenseServerConfigured): srmService.vim.NoLicenseServerConfigured;
         };
         NoPeerHostFound: {
            (options?: srmService.vim.NoPeerHostFound): srmService.vim.NoPeerHostFound;
         };
         NoPermission: {
            (options?: srmService.vim.NoPermission): srmService.vim.NoPermission;
         };
         NoPermissionOnAD: {
            (options?: srmService.vim.NoPermissionOnAD): srmService.vim.NoPermissionOnAD;
         };
         NoPermissionOnHost: {
            (options?: srmService.vim.NoPermissionOnHost): srmService.vim.NoPermissionOnHost;
         };
         NoPermissionOnNasVolume: {
            (options?: srmService.vim.NoPermissionOnNasVolume): srmService.vim.NoPermissionOnNasVolume;
         };
         NoSubjectName: {
            (options?: srmService.vim.NoSubjectName): srmService.vim.NoSubjectName;
         };
         NoVcManagedIpConfigured: {
            (options?: srmService.vim.NoVcManagedIpConfigured): srmService.vim.NoVcManagedIpConfigured;
         };
         NoVirtualNic: {
            (options?: srmService.vim.NoVirtualNic): srmService.vim.NoVirtualNic;
         };
         NoVmInVApp: {
            (options?: srmService.vim.NoVmInVApp): srmService.vim.NoVmInVApp;
         };
         NonADUserRequired: {
            (options?: srmService.vim.NonADUserRequired): srmService.vim.NonADUserRequired;
         };
         NonHomeRDMVMotionNotSupported: {
            (options?: srmService.vim.NonHomeRDMVMotionNotSupported): srmService.vim.NonHomeRDMVMotionNotSupported;
         };
         NonPersistentDisksNotSupported: {
            (options?: srmService.vim.NonPersistentDisksNotSupported): srmService.vim.NonPersistentDisksNotSupported;
         };
         NonVmwareOuiMacNotSupportedHost: {
            (options?: srmService.vim.NonVmwareOuiMacNotSupportedHost): srmService.vim.NonVmwareOuiMacNotSupportedHost;
         };
         NotADirectory: {
            (options?: srmService.vim.NotADirectory): srmService.vim.NotADirectory;
         };
         NotAFile: {
            (options?: srmService.vim.NotAFile): srmService.vim.NotAFile;
         };
         NotAuthenticated: {
            (options?: srmService.vim.NotAuthenticated): srmService.vim.NotAuthenticated;
         };
         NotEnoughCpus: {
            (options?: srmService.vim.NotEnoughCpus): srmService.vim.NotEnoughCpus;
         };
         NotEnoughLogicalCpus: {
            (options?: srmService.vim.NotEnoughLogicalCpus): srmService.vim.NotEnoughLogicalCpus;
         };
         NotFound: {
            (options?: srmService.vim.NotFound): srmService.vim.NotFound;
         };
         NotSupportedDeviceForFTDeviceType: {
            "virtualVmxnet3": string;
            "paraVirtualSCSIController": string;
         };
         NotSupportedDeviceForFT: {
            (options?: srmService.vim.NotSupportedDeviceForFT): srmService.vim.NotSupportedDeviceForFT;
         };
         NotSupportedHost: {
            (options?: srmService.vim.NotSupportedHost): srmService.vim.NotSupportedHost;
         };
         NotSupportedHostForVFlash: {
            (options?: srmService.vim.NotSupportedHostForVFlash): srmService.vim.NotSupportedHostForVFlash;
         };
         NotSupportedHostForVsan: {
            (options?: srmService.vim.NotSupportedHostForVsan): srmService.vim.NotSupportedHostForVsan;
         };
         NotSupportedHostInCluster: {
            (options?: srmService.vim.NotSupportedHostInCluster): srmService.vim.NotSupportedHostInCluster;
         };
         NotSupportedHostInDvs: {
            (options?: srmService.vim.NotSupportedHostInDvs): srmService.vim.NotSupportedHostInDvs;
         };
         NotSupportedHostInHACluster: {
            (options?: srmService.vim.NotSupportedHostInHACluster): srmService.vim.NotSupportedHostInHACluster;
         };
         NotUserConfigurableProperty: {
            (options?: srmService.vim.NotUserConfigurableProperty): srmService.vim.NotUserConfigurableProperty;
         };
         NumVirtualCoresPerSocketNotSupported: {
            (options?: srmService.vim.NumVirtualCoresPerSocketNotSupported): srmService.vim.NumVirtualCoresPerSocketNotSupported;
         };
         NumVirtualCpusExceedsLimit: {
            (options?: srmService.vim.NumVirtualCpusExceedsLimit): srmService.vim.NumVirtualCpusExceedsLimit;
         };
         NumVirtualCpusIncompatibleReason: {
            "recordReplay": string;
            "faultTolerance": string;
         };
         NumVirtualCpusIncompatible: {
            (options?: srmService.vim.NumVirtualCpusIncompatible): srmService.vim.NumVirtualCpusIncompatible;
         };
         NumVirtualCpusNotSupported: {
            (options?: srmService.vim.NumVirtualCpusNotSupported): srmService.vim.NumVirtualCpusNotSupported;
         };
         OperationDisabledByGuest: {
            (options?: srmService.vim.OperationDisabledByGuest): srmService.vim.OperationDisabledByGuest;
         };
         OperationDisallowedOnHost: {
            (options?: srmService.vim.OperationDisallowedOnHost): srmService.vim.OperationDisallowedOnHost;
         };
         OperationNotSupportedByGuest: {
            (options?: srmService.vim.OperationNotSupportedByGuest): srmService.vim.OperationNotSupportedByGuest;
         };
         OutOfBounds: {
            (options?: srmService.vim.OutOfBounds): srmService.vim.OutOfBounds;
         };
         OvfAttribute: {
            (options?: srmService.vim.OvfAttribute): srmService.vim.OvfAttribute;
         };
         OvfConnectedDevice: {
            (options?: srmService.vim.OvfConnectedDevice): srmService.vim.OvfConnectedDevice;
         };
         OvfConnectedDeviceFloppy: {
            (options?: srmService.vim.OvfConnectedDeviceFloppy): srmService.vim.OvfConnectedDeviceFloppy;
         };
         OvfConnectedDeviceIso: {
            (options?: srmService.vim.OvfConnectedDeviceIso): srmService.vim.OvfConnectedDeviceIso;
         };
         OvfConstraint: {
            (options?: srmService.vim.OvfConstraint): srmService.vim.OvfConstraint;
         };
         OvfConsumerCallbackFault: {
            (options?: srmService.vim.OvfConsumerCallbackFault): srmService.vim.OvfConsumerCallbackFault;
         };
         OvfConsumerCommunicationError: {
            (options?: srmService.vim.OvfConsumerCommunicationError): srmService.vim.OvfConsumerCommunicationError;
         };
         OvfConsumerFault: {
            (options?: srmService.vim.OvfConsumerFault): srmService.vim.OvfConsumerFault;
         };
         OvfConsumerInvalidSection: {
            (options?: srmService.vim.OvfConsumerInvalidSection): srmService.vim.OvfConsumerInvalidSection;
         };
         OvfConsumerPowerOnFault: {
            (options?: srmService.vim.OvfConsumerPowerOnFault): srmService.vim.OvfConsumerPowerOnFault;
         };
         OvfConsumerUndeclaredSection: {
            (options?: srmService.vim.OvfConsumerUndeclaredSection): srmService.vim.OvfConsumerUndeclaredSection;
         };
         OvfConsumerUndefinedPrefix: {
            (options?: srmService.vim.OvfConsumerUndefinedPrefix): srmService.vim.OvfConsumerUndefinedPrefix;
         };
         OvfConsumerValidationFault: {
            (options?: srmService.vim.OvfConsumerValidationFault): srmService.vim.OvfConsumerValidationFault;
         };
         OvfCpuCompatibility: {
            (options?: srmService.vim.OvfCpuCompatibility): srmService.vim.OvfCpuCompatibility;
         };
         OvfCpuCompatibilityCheckNotSupported: {
            (options?: srmService.vim.OvfCpuCompatibilityCheckNotSupported): srmService.vim.OvfCpuCompatibilityCheckNotSupported;
         };
         OvfDiskMappingNotFound: {
            (options?: srmService.vim.OvfDiskMappingNotFound): srmService.vim.OvfDiskMappingNotFound;
         };
         OvfDiskOrderConstraint: {
            (options?: srmService.vim.OvfDiskOrderConstraint): srmService.vim.OvfDiskOrderConstraint;
         };
         OvfDuplicateElement: {
            (options?: srmService.vim.OvfDuplicateElement): srmService.vim.OvfDuplicateElement;
         };
         OvfDuplicatedElementBoundary: {
            (options?: srmService.vim.OvfDuplicatedElementBoundary): srmService.vim.OvfDuplicatedElementBoundary;
         };
         OvfDuplicatedPropertyIdExport: {
            (options?: srmService.vim.OvfDuplicatedPropertyIdExport): srmService.vim.OvfDuplicatedPropertyIdExport;
         };
         OvfDuplicatedPropertyIdImport: {
            (options?: srmService.vim.OvfDuplicatedPropertyIdImport): srmService.vim.OvfDuplicatedPropertyIdImport;
         };
         OvfElement: {
            (options?: srmService.vim.OvfElement): srmService.vim.OvfElement;
         };
         OvfElementInvalidValue: {
            (options?: srmService.vim.OvfElementInvalidValue): srmService.vim.OvfElementInvalidValue;
         };
         OvfExport: {
            (options?: srmService.vim.OvfExport): srmService.vim.OvfExport;
         };
         OvfExportFailed: {
            (options?: srmService.vim.OvfExportFailed): srmService.vim.OvfExportFailed;
         };
         OvfFault: {
            (options?: srmService.vim.OvfFault): srmService.vim.OvfFault;
         };
         OvfHardwareCheck: {
            (options?: srmService.vim.OvfHardwareCheck): srmService.vim.OvfHardwareCheck;
         };
         OvfHardwareExport: {
            (options?: srmService.vim.OvfHardwareExport): srmService.vim.OvfHardwareExport;
         };
         OvfHostResourceConstraint: {
            (options?: srmService.vim.OvfHostResourceConstraint): srmService.vim.OvfHostResourceConstraint;
         };
         OvfHostValueNotParsed: {
            (options?: srmService.vim.OvfHostValueNotParsed): srmService.vim.OvfHostValueNotParsed;
         };
         OvfImport: {
            (options?: srmService.vim.OvfImport): srmService.vim.OvfImport;
         };
         OvfImportFailed: {
            (options?: srmService.vim.OvfImportFailed): srmService.vim.OvfImportFailed;
         };
         OvfInternalError: {
            (options?: srmService.vim.OvfInternalError): srmService.vim.OvfInternalError;
         };
         OvfInvalidPackage: {
            (options?: srmService.vim.OvfInvalidPackage): srmService.vim.OvfInvalidPackage;
         };
         OvfInvalidValue: {
            (options?: srmService.vim.OvfInvalidValue): srmService.vim.OvfInvalidValue;
         };
         OvfInvalidValueConfiguration: {
            (options?: srmService.vim.OvfInvalidValueConfiguration): srmService.vim.OvfInvalidValueConfiguration;
         };
         OvfInvalidValueEmpty: {
            (options?: srmService.vim.OvfInvalidValueEmpty): srmService.vim.OvfInvalidValueEmpty;
         };
         OvfInvalidValueFormatMalformed: {
            (options?: srmService.vim.OvfInvalidValueFormatMalformed): srmService.vim.OvfInvalidValueFormatMalformed;
         };
         OvfInvalidValueReference: {
            (options?: srmService.vim.OvfInvalidValueReference): srmService.vim.OvfInvalidValueReference;
         };
         OvfInvalidVmName: {
            (options?: srmService.vim.OvfInvalidVmName): srmService.vim.OvfInvalidVmName;
         };
         OvfMappedOsId: {
            (options?: srmService.vim.OvfMappedOsId): srmService.vim.OvfMappedOsId;
         };
         OvfMissingAttribute: {
            (options?: srmService.vim.OvfMissingAttribute): srmService.vim.OvfMissingAttribute;
         };
         OvfMissingElement: {
            (options?: srmService.vim.OvfMissingElement): srmService.vim.OvfMissingElement;
         };
         OvfMissingElementNormalBoundary: {
            (options?: srmService.vim.OvfMissingElementNormalBoundary): srmService.vim.OvfMissingElementNormalBoundary;
         };
         OvfMissingHardware: {
            (options?: srmService.vim.OvfMissingHardware): srmService.vim.OvfMissingHardware;
         };
         OvfNetworkMappingNotSupported: {
            (options?: srmService.vim.OvfNetworkMappingNotSupported): srmService.vim.OvfNetworkMappingNotSupported;
         };
         OvfNoHostNic: {
            (options?: srmService.vim.OvfNoHostNic): srmService.vim.OvfNoHostNic;
         };
         OvfNoSpaceOnController: {
            (options?: srmService.vim.OvfNoSpaceOnController): srmService.vim.OvfNoSpaceOnController;
         };
         OvfNoSupportedHardwareFamily: {
            (options?: srmService.vim.OvfNoSupportedHardwareFamily): srmService.vim.OvfNoSupportedHardwareFamily;
         };
         OvfProperty: {
            (options?: srmService.vim.OvfProperty): srmService.vim.OvfProperty;
         };
         OvfPropertyExport: {
            (options?: srmService.vim.OvfPropertyExport): srmService.vim.OvfPropertyExport;
         };
         OvfPropertyNetwork: {
            (options?: srmService.vim.OvfPropertyNetwork): srmService.vim.OvfPropertyNetwork;
         };
         OvfPropertyNetworkExport: {
            (options?: srmService.vim.OvfPropertyNetworkExport): srmService.vim.OvfPropertyNetworkExport;
         };
         OvfPropertyQualifier: {
            (options?: srmService.vim.OvfPropertyQualifier): srmService.vim.OvfPropertyQualifier;
         };
         OvfPropertyQualifierDuplicate: {
            (options?: srmService.vim.OvfPropertyQualifierDuplicate): srmService.vim.OvfPropertyQualifierDuplicate;
         };
         OvfPropertyQualifierIgnored: {
            (options?: srmService.vim.OvfPropertyQualifierIgnored): srmService.vim.OvfPropertyQualifierIgnored;
         };
         OvfPropertyType: {
            (options?: srmService.vim.OvfPropertyType): srmService.vim.OvfPropertyType;
         };
         OvfPropertyValue: {
            (options?: srmService.vim.OvfPropertyValue): srmService.vim.OvfPropertyValue;
         };
         OvfSystemFault: {
            (options?: srmService.vim.OvfSystemFault): srmService.vim.OvfSystemFault;
         };
         OvfToXmlUnsupportedElement: {
            (options?: srmService.vim.OvfToXmlUnsupportedElement): srmService.vim.OvfToXmlUnsupportedElement;
         };
         OvfUnableToExportDisk: {
            (options?: srmService.vim.OvfUnableToExportDisk): srmService.vim.OvfUnableToExportDisk;
         };
         OvfUnexpectedElement: {
            (options?: srmService.vim.OvfUnexpectedElement): srmService.vim.OvfUnexpectedElement;
         };
         OvfUnknownDevice: {
            (options?: srmService.vim.OvfUnknownDevice): srmService.vim.OvfUnknownDevice;
         };
         OvfUnknownDeviceBacking: {
            (options?: srmService.vim.OvfUnknownDeviceBacking): srmService.vim.OvfUnknownDeviceBacking;
         };
         OvfUnknownEntity: {
            (options?: srmService.vim.OvfUnknownEntity): srmService.vim.OvfUnknownEntity;
         };
         OvfUnsupportedAttribute: {
            (options?: srmService.vim.OvfUnsupportedAttribute): srmService.vim.OvfUnsupportedAttribute;
         };
         OvfUnsupportedAttributeValue: {
            (options?: srmService.vim.OvfUnsupportedAttributeValue): srmService.vim.OvfUnsupportedAttributeValue;
         };
         OvfUnsupportedDeviceBackingInfo: {
            (options?: srmService.vim.OvfUnsupportedDeviceBackingInfo): srmService.vim.OvfUnsupportedDeviceBackingInfo;
         };
         OvfUnsupportedDeviceBackingOption: {
            (options?: srmService.vim.OvfUnsupportedDeviceBackingOption): srmService.vim.OvfUnsupportedDeviceBackingOption;
         };
         OvfUnsupportedDeviceExport: {
            (options?: srmService.vim.OvfUnsupportedDeviceExport): srmService.vim.OvfUnsupportedDeviceExport;
         };
         OvfUnsupportedDiskProvisioning: {
            (options?: srmService.vim.OvfUnsupportedDiskProvisioning): srmService.vim.OvfUnsupportedDiskProvisioning;
         };
         OvfUnsupportedElement: {
            (options?: srmService.vim.OvfUnsupportedElement): srmService.vim.OvfUnsupportedElement;
         };
         OvfUnsupportedElementValue: {
            (options?: srmService.vim.OvfUnsupportedElementValue): srmService.vim.OvfUnsupportedElementValue;
         };
         OvfUnsupportedPackage: {
            (options?: srmService.vim.OvfUnsupportedPackage): srmService.vim.OvfUnsupportedPackage;
         };
         OvfUnsupportedSection: {
            (options?: srmService.vim.OvfUnsupportedSection): srmService.vim.OvfUnsupportedSection;
         };
         OvfUnsupportedSubType: {
            (options?: srmService.vim.OvfUnsupportedSubType): srmService.vim.OvfUnsupportedSubType;
         };
         OvfUnsupportedType: {
            (options?: srmService.vim.OvfUnsupportedType): srmService.vim.OvfUnsupportedType;
         };
         OvfWrongElement: {
            (options?: srmService.vim.OvfWrongElement): srmService.vim.OvfWrongElement;
         };
         OvfWrongNamespace: {
            (options?: srmService.vim.OvfWrongNamespace): srmService.vim.OvfWrongNamespace;
         };
         OvfXmlFormat: {
            (options?: srmService.vim.OvfXmlFormat): srmService.vim.OvfXmlFormat;
         };
         PatchAlreadyInstalled: {
            (options?: srmService.vim.PatchAlreadyInstalled): srmService.vim.PatchAlreadyInstalled;
         };
         PatchBinariesNotFound: {
            (options?: srmService.vim.PatchBinariesNotFound): srmService.vim.PatchBinariesNotFound;
         };
         PatchInstallFailed: {
            (options?: srmService.vim.PatchInstallFailed): srmService.vim.PatchInstallFailed;
         };
         PatchIntegrityError: {
            (options?: srmService.vim.PatchIntegrityError): srmService.vim.PatchIntegrityError;
         };
         PatchMetadataCorrupted: {
            (options?: srmService.vim.PatchMetadataCorrupted): srmService.vim.PatchMetadataCorrupted;
         };
         PatchMetadataInvalid: {
            (options?: srmService.vim.PatchMetadataInvalid): srmService.vim.PatchMetadataInvalid;
         };
         PatchMetadataNotFound: {
            (options?: srmService.vim.PatchMetadataNotFound): srmService.vim.PatchMetadataNotFound;
         };
         PatchMissingDependencies: {
            (options?: srmService.vim.PatchMissingDependencies): srmService.vim.PatchMissingDependencies;
         };
         PatchNotApplicable: {
            (options?: srmService.vim.PatchNotApplicable): srmService.vim.PatchNotApplicable;
         };
         PatchSuperseded: {
            (options?: srmService.vim.PatchSuperseded): srmService.vim.PatchSuperseded;
         };
         PhysCompatRDMNotSupported: {
            (options?: srmService.vim.PhysCompatRDMNotSupported): srmService.vim.PhysCompatRDMNotSupported;
         };
         PlatformConfigFault: {
            (options?: srmService.vim.PlatformConfigFault): srmService.vim.PlatformConfigFault;
         };
         PowerOnFtSecondaryFailed: {
            (options?: srmService.vim.PowerOnFtSecondaryFailed): srmService.vim.PowerOnFtSecondaryFailed;
         };
         PowerOnFtSecondaryTimedout: {
            (options?: srmService.vim.PowerOnFtSecondaryTimedout): srmService.vim.PowerOnFtSecondaryTimedout;
         };
         ProfileUpdateFailedUpdateFailure: {
            (options?: srmService.vim.ProfileUpdateFailedUpdateFailure): srmService.vim.ProfileUpdateFailedUpdateFailure;
         };
         ArrayOfProfileUpdateFailedUpdateFailure: {
            (options?: srmService.vim.ArrayOfProfileUpdateFailedUpdateFailure): srmService.vim.ArrayOfProfileUpdateFailedUpdateFailure;
         };
         ProfileUpdateFailed: {
            (options?: srmService.vim.ProfileUpdateFailed): srmService.vim.ProfileUpdateFailed;
         };
         QuestionPending: {
            (options?: srmService.vim.QuestionPending): srmService.vim.QuestionPending;
         };
         QuiesceDatastoreIOForHAFailed: {
            (options?: srmService.vim.QuiesceDatastoreIOForHAFailed): srmService.vim.QuiesceDatastoreIOForHAFailed;
         };
         RDMConversionNotSupported: {
            (options?: srmService.vim.RDMConversionNotSupported): srmService.vim.RDMConversionNotSupported;
         };
         RDMNotPreserved: {
            (options?: srmService.vim.RDMNotPreserved): srmService.vim.RDMNotPreserved;
         };
         RDMNotSupported: {
            (options?: srmService.vim.RDMNotSupported): srmService.vim.RDMNotSupported;
         };
         RDMNotSupportedOnDatastore: {
            (options?: srmService.vim.RDMNotSupportedOnDatastore): srmService.vim.RDMNotSupportedOnDatastore;
         };
         RDMPointsToInaccessibleDisk: {
            (options?: srmService.vim.RDMPointsToInaccessibleDisk): srmService.vim.RDMPointsToInaccessibleDisk;
         };
         RawDiskNotSupported: {
            (options?: srmService.vim.RawDiskNotSupported): srmService.vim.RawDiskNotSupported;
         };
         ReadHostResourcePoolTreeFailed: {
            (options?: srmService.vim.ReadHostResourcePoolTreeFailed): srmService.vim.ReadHostResourcePoolTreeFailed;
         };
         ReadOnlyDisksWithLegacyDestination: {
            (options?: srmService.vim.ReadOnlyDisksWithLegacyDestination): srmService.vim.ReadOnlyDisksWithLegacyDestination;
         };
         RebootRequired: {
            (options?: srmService.vim.RebootRequired): srmService.vim.RebootRequired;
         };
         RecordReplayDisabled: {
            (options?: srmService.vim.RecordReplayDisabled): srmService.vim.RecordReplayDisabled;
         };
         RemoteDeviceNotSupported: {
            (options?: srmService.vim.RemoteDeviceNotSupported): srmService.vim.RemoteDeviceNotSupported;
         };
         RemoveFailed: {
            (options?: srmService.vim.RemoveFailed): srmService.vim.RemoveFailed;
         };
         ReplicationConfigFault: {
            (options?: srmService.vim.ReplicationConfigFault): srmService.vim.ReplicationConfigFault;
         };
         ReplicationDiskConfigFaultReasonForFault: {
            "diskNotFound": string;
            "diskTypeNotSupported": string;
            "invalidDiskKey": string;
            "invalidDiskReplicationId": string;
            "duplicateDiskReplicationId": string;
            "invalidPersistentFilePath": string;
            "reconfigureDiskReplicationIdNotAllowed": string;
         };
         ReplicationDiskConfigFault: {
            (options?: srmService.vim.ReplicationDiskConfigFault): srmService.vim.ReplicationDiskConfigFault;
         };
         ReplicationFault: {
            (options?: srmService.vim.ReplicationFault): srmService.vim.ReplicationFault;
         };
         ReplicationIncompatibleWithFT: {
            (options?: srmService.vim.ReplicationIncompatibleWithFT): srmService.vim.ReplicationIncompatibleWithFT;
         };
         ReplicationInvalidOptions: {
            (options?: srmService.vim.ReplicationInvalidOptions): srmService.vim.ReplicationInvalidOptions;
         };
         ReplicationNotSupportedOnHost: {
            (options?: srmService.vim.ReplicationNotSupportedOnHost): srmService.vim.ReplicationNotSupportedOnHost;
         };
         ReplicationVmConfigFaultReasonForFault: {
            "incompatibleHwVersion": string;
            "invalidVmReplicationId": string;
            "invalidGenerationNumber": string;
            "outOfBoundsRpoValue": string;
            "invalidDestinationIpAddress": string;
            "invalidDestinationPort": string;
            "invalidExtraVmOptions": string;
            "staleGenerationNumber": string;
            "reconfigureVmReplicationIdNotAllowed": string;
            "cannotRetrieveVmReplicationConfiguration": string;
            "replicationAlreadyEnabled": string;
            "invalidPriorConfiguration": string;
            "replicationNotEnabled": string;
            "replicationConfigurationFailed": string;
         };
         ReplicationVmConfigFault: {
            (options?: srmService.vim.ReplicationVmConfigFault): srmService.vim.ReplicationVmConfigFault;
         };
         ReplicationVmFaultReasonForFault: {
            "notConfigured": string;
            "poweredOff": string;
            "suspended": string;
            "poweredOn": string;
            "offlineReplicating": string;
            "invalidState": string;
            "invalidInstanceId": string;
         };
         ReplicationVmFault: {
            (options?: srmService.vim.ReplicationVmFault): srmService.vim.ReplicationVmFault;
         };
         ResourceInUse: {
            (options?: srmService.vim.ResourceInUse): srmService.vim.ResourceInUse;
         };
         ResourceNotAvailable: {
            (options?: srmService.vim.ResourceNotAvailable): srmService.vim.ResourceNotAvailable;
         };
         RestrictedVersion: {
            (options?: srmService.vim.RestrictedVersion): srmService.vim.RestrictedVersion;
         };
         RollbackFailure: {
            (options?: srmService.vim.RollbackFailure): srmService.vim.RollbackFailure;
         };
         RuleViolation: {
            (options?: srmService.vim.RuleViolation): srmService.vim.RuleViolation;
         };
         SSLDisabledFault: {
            (options?: srmService.vim.SSLDisabledFault): srmService.vim.SSLDisabledFault;
         };
         SSLVerifyFault: {
            (options?: srmService.vim.SSLVerifyFault): srmService.vim.SSLVerifyFault;
         };
         SSPIChallenge: {
            (options?: srmService.vim.SSPIChallenge): srmService.vim.SSPIChallenge;
         };
         SecondaryVmAlreadyDisabled: {
            (options?: srmService.vim.SecondaryVmAlreadyDisabled): srmService.vim.SecondaryVmAlreadyDisabled;
         };
         SecondaryVmAlreadyEnabled: {
            (options?: srmService.vim.SecondaryVmAlreadyEnabled): srmService.vim.SecondaryVmAlreadyEnabled;
         };
         SecondaryVmAlreadyRegistered: {
            (options?: srmService.vim.SecondaryVmAlreadyRegistered): srmService.vim.SecondaryVmAlreadyRegistered;
         };
         SecondaryVmNotRegistered: {
            (options?: srmService.vim.SecondaryVmNotRegistered): srmService.vim.SecondaryVmNotRegistered;
         };
         SharedBusControllerNotSupported: {
            (options?: srmService.vim.SharedBusControllerNotSupported): srmService.vim.SharedBusControllerNotSupported;
         };
         ShrinkDiskFault: {
            (options?: srmService.vim.ShrinkDiskFault): srmService.vim.ShrinkDiskFault;
         };
         SnapshotCloneNotSupported: {
            (options?: srmService.vim.SnapshotCloneNotSupported): srmService.vim.SnapshotCloneNotSupported;
         };
         SnapshotCopyNotSupported: {
            (options?: srmService.vim.SnapshotCopyNotSupported): srmService.vim.SnapshotCopyNotSupported;
         };
         SnapshotDisabled: {
            (options?: srmService.vim.SnapshotDisabled): srmService.vim.SnapshotDisabled;
         };
         SnapshotFault: {
            (options?: srmService.vim.SnapshotFault): srmService.vim.SnapshotFault;
         };
         SnapshotIncompatibleDeviceInVm: {
            (options?: srmService.vim.SnapshotIncompatibleDeviceInVm): srmService.vim.SnapshotIncompatibleDeviceInVm;
         };
         SnapshotLocked: {
            (options?: srmService.vim.SnapshotLocked): srmService.vim.SnapshotLocked;
         };
         SnapshotMoveFromNonHomeNotSupported: {
            (options?: srmService.vim.SnapshotMoveFromNonHomeNotSupported): srmService.vim.SnapshotMoveFromNonHomeNotSupported;
         };
         SnapshotMoveNotSupported: {
            (options?: srmService.vim.SnapshotMoveNotSupported): srmService.vim.SnapshotMoveNotSupported;
         };
         SnapshotMoveToNonHomeNotSupported: {
            (options?: srmService.vim.SnapshotMoveToNonHomeNotSupported): srmService.vim.SnapshotMoveToNonHomeNotSupported;
         };
         SnapshotNoChange: {
            (options?: srmService.vim.SnapshotNoChange): srmService.vim.SnapshotNoChange;
         };
         SnapshotRevertIssue: {
            (options?: srmService.vim.SnapshotRevertIssue): srmService.vim.SnapshotRevertIssue;
         };
         SoftRuleVioCorrectionDisallowed: {
            (options?: srmService.vim.SoftRuleVioCorrectionDisallowed): srmService.vim.SoftRuleVioCorrectionDisallowed;
         };
         SoftRuleVioCorrectionImpact: {
            (options?: srmService.vim.SoftRuleVioCorrectionImpact): srmService.vim.SoftRuleVioCorrectionImpact;
         };
         SsdDiskNotAvailable: {
            (options?: srmService.vim.SsdDiskNotAvailable): srmService.vim.SsdDiskNotAvailable;
         };
         StorageDrsCannotMoveDiskInMultiWriterMode: {
            (options?: srmService.vim.StorageDrsCannotMoveDiskInMultiWriterMode): srmService.vim.StorageDrsCannotMoveDiskInMultiWriterMode;
         };
         StorageDrsCannotMoveFTVm: {
            (options?: srmService.vim.StorageDrsCannotMoveFTVm): srmService.vim.StorageDrsCannotMoveFTVm;
         };
         StorageDrsCannotMoveIndependentDisk: {
            (options?: srmService.vim.StorageDrsCannotMoveIndependentDisk): srmService.vim.StorageDrsCannotMoveIndependentDisk;
         };
         StorageDrsCannotMoveManuallyPlacedSwapFile: {
            (options?: srmService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile): srmService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile;
         };
         StorageDrsCannotMoveManuallyPlacedVm: {
            (options?: srmService.vim.StorageDrsCannotMoveManuallyPlacedVm): srmService.vim.StorageDrsCannotMoveManuallyPlacedVm;
         };
         StorageDrsCannotMoveSharedDisk: {
            (options?: srmService.vim.StorageDrsCannotMoveSharedDisk): srmService.vim.StorageDrsCannotMoveSharedDisk;
         };
         StorageDrsCannotMoveTemplate: {
            (options?: srmService.vim.StorageDrsCannotMoveTemplate): srmService.vim.StorageDrsCannotMoveTemplate;
         };
         StorageDrsCannotMoveVmInUserFolder: {
            (options?: srmService.vim.StorageDrsCannotMoveVmInUserFolder): srmService.vim.StorageDrsCannotMoveVmInUserFolder;
         };
         StorageDrsCannotMoveVmWithMountedCDROM: {
            (options?: srmService.vim.StorageDrsCannotMoveVmWithMountedCDROM): srmService.vim.StorageDrsCannotMoveVmWithMountedCDROM;
         };
         StorageDrsCannotMoveVmWithNoFilesInLayout: {
            (options?: srmService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout): srmService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout;
         };
         StorageDrsDatacentersCannotShareDatastore: {
            (options?: srmService.vim.StorageDrsDatacentersCannotShareDatastore): srmService.vim.StorageDrsDatacentersCannotShareDatastore;
         };
         StorageDrsDisabledOnVm: {
            (options?: srmService.vim.StorageDrsDisabledOnVm): srmService.vim.StorageDrsDisabledOnVm;
         };
         StorageDrsIolbDisabledInternally: {
            (options?: srmService.vim.StorageDrsIolbDisabledInternally): srmService.vim.StorageDrsIolbDisabledInternally;
         };
         StorageDrsUnableToMoveFiles: {
            (options?: srmService.vim.StorageDrsUnableToMoveFiles): srmService.vim.StorageDrsUnableToMoveFiles;
         };
         StorageVMotionNotSupported: {
            (options?: srmService.vim.StorageVMotionNotSupported): srmService.vim.StorageVMotionNotSupported;
         };
         StorageVmotionIncompatible: {
            (options?: srmService.vim.StorageVmotionIncompatible): srmService.vim.StorageVmotionIncompatible;
         };
         SuspendedRelocateNotSupported: {
            (options?: srmService.vim.SuspendedRelocateNotSupported): srmService.vim.SuspendedRelocateNotSupported;
         };
         SwapDatastoreNotWritableOnHost: {
            (options?: srmService.vim.SwapDatastoreNotWritableOnHost): srmService.vim.SwapDatastoreNotWritableOnHost;
         };
         SwapDatastoreUnset: {
            (options?: srmService.vim.SwapDatastoreUnset): srmService.vim.SwapDatastoreUnset;
         };
         SwapPlacementOverrideNotSupported: {
            (options?: srmService.vim.SwapPlacementOverrideNotSupported): srmService.vim.SwapPlacementOverrideNotSupported;
         };
         SwitchIpUnset: {
            (options?: srmService.vim.SwitchIpUnset): srmService.vim.SwitchIpUnset;
         };
         SwitchNotInUpgradeMode: {
            (options?: srmService.vim.SwitchNotInUpgradeMode): srmService.vim.SwitchNotInUpgradeMode;
         };
         TaskInProgress: {
            (options?: srmService.vim.TaskInProgress): srmService.vim.TaskInProgress;
         };
         ThirdPartyLicenseAssignmentFailedReason: {
            "licenseAssignmentFailed": string;
            "moduleNotInstalled": string;
         };
         ThirdPartyLicenseAssignmentFailed: {
            (options?: srmService.vim.ThirdPartyLicenseAssignmentFailed): srmService.vim.ThirdPartyLicenseAssignmentFailed;
         };
         Timedout: {
            (options?: srmService.vim.Timedout): srmService.vim.Timedout;
         };
         TooManyConcurrentNativeClones: {
            (options?: srmService.vim.TooManyConcurrentNativeClones): srmService.vim.TooManyConcurrentNativeClones;
         };
         TooManyConsecutiveOverrides: {
            (options?: srmService.vim.TooManyConsecutiveOverrides): srmService.vim.TooManyConsecutiveOverrides;
         };
         TooManyDevices: {
            (options?: srmService.vim.TooManyDevices): srmService.vim.TooManyDevices;
         };
         TooManyDisksOnLegacyHost: {
            (options?: srmService.vim.TooManyDisksOnLegacyHost): srmService.vim.TooManyDisksOnLegacyHost;
         };
         TooManyGuestLogons: {
            (options?: srmService.vim.TooManyGuestLogons): srmService.vim.TooManyGuestLogons;
         };
         TooManyHosts: {
            (options?: srmService.vim.TooManyHosts): srmService.vim.TooManyHosts;
         };
         TooManyNativeCloneLevels: {
            (options?: srmService.vim.TooManyNativeCloneLevels): srmService.vim.TooManyNativeCloneLevels;
         };
         TooManyNativeClonesOnFile: {
            (options?: srmService.vim.TooManyNativeClonesOnFile): srmService.vim.TooManyNativeClonesOnFile;
         };
         TooManySnapshotLevels: {
            (options?: srmService.vim.TooManySnapshotLevels): srmService.vim.TooManySnapshotLevels;
         };
         ToolsAlreadyUpgraded: {
            (options?: srmService.vim.ToolsAlreadyUpgraded): srmService.vim.ToolsAlreadyUpgraded;
         };
         ToolsAutoUpgradeNotSupported: {
            (options?: srmService.vim.ToolsAutoUpgradeNotSupported): srmService.vim.ToolsAutoUpgradeNotSupported;
         };
         ToolsImageCopyFailed: {
            (options?: srmService.vim.ToolsImageCopyFailed): srmService.vim.ToolsImageCopyFailed;
         };
         ToolsImageNotAvailable: {
            (options?: srmService.vim.ToolsImageNotAvailable): srmService.vim.ToolsImageNotAvailable;
         };
         ToolsImageSignatureCheckFailed: {
            (options?: srmService.vim.ToolsImageSignatureCheckFailed): srmService.vim.ToolsImageSignatureCheckFailed;
         };
         ToolsInstallationInProgress: {
            (options?: srmService.vim.ToolsInstallationInProgress): srmService.vim.ToolsInstallationInProgress;
         };
         ToolsUnavailable: {
            (options?: srmService.vim.ToolsUnavailable): srmService.vim.ToolsUnavailable;
         };
         ToolsUpgradeCancelled: {
            (options?: srmService.vim.ToolsUpgradeCancelled): srmService.vim.ToolsUpgradeCancelled;
         };
         UnSupportedDatastoreForVFlash: {
            (options?: srmService.vim.UnSupportedDatastoreForVFlash): srmService.vim.UnSupportedDatastoreForVFlash;
         };
         UncommittedUndoableDisk: {
            (options?: srmService.vim.UncommittedUndoableDisk): srmService.vim.UncommittedUndoableDisk;
         };
         UnconfiguredPropertyValue: {
            (options?: srmService.vim.UnconfiguredPropertyValue): srmService.vim.UnconfiguredPropertyValue;
         };
         UncustomizableGuest: {
            (options?: srmService.vim.UncustomizableGuest): srmService.vim.UncustomizableGuest;
         };
         UnexpectedCustomizationFault: {
            (options?: srmService.vim.UnexpectedCustomizationFault): srmService.vim.UnexpectedCustomizationFault;
         };
         UnrecognizedHost: {
            (options?: srmService.vim.UnrecognizedHost): srmService.vim.UnrecognizedHost;
         };
         UnsharedSwapVMotionNotSupported: {
            (options?: srmService.vim.UnsharedSwapVMotionNotSupported): srmService.vim.UnsharedSwapVMotionNotSupported;
         };
         UnsupportedDatastore: {
            (options?: srmService.vim.UnsupportedDatastore): srmService.vim.UnsupportedDatastore;
         };
         UnsupportedGuest: {
            (options?: srmService.vim.UnsupportedGuest): srmService.vim.UnsupportedGuest;
         };
         UnsupportedVimApiVersion: {
            (options?: srmService.vim.UnsupportedVimApiVersion): srmService.vim.UnsupportedVimApiVersion;
         };
         UnsupportedVmxLocation: {
            (options?: srmService.vim.UnsupportedVmxLocation): srmService.vim.UnsupportedVmxLocation;
         };
         UnusedVirtualDiskBlocksNotScrubbed: {
            (options?: srmService.vim.UnusedVirtualDiskBlocksNotScrubbed): srmService.vim.UnusedVirtualDiskBlocksNotScrubbed;
         };
         UserNotFound: {
            (options?: srmService.vim.UserNotFound): srmService.vim.UserNotFound;
         };
         VAppConfigFault: {
            (options?: srmService.vim.VAppConfigFault): srmService.vim.VAppConfigFault;
         };
         VAppNotRunning: {
            (options?: srmService.vim.VAppNotRunning): srmService.vim.VAppNotRunning;
         };
         VAppOperationInProgress: {
            (options?: srmService.vim.VAppOperationInProgress): srmService.vim.VAppOperationInProgress;
         };
         VAppPropertyFault: {
            (options?: srmService.vim.VAppPropertyFault): srmService.vim.VAppPropertyFault;
         };
         VAppTaskInProgress: {
            (options?: srmService.vim.VAppTaskInProgress): srmService.vim.VAppTaskInProgress;
         };
         VFlashModuleNotSupportedReason: {
            "CacheModeNotSupported": string;
            "CacheConsistencyTypeNotSupported": string;
            "CacheBlockSizeNotSupported": string;
            "CacheReservationNotSupported": string;
            "DiskSizeNotSupported": string;
         };
         VFlashModuleNotSupported: {
            (options?: srmService.vim.VFlashModuleNotSupported): srmService.vim.VFlashModuleNotSupported;
         };
         VFlashModuleVersionIncompatible: {
            (options?: srmService.vim.VFlashModuleVersionIncompatible): srmService.vim.VFlashModuleVersionIncompatible;
         };
         VMINotSupported: {
            (options?: srmService.vim.VMINotSupported): srmService.vim.VMINotSupported;
         };
         VMOnConflictDVPort: {
            (options?: srmService.vim.VMOnConflictDVPort): srmService.vim.VMOnConflictDVPort;
         };
         VMOnVirtualIntranet: {
            (options?: srmService.vim.VMOnVirtualIntranet): srmService.vim.VMOnVirtualIntranet;
         };
         VMotionAcrossNetworkNotSupported: {
            (options?: srmService.vim.VMotionAcrossNetworkNotSupported): srmService.vim.VMotionAcrossNetworkNotSupported;
         };
         VMotionInterfaceIssue: {
            (options?: srmService.vim.VMotionInterfaceIssue): srmService.vim.VMotionInterfaceIssue;
         };
         VMotionLinkCapacityLow: {
            (options?: srmService.vim.VMotionLinkCapacityLow): srmService.vim.VMotionLinkCapacityLow;
         };
         VMotionLinkDown: {
            (options?: srmService.vim.VMotionLinkDown): srmService.vim.VMotionLinkDown;
         };
         VMotionNotConfigured: {
            (options?: srmService.vim.VMotionNotConfigured): srmService.vim.VMotionNotConfigured;
         };
         VMotionNotLicensed: {
            (options?: srmService.vim.VMotionNotLicensed): srmService.vim.VMotionNotLicensed;
         };
         VMotionNotSupported: {
            (options?: srmService.vim.VMotionNotSupported): srmService.vim.VMotionNotSupported;
         };
         VMotionProtocolIncompatible: {
            (options?: srmService.vim.VMotionProtocolIncompatible): srmService.vim.VMotionProtocolIncompatible;
         };
         VimFault: {
            (options?: srmService.vim.VimFault): srmService.vim.VimFault;
         };
         VirtualDiskBlocksNotFullyProvisioned: {
            (options?: srmService.vim.VirtualDiskBlocksNotFullyProvisioned): srmService.vim.VirtualDiskBlocksNotFullyProvisioned;
         };
         VirtualDiskModeNotSupported: {
            (options?: srmService.vim.VirtualDiskModeNotSupported): srmService.vim.VirtualDiskModeNotSupported;
         };
         VirtualEthernetCardNotSupported: {
            (options?: srmService.vim.VirtualEthernetCardNotSupported): srmService.vim.VirtualEthernetCardNotSupported;
         };
         VirtualHardwareCompatibilityIssue: {
            (options?: srmService.vim.VirtualHardwareCompatibilityIssue): srmService.vim.VirtualHardwareCompatibilityIssue;
         };
         VirtualHardwareVersionNotSupported: {
            (options?: srmService.vim.VirtualHardwareVersionNotSupported): srmService.vim.VirtualHardwareVersionNotSupported;
         };
         VmAlreadyExistsInDatacenter: {
            (options?: srmService.vim.VmAlreadyExistsInDatacenter): srmService.vim.VmAlreadyExistsInDatacenter;
         };
         VmConfigFault: {
            (options?: srmService.vim.VmConfigFault): srmService.vim.VmConfigFault;
         };
         VmConfigIncompatibleForFaultTolerance: {
            (options?: srmService.vim.VmConfigIncompatibleForFaultTolerance): srmService.vim.VmConfigIncompatibleForFaultTolerance;
         };
         VmConfigIncompatibleForRecordReplay: {
            (options?: srmService.vim.VmConfigIncompatibleForRecordReplay): srmService.vim.VmConfigIncompatibleForRecordReplay;
         };
         VmFaultToleranceConfigIssueReasonForIssue: {
            "haNotEnabled": string;
            "moreThanOneSecondary": string;
            "recordReplayNotSupported": string;
            "replayNotSupported": string;
            "templateVm": string;
            "multipleVCPU": string;
            "hostInactive": string;
            "ftUnsupportedHardware": string;
            "ftUnsupportedProduct": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "thinDisk": string;
            "verifySSLCertificateFlagNotSet": string;
            "hasSnapshots": string;
            "noConfig": string;
            "ftSecondaryVm": string;
            "hasLocalDisk": string;
            "esxAgentVm": string;
            "video3dEnabled": string;
            "hasUnsupportedDisk": string;
            "hasNestedHVConfiguration": string;
            "hasVFlashConfiguration": string;
         };
         VmFaultToleranceConfigIssue: {
            (options?: srmService.vim.VmFaultToleranceConfigIssue): srmService.vim.VmFaultToleranceConfigIssue;
         };
         VmFaultToleranceConfigIssueWrapper: {
            (options?: srmService.vim.VmFaultToleranceConfigIssueWrapper): srmService.vim.VmFaultToleranceConfigIssueWrapper;
         };
         VmFaultToleranceInvalidFileBackingDeviceType: {
            "virtualFloppy": string;
            "virtualCdrom": string;
            "virtualSerialPort": string;
            "virtualParallelPort": string;
            "virtualDisk": string;
         };
         VmFaultToleranceInvalidFileBacking: {
            (options?: srmService.vim.VmFaultToleranceInvalidFileBacking): srmService.vim.VmFaultToleranceInvalidFileBacking;
         };
         VmFaultToleranceIssue: {
            (options?: srmService.vim.VmFaultToleranceIssue): srmService.vim.VmFaultToleranceIssue;
         };
         VmFaultToleranceOpIssuesList: {
            (options?: srmService.vim.VmFaultToleranceOpIssuesList): srmService.vim.VmFaultToleranceOpIssuesList;
         };
         VmFaultToleranceTooManyVMsOnHost: {
            (options?: srmService.vim.VmFaultToleranceTooManyVMsOnHost): srmService.vim.VmFaultToleranceTooManyVMsOnHost;
         };
         VmHostAffinityRuleViolation: {
            (options?: srmService.vim.VmHostAffinityRuleViolation): srmService.vim.VmHostAffinityRuleViolation;
         };
         VmLimitLicense: {
            (options?: srmService.vim.VmLimitLicense): srmService.vim.VmLimitLicense;
         };
         VmMetadataManagerFault: {
            (options?: srmService.vim.VmMetadataManagerFault): srmService.vim.VmMetadataManagerFault;
         };
         VmMonitorIncompatibleForFaultTolerance: {
            (options?: srmService.vim.VmMonitorIncompatibleForFaultTolerance): srmService.vim.VmMonitorIncompatibleForFaultTolerance;
         };
         VmPowerOnDisabled: {
            (options?: srmService.vim.VmPowerOnDisabled): srmService.vim.VmPowerOnDisabled;
         };
         VmToolsUpgradeFault: {
            (options?: srmService.vim.VmToolsUpgradeFault): srmService.vim.VmToolsUpgradeFault;
         };
         VmValidateMaxDevice: {
            (options?: srmService.vim.VmValidateMaxDevice): srmService.vim.VmValidateMaxDevice;
         };
         VmWwnConflict: {
            (options?: srmService.vim.VmWwnConflict): srmService.vim.VmWwnConflict;
         };
         VmfsAlreadyMounted: {
            (options?: srmService.vim.VmfsAlreadyMounted): srmService.vim.VmfsAlreadyMounted;
         };
         VmfsAmbiguousMount: {
            (options?: srmService.vim.VmfsAmbiguousMount): srmService.vim.VmfsAmbiguousMount;
         };
         VmfsMountFault: {
            (options?: srmService.vim.VmfsMountFault): srmService.vim.VmfsMountFault;
         };
         VmotionInterfaceNotEnabled: {
            (options?: srmService.vim.VmotionInterfaceNotEnabled): srmService.vim.VmotionInterfaceNotEnabled;
         };
         VolumeEditorError: {
            (options?: srmService.vim.VolumeEditorError): srmService.vim.VolumeEditorError;
         };
         VramLimitLicense: {
            (options?: srmService.vim.VramLimitLicense): srmService.vim.VramLimitLicense;
         };
         VsanClusterUuidMismatch: {
            (options?: srmService.vim.VsanClusterUuidMismatch): srmService.vim.VsanClusterUuidMismatch;
         };
         VsanDiskFault: {
            (options?: srmService.vim.VsanDiskFault): srmService.vim.VsanDiskFault;
         };
         VsanFault: {
            (options?: srmService.vim.VsanFault): srmService.vim.VsanFault;
         };
         VspanDestPortConflict: {
            (options?: srmService.vim.VspanDestPortConflict): srmService.vim.VspanDestPortConflict;
         };
         VspanPortConflict: {
            (options?: srmService.vim.VspanPortConflict): srmService.vim.VspanPortConflict;
         };
         VspanPortMoveFault: {
            (options?: srmService.vim.VspanPortMoveFault): srmService.vim.VspanPortMoveFault;
         };
         VspanPortPromiscChangeFault: {
            (options?: srmService.vim.VspanPortPromiscChangeFault): srmService.vim.VspanPortPromiscChangeFault;
         };
         VspanPortgroupPromiscChangeFault: {
            (options?: srmService.vim.VspanPortgroupPromiscChangeFault): srmService.vim.VspanPortgroupPromiscChangeFault;
         };
         VspanPortgroupTypeChangeFault: {
            (options?: srmService.vim.VspanPortgroupTypeChangeFault): srmService.vim.VspanPortgroupTypeChangeFault;
         };
         VspanPromiscuousPortNotSupported: {
            (options?: srmService.vim.VspanPromiscuousPortNotSupported): srmService.vim.VspanPromiscuousPortNotSupported;
         };
         VspanSameSessionPortConflict: {
            (options?: srmService.vim.VspanSameSessionPortConflict): srmService.vim.VspanSameSessionPortConflict;
         };
         WakeOnLanNotSupported: {
            (options?: srmService.vim.WakeOnLanNotSupported): srmService.vim.WakeOnLanNotSupported;
         };
         WakeOnLanNotSupportedByVmotionNIC: {
            (options?: srmService.vim.WakeOnLanNotSupportedByVmotionNIC): srmService.vim.WakeOnLanNotSupportedByVmotionNIC;
         };
         WillLoseHAProtectionResolution: {
            "svmotion": string;
            "relocate": string;
         };
         WillLoseHAProtection: {
            (options?: srmService.vim.WillLoseHAProtection): srmService.vim.WillLoseHAProtection;
         };
         WillModifyConfigCpuRequirements: {
            (options?: srmService.vim.WillModifyConfigCpuRequirements): srmService.vim.WillModifyConfigCpuRequirements;
         };
         WillResetSnapshotDirectory: {
            (options?: srmService.vim.WillResetSnapshotDirectory): srmService.vim.WillResetSnapshotDirectory;
         };
         WipeDiskFault: {
            (options?: srmService.vim.WipeDiskFault): srmService.vim.WipeDiskFault;
         };
         HostActiveDirectoryInfoDomainMembershipStatus: {
            "unknown": string;
            "ok": string;
            "noServers": string;
            "clientTrustBroken": string;
            "serverTrustBroken": string;
            "inconsistentTrust": string;
            "otherProblem": string;
         };
         HostActiveDirectoryInfo: {
            (options?: srmService.vim.HostActiveDirectoryInfo): srmService.vim.HostActiveDirectoryInfo;
         };
         HostActiveDirectorySpec: {
            (options?: srmService.vim.HostActiveDirectorySpec): srmService.vim.HostActiveDirectorySpec;
         };
         HostActiveDirectory: {
            (options?: srmService.vim.HostActiveDirectory): srmService.vim.HostActiveDirectory;
         };
         ArrayOfHostActiveDirectory: {
            (options?: srmService.vim.ArrayOfHostActiveDirectory): srmService.vim.ArrayOfHostActiveDirectory;
         };
         HostAuthenticationManagerInfo: {
            (options?: srmService.vim.HostAuthenticationManagerInfo): srmService.vim.HostAuthenticationManagerInfo;
         };
         HostAuthenticationStoreInfo: {
            (options?: srmService.vim.HostAuthenticationStoreInfo): srmService.vim.HostAuthenticationStoreInfo;
         };
         ArrayOfHostAuthenticationStoreInfo: {
            (options?: srmService.vim.ArrayOfHostAuthenticationStoreInfo): srmService.vim.ArrayOfHostAuthenticationStoreInfo;
         };
         AutoStartAction: {
            "none": string;
            "systemDefault": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         AutoStartDefaults: {
            (options?: srmService.vim.AutoStartDefaults): srmService.vim.AutoStartDefaults;
         };
         AutoStartWaitHeartbeatSetting: {
            "yes": string;
            "no": string;
            "systemDefault": string;
         };
         AutoStartPowerInfo: {
            (options?: srmService.vim.AutoStartPowerInfo): srmService.vim.AutoStartPowerInfo;
         };
         ArrayOfAutoStartPowerInfo: {
            (options?: srmService.vim.ArrayOfAutoStartPowerInfo): srmService.vim.ArrayOfAutoStartPowerInfo;
         };
         HostAutoStartManagerConfig: {
            (options?: srmService.vim.HostAutoStartManagerConfig): srmService.vim.HostAutoStartManagerConfig;
         };
         HostBootDeviceInfo: {
            (options?: srmService.vim.HostBootDeviceInfo): srmService.vim.HostBootDeviceInfo;
         };
         HostBootDevice: {
            (options?: srmService.vim.HostBootDevice): srmService.vim.HostBootDevice;
         };
         ArrayOfHostBootDevice: {
            (options?: srmService.vim.ArrayOfHostBootDevice): srmService.vim.ArrayOfHostBootDevice;
         };
         HostCacheConfigurationSpec: {
            (options?: srmService.vim.HostCacheConfigurationSpec): srmService.vim.HostCacheConfigurationSpec;
         };
         HostCacheConfigurationInfo: {
            (options?: srmService.vim.HostCacheConfigurationInfo): srmService.vim.HostCacheConfigurationInfo;
         };
         ArrayOfHostCacheConfigurationInfo: {
            (options?: srmService.vim.ArrayOfHostCacheConfigurationInfo): srmService.vim.ArrayOfHostCacheConfigurationInfo;
         };
         HostReplayUnsupportedReason: {
            "incompatibleProduct": string;
            "incompatibleCpu": string;
            "hvDisabled": string;
            "cpuidLimitSet": string;
            "oldBIOS": string;
            "unknown": string;
         };
         HostCapabilityFtUnsupportedReason: {
            "vMotionNotLicensed": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "ftNotLicensed": string;
            "haAgentIssue": string;
         };
         HostCapabilityVmDirectPathGen2UnsupportedReason: {
            "hostNptIncompatibleProduct": string;
            "hostNptIncompatibleHardware": string;
            "hostNptDisabled": string;
         };
         HostCapability: {
            (options?: srmService.vim.HostCapability): srmService.vim.HostCapability;
         };
         HostConfigChangeMode: {
            "modify": string;
            "replace": string;
         };
         HostConfigChangeOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         HostConfigChange: {
            (options?: srmService.vim.HostConfigChange): srmService.vim.HostConfigChange;
         };
         HostConfigInfo: {
            (options?: srmService.vim.HostConfigInfo): srmService.vim.HostConfigInfo;
         };
         HostConfigManager: {
            (options?: srmService.vim.HostConfigManager): srmService.vim.HostConfigManager;
         };
         HostConfigSpec: {
            (options?: srmService.vim.HostConfigSpec): srmService.vim.HostConfigSpec;
         };
         HostConnectInfoNetworkInfo: {
            (options?: srmService.vim.HostConnectInfoNetworkInfo): srmService.vim.HostConnectInfoNetworkInfo;
         };
         ArrayOfHostConnectInfoNetworkInfo: {
            (options?: srmService.vim.ArrayOfHostConnectInfoNetworkInfo): srmService.vim.ArrayOfHostConnectInfoNetworkInfo;
         };
         HostNewNetworkConnectInfo: {
            (options?: srmService.vim.HostNewNetworkConnectInfo): srmService.vim.HostNewNetworkConnectInfo;
         };
         HostDatastoreConnectInfo: {
            (options?: srmService.vim.HostDatastoreConnectInfo): srmService.vim.HostDatastoreConnectInfo;
         };
         ArrayOfHostDatastoreConnectInfo: {
            (options?: srmService.vim.ArrayOfHostDatastoreConnectInfo): srmService.vim.ArrayOfHostDatastoreConnectInfo;
         };
         HostDatastoreExistsConnectInfo: {
            (options?: srmService.vim.HostDatastoreExistsConnectInfo): srmService.vim.HostDatastoreExistsConnectInfo;
         };
         HostDatastoreNameConflictConnectInfo: {
            (options?: srmService.vim.HostDatastoreNameConflictConnectInfo): srmService.vim.HostDatastoreNameConflictConnectInfo;
         };
         HostLicenseConnectInfo: {
            (options?: srmService.vim.HostLicenseConnectInfo): srmService.vim.HostLicenseConnectInfo;
         };
         HostConnectInfo: {
            (options?: srmService.vim.HostConnectInfo): srmService.vim.HostConnectInfo;
         };
         HostConnectSpec: {
            (options?: srmService.vim.HostConnectSpec): srmService.vim.HostConnectSpec;
         };
         HostCpuIdInfo: {
            (options?: srmService.vim.HostCpuIdInfo): srmService.vim.HostCpuIdInfo;
         };
         ArrayOfHostCpuIdInfo: {
            (options?: srmService.vim.ArrayOfHostCpuIdInfo): srmService.vim.ArrayOfHostCpuIdInfo;
         };
         HostHyperThreadScheduleInfo: {
            (options?: srmService.vim.HostHyperThreadScheduleInfo): srmService.vim.HostHyperThreadScheduleInfo;
         };
         FileQueryFlags: {
            (options?: srmService.vim.FileQueryFlags): srmService.vim.FileQueryFlags;
         };
         FileInfo: {
            (options?: srmService.vim.FileInfo): srmService.vim.FileInfo;
         };
         ArrayOfFileInfo: {
            (options?: srmService.vim.ArrayOfFileInfo): srmService.vim.ArrayOfFileInfo;
         };
         FileQuery: {
            (options?: srmService.vim.FileQuery): srmService.vim.FileQuery;
         };
         ArrayOfFileQuery: {
            (options?: srmService.vim.ArrayOfFileQuery): srmService.vim.ArrayOfFileQuery;
         };
         VmConfigFileQueryFilter: {
            (options?: srmService.vim.VmConfigFileQueryFilter): srmService.vim.VmConfigFileQueryFilter;
         };
         VmConfigFileQueryFlags: {
            (options?: srmService.vim.VmConfigFileQueryFlags): srmService.vim.VmConfigFileQueryFlags;
         };
         VmConfigFileQuery: {
            (options?: srmService.vim.VmConfigFileQuery): srmService.vim.VmConfigFileQuery;
         };
         TemplateConfigFileQuery: {
            (options?: srmService.vim.TemplateConfigFileQuery): srmService.vim.TemplateConfigFileQuery;
         };
         VmDiskFileQueryFilter: {
            (options?: srmService.vim.VmDiskFileQueryFilter): srmService.vim.VmDiskFileQueryFilter;
         };
         VmDiskFileQueryFlags: {
            (options?: srmService.vim.VmDiskFileQueryFlags): srmService.vim.VmDiskFileQueryFlags;
         };
         VmDiskFileQuery: {
            (options?: srmService.vim.VmDiskFileQuery): srmService.vim.VmDiskFileQuery;
         };
         FolderFileQuery: {
            (options?: srmService.vim.FolderFileQuery): srmService.vim.FolderFileQuery;
         };
         VmSnapshotFileQuery: {
            (options?: srmService.vim.VmSnapshotFileQuery): srmService.vim.VmSnapshotFileQuery;
         };
         IsoImageFileQuery: {
            (options?: srmService.vim.IsoImageFileQuery): srmService.vim.IsoImageFileQuery;
         };
         FloppyImageFileQuery: {
            (options?: srmService.vim.FloppyImageFileQuery): srmService.vim.FloppyImageFileQuery;
         };
         VmNvramFileQuery: {
            (options?: srmService.vim.VmNvramFileQuery): srmService.vim.VmNvramFileQuery;
         };
         VmLogFileQuery: {
            (options?: srmService.vim.VmLogFileQuery): srmService.vim.VmLogFileQuery;
         };
         VmConfigFileInfo: {
            (options?: srmService.vim.VmConfigFileInfo): srmService.vim.VmConfigFileInfo;
         };
         TemplateConfigFileInfo: {
            (options?: srmService.vim.TemplateConfigFileInfo): srmService.vim.TemplateConfigFileInfo;
         };
         VmDiskFileInfo: {
            (options?: srmService.vim.VmDiskFileInfo): srmService.vim.VmDiskFileInfo;
         };
         FolderFileInfo: {
            (options?: srmService.vim.FolderFileInfo): srmService.vim.FolderFileInfo;
         };
         VmSnapshotFileInfo: {
            (options?: srmService.vim.VmSnapshotFileInfo): srmService.vim.VmSnapshotFileInfo;
         };
         IsoImageFileInfo: {
            (options?: srmService.vim.IsoImageFileInfo): srmService.vim.IsoImageFileInfo;
         };
         FloppyImageFileInfo: {
            (options?: srmService.vim.FloppyImageFileInfo): srmService.vim.FloppyImageFileInfo;
         };
         VmNvramFileInfo: {
            (options?: srmService.vim.VmNvramFileInfo): srmService.vim.VmNvramFileInfo;
         };
         VmLogFileInfo: {
            (options?: srmService.vim.VmLogFileInfo): srmService.vim.VmLogFileInfo;
         };
         HostDatastoreBrowserSearchSpec: {
            (options?: srmService.vim.HostDatastoreBrowserSearchSpec): srmService.vim.HostDatastoreBrowserSearchSpec;
         };
         HostDatastoreBrowserSearchResults: {
            (options?: srmService.vim.HostDatastoreBrowserSearchResults): srmService.vim.HostDatastoreBrowserSearchResults;
         };
         ArrayOfHostDatastoreBrowserSearchResults: {
            (options?: srmService.vim.ArrayOfHostDatastoreBrowserSearchResults): srmService.vim.ArrayOfHostDatastoreBrowserSearchResults;
         };
         HostDatastoreSystemCapabilities: {
            (options?: srmService.vim.HostDatastoreSystemCapabilities): srmService.vim.HostDatastoreSystemCapabilities;
         };
         VmfsDatastoreInfo: {
            (options?: srmService.vim.VmfsDatastoreInfo): srmService.vim.VmfsDatastoreInfo;
         };
         NasDatastoreInfo: {
            (options?: srmService.vim.NasDatastoreInfo): srmService.vim.NasDatastoreInfo;
         };
         LocalDatastoreInfo: {
            (options?: srmService.vim.LocalDatastoreInfo): srmService.vim.LocalDatastoreInfo;
         };
         VmfsDatastoreSpec: {
            (options?: srmService.vim.VmfsDatastoreSpec): srmService.vim.VmfsDatastoreSpec;
         };
         VmfsDatastoreCreateSpec: {
            (options?: srmService.vim.VmfsDatastoreCreateSpec): srmService.vim.VmfsDatastoreCreateSpec;
         };
         VmfsDatastoreExtendSpec: {
            (options?: srmService.vim.VmfsDatastoreExtendSpec): srmService.vim.VmfsDatastoreExtendSpec;
         };
         VmfsDatastoreExpandSpec: {
            (options?: srmService.vim.VmfsDatastoreExpandSpec): srmService.vim.VmfsDatastoreExpandSpec;
         };
         VmfsDatastoreBaseOption: {
            (options?: srmService.vim.VmfsDatastoreBaseOption): srmService.vim.VmfsDatastoreBaseOption;
         };
         VmfsDatastoreSingleExtentOption: {
            (options?: srmService.vim.VmfsDatastoreSingleExtentOption): srmService.vim.VmfsDatastoreSingleExtentOption;
         };
         VmfsDatastoreAllExtentOption: {
            (options?: srmService.vim.VmfsDatastoreAllExtentOption): srmService.vim.VmfsDatastoreAllExtentOption;
         };
         VmfsDatastoreMultipleExtentOption: {
            (options?: srmService.vim.VmfsDatastoreMultipleExtentOption): srmService.vim.VmfsDatastoreMultipleExtentOption;
         };
         VmfsDatastoreOption: {
            (options?: srmService.vim.VmfsDatastoreOption): srmService.vim.VmfsDatastoreOption;
         };
         ArrayOfVmfsDatastoreOption: {
            (options?: srmService.vim.ArrayOfVmfsDatastoreOption): srmService.vim.ArrayOfVmfsDatastoreOption;
         };
         HostDateTimeConfig: {
            (options?: srmService.vim.HostDateTimeConfig): srmService.vim.HostDateTimeConfig;
         };
         HostDateTimeInfo: {
            (options?: srmService.vim.HostDateTimeInfo): srmService.vim.HostDateTimeInfo;
         };
         HostDateTimeSystemTimeZone: {
            (options?: srmService.vim.HostDateTimeSystemTimeZone): srmService.vim.HostDateTimeSystemTimeZone;
         };
         ArrayOfHostDateTimeSystemTimeZone: {
            (options?: srmService.vim.ArrayOfHostDateTimeSystemTimeZone): srmService.vim.ArrayOfHostDateTimeSystemTimeZone;
         };
         HostDevice: {
            (options?: srmService.vim.HostDevice): srmService.vim.HostDevice;
         };
         HostDhcpServiceSpec: {
            (options?: srmService.vim.HostDhcpServiceSpec): srmService.vim.HostDhcpServiceSpec;
         };
         HostDhcpServiceConfig: {
            (options?: srmService.vim.HostDhcpServiceConfig): srmService.vim.HostDhcpServiceConfig;
         };
         ArrayOfHostDhcpServiceConfig: {
            (options?: srmService.vim.ArrayOfHostDhcpServiceConfig): srmService.vim.ArrayOfHostDhcpServiceConfig;
         };
         HostDhcpService: {
            (options?: srmService.vim.HostDhcpService): srmService.vim.HostDhcpService;
         };
         ArrayOfHostDhcpService: {
            (options?: srmService.vim.ArrayOfHostDhcpService): srmService.vim.ArrayOfHostDhcpService;
         };
         DiagnosticPartitionStorageType: {
            "directAttached": string;
            "networkAttached": string;
         };
         DiagnosticPartitionType: {
            "singleHost": string;
            "multiHost": string;
         };
         HostDiagnosticPartitionCreateOption: {
            (options?: srmService.vim.HostDiagnosticPartitionCreateOption): srmService.vim.HostDiagnosticPartitionCreateOption;
         };
         ArrayOfHostDiagnosticPartitionCreateOption: {
            (options?: srmService.vim.ArrayOfHostDiagnosticPartitionCreateOption): srmService.vim.ArrayOfHostDiagnosticPartitionCreateOption;
         };
         HostDiagnosticPartitionCreateSpec: {
            (options?: srmService.vim.HostDiagnosticPartitionCreateSpec): srmService.vim.HostDiagnosticPartitionCreateSpec;
         };
         HostDiagnosticPartitionCreateDescription: {
            (options?: srmService.vim.HostDiagnosticPartitionCreateDescription): srmService.vim.HostDiagnosticPartitionCreateDescription;
         };
         HostDiagnosticPartition: {
            (options?: srmService.vim.HostDiagnosticPartition): srmService.vim.HostDiagnosticPartition;
         };
         ArrayOfHostDiagnosticPartition: {
            (options?: srmService.vim.ArrayOfHostDiagnosticPartition): srmService.vim.ArrayOfHostDiagnosticPartition;
         };
         HostDirectoryStoreInfo: {
            (options?: srmService.vim.HostDirectoryStoreInfo): srmService.vim.HostDirectoryStoreInfo;
         };
         HostDiskConfigurationResult: {
            (options?: srmService.vim.HostDiskConfigurationResult): srmService.vim.HostDiskConfigurationResult;
         };
         ArrayOfHostDiskConfigurationResult: {
            (options?: srmService.vim.ArrayOfHostDiskConfigurationResult): srmService.vim.ArrayOfHostDiskConfigurationResult;
         };
         HostDiskDimensionsChs: {
            (options?: srmService.vim.HostDiskDimensionsChs): srmService.vim.HostDiskDimensionsChs;
         };
         HostDiskDimensionsLba: {
            (options?: srmService.vim.HostDiskDimensionsLba): srmService.vim.HostDiskDimensionsLba;
         };
         HostDiskDimensions: {
            (options?: srmService.vim.HostDiskDimensions): srmService.vim.HostDiskDimensions;
         };
         HostDiskPartitionInfoPartitionFormat: {
            "gpt": string;
            "mbr": string;
            "unknown": string;
         };
         HostDiskPartitionInfoType: {
            "none": string;
            "vmfs": string;
            "linuxNative": string;
            "linuxSwap": string;
            "extended": string;
            "ntfs": string;
            "vmkDiagnostic": string;
            "vffs": string;
         };
         HostDiskPartitionAttributes: {
            (options?: srmService.vim.HostDiskPartitionAttributes): srmService.vim.HostDiskPartitionAttributes;
         };
         ArrayOfHostDiskPartitionAttributes: {
            (options?: srmService.vim.ArrayOfHostDiskPartitionAttributes): srmService.vim.ArrayOfHostDiskPartitionAttributes;
         };
         HostDiskPartitionBlockRange: {
            (options?: srmService.vim.HostDiskPartitionBlockRange): srmService.vim.HostDiskPartitionBlockRange;
         };
         ArrayOfHostDiskPartitionBlockRange: {
            (options?: srmService.vim.ArrayOfHostDiskPartitionBlockRange): srmService.vim.ArrayOfHostDiskPartitionBlockRange;
         };
         HostDiskPartitionSpec: {
            (options?: srmService.vim.HostDiskPartitionSpec): srmService.vim.HostDiskPartitionSpec;
         };
         HostDiskPartitionLayout: {
            (options?: srmService.vim.HostDiskPartitionLayout): srmService.vim.HostDiskPartitionLayout;
         };
         HostDiskPartitionInfo: {
            (options?: srmService.vim.HostDiskPartitionInfo): srmService.vim.HostDiskPartitionInfo;
         };
         ArrayOfHostDiskPartitionInfo: {
            (options?: srmService.vim.ArrayOfHostDiskPartitionInfo): srmService.vim.ArrayOfHostDiskPartitionInfo;
         };
         HostDnsConfig: {
            (options?: srmService.vim.HostDnsConfig): srmService.vim.HostDnsConfig;
         };
         HostDnsConfigSpec: {
            (options?: srmService.vim.HostDnsConfigSpec): srmService.vim.HostDnsConfigSpec;
         };
         HostEsxAgentHostManagerConfigInfo: {
            (options?: srmService.vim.HostEsxAgentHostManagerConfigInfo): srmService.vim.HostEsxAgentHostManagerConfigInfo;
         };
         FcoeConfigVlanRange: {
            (options?: srmService.vim.FcoeConfigVlanRange): srmService.vim.FcoeConfigVlanRange;
         };
         ArrayOfFcoeConfigVlanRange: {
            (options?: srmService.vim.ArrayOfFcoeConfigVlanRange): srmService.vim.ArrayOfFcoeConfigVlanRange;
         };
         FcoeConfigFcoeCapabilities: {
            (options?: srmService.vim.FcoeConfigFcoeCapabilities): srmService.vim.FcoeConfigFcoeCapabilities;
         };
         FcoeConfigFcoeSpecification: {
            (options?: srmService.vim.FcoeConfigFcoeSpecification): srmService.vim.FcoeConfigFcoeSpecification;
         };
         FcoeConfig: {
            (options?: srmService.vim.FcoeConfig): srmService.vim.FcoeConfig;
         };
         HostFeatureCapability: {
            (options?: srmService.vim.HostFeatureCapability): srmService.vim.HostFeatureCapability;
         };
         ArrayOfHostFeatureCapability: {
            (options?: srmService.vim.ArrayOfHostFeatureCapability): srmService.vim.ArrayOfHostFeatureCapability;
         };
         HostFeatureMask: {
            (options?: srmService.vim.HostFeatureMask): srmService.vim.HostFeatureMask;
         };
         ArrayOfHostFeatureMask: {
            (options?: srmService.vim.ArrayOfHostFeatureMask): srmService.vim.ArrayOfHostFeatureMask;
         };
         HostFeatureVersionKey: {
            "faultTolerance": string;
         };
         HostFeatureVersionInfo: {
            (options?: srmService.vim.HostFeatureVersionInfo): srmService.vim.HostFeatureVersionInfo;
         };
         ArrayOfHostFeatureVersionInfo: {
            (options?: srmService.vim.ArrayOfHostFeatureVersionInfo): srmService.vim.ArrayOfHostFeatureVersionInfo;
         };
         ModeInfo: {
            (options?: srmService.vim.ModeInfo): srmService.vim.ModeInfo;
         };
         HostFileAccess: {
            (options?: srmService.vim.HostFileAccess): srmService.vim.HostFileAccess;
         };
         HostFileSystemVolumeInfo: {
            (options?: srmService.vim.HostFileSystemVolumeInfo): srmService.vim.HostFileSystemVolumeInfo;
         };
         FileSystemMountInfoVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         HostFileSystemMountInfo: {
            (options?: srmService.vim.HostFileSystemMountInfo): srmService.vim.HostFileSystemMountInfo;
         };
         ArrayOfHostFileSystemMountInfo: {
            (options?: srmService.vim.ArrayOfHostFileSystemMountInfo): srmService.vim.ArrayOfHostFileSystemMountInfo;
         };
         HostFileSystemVolume: {
            (options?: srmService.vim.HostFileSystemVolume): srmService.vim.HostFileSystemVolume;
         };
         HostNasVolumeSpec: {
            (options?: srmService.vim.HostNasVolumeSpec): srmService.vim.HostNasVolumeSpec;
         };
         HostNasVolumeConfig: {
            (options?: srmService.vim.HostNasVolumeConfig): srmService.vim.HostNasVolumeConfig;
         };
         ArrayOfHostNasVolumeConfig: {
            (options?: srmService.vim.ArrayOfHostNasVolumeConfig): srmService.vim.ArrayOfHostNasVolumeConfig;
         };
         HostNasVolume: {
            (options?: srmService.vim.HostNasVolume): srmService.vim.HostNasVolume;
         };
         HostLocalFileSystemVolumeSpec: {
            (options?: srmService.vim.HostLocalFileSystemVolumeSpec): srmService.vim.HostLocalFileSystemVolumeSpec;
         };
         HostLocalFileSystemVolume: {
            (options?: srmService.vim.HostLocalFileSystemVolume): srmService.vim.HostLocalFileSystemVolume;
         };
         HostVfatVolume: {
            (options?: srmService.vim.HostVfatVolume): srmService.vim.HostVfatVolume;
         };
         HostFirewallConfigRuleSetConfig: {
            (options?: srmService.vim.HostFirewallConfigRuleSetConfig): srmService.vim.HostFirewallConfigRuleSetConfig;
         };
         ArrayOfHostFirewallConfigRuleSetConfig: {
            (options?: srmService.vim.ArrayOfHostFirewallConfigRuleSetConfig): srmService.vim.ArrayOfHostFirewallConfigRuleSetConfig;
         };
         HostFirewallConfig: {
            (options?: srmService.vim.HostFirewallConfig): srmService.vim.HostFirewallConfig;
         };
         HostFirewallDefaultPolicy: {
            (options?: srmService.vim.HostFirewallDefaultPolicy): srmService.vim.HostFirewallDefaultPolicy;
         };
         HostFirewallInfo: {
            (options?: srmService.vim.HostFirewallInfo): srmService.vim.HostFirewallInfo;
         };
         HostFlagInfo: {
            (options?: srmService.vim.HostFlagInfo): srmService.vim.HostFlagInfo;
         };
         HostForceMountedInfo: {
            (options?: srmService.vim.HostForceMountedInfo): srmService.vim.HostForceMountedInfo;
         };
         HostGraphicsInfoGraphicsType: {
            "basic": string;
            "shared": string;
            "direct": string;
         };
         HostGraphicsInfo: {
            (options?: srmService.vim.HostGraphicsInfo): srmService.vim.HostGraphicsInfo;
         };
         ArrayOfHostGraphicsInfo: {
            (options?: srmService.vim.ArrayOfHostGraphicsInfo): srmService.vim.ArrayOfHostGraphicsInfo;
         };
         HostHardwareInfo: {
            (options?: srmService.vim.HostHardwareInfo): srmService.vim.HostHardwareInfo;
         };
         HostSystemInfo: {
            (options?: srmService.vim.HostSystemInfo): srmService.vim.HostSystemInfo;
         };
         HostCpuPowerManagementInfoPolicyType: {
            "off": string;
            "staticPolicy": string;
            "dynamicPolicy": string;
         };
         HostCpuPowerManagementInfo: {
            (options?: srmService.vim.HostCpuPowerManagementInfo): srmService.vim.HostCpuPowerManagementInfo;
         };
         HostCpuInfo: {
            (options?: srmService.vim.HostCpuInfo): srmService.vim.HostCpuInfo;
         };
         HostCpuPackageVendor: {
            "unknown": string;
            "intel": string;
            "amd": string;
         };
         HostCpuPackage: {
            (options?: srmService.vim.HostCpuPackage): srmService.vim.HostCpuPackage;
         };
         ArrayOfHostCpuPackage: {
            (options?: srmService.vim.ArrayOfHostCpuPackage): srmService.vim.ArrayOfHostCpuPackage;
         };
         HostNumaInfo: {
            (options?: srmService.vim.HostNumaInfo): srmService.vim.HostNumaInfo;
         };
         HostNumaNode: {
            (options?: srmService.vim.HostNumaNode): srmService.vim.HostNumaNode;
         };
         ArrayOfHostNumaNode: {
            (options?: srmService.vim.ArrayOfHostNumaNode): srmService.vim.ArrayOfHostNumaNode;
         };
         HostBIOSInfo: {
            (options?: srmService.vim.HostBIOSInfo): srmService.vim.HostBIOSInfo;
         };
         HostReliableMemoryInfo: {
            (options?: srmService.vim.HostReliableMemoryInfo): srmService.vim.HostReliableMemoryInfo;
         };
         HostHardwareElementStatus: {
            "Unknown": string;
            "Green": string;
            "Yellow": string;
            "Red": string;
         };
         HostHardwareElementInfo: {
            (options?: srmService.vim.HostHardwareElementInfo): srmService.vim.HostHardwareElementInfo;
         };
         ArrayOfHostHardwareElementInfo: {
            (options?: srmService.vim.ArrayOfHostHardwareElementInfo): srmService.vim.ArrayOfHostHardwareElementInfo;
         };
         HostStorageOperationalInfo: {
            (options?: srmService.vim.HostStorageOperationalInfo): srmService.vim.HostStorageOperationalInfo;
         };
         ArrayOfHostStorageOperationalInfo: {
            (options?: srmService.vim.ArrayOfHostStorageOperationalInfo): srmService.vim.ArrayOfHostStorageOperationalInfo;
         };
         HostStorageElementInfo: {
            (options?: srmService.vim.HostStorageElementInfo): srmService.vim.HostStorageElementInfo;
         };
         ArrayOfHostStorageElementInfo: {
            (options?: srmService.vim.ArrayOfHostStorageElementInfo): srmService.vim.ArrayOfHostStorageElementInfo;
         };
         HostHardwareStatusInfo: {
            (options?: srmService.vim.HostHardwareStatusInfo): srmService.vim.HostHardwareStatusInfo;
         };
         HealthSystemRuntime: {
            (options?: srmService.vim.HealthSystemRuntime): srmService.vim.HealthSystemRuntime;
         };
         HostHostBusAdapter: {
            (options?: srmService.vim.HostHostBusAdapter): srmService.vim.HostHostBusAdapter;
         };
         ArrayOfHostHostBusAdapter: {
            (options?: srmService.vim.ArrayOfHostHostBusAdapter): srmService.vim.ArrayOfHostHostBusAdapter;
         };
         HostParallelScsiHba: {
            (options?: srmService.vim.HostParallelScsiHba): srmService.vim.HostParallelScsiHba;
         };
         HostBlockHba: {
            (options?: srmService.vim.HostBlockHba): srmService.vim.HostBlockHba;
         };
         FibreChannelPortType: {
            "fabric": string;
            "loop": string;
            "pointToPoint": string;
            "unknown": string;
         };
         HostFibreChannelHba: {
            (options?: srmService.vim.HostFibreChannelHba): srmService.vim.HostFibreChannelHba;
         };
         HostInternetScsiHbaParamValue: {
            (options?: srmService.vim.HostInternetScsiHbaParamValue): srmService.vim.HostInternetScsiHbaParamValue;
         };
         ArrayOfHostInternetScsiHbaParamValue: {
            (options?: srmService.vim.ArrayOfHostInternetScsiHbaParamValue): srmService.vim.ArrayOfHostInternetScsiHbaParamValue;
         };
         HostInternetScsiHbaDiscoveryCapabilities: {
            (options?: srmService.vim.HostInternetScsiHbaDiscoveryCapabilities): srmService.vim.HostInternetScsiHbaDiscoveryCapabilities;
         };
         InternetScsiSnsDiscoveryMethod: {
            "isnsStatic": string;
            "isnsDhcp": string;
            "isnsSlp": string;
         };
         SlpDiscoveryMethod: {
            "slpDhcp": string;
            "slpAutoUnicast": string;
            "slpAutoMulticast": string;
            "slpManual": string;
         };
         HostInternetScsiHbaDiscoveryProperties: {
            (options?: srmService.vim.HostInternetScsiHbaDiscoveryProperties): srmService.vim.HostInternetScsiHbaDiscoveryProperties;
         };
         HostInternetScsiHbaChapAuthenticationType: {
            "chapProhibited": string;
            "chapDiscouraged": string;
            "chapPreferred": string;
            "chapRequired": string;
         };
         HostInternetScsiHbaAuthenticationCapabilities: {
            (options?: srmService.vim.HostInternetScsiHbaAuthenticationCapabilities): srmService.vim.HostInternetScsiHbaAuthenticationCapabilities;
         };
         HostInternetScsiHbaAuthenticationProperties: {
            (options?: srmService.vim.HostInternetScsiHbaAuthenticationProperties): srmService.vim.HostInternetScsiHbaAuthenticationProperties;
         };
         HostInternetScsiHbaDigestType: {
            "digestProhibited": string;
            "digestDiscouraged": string;
            "digestPreferred": string;
            "digestRequired": string;
         };
         HostInternetScsiHbaDigestCapabilities: {
            (options?: srmService.vim.HostInternetScsiHbaDigestCapabilities): srmService.vim.HostInternetScsiHbaDigestCapabilities;
         };
         HostInternetScsiHbaDigestProperties: {
            (options?: srmService.vim.HostInternetScsiHbaDigestProperties): srmService.vim.HostInternetScsiHbaDigestProperties;
         };
         HostInternetScsiHbaIPCapabilities: {
            (options?: srmService.vim.HostInternetScsiHbaIPCapabilities): srmService.vim.HostInternetScsiHbaIPCapabilities;
         };
         HostInternetScsiHbaIPProperties: {
            (options?: srmService.vim.HostInternetScsiHbaIPProperties): srmService.vim.HostInternetScsiHbaIPProperties;
         };
         HostInternetScsiHbaSendTarget: {
            (options?: srmService.vim.HostInternetScsiHbaSendTarget): srmService.vim.HostInternetScsiHbaSendTarget;
         };
         ArrayOfHostInternetScsiHbaSendTarget: {
            (options?: srmService.vim.ArrayOfHostInternetScsiHbaSendTarget): srmService.vim.ArrayOfHostInternetScsiHbaSendTarget;
         };
         HostInternetScsiHbaStaticTargetTargetDiscoveryMethod: {
            "staticMethod": string;
            "sendTargetMethod": string;
            "slpMethod": string;
            "isnsMethod": string;
            "unknownMethod": string;
         };
         HostInternetScsiHbaStaticTarget: {
            (options?: srmService.vim.HostInternetScsiHbaStaticTarget): srmService.vim.HostInternetScsiHbaStaticTarget;
         };
         ArrayOfHostInternetScsiHbaStaticTarget: {
            (options?: srmService.vim.ArrayOfHostInternetScsiHbaStaticTarget): srmService.vim.ArrayOfHostInternetScsiHbaStaticTarget;
         };
         HostInternetScsiHbaTargetSet: {
            (options?: srmService.vim.HostInternetScsiHbaTargetSet): srmService.vim.HostInternetScsiHbaTargetSet;
         };
         HostInternetScsiHbaNetworkBindingSupportType: {
            "notsupported": string;
            "optional": string;
            "required": string;
         };
         HostInternetScsiHba: {
            (options?: srmService.vim.HostInternetScsiHba): srmService.vim.HostInternetScsiHba;
         };
         HostFibreChannelOverEthernetHbaLinkInfo: {
            (options?: srmService.vim.HostFibreChannelOverEthernetHbaLinkInfo): srmService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
         };
         HostFibreChannelOverEthernetHba: {
            (options?: srmService.vim.HostFibreChannelOverEthernetHba): srmService.vim.HostFibreChannelOverEthernetHba;
         };
         HostProxySwitchSpec: {
            (options?: srmService.vim.HostProxySwitchSpec): srmService.vim.HostProxySwitchSpec;
         };
         HostProxySwitchConfig: {
            (options?: srmService.vim.HostProxySwitchConfig): srmService.vim.HostProxySwitchConfig;
         };
         ArrayOfHostProxySwitchConfig: {
            (options?: srmService.vim.ArrayOfHostProxySwitchConfig): srmService.vim.ArrayOfHostProxySwitchConfig;
         };
         HostProxySwitchHostLagConfig: {
            (options?: srmService.vim.HostProxySwitchHostLagConfig): srmService.vim.HostProxySwitchHostLagConfig;
         };
         ArrayOfHostProxySwitchHostLagConfig: {
            (options?: srmService.vim.ArrayOfHostProxySwitchHostLagConfig): srmService.vim.ArrayOfHostProxySwitchHostLagConfig;
         };
         HostProxySwitch: {
            (options?: srmService.vim.HostProxySwitch): srmService.vim.HostProxySwitch;
         };
         ArrayOfHostProxySwitch: {
            (options?: srmService.vim.ArrayOfHostProxySwitch): srmService.vim.ArrayOfHostProxySwitch;
         };
         HostImageAcceptanceLevel: {
            "vmware_certified": string;
            "vmware_accepted": string;
            "partner": string;
            "community": string;
         };
         HostImageProfileSummary: {
            (options?: srmService.vim.HostImageProfileSummary): srmService.vim.HostImageProfileSummary;
         };
         HostIpConfigIpV6AddressConfigType: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         HostIpConfigIpV6AddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         HostIpConfigIpV6Address: {
            (options?: srmService.vim.HostIpConfigIpV6Address): srmService.vim.HostIpConfigIpV6Address;
         };
         ArrayOfHostIpConfigIpV6Address: {
            (options?: srmService.vim.ArrayOfHostIpConfigIpV6Address): srmService.vim.ArrayOfHostIpConfigIpV6Address;
         };
         HostIpConfigIpV6AddressConfiguration: {
            (options?: srmService.vim.HostIpConfigIpV6AddressConfiguration): srmService.vim.HostIpConfigIpV6AddressConfiguration;
         };
         HostIpConfig: {
            (options?: srmService.vim.HostIpConfig): srmService.vim.HostIpConfig;
         };
         HostIpRouteConfig: {
            (options?: srmService.vim.HostIpRouteConfig): srmService.vim.HostIpRouteConfig;
         };
         HostIpRouteConfigSpec: {
            (options?: srmService.vim.HostIpRouteConfigSpec): srmService.vim.HostIpRouteConfigSpec;
         };
         HostIpRouteEntry: {
            (options?: srmService.vim.HostIpRouteEntry): srmService.vim.HostIpRouteEntry;
         };
         ArrayOfHostIpRouteEntry: {
            (options?: srmService.vim.ArrayOfHostIpRouteEntry): srmService.vim.ArrayOfHostIpRouteEntry;
         };
         HostIpRouteOp: {
            (options?: srmService.vim.HostIpRouteOp): srmService.vim.HostIpRouteOp;
         };
         ArrayOfHostIpRouteOp: {
            (options?: srmService.vim.ArrayOfHostIpRouteOp): srmService.vim.ArrayOfHostIpRouteOp;
         };
         HostIpRouteTableConfig: {
            (options?: srmService.vim.HostIpRouteTableConfig): srmService.vim.HostIpRouteTableConfig;
         };
         HostIpRouteTableInfo: {
            (options?: srmService.vim.HostIpRouteTableInfo): srmService.vim.HostIpRouteTableInfo;
         };
         HostIpmiInfo: {
            (options?: srmService.vim.HostIpmiInfo): srmService.vim.HostIpmiInfo;
         };
         IscsiStatus: {
            (options?: srmService.vim.IscsiStatus): srmService.vim.IscsiStatus;
         };
         IscsiPortInfoPathStatus: {
            "notUsed": string;
            "active": string;
            "standBy": string;
            "lastActive": string;
         };
         IscsiPortInfo: {
            (options?: srmService.vim.IscsiPortInfo): srmService.vim.IscsiPortInfo;
         };
         ArrayOfIscsiPortInfo: {
            (options?: srmService.vim.ArrayOfIscsiPortInfo): srmService.vim.ArrayOfIscsiPortInfo;
         };
         IscsiDependencyEntity: {
            (options?: srmService.vim.IscsiDependencyEntity): srmService.vim.IscsiDependencyEntity;
         };
         ArrayOfIscsiDependencyEntity: {
            (options?: srmService.vim.ArrayOfIscsiDependencyEntity): srmService.vim.ArrayOfIscsiDependencyEntity;
         };
         IscsiMigrationDependency: {
            (options?: srmService.vim.IscsiMigrationDependency): srmService.vim.IscsiMigrationDependency;
         };
         KernelModuleSectionInfo: {
            (options?: srmService.vim.KernelModuleSectionInfo): srmService.vim.KernelModuleSectionInfo;
         };
         KernelModuleInfo: {
            (options?: srmService.vim.KernelModuleInfo): srmService.vim.KernelModuleInfo;
         };
         ArrayOfKernelModuleInfo: {
            (options?: srmService.vim.ArrayOfKernelModuleInfo): srmService.vim.ArrayOfKernelModuleInfo;
         };
         HostLicenseSpec: {
            (options?: srmService.vim.HostLicenseSpec): srmService.vim.HostLicenseSpec;
         };
         LinkDiscoveryProtocolConfigProtocolType: {
            "cdp": string;
            "lldp": string;
         };
         LinkDiscoveryProtocolConfigOperationType: {
            "none": string;
            "listen": string;
            "advertise": string;
            "both": string;
         };
         LinkDiscoveryProtocolConfig: {
            (options?: srmService.vim.LinkDiscoveryProtocolConfig): srmService.vim.LinkDiscoveryProtocolConfig;
         };
         HostAccountSpec: {
            (options?: srmService.vim.HostAccountSpec): srmService.vim.HostAccountSpec;
         };
         ArrayOfHostAccountSpec: {
            (options?: srmService.vim.ArrayOfHostAccountSpec): srmService.vim.ArrayOfHostAccountSpec;
         };
         HostPosixAccountSpec: {
            (options?: srmService.vim.HostPosixAccountSpec): srmService.vim.HostPosixAccountSpec;
         };
         HostLocalAuthenticationInfo: {
            (options?: srmService.vim.HostLocalAuthenticationInfo): srmService.vim.HostLocalAuthenticationInfo;
         };
         HostLowLevelProvisioningManagerVmRecoveryInfo: {
            (options?: srmService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo): srmService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo;
         };
         HostLowLevelProvisioningManagerVmMigrationStatus: {
            (options?: srmService.vim.HostLowLevelProvisioningManagerVmMigrationStatus): srmService.vim.HostLowLevelProvisioningManagerVmMigrationStatus;
         };
         HostLowLevelProvisioningManagerReloadTarget: {
            "currentConfig": string;
            "snapshotConfig": string;
         };
         HostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: srmService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec): srmService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: srmService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec): srmService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         HostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: srmService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec): srmService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: srmService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec): srmService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         HostMaintenanceSpec: {
            (options?: srmService.vim.HostMaintenanceSpec): srmService.vim.HostMaintenanceSpec;
         };
         ServiceConsoleReservationInfo: {
            (options?: srmService.vim.ServiceConsoleReservationInfo): srmService.vim.ServiceConsoleReservationInfo;
         };
         VirtualMachineMemoryAllocationPolicy: {
            "swapNone": string;
            "swapSome": string;
            "swapMost": string;
         };
         VirtualMachineMemoryReservationInfo: {
            (options?: srmService.vim.VirtualMachineMemoryReservationInfo): srmService.vim.VirtualMachineMemoryReservationInfo;
         };
         VirtualMachineMemoryReservationSpec: {
            (options?: srmService.vim.VirtualMachineMemoryReservationSpec): srmService.vim.VirtualMachineMemoryReservationSpec;
         };
         HostMemorySpec: {
            (options?: srmService.vim.HostMemorySpec): srmService.vim.HostMemorySpec;
         };
         HostMountMode: {
            "readWrite": string;
            "readOnly": string;
         };
         HostMountInfoInaccessibleReason: {
            "AllPathsDown_Start": string;
            "AllPathsDown_Timeout": string;
            "PermanentDeviceLoss": string;
         };
         HostMountInfo: {
            (options?: srmService.vim.HostMountInfo): srmService.vim.HostMountInfo;
         };
         MultipathState: {
            "standby": string;
            "active": string;
            "disabled": string;
            "dead": string;
            "unknown": string;
         };
         HostMultipathInfoLogicalUnitPolicy: {
            (options?: srmService.vim.HostMultipathInfoLogicalUnitPolicy): srmService.vim.HostMultipathInfoLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnitStorageArrayTypePolicy: {
            (options?: srmService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy): srmService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         };
         HostMultipathInfoFixedLogicalUnitPolicy: {
            (options?: srmService.vim.HostMultipathInfoFixedLogicalUnitPolicy): srmService.vim.HostMultipathInfoFixedLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnit: {
            (options?: srmService.vim.HostMultipathInfoLogicalUnit): srmService.vim.HostMultipathInfoLogicalUnit;
         };
         ArrayOfHostMultipathInfoLogicalUnit: {
            (options?: srmService.vim.ArrayOfHostMultipathInfoLogicalUnit): srmService.vim.ArrayOfHostMultipathInfoLogicalUnit;
         };
         HostMultipathInfoPath: {
            (options?: srmService.vim.HostMultipathInfoPath): srmService.vim.HostMultipathInfoPath;
         };
         ArrayOfHostMultipathInfoPath: {
            (options?: srmService.vim.ArrayOfHostMultipathInfoPath): srmService.vim.ArrayOfHostMultipathInfoPath;
         };
         HostMultipathInfo: {
            (options?: srmService.vim.HostMultipathInfo): srmService.vim.HostMultipathInfo;
         };
         HostMultipathStateInfoPath: {
            (options?: srmService.vim.HostMultipathStateInfoPath): srmService.vim.HostMultipathStateInfoPath;
         };
         ArrayOfHostMultipathStateInfoPath: {
            (options?: srmService.vim.ArrayOfHostMultipathStateInfoPath): srmService.vim.ArrayOfHostMultipathStateInfoPath;
         };
         HostMultipathStateInfo: {
            (options?: srmService.vim.HostMultipathStateInfo): srmService.vim.HostMultipathStateInfo;
         };
         HostNatServicePortForwardSpec: {
            (options?: srmService.vim.HostNatServicePortForwardSpec): srmService.vim.HostNatServicePortForwardSpec;
         };
         ArrayOfHostNatServicePortForwardSpec: {
            (options?: srmService.vim.ArrayOfHostNatServicePortForwardSpec): srmService.vim.ArrayOfHostNatServicePortForwardSpec;
         };
         HostNatServiceNameServiceSpec: {
            (options?: srmService.vim.HostNatServiceNameServiceSpec): srmService.vim.HostNatServiceNameServiceSpec;
         };
         HostNatServiceSpec: {
            (options?: srmService.vim.HostNatServiceSpec): srmService.vim.HostNatServiceSpec;
         };
         HostNatServiceConfig: {
            (options?: srmService.vim.HostNatServiceConfig): srmService.vim.HostNatServiceConfig;
         };
         ArrayOfHostNatServiceConfig: {
            (options?: srmService.vim.ArrayOfHostNatServiceConfig): srmService.vim.ArrayOfHostNatServiceConfig;
         };
         HostNatService: {
            (options?: srmService.vim.HostNatService): srmService.vim.HostNatService;
         };
         ArrayOfHostNatService: {
            (options?: srmService.vim.ArrayOfHostNatService): srmService.vim.ArrayOfHostNatService;
         };
         HostNetCapabilities: {
            (options?: srmService.vim.HostNetCapabilities): srmService.vim.HostNetCapabilities;
         };
         HostNetOffloadCapabilities: {
            (options?: srmService.vim.HostNetOffloadCapabilities): srmService.vim.HostNetOffloadCapabilities;
         };
         HostNetStackInstanceSystemStackKey: {
            "defaultTcpipStack": string;
         };
         HostNetStackInstanceCongestionControlAlgorithmType: {
            "newreno": string;
            "cubic": string;
         };
         HostNetStackInstance: {
            (options?: srmService.vim.HostNetStackInstance): srmService.vim.HostNetStackInstance;
         };
         ArrayOfHostNetStackInstance: {
            (options?: srmService.vim.ArrayOfHostNetStackInstance): srmService.vim.ArrayOfHostNetStackInstance;
         };
         HostNetworkConfigResult: {
            (options?: srmService.vim.HostNetworkConfigResult): srmService.vim.HostNetworkConfigResult;
         };
         HostNetworkConfigNetStackSpec: {
            (options?: srmService.vim.HostNetworkConfigNetStackSpec): srmService.vim.HostNetworkConfigNetStackSpec;
         };
         ArrayOfHostNetworkConfigNetStackSpec: {
            (options?: srmService.vim.ArrayOfHostNetworkConfigNetStackSpec): srmService.vim.ArrayOfHostNetworkConfigNetStackSpec;
         };
         HostNetworkConfig: {
            (options?: srmService.vim.HostNetworkConfig): srmService.vim.HostNetworkConfig;
         };
         HostNetworkInfo: {
            (options?: srmService.vim.HostNetworkInfo): srmService.vim.HostNetworkInfo;
         };
         HostNetworkSecurityPolicy: {
            (options?: srmService.vim.HostNetworkSecurityPolicy): srmService.vim.HostNetworkSecurityPolicy;
         };
         HostNetworkTrafficShapingPolicy: {
            (options?: srmService.vim.HostNetworkTrafficShapingPolicy): srmService.vim.HostNetworkTrafficShapingPolicy;
         };
         HostNicFailureCriteria: {
            (options?: srmService.vim.HostNicFailureCriteria): srmService.vim.HostNicFailureCriteria;
         };
         HostNicOrderPolicy: {
            (options?: srmService.vim.HostNicOrderPolicy): srmService.vim.HostNicOrderPolicy;
         };
         HostNicTeamingPolicy: {
            (options?: srmService.vim.HostNicTeamingPolicy): srmService.vim.HostNicTeamingPolicy;
         };
         HostNetworkPolicy: {
            (options?: srmService.vim.HostNetworkPolicy): srmService.vim.HostNetworkPolicy;
         };
         HostNtpConfig: {
            (options?: srmService.vim.HostNtpConfig): srmService.vim.HostNtpConfig;
         };
         HostNumericSensorHealthState: {
            "unknown": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         HostNumericSensorType: {
            "fan": string;
            "power": string;
            "temperature": string;
            "voltage": string;
            "other": string;
         };
         HostNumericSensorInfo: {
            (options?: srmService.vim.HostNumericSensorInfo): srmService.vim.HostNumericSensorInfo;
         };
         ArrayOfHostNumericSensorInfo: {
            (options?: srmService.vim.ArrayOfHostNumericSensorInfo): srmService.vim.ArrayOfHostNumericSensorInfo;
         };
         HostOpaqueNetworkInfo: {
            (options?: srmService.vim.HostOpaqueNetworkInfo): srmService.vim.HostOpaqueNetworkInfo;
         };
         ArrayOfHostOpaqueNetworkInfo: {
            (options?: srmService.vim.ArrayOfHostOpaqueNetworkInfo): srmService.vim.ArrayOfHostOpaqueNetworkInfo;
         };
         HostOpaqueSwitch: {
            (options?: srmService.vim.HostOpaqueSwitch): srmService.vim.HostOpaqueSwitch;
         };
         ArrayOfHostOpaqueSwitch: {
            (options?: srmService.vim.ArrayOfHostOpaqueSwitch): srmService.vim.ArrayOfHostOpaqueSwitch;
         };
         HostPatchManagerResult: {
            (options?: srmService.vim.HostPatchManagerResult): srmService.vim.HostPatchManagerResult;
         };
         HostPatchManagerReason: {
            "obsoleted": string;
            "missingPatch": string;
            "missingLib": string;
            "hasDependentPatch": string;
            "conflictPatch": string;
            "conflictLib": string;
         };
         HostPatchManagerIntegrityStatus: {
            "validated": string;
            "keyNotFound": string;
            "keyRevoked": string;
            "keyExpired": string;
            "digestMismatch": string;
            "notEnoughSignatures": string;
            "validationError": string;
         };
         HostPatchManagerInstallState: {
            "hostRestarted": string;
            "imageActive": string;
         };
         HostPatchManagerStatusPrerequisitePatch: {
            (options?: srmService.vim.HostPatchManagerStatusPrerequisitePatch): srmService.vim.HostPatchManagerStatusPrerequisitePatch;
         };
         ArrayOfHostPatchManagerStatusPrerequisitePatch: {
            (options?: srmService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch): srmService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch;
         };
         HostPatchManagerStatus: {
            (options?: srmService.vim.HostPatchManagerStatus): srmService.vim.HostPatchManagerStatus;
         };
         ArrayOfHostPatchManagerStatus: {
            (options?: srmService.vim.ArrayOfHostPatchManagerStatus): srmService.vim.ArrayOfHostPatchManagerStatus;
         };
         HostPatchManagerLocator: {
            (options?: srmService.vim.HostPatchManagerLocator): srmService.vim.HostPatchManagerLocator;
         };
         HostPatchManagerPatchManagerOperationSpec: {
            (options?: srmService.vim.HostPatchManagerPatchManagerOperationSpec): srmService.vim.HostPatchManagerPatchManagerOperationSpec;
         };
         HostPathSelectionPolicyOption: {
            (options?: srmService.vim.HostPathSelectionPolicyOption): srmService.vim.HostPathSelectionPolicyOption;
         };
         ArrayOfHostPathSelectionPolicyOption: {
            (options?: srmService.vim.ArrayOfHostPathSelectionPolicyOption): srmService.vim.ArrayOfHostPathSelectionPolicyOption;
         };
         HostPciDevice: {
            (options?: srmService.vim.HostPciDevice): srmService.vim.HostPciDevice;
         };
         ArrayOfHostPciDevice: {
            (options?: srmService.vim.ArrayOfHostPciDevice): srmService.vim.ArrayOfHostPciDevice;
         };
         HostPciPassthruConfig: {
            (options?: srmService.vim.HostPciPassthruConfig): srmService.vim.HostPciPassthruConfig;
         };
         ArrayOfHostPciPassthruConfig: {
            (options?: srmService.vim.ArrayOfHostPciPassthruConfig): srmService.vim.ArrayOfHostPciPassthruConfig;
         };
         HostPciPassthruInfo: {
            (options?: srmService.vim.HostPciPassthruInfo): srmService.vim.HostPciPassthruInfo;
         };
         ArrayOfHostPciPassthruInfo: {
            (options?: srmService.vim.ArrayOfHostPciPassthruInfo): srmService.vim.ArrayOfHostPciPassthruInfo;
         };
         PhysicalNicSpec: {
            (options?: srmService.vim.PhysicalNicSpec): srmService.vim.PhysicalNicSpec;
         };
         PhysicalNicConfig: {
            (options?: srmService.vim.PhysicalNicConfig): srmService.vim.PhysicalNicConfig;
         };
         ArrayOfPhysicalNicConfig: {
            (options?: srmService.vim.ArrayOfPhysicalNicConfig): srmService.vim.ArrayOfPhysicalNicConfig;
         };
         PhysicalNicLinkInfo: {
            (options?: srmService.vim.PhysicalNicLinkInfo): srmService.vim.PhysicalNicLinkInfo;
         };
         ArrayOfPhysicalNicLinkInfo: {
            (options?: srmService.vim.ArrayOfPhysicalNicLinkInfo): srmService.vim.ArrayOfPhysicalNicLinkInfo;
         };
         PhysicalNicHint: {
            (options?: srmService.vim.PhysicalNicHint): srmService.vim.PhysicalNicHint;
         };
         PhysicalNicIpHint: {
            (options?: srmService.vim.PhysicalNicIpHint): srmService.vim.PhysicalNicIpHint;
         };
         ArrayOfPhysicalNicIpHint: {
            (options?: srmService.vim.ArrayOfPhysicalNicIpHint): srmService.vim.ArrayOfPhysicalNicIpHint;
         };
         PhysicalNicNameHint: {
            (options?: srmService.vim.PhysicalNicNameHint): srmService.vim.PhysicalNicNameHint;
         };
         ArrayOfPhysicalNicNameHint: {
            (options?: srmService.vim.ArrayOfPhysicalNicNameHint): srmService.vim.ArrayOfPhysicalNicNameHint;
         };
         PhysicalNicHintInfo: {
            (options?: srmService.vim.PhysicalNicHintInfo): srmService.vim.PhysicalNicHintInfo;
         };
         ArrayOfPhysicalNicHintInfo: {
            (options?: srmService.vim.ArrayOfPhysicalNicHintInfo): srmService.vim.ArrayOfPhysicalNicHintInfo;
         };
         PhysicalNicCdpDeviceCapability: {
            (options?: srmService.vim.PhysicalNicCdpDeviceCapability): srmService.vim.PhysicalNicCdpDeviceCapability;
         };
         PhysicalNicCdpInfo: {
            (options?: srmService.vim.PhysicalNicCdpInfo): srmService.vim.PhysicalNicCdpInfo;
         };
         LinkLayerDiscoveryProtocolInfo: {
            (options?: srmService.vim.LinkLayerDiscoveryProtocolInfo): srmService.vim.LinkLayerDiscoveryProtocolInfo;
         };
         PhysicalNicVmDirectPathGen2SupportedMode: {
            "upt": string;
         };
         PhysicalNicResourcePoolSchedulerDisallowedReason: {
            "userOptOut": string;
            "hardwareUnsupported": string;
         };
         PhysicalNic: {
            (options?: srmService.vim.PhysicalNic): srmService.vim.PhysicalNic;
         };
         ArrayOfPhysicalNic: {
            (options?: srmService.vim.ArrayOfPhysicalNic): srmService.vim.ArrayOfPhysicalNic;
         };
         HostPlugStoreTopologyAdapter: {
            (options?: srmService.vim.HostPlugStoreTopologyAdapter): srmService.vim.HostPlugStoreTopologyAdapter;
         };
         ArrayOfHostPlugStoreTopologyAdapter: {
            (options?: srmService.vim.ArrayOfHostPlugStoreTopologyAdapter): srmService.vim.ArrayOfHostPlugStoreTopologyAdapter;
         };
         HostPlugStoreTopologyPath: {
            (options?: srmService.vim.HostPlugStoreTopologyPath): srmService.vim.HostPlugStoreTopologyPath;
         };
         ArrayOfHostPlugStoreTopologyPath: {
            (options?: srmService.vim.ArrayOfHostPlugStoreTopologyPath): srmService.vim.ArrayOfHostPlugStoreTopologyPath;
         };
         HostPlugStoreTopologyDevice: {
            (options?: srmService.vim.HostPlugStoreTopologyDevice): srmService.vim.HostPlugStoreTopologyDevice;
         };
         ArrayOfHostPlugStoreTopologyDevice: {
            (options?: srmService.vim.ArrayOfHostPlugStoreTopologyDevice): srmService.vim.ArrayOfHostPlugStoreTopologyDevice;
         };
         HostPlugStoreTopologyPlugin: {
            (options?: srmService.vim.HostPlugStoreTopologyPlugin): srmService.vim.HostPlugStoreTopologyPlugin;
         };
         ArrayOfHostPlugStoreTopologyPlugin: {
            (options?: srmService.vim.ArrayOfHostPlugStoreTopologyPlugin): srmService.vim.ArrayOfHostPlugStoreTopologyPlugin;
         };
         HostPlugStoreTopologyTarget: {
            (options?: srmService.vim.HostPlugStoreTopologyTarget): srmService.vim.HostPlugStoreTopologyTarget;
         };
         ArrayOfHostPlugStoreTopologyTarget: {
            (options?: srmService.vim.ArrayOfHostPlugStoreTopologyTarget): srmService.vim.ArrayOfHostPlugStoreTopologyTarget;
         };
         HostPlugStoreTopology: {
            (options?: srmService.vim.HostPlugStoreTopology): srmService.vim.HostPlugStoreTopology;
         };
         PortGroupConnecteeType: {
            "virtualMachine": string;
            "systemManagement": string;
            "host": string;
            "unknown": string;
         };
         HostPortGroupSpec: {
            (options?: srmService.vim.HostPortGroupSpec): srmService.vim.HostPortGroupSpec;
         };
         HostPortGroupConfig: {
            (options?: srmService.vim.HostPortGroupConfig): srmService.vim.HostPortGroupConfig;
         };
         ArrayOfHostPortGroupConfig: {
            (options?: srmService.vim.ArrayOfHostPortGroupConfig): srmService.vim.ArrayOfHostPortGroupConfig;
         };
         HostPortGroupPort: {
            (options?: srmService.vim.HostPortGroupPort): srmService.vim.HostPortGroupPort;
         };
         ArrayOfHostPortGroupPort: {
            (options?: srmService.vim.ArrayOfHostPortGroupPort): srmService.vim.ArrayOfHostPortGroupPort;
         };
         HostPortGroup: {
            (options?: srmService.vim.HostPortGroup): srmService.vim.HostPortGroup;
         };
         ArrayOfHostPortGroup: {
            (options?: srmService.vim.ArrayOfHostPortGroup): srmService.vim.ArrayOfHostPortGroup;
         };
         HostPowerPolicy: {
            (options?: srmService.vim.HostPowerPolicy): srmService.vim.HostPowerPolicy;
         };
         ArrayOfHostPowerPolicy: {
            (options?: srmService.vim.ArrayOfHostPowerPolicy): srmService.vim.ArrayOfHostPowerPolicy;
         };
         PowerSystemCapability: {
            (options?: srmService.vim.PowerSystemCapability): srmService.vim.PowerSystemCapability;
         };
         PowerSystemInfo: {
            (options?: srmService.vim.PowerSystemInfo): srmService.vim.PowerSystemInfo;
         };
         HostResignatureRescanResult: {
            (options?: srmService.vim.HostResignatureRescanResult): srmService.vim.HostResignatureRescanResult;
         };
         HostFirewallRulesetIpNetwork: {
            (options?: srmService.vim.HostFirewallRulesetIpNetwork): srmService.vim.HostFirewallRulesetIpNetwork;
         };
         ArrayOfHostFirewallRulesetIpNetwork: {
            (options?: srmService.vim.ArrayOfHostFirewallRulesetIpNetwork): srmService.vim.ArrayOfHostFirewallRulesetIpNetwork;
         };
         HostFirewallRulesetIpList: {
            (options?: srmService.vim.HostFirewallRulesetIpList): srmService.vim.HostFirewallRulesetIpList;
         };
         HostFirewallRulesetRulesetSpec: {
            (options?: srmService.vim.HostFirewallRulesetRulesetSpec): srmService.vim.HostFirewallRulesetRulesetSpec;
         };
         HostFirewallRuleDirection: {
            "inbound": string;
            "outbound": string;
         };
         HostFirewallRulePortType: {
            "src": string;
            "dst": string;
         };
         HostFirewallRuleProtocol: {
            "tcp": string;
            "udp": string;
         };
         HostFirewallRule: {
            (options?: srmService.vim.HostFirewallRule): srmService.vim.HostFirewallRule;
         };
         ArrayOfHostFirewallRule: {
            (options?: srmService.vim.ArrayOfHostFirewallRule): srmService.vim.ArrayOfHostFirewallRule;
         };
         HostFirewallRuleset: {
            (options?: srmService.vim.HostFirewallRuleset): srmService.vim.HostFirewallRuleset;
         };
         ArrayOfHostFirewallRuleset: {
            (options?: srmService.vim.ArrayOfHostFirewallRuleset): srmService.vim.ArrayOfHostFirewallRuleset;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfoState: {
            "inactive": string;
            "active": string;
            "deactivating": string;
            "activating": string;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: srmService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo): srmService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: srmService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo): srmService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         HostRuntimeInfoNetworkRuntimeInfo: {
            (options?: srmService.vim.HostRuntimeInfoNetworkRuntimeInfo): srmService.vim.HostRuntimeInfoNetworkRuntimeInfo;
         };
         HostRuntimeInfo: {
            (options?: srmService.vim.HostRuntimeInfo): srmService.vim.HostRuntimeInfo;
         };
         HostScsiDiskPartition: {
            (options?: srmService.vim.HostScsiDiskPartition): srmService.vim.HostScsiDiskPartition;
         };
         ArrayOfHostScsiDiskPartition: {
            (options?: srmService.vim.ArrayOfHostScsiDiskPartition): srmService.vim.ArrayOfHostScsiDiskPartition;
         };
         HostScsiDisk: {
            (options?: srmService.vim.HostScsiDisk): srmService.vim.HostScsiDisk;
         };
         ArrayOfHostScsiDisk: {
            (options?: srmService.vim.ArrayOfHostScsiDisk): srmService.vim.ArrayOfHostScsiDisk;
         };
         ScsiLunType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "opticalDevice": string;
            "mediaChanger": string;
            "communications": string;
            "storageArrayController": string;
            "enclosure": string;
            "unknown": string;
         };
         ScsiLunCapabilities: {
            (options?: srmService.vim.ScsiLunCapabilities): srmService.vim.ScsiLunCapabilities;
         };
         ScsiLunDurableName: {
            (options?: srmService.vim.ScsiLunDurableName): srmService.vim.ScsiLunDurableName;
         };
         ArrayOfScsiLunDurableName: {
            (options?: srmService.vim.ArrayOfScsiLunDurableName): srmService.vim.ArrayOfScsiLunDurableName;
         };
         ScsiLunState: {
            "unknownState": string;
            "ok": string;
            "error": string;
            "off": string;
            "quiesced": string;
            "degraded": string;
            "lostCommunication": string;
            "timeout": string;
         };
         ScsiLunDescriptorQuality: {
            "highQuality": string;
            "mediumQuality": string;
            "lowQuality": string;
            "unknownQuality": string;
         };
         ScsiLunDescriptor: {
            (options?: srmService.vim.ScsiLunDescriptor): srmService.vim.ScsiLunDescriptor;
         };
         ArrayOfScsiLunDescriptor: {
            (options?: srmService.vim.ArrayOfScsiLunDescriptor): srmService.vim.ArrayOfScsiLunDescriptor;
         };
         ScsiLunVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         ScsiLun: {
            (options?: srmService.vim.ScsiLun): srmService.vim.ScsiLun;
         };
         ArrayOfScsiLun: {
            (options?: srmService.vim.ArrayOfScsiLun): srmService.vim.ArrayOfScsiLun;
         };
         HostScsiTopologyInterface: {
            (options?: srmService.vim.HostScsiTopologyInterface): srmService.vim.HostScsiTopologyInterface;
         };
         ArrayOfHostScsiTopologyInterface: {
            (options?: srmService.vim.ArrayOfHostScsiTopologyInterface): srmService.vim.ArrayOfHostScsiTopologyInterface;
         };
         HostScsiTopologyTarget: {
            (options?: srmService.vim.HostScsiTopologyTarget): srmService.vim.HostScsiTopologyTarget;
         };
         ArrayOfHostScsiTopologyTarget: {
            (options?: srmService.vim.ArrayOfHostScsiTopologyTarget): srmService.vim.ArrayOfHostScsiTopologyTarget;
         };
         HostScsiTopologyLun: {
            (options?: srmService.vim.HostScsiTopologyLun): srmService.vim.HostScsiTopologyLun;
         };
         ArrayOfHostScsiTopologyLun: {
            (options?: srmService.vim.ArrayOfHostScsiTopologyLun): srmService.vim.ArrayOfHostScsiTopologyLun;
         };
         HostScsiTopology: {
            (options?: srmService.vim.HostScsiTopology): srmService.vim.HostScsiTopology;
         };
         HostSecuritySpec: {
            (options?: srmService.vim.HostSecuritySpec): srmService.vim.HostSecuritySpec;
         };
         HostServicePolicy: {
            "on": string;
            "automatic": string;
            "off": string;
         };
         HostServiceSourcePackage: {
            (options?: srmService.vim.HostServiceSourcePackage): srmService.vim.HostServiceSourcePackage;
         };
         HostService: {
            (options?: srmService.vim.HostService): srmService.vim.HostService;
         };
         ArrayOfHostService: {
            (options?: srmService.vim.ArrayOfHostService): srmService.vim.ArrayOfHostService;
         };
         HostServiceConfig: {
            (options?: srmService.vim.HostServiceConfig): srmService.vim.HostServiceConfig;
         };
         ArrayOfHostServiceConfig: {
            (options?: srmService.vim.ArrayOfHostServiceConfig): srmService.vim.ArrayOfHostServiceConfig;
         };
         HostServiceInfo: {
            (options?: srmService.vim.HostServiceInfo): srmService.vim.HostServiceInfo;
         };
         HostSnmpDestination: {
            (options?: srmService.vim.HostSnmpDestination): srmService.vim.HostSnmpDestination;
         };
         ArrayOfHostSnmpDestination: {
            (options?: srmService.vim.ArrayOfHostSnmpDestination): srmService.vim.ArrayOfHostSnmpDestination;
         };
         HostSnmpConfigSpec: {
            (options?: srmService.vim.HostSnmpConfigSpec): srmService.vim.HostSnmpConfigSpec;
         };
         HostSnmpAgentCapability: {
            "COMPLETE": string;
            "DIAGNOSTICS": string;
            "CONFIGURATION": string;
         };
         HostSnmpSystemAgentLimits: {
            (options?: srmService.vim.HostSnmpSystemAgentLimits): srmService.vim.HostSnmpSystemAgentLimits;
         };
         HostSriovConfig: {
            (options?: srmService.vim.HostSriovConfig): srmService.vim.HostSriovConfig;
         };
         HostSriovInfo: {
            (options?: srmService.vim.HostSriovInfo): srmService.vim.HostSriovInfo;
         };
         HostSslThumbprintInfo: {
            (options?: srmService.vim.HostSslThumbprintInfo): srmService.vim.HostSslThumbprintInfo;
         };
         ArrayOfHostSslThumbprintInfo: {
            (options?: srmService.vim.ArrayOfHostSslThumbprintInfo): srmService.vim.ArrayOfHostSslThumbprintInfo;
         };
         HostStorageArrayTypePolicyOption: {
            (options?: srmService.vim.HostStorageArrayTypePolicyOption): srmService.vim.HostStorageArrayTypePolicyOption;
         };
         ArrayOfHostStorageArrayTypePolicyOption: {
            (options?: srmService.vim.ArrayOfHostStorageArrayTypePolicyOption): srmService.vim.ArrayOfHostStorageArrayTypePolicyOption;
         };
         HostStorageDeviceInfo: {
            (options?: srmService.vim.HostStorageDeviceInfo): srmService.vim.HostStorageDeviceInfo;
         };
         HostHardwareSummary: {
            (options?: srmService.vim.HostHardwareSummary): srmService.vim.HostHardwareSummary;
         };
         HostListSummaryQuickStats: {
            (options?: srmService.vim.HostListSummaryQuickStats): srmService.vim.HostListSummaryQuickStats;
         };
         HostConfigSummary: {
            (options?: srmService.vim.HostConfigSummary): srmService.vim.HostConfigSummary;
         };
         HostListSummary: {
            (options?: srmService.vim.HostListSummary): srmService.vim.HostListSummary;
         };
         HostSystemHealthInfo: {
            (options?: srmService.vim.HostSystemHealthInfo): srmService.vim.HostSystemHealthInfo;
         };
         HostSystemIdentificationInfoIdentifier: {
            "AssetTag": string;
            "ServiceTag": string;
            "OemSpecificString": string;
         };
         HostSystemIdentificationInfo: {
            (options?: srmService.vim.HostSystemIdentificationInfo): srmService.vim.HostSystemIdentificationInfo;
         };
         ArrayOfHostSystemIdentificationInfo: {
            (options?: srmService.vim.ArrayOfHostSystemIdentificationInfo): srmService.vim.ArrayOfHostSystemIdentificationInfo;
         };
         HostSystemResourceInfo: {
            (options?: srmService.vim.HostSystemResourceInfo): srmService.vim.HostSystemResourceInfo;
         };
         ArrayOfHostSystemResourceInfo: {
            (options?: srmService.vim.ArrayOfHostSystemResourceInfo): srmService.vim.ArrayOfHostSystemResourceInfo;
         };
         HostSystemSwapConfigurationSystemSwapOption: {
            (options?: srmService.vim.HostSystemSwapConfigurationSystemSwapOption): srmService.vim.HostSystemSwapConfigurationSystemSwapOption;
         };
         ArrayOfHostSystemSwapConfigurationSystemSwapOption: {
            (options?: srmService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption): srmService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption;
         };
         HostSystemSwapConfigurationDisabledOption: {
            (options?: srmService.vim.HostSystemSwapConfigurationDisabledOption): srmService.vim.HostSystemSwapConfigurationDisabledOption;
         };
         HostSystemSwapConfigurationHostCacheOption: {
            (options?: srmService.vim.HostSystemSwapConfigurationHostCacheOption): srmService.vim.HostSystemSwapConfigurationHostCacheOption;
         };
         HostSystemSwapConfigurationHostLocalSwapOption: {
            (options?: srmService.vim.HostSystemSwapConfigurationHostLocalSwapOption): srmService.vim.HostSystemSwapConfigurationHostLocalSwapOption;
         };
         HostSystemSwapConfigurationDatastoreOption: {
            (options?: srmService.vim.HostSystemSwapConfigurationDatastoreOption): srmService.vim.HostSystemSwapConfigurationDatastoreOption;
         };
         HostSystemSwapConfiguration: {
            (options?: srmService.vim.HostSystemSwapConfiguration): srmService.vim.HostSystemSwapConfiguration;
         };
         HostTargetTransport: {
            (options?: srmService.vim.HostTargetTransport): srmService.vim.HostTargetTransport;
         };
         HostParallelScsiTargetTransport: {
            (options?: srmService.vim.HostParallelScsiTargetTransport): srmService.vim.HostParallelScsiTargetTransport;
         };
         HostBlockAdapterTargetTransport: {
            (options?: srmService.vim.HostBlockAdapterTargetTransport): srmService.vim.HostBlockAdapterTargetTransport;
         };
         HostFibreChannelTargetTransport: {
            (options?: srmService.vim.HostFibreChannelTargetTransport): srmService.vim.HostFibreChannelTargetTransport;
         };
         HostInternetScsiTargetTransport: {
            (options?: srmService.vim.HostInternetScsiTargetTransport): srmService.vim.HostInternetScsiTargetTransport;
         };
         HostFibreChannelOverEthernetTargetTransport: {
            (options?: srmService.vim.HostFibreChannelOverEthernetTargetTransport): srmService.vim.HostFibreChannelOverEthernetTargetTransport;
         };
         HostTpmAttestationReport: {
            (options?: srmService.vim.HostTpmAttestationReport): srmService.vim.HostTpmAttestationReport;
         };
         HostTpmBootSecurityOptionEventDetails: {
            (options?: srmService.vim.HostTpmBootSecurityOptionEventDetails): srmService.vim.HostTpmBootSecurityOptionEventDetails;
         };
         HostTpmCommandEventDetails: {
            (options?: srmService.vim.HostTpmCommandEventDetails): srmService.vim.HostTpmCommandEventDetails;
         };
         HostDigestInfoDigestMethodType: {
            "SHA1": string;
            "MD5": string;
         };
         HostDigestInfo: {
            (options?: srmService.vim.HostDigestInfo): srmService.vim.HostDigestInfo;
         };
         HostTpmDigestInfo: {
            (options?: srmService.vim.HostTpmDigestInfo): srmService.vim.HostTpmDigestInfo;
         };
         ArrayOfHostTpmDigestInfo: {
            (options?: srmService.vim.ArrayOfHostTpmDigestInfo): srmService.vim.ArrayOfHostTpmDigestInfo;
         };
         HostTpmEventDetails: {
            (options?: srmService.vim.HostTpmEventDetails): srmService.vim.HostTpmEventDetails;
         };
         HostTpmEventLogEntry: {
            (options?: srmService.vim.HostTpmEventLogEntry): srmService.vim.HostTpmEventLogEntry;
         };
         ArrayOfHostTpmEventLogEntry: {
            (options?: srmService.vim.ArrayOfHostTpmEventLogEntry): srmService.vim.ArrayOfHostTpmEventLogEntry;
         };
         HostTpmOptionEventDetails: {
            (options?: srmService.vim.HostTpmOptionEventDetails): srmService.vim.HostTpmOptionEventDetails;
         };
         HostTpmSoftwareComponentEventDetails: {
            (options?: srmService.vim.HostTpmSoftwareComponentEventDetails): srmService.vim.HostTpmSoftwareComponentEventDetails;
         };
         HostUnresolvedVmfsExtentUnresolvedReason: {
            "diskIdMismatch": string;
            "uuidConflict": string;
         };
         HostUnresolvedVmfsExtent: {
            (options?: srmService.vim.HostUnresolvedVmfsExtent): srmService.vim.HostUnresolvedVmfsExtent;
         };
         ArrayOfHostUnresolvedVmfsExtent: {
            (options?: srmService.vim.ArrayOfHostUnresolvedVmfsExtent): srmService.vim.ArrayOfHostUnresolvedVmfsExtent;
         };
         HostUnresolvedVmfsResignatureSpec: {
            (options?: srmService.vim.HostUnresolvedVmfsResignatureSpec): srmService.vim.HostUnresolvedVmfsResignatureSpec;
         };
         HostUnresolvedVmfsResolutionResult: {
            (options?: srmService.vim.HostUnresolvedVmfsResolutionResult): srmService.vim.HostUnresolvedVmfsResolutionResult;
         };
         ArrayOfHostUnresolvedVmfsResolutionResult: {
            (options?: srmService.vim.ArrayOfHostUnresolvedVmfsResolutionResult): srmService.vim.ArrayOfHostUnresolvedVmfsResolutionResult;
         };
         HostUnresolvedVmfsResolutionSpecVmfsUuidResolution: {
            "resignature": string;
            "forceMount": string;
         };
         HostUnresolvedVmfsResolutionSpec: {
            (options?: srmService.vim.HostUnresolvedVmfsResolutionSpec): srmService.vim.HostUnresolvedVmfsResolutionSpec;
         };
         ArrayOfHostUnresolvedVmfsResolutionSpec: {
            (options?: srmService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec): srmService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec;
         };
         HostUnresolvedVmfsVolumeResolveStatus: {
            (options?: srmService.vim.HostUnresolvedVmfsVolumeResolveStatus): srmService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         };
         HostUnresolvedVmfsVolume: {
            (options?: srmService.vim.HostUnresolvedVmfsVolume): srmService.vim.HostUnresolvedVmfsVolume;
         };
         ArrayOfHostUnresolvedVmfsVolume: {
            (options?: srmService.vim.ArrayOfHostUnresolvedVmfsVolume): srmService.vim.ArrayOfHostUnresolvedVmfsVolume;
         };
         HostVFlashManagerVFlashResourceConfigSpec: {
            (options?: srmService.vim.HostVFlashManagerVFlashResourceConfigSpec): srmService.vim.HostVFlashManagerVFlashResourceConfigSpec;
         };
         HostVFlashManagerVFlashResourceConfigInfo: {
            (options?: srmService.vim.HostVFlashManagerVFlashResourceConfigInfo): srmService.vim.HostVFlashManagerVFlashResourceConfigInfo;
         };
         HostVFlashManagerVFlashResourceRunTimeInfo: {
            (options?: srmService.vim.HostVFlashManagerVFlashResourceRunTimeInfo): srmService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
         };
         HostVFlashManagerVFlashCacheConfigSpec: {
            (options?: srmService.vim.HostVFlashManagerVFlashCacheConfigSpec): srmService.vim.HostVFlashManagerVFlashCacheConfigSpec;
         };
         HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: srmService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): srmService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: srmService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): srmService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         HostVFlashManagerVFlashCacheConfigInfo: {
            (options?: srmService.vim.HostVFlashManagerVFlashCacheConfigInfo): srmService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         };
         HostVFlashManagerVFlashConfigInfo: {
            (options?: srmService.vim.HostVFlashManagerVFlashConfigInfo): srmService.vim.HostVFlashManagerVFlashConfigInfo;
         };
         HostVFlashResourceConfigurationResult: {
            (options?: srmService.vim.HostVFlashResourceConfigurationResult): srmService.vim.HostVFlashResourceConfigurationResult;
         };
         HostVMotionConfig: {
            (options?: srmService.vim.HostVMotionConfig): srmService.vim.HostVMotionConfig;
         };
         HostVMotionInfo: {
            (options?: srmService.vim.HostVMotionInfo): srmService.vim.HostVMotionInfo;
         };
         HostVMotionNetConfig: {
            (options?: srmService.vim.HostVMotionNetConfig): srmService.vim.HostVMotionNetConfig;
         };
         HostVffsSpec: {
            (options?: srmService.vim.HostVffsSpec): srmService.vim.HostVffsSpec;
         };
         HostVffsVolume: {
            (options?: srmService.vim.HostVffsVolume): srmService.vim.HostVffsVolume;
         };
         HostVirtualNicSpec: {
            (options?: srmService.vim.HostVirtualNicSpec): srmService.vim.HostVirtualNicSpec;
         };
         HostVirtualNicConfig: {
            (options?: srmService.vim.HostVirtualNicConfig): srmService.vim.HostVirtualNicConfig;
         };
         ArrayOfHostVirtualNicConfig: {
            (options?: srmService.vim.ArrayOfHostVirtualNicConfig): srmService.vim.ArrayOfHostVirtualNicConfig;
         };
         HostVirtualNic: {
            (options?: srmService.vim.HostVirtualNic): srmService.vim.HostVirtualNic;
         };
         ArrayOfHostVirtualNic: {
            (options?: srmService.vim.ArrayOfHostVirtualNic): srmService.vim.ArrayOfHostVirtualNic;
         };
         HostVirtualNicConnection: {
            (options?: srmService.vim.HostVirtualNicConnection): srmService.vim.HostVirtualNicConnection;
         };
         HostVirtualNicManagerNicType: {
            "vmotion": string;
            "faultToleranceLogging": string;
            "vSphereReplication": string;
            "management": string;
            "vsan": string;
         };
         HostVirtualNicManagerNicTypeSelection: {
            (options?: srmService.vim.HostVirtualNicManagerNicTypeSelection): srmService.vim.HostVirtualNicManagerNicTypeSelection;
         };
         ArrayOfHostVirtualNicManagerNicTypeSelection: {
            (options?: srmService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection): srmService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection;
         };
         VirtualNicManagerNetConfig: {
            (options?: srmService.vim.VirtualNicManagerNetConfig): srmService.vim.VirtualNicManagerNetConfig;
         };
         ArrayOfVirtualNicManagerNetConfig: {
            (options?: srmService.vim.ArrayOfVirtualNicManagerNetConfig): srmService.vim.ArrayOfVirtualNicManagerNetConfig;
         };
         HostVirtualNicManagerInfo: {
            (options?: srmService.vim.HostVirtualNicManagerInfo): srmService.vim.HostVirtualNicManagerInfo;
         };
         HostVirtualSwitchBridge: {
            (options?: srmService.vim.HostVirtualSwitchBridge): srmService.vim.HostVirtualSwitchBridge;
         };
         HostVirtualSwitchAutoBridge: {
            (options?: srmService.vim.HostVirtualSwitchAutoBridge): srmService.vim.HostVirtualSwitchAutoBridge;
         };
         HostVirtualSwitchSimpleBridge: {
            (options?: srmService.vim.HostVirtualSwitchSimpleBridge): srmService.vim.HostVirtualSwitchSimpleBridge;
         };
         HostVirtualSwitchBondBridge: {
            (options?: srmService.vim.HostVirtualSwitchBondBridge): srmService.vim.HostVirtualSwitchBondBridge;
         };
         HostVirtualSwitchBeaconConfig: {
            (options?: srmService.vim.HostVirtualSwitchBeaconConfig): srmService.vim.HostVirtualSwitchBeaconConfig;
         };
         HostVirtualSwitchSpec: {
            (options?: srmService.vim.HostVirtualSwitchSpec): srmService.vim.HostVirtualSwitchSpec;
         };
         HostVirtualSwitchConfig: {
            (options?: srmService.vim.HostVirtualSwitchConfig): srmService.vim.HostVirtualSwitchConfig;
         };
         ArrayOfHostVirtualSwitchConfig: {
            (options?: srmService.vim.ArrayOfHostVirtualSwitchConfig): srmService.vim.ArrayOfHostVirtualSwitchConfig;
         };
         HostVirtualSwitch: {
            (options?: srmService.vim.HostVirtualSwitch): srmService.vim.HostVirtualSwitch;
         };
         ArrayOfHostVirtualSwitch: {
            (options?: srmService.vim.ArrayOfHostVirtualSwitch): srmService.vim.ArrayOfHostVirtualSwitch;
         };
         HostVmciAccessManagerMode: {
            "grant": string;
            "replace": string;
            "revoke": string;
         };
         HostVmciAccessManagerAccessSpec: {
            (options?: srmService.vim.HostVmciAccessManagerAccessSpec): srmService.vim.HostVmciAccessManagerAccessSpec;
         };
         ArrayOfHostVmciAccessManagerAccessSpec: {
            (options?: srmService.vim.ArrayOfHostVmciAccessManagerAccessSpec): srmService.vim.ArrayOfHostVmciAccessManagerAccessSpec;
         };
         HostVmfsRescanResult: {
            (options?: srmService.vim.HostVmfsRescanResult): srmService.vim.HostVmfsRescanResult;
         };
         ArrayOfHostVmfsRescanResult: {
            (options?: srmService.vim.ArrayOfHostVmfsRescanResult): srmService.vim.ArrayOfHostVmfsRescanResult;
         };
         HostVmfsSpec: {
            (options?: srmService.vim.HostVmfsSpec): srmService.vim.HostVmfsSpec;
         };
         HostVmfsVolume: {
            (options?: srmService.vim.HostVmfsVolume): srmService.vim.HostVmfsVolume;
         };
         HostVsanInternalSystemCmmdsQuery: {
            (options?: srmService.vim.HostVsanInternalSystemCmmdsQuery): srmService.vim.HostVsanInternalSystemCmmdsQuery;
         };
         ArrayOfHostVsanInternalSystemCmmdsQuery: {
            (options?: srmService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery): srmService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery;
         };
         NetDhcpConfigInfoDhcpOptions: {
            (options?: srmService.vim.NetDhcpConfigInfoDhcpOptions): srmService.vim.NetDhcpConfigInfoDhcpOptions;
         };
         NetDhcpConfigInfo: {
            (options?: srmService.vim.NetDhcpConfigInfo): srmService.vim.NetDhcpConfigInfo;
         };
         NetDhcpConfigSpecDhcpOptionsSpec: {
            (options?: srmService.vim.NetDhcpConfigSpecDhcpOptionsSpec): srmService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         };
         NetDhcpConfigSpec: {
            (options?: srmService.vim.NetDhcpConfigSpec): srmService.vim.NetDhcpConfigSpec;
         };
         NetDnsConfigInfo: {
            (options?: srmService.vim.NetDnsConfigInfo): srmService.vim.NetDnsConfigInfo;
         };
         NetDnsConfigSpec: {
            (options?: srmService.vim.NetDnsConfigSpec): srmService.vim.NetDnsConfigSpec;
         };
         NetIpConfigInfoIpAddressOrigin: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         NetIpConfigInfoIpAddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         NetIpConfigInfoIpAddress: {
            (options?: srmService.vim.NetIpConfigInfoIpAddress): srmService.vim.NetIpConfigInfoIpAddress;
         };
         ArrayOfNetIpConfigInfoIpAddress: {
            (options?: srmService.vim.ArrayOfNetIpConfigInfoIpAddress): srmService.vim.ArrayOfNetIpConfigInfoIpAddress;
         };
         NetIpConfigInfo: {
            (options?: srmService.vim.NetIpConfigInfo): srmService.vim.NetIpConfigInfo;
         };
         NetIpConfigSpecIpAddressSpec: {
            (options?: srmService.vim.NetIpConfigSpecIpAddressSpec): srmService.vim.NetIpConfigSpecIpAddressSpec;
         };
         ArrayOfNetIpConfigSpecIpAddressSpec: {
            (options?: srmService.vim.ArrayOfNetIpConfigSpecIpAddressSpec): srmService.vim.ArrayOfNetIpConfigSpecIpAddressSpec;
         };
         NetIpConfigSpec: {
            (options?: srmService.vim.NetIpConfigSpec): srmService.vim.NetIpConfigSpec;
         };
         NetIpRouteConfigInfoGateway: {
            (options?: srmService.vim.NetIpRouteConfigInfoGateway): srmService.vim.NetIpRouteConfigInfoGateway;
         };
         NetIpRouteConfigInfoIpRoute: {
            (options?: srmService.vim.NetIpRouteConfigInfoIpRoute): srmService.vim.NetIpRouteConfigInfoIpRoute;
         };
         ArrayOfNetIpRouteConfigInfoIpRoute: {
            (options?: srmService.vim.ArrayOfNetIpRouteConfigInfoIpRoute): srmService.vim.ArrayOfNetIpRouteConfigInfoIpRoute;
         };
         NetIpRouteConfigInfo: {
            (options?: srmService.vim.NetIpRouteConfigInfo): srmService.vim.NetIpRouteConfigInfo;
         };
         NetIpRouteConfigSpecGatewaySpec: {
            (options?: srmService.vim.NetIpRouteConfigSpecGatewaySpec): srmService.vim.NetIpRouteConfigSpecGatewaySpec;
         };
         NetIpRouteConfigSpecIpRouteSpec: {
            (options?: srmService.vim.NetIpRouteConfigSpecIpRouteSpec): srmService.vim.NetIpRouteConfigSpecIpRouteSpec;
         };
         ArrayOfNetIpRouteConfigSpecIpRouteSpec: {
            (options?: srmService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec): srmService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec;
         };
         NetIpRouteConfigSpec: {
            (options?: srmService.vim.NetIpRouteConfigSpec): srmService.vim.NetIpRouteConfigSpec;
         };
         NetIpStackInfoEntryType: {
            "other": string;
            "invalid": string;
            "dynamic": string;
            "manual": string;
         };
         NetIpStackInfoPreference: {
            "reserved": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         NetIpStackInfoNetToMedia: {
            (options?: srmService.vim.NetIpStackInfoNetToMedia): srmService.vim.NetIpStackInfoNetToMedia;
         };
         ArrayOfNetIpStackInfoNetToMedia: {
            (options?: srmService.vim.ArrayOfNetIpStackInfoNetToMedia): srmService.vim.ArrayOfNetIpStackInfoNetToMedia;
         };
         NetIpStackInfoDefaultRouter: {
            (options?: srmService.vim.NetIpStackInfoDefaultRouter): srmService.vim.NetIpStackInfoDefaultRouter;
         };
         ArrayOfNetIpStackInfoDefaultRouter: {
            (options?: srmService.vim.ArrayOfNetIpStackInfoDefaultRouter): srmService.vim.ArrayOfNetIpStackInfoDefaultRouter;
         };
         NetIpStackInfo: {
            (options?: srmService.vim.NetIpStackInfo): srmService.vim.NetIpStackInfo;
         };
         NetBIOSConfigInfoMode: {
            "unknown": string;
            "enabled": string;
            "disabled": string;
            "enabledViaDHCP": string;
         };
         NetBIOSConfigInfo: {
            (options?: srmService.vim.NetBIOSConfigInfo): srmService.vim.NetBIOSConfigInfo;
         };
         WinNetBIOSConfigInfo: {
            (options?: srmService.vim.WinNetBIOSConfigInfo): srmService.vim.WinNetBIOSConfigInfo;
         };
         ArrayUpdateOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         ArrayUpdateSpec: {
            (options?: srmService.vim.ArrayUpdateSpec): srmService.vim.ArrayUpdateSpec;
         };
         BoolOption: {
            (options?: srmService.vim.BoolOption): srmService.vim.BoolOption;
         };
         ChoiceOption: {
            (options?: srmService.vim.ChoiceOption): srmService.vim.ChoiceOption;
         };
         FloatOption: {
            (options?: srmService.vim.FloatOption): srmService.vim.FloatOption;
         };
         IntOption: {
            (options?: srmService.vim.IntOption): srmService.vim.IntOption;
         };
         LongOption: {
            (options?: srmService.vim.LongOption): srmService.vim.LongOption;
         };
         OptionDef: {
            (options?: srmService.vim.OptionDef): srmService.vim.OptionDef;
         };
         ArrayOfOptionDef: {
            (options?: srmService.vim.ArrayOfOptionDef): srmService.vim.ArrayOfOptionDef;
         };
         OptionType: {
            (options?: srmService.vim.OptionType): srmService.vim.OptionType;
         };
         OptionValue: {
            (options?: srmService.vim.OptionValue): srmService.vim.OptionValue;
         };
         ArrayOfOptionValue: {
            (options?: srmService.vim.ArrayOfOptionValue): srmService.vim.ArrayOfOptionValue;
         };
         StringOption: {
            (options?: srmService.vim.StringOption): srmService.vim.StringOption;
         };
         ApplyProfile: {
            (options?: srmService.vim.ApplyProfile): srmService.vim.ApplyProfile;
         };
         ArrayOfApplyProfile: {
            (options?: srmService.vim.ArrayOfApplyProfile): srmService.vim.ArrayOfApplyProfile;
         };
         ProfileApplyProfileElement: {
            (options?: srmService.vim.ProfileApplyProfileElement): srmService.vim.ProfileApplyProfileElement;
         };
         ProfileApplyProfileProperty: {
            (options?: srmService.vim.ProfileApplyProfileProperty): srmService.vim.ProfileApplyProfileProperty;
         };
         ArrayOfProfileApplyProfileProperty: {
            (options?: srmService.vim.ArrayOfProfileApplyProfileProperty): srmService.vim.ArrayOfProfileApplyProfileProperty;
         };
         ComplianceLocator: {
            (options?: srmService.vim.ComplianceLocator): srmService.vim.ComplianceLocator;
         };
         ArrayOfComplianceLocator: {
            (options?: srmService.vim.ArrayOfComplianceLocator): srmService.vim.ArrayOfComplianceLocator;
         };
         ComplianceProfile: {
            (options?: srmService.vim.ComplianceProfile): srmService.vim.ComplianceProfile;
         };
         ComplianceResultStatus: {
            "compliant": string;
            "nonCompliant": string;
            "unknown": string;
         };
         ComplianceFailure: {
            (options?: srmService.vim.ComplianceFailure): srmService.vim.ComplianceFailure;
         };
         ArrayOfComplianceFailure: {
            (options?: srmService.vim.ArrayOfComplianceFailure): srmService.vim.ArrayOfComplianceFailure;
         };
         ComplianceResult: {
            (options?: srmService.vim.ComplianceResult): srmService.vim.ComplianceResult;
         };
         ArrayOfComplianceResult: {
            (options?: srmService.vim.ArrayOfComplianceResult): srmService.vim.ArrayOfComplianceResult;
         };
         ProfileDeferredPolicyOptionParameter: {
            (options?: srmService.vim.ProfileDeferredPolicyOptionParameter): srmService.vim.ProfileDeferredPolicyOptionParameter;
         };
         ArrayOfProfileDeferredPolicyOptionParameter: {
            (options?: srmService.vim.ArrayOfProfileDeferredPolicyOptionParameter): srmService.vim.ArrayOfProfileDeferredPolicyOptionParameter;
         };
         ProfileExpression: {
            (options?: srmService.vim.ProfileExpression): srmService.vim.ProfileExpression;
         };
         ArrayOfProfileExpression: {
            (options?: srmService.vim.ArrayOfProfileExpression): srmService.vim.ArrayOfProfileExpression;
         };
         ProfileSimpleExpression: {
            (options?: srmService.vim.ProfileSimpleExpression): srmService.vim.ProfileSimpleExpression;
         };
         ProfileCompositeExpression: {
            (options?: srmService.vim.ProfileCompositeExpression): srmService.vim.ProfileCompositeExpression;
         };
         ProfileExpressionMetadata: {
            (options?: srmService.vim.ProfileExpressionMetadata): srmService.vim.ProfileExpressionMetadata;
         };
         ArrayOfProfileExpressionMetadata: {
            (options?: srmService.vim.ArrayOfProfileExpressionMetadata): srmService.vim.ArrayOfProfileExpressionMetadata;
         };
         ProfileNumericComparator: {
            "lessThan": string;
            "lessThanEqual": string;
            "equal": string;
            "notEqual": string;
            "greaterThanEqual": string;
            "greaterThan": string;
         };
         ProfileParameterMetadata: {
            (options?: srmService.vim.ProfileParameterMetadata): srmService.vim.ProfileParameterMetadata;
         };
         ArrayOfProfileParameterMetadata: {
            (options?: srmService.vim.ArrayOfProfileParameterMetadata): srmService.vim.ArrayOfProfileParameterMetadata;
         };
         ProfilePolicy: {
            (options?: srmService.vim.ProfilePolicy): srmService.vim.ProfilePolicy;
         };
         ArrayOfProfilePolicy: {
            (options?: srmService.vim.ArrayOfProfilePolicy): srmService.vim.ArrayOfProfilePolicy;
         };
         ProfilePolicyOptionMetadata: {
            (options?: srmService.vim.ProfilePolicyOptionMetadata): srmService.vim.ProfilePolicyOptionMetadata;
         };
         ArrayOfProfilePolicyOptionMetadata: {
            (options?: srmService.vim.ArrayOfProfilePolicyOptionMetadata): srmService.vim.ArrayOfProfilePolicyOptionMetadata;
         };
         ProfileCompositePolicyOptionMetadata: {
            (options?: srmService.vim.ProfileCompositePolicyOptionMetadata): srmService.vim.ProfileCompositePolicyOptionMetadata;
         };
         UserInputRequiredParameterMetadata: {
            (options?: srmService.vim.UserInputRequiredParameterMetadata): srmService.vim.UserInputRequiredParameterMetadata;
         };
         ProfilePolicyMetadata: {
            (options?: srmService.vim.ProfilePolicyMetadata): srmService.vim.ProfilePolicyMetadata;
         };
         ArrayOfProfilePolicyMetadata: {
            (options?: srmService.vim.ArrayOfProfilePolicyMetadata): srmService.vim.ArrayOfProfilePolicyMetadata;
         };
         PolicyOption: {
            (options?: srmService.vim.PolicyOption): srmService.vim.PolicyOption;
         };
         ArrayOfPolicyOption: {
            (options?: srmService.vim.ArrayOfPolicyOption): srmService.vim.ArrayOfPolicyOption;
         };
         CompositePolicyOption: {
            (options?: srmService.vim.CompositePolicyOption): srmService.vim.CompositePolicyOption;
         };
         ProfileCreateSpec: {
            (options?: srmService.vim.ProfileCreateSpec): srmService.vim.ProfileCreateSpec;
         };
         ProfileSerializedCreateSpec: {
            (options?: srmService.vim.ProfileSerializedCreateSpec): srmService.vim.ProfileSerializedCreateSpec;
         };
         ProfileConfigInfo: {
            (options?: srmService.vim.ProfileConfigInfo): srmService.vim.ProfileConfigInfo;
         };
         ProfileDescriptionSection: {
            (options?: srmService.vim.ProfileDescriptionSection): srmService.vim.ProfileDescriptionSection;
         };
         ArrayOfProfileDescriptionSection: {
            (options?: srmService.vim.ArrayOfProfileDescriptionSection): srmService.vim.ArrayOfProfileDescriptionSection;
         };
         ProfileDescription: {
            (options?: srmService.vim.ProfileDescription): srmService.vim.ProfileDescription;
         };
         ProfileMetadataProfileSortSpec: {
            (options?: srmService.vim.ProfileMetadataProfileSortSpec): srmService.vim.ProfileMetadataProfileSortSpec;
         };
         ArrayOfProfileMetadataProfileSortSpec: {
            (options?: srmService.vim.ArrayOfProfileMetadataProfileSortSpec): srmService.vim.ArrayOfProfileMetadataProfileSortSpec;
         };
         ProfileMetadata: {
            (options?: srmService.vim.ProfileMetadata): srmService.vim.ProfileMetadata;
         };
         ArrayOfProfileMetadata: {
            (options?: srmService.vim.ArrayOfProfileMetadata): srmService.vim.ArrayOfProfileMetadata;
         };
         ProfilePropertyPath: {
            (options?: srmService.vim.ProfilePropertyPath): srmService.vim.ProfilePropertyPath;
         };
         ArrayOfProfilePropertyPath: {
            (options?: srmService.vim.ArrayOfProfilePropertyPath): srmService.vim.ArrayOfProfilePropertyPath;
         };
         ProfileProfileStructure: {
            (options?: srmService.vim.ProfileProfileStructure): srmService.vim.ProfileProfileStructure;
         };
         ProfileProfileStructureProperty: {
            (options?: srmService.vim.ProfileProfileStructureProperty): srmService.vim.ProfileProfileStructureProperty;
         };
         ArrayOfProfileProfileStructureProperty: {
            (options?: srmService.vim.ArrayOfProfileProfileStructureProperty): srmService.vim.ArrayOfProfileProfileStructureProperty;
         };
         ClusterProfileConfigInfo: {
            (options?: srmService.vim.ClusterProfileConfigInfo): srmService.vim.ClusterProfileConfigInfo;
         };
         ClusterProfileCreateSpec: {
            (options?: srmService.vim.ClusterProfileCreateSpec): srmService.vim.ClusterProfileCreateSpec;
         };
         ClusterProfileConfigSpec: {
            (options?: srmService.vim.ClusterProfileConfigSpec): srmService.vim.ClusterProfileConfigSpec;
         };
         ClusterProfileCompleteConfigSpec: {
            (options?: srmService.vim.ClusterProfileCompleteConfigSpec): srmService.vim.ClusterProfileCompleteConfigSpec;
         };
         ClusterProfileServiceType: {
            "DRS": string;
            "HA": string;
            "DPM": string;
            "FT": string;
         };
         ClusterProfileConfigServiceCreateSpec: {
            (options?: srmService.vim.ClusterProfileConfigServiceCreateSpec): srmService.vim.ClusterProfileConfigServiceCreateSpec;
         };
         AnswerFile: {
            (options?: srmService.vim.AnswerFile): srmService.vim.AnswerFile;
         };
         AnswerFileStatusError: {
            (options?: srmService.vim.AnswerFileStatusError): srmService.vim.AnswerFileStatusError;
         };
         ArrayOfAnswerFileStatusError: {
            (options?: srmService.vim.ArrayOfAnswerFileStatusError): srmService.vim.ArrayOfAnswerFileStatusError;
         };
         AnswerFileStatusResult: {
            (options?: srmService.vim.AnswerFileStatusResult): srmService.vim.AnswerFileStatusResult;
         };
         ArrayOfAnswerFileStatusResult: {
            (options?: srmService.vim.ArrayOfAnswerFileStatusResult): srmService.vim.ArrayOfAnswerFileStatusResult;
         };
         ProfileExecuteResultStatus: {
            "success": string;
            "needInput": string;
            "error": string;
         };
         ProfileExecuteError: {
            (options?: srmService.vim.ProfileExecuteError): srmService.vim.ProfileExecuteError;
         };
         ArrayOfProfileExecuteError: {
            (options?: srmService.vim.ArrayOfProfileExecuteError): srmService.vim.ArrayOfProfileExecuteError;
         };
         ProfileExecuteResult: {
            (options?: srmService.vim.ProfileExecuteResult): srmService.vim.ProfileExecuteResult;
         };
         HostApplyProfile: {
            (options?: srmService.vim.HostApplyProfile): srmService.vim.HostApplyProfile;
         };
         PhysicalNicProfile: {
            (options?: srmService.vim.PhysicalNicProfile): srmService.vim.PhysicalNicProfile;
         };
         ArrayOfPhysicalNicProfile: {
            (options?: srmService.vim.ArrayOfPhysicalNicProfile): srmService.vim.ArrayOfPhysicalNicProfile;
         };
         HostMemoryProfile: {
            (options?: srmService.vim.HostMemoryProfile): srmService.vim.HostMemoryProfile;
         };
         UserProfile: {
            (options?: srmService.vim.UserProfile): srmService.vim.UserProfile;
         };
         ArrayOfUserProfile: {
            (options?: srmService.vim.ArrayOfUserProfile): srmService.vim.ArrayOfUserProfile;
         };
         UserGroupProfile: {
            (options?: srmService.vim.UserGroupProfile): srmService.vim.UserGroupProfile;
         };
         ArrayOfUserGroupProfile: {
            (options?: srmService.vim.ArrayOfUserGroupProfile): srmService.vim.ArrayOfUserGroupProfile;
         };
         SecurityProfile: {
            (options?: srmService.vim.SecurityProfile): srmService.vim.SecurityProfile;
         };
         OptionProfile: {
            (options?: srmService.vim.OptionProfile): srmService.vim.OptionProfile;
         };
         ArrayOfOptionProfile: {
            (options?: srmService.vim.ArrayOfOptionProfile): srmService.vim.ArrayOfOptionProfile;
         };
         DateTimeProfile: {
            (options?: srmService.vim.DateTimeProfile): srmService.vim.DateTimeProfile;
         };
         ServiceProfile: {
            (options?: srmService.vim.ServiceProfile): srmService.vim.ServiceProfile;
         };
         ArrayOfServiceProfile: {
            (options?: srmService.vim.ArrayOfServiceProfile): srmService.vim.ArrayOfServiceProfile;
         };
         FirewallProfileRulesetProfile: {
            (options?: srmService.vim.FirewallProfileRulesetProfile): srmService.vim.FirewallProfileRulesetProfile;
         };
         ArrayOfFirewallProfileRulesetProfile: {
            (options?: srmService.vim.ArrayOfFirewallProfileRulesetProfile): srmService.vim.ArrayOfFirewallProfileRulesetProfile;
         };
         FirewallProfile: {
            (options?: srmService.vim.FirewallProfile): srmService.vim.FirewallProfile;
         };
         NasStorageProfile: {
            (options?: srmService.vim.NasStorageProfile): srmService.vim.NasStorageProfile;
         };
         ArrayOfNasStorageProfile: {
            (options?: srmService.vim.ArrayOfNasStorageProfile): srmService.vim.ArrayOfNasStorageProfile;
         };
         StorageProfile: {
            (options?: srmService.vim.StorageProfile): srmService.vim.StorageProfile;
         };
         NetworkProfileDnsConfigProfile: {
            (options?: srmService.vim.NetworkProfileDnsConfigProfile): srmService.vim.NetworkProfileDnsConfigProfile;
         };
         NetworkProfile: {
            (options?: srmService.vim.NetworkProfile): srmService.vim.NetworkProfile;
         };
         DvsVNicProfile: {
            (options?: srmService.vim.DvsVNicProfile): srmService.vim.DvsVNicProfile;
         };
         DvsServiceConsoleVNicProfile: {
            (options?: srmService.vim.DvsServiceConsoleVNicProfile): srmService.vim.DvsServiceConsoleVNicProfile;
         };
         ArrayOfDvsServiceConsoleVNicProfile: {
            (options?: srmService.vim.ArrayOfDvsServiceConsoleVNicProfile): srmService.vim.ArrayOfDvsServiceConsoleVNicProfile;
         };
         DvsHostVNicProfile: {
            (options?: srmService.vim.DvsHostVNicProfile): srmService.vim.DvsHostVNicProfile;
         };
         ArrayOfDvsHostVNicProfile: {
            (options?: srmService.vim.ArrayOfDvsHostVNicProfile): srmService.vim.ArrayOfDvsHostVNicProfile;
         };
         DvsProfile: {
            (options?: srmService.vim.DvsProfile): srmService.vim.DvsProfile;
         };
         ArrayOfDvsProfile: {
            (options?: srmService.vim.ArrayOfDvsProfile): srmService.vim.ArrayOfDvsProfile;
         };
         PnicUplinkProfile: {
            (options?: srmService.vim.PnicUplinkProfile): srmService.vim.PnicUplinkProfile;
         };
         ArrayOfPnicUplinkProfile: {
            (options?: srmService.vim.ArrayOfPnicUplinkProfile): srmService.vim.ArrayOfPnicUplinkProfile;
         };
         IpRouteProfile: {
            (options?: srmService.vim.IpRouteProfile): srmService.vim.IpRouteProfile;
         };
         StaticRouteProfile: {
            (options?: srmService.vim.StaticRouteProfile): srmService.vim.StaticRouteProfile;
         };
         ArrayOfStaticRouteProfile: {
            (options?: srmService.vim.ArrayOfStaticRouteProfile): srmService.vim.ArrayOfStaticRouteProfile;
         };
         LinkProfile: {
            (options?: srmService.vim.LinkProfile): srmService.vim.LinkProfile;
         };
         NumPortsProfile: {
            (options?: srmService.vim.NumPortsProfile): srmService.vim.NumPortsProfile;
         };
         VirtualSwitchProfile: {
            (options?: srmService.vim.VirtualSwitchProfile): srmService.vim.VirtualSwitchProfile;
         };
         ArrayOfVirtualSwitchProfile: {
            (options?: srmService.vim.ArrayOfVirtualSwitchProfile): srmService.vim.ArrayOfVirtualSwitchProfile;
         };
         NetStackInstanceProfile: {
            (options?: srmService.vim.NetStackInstanceProfile): srmService.vim.NetStackInstanceProfile;
         };
         ArrayOfNetStackInstanceProfile: {
            (options?: srmService.vim.ArrayOfNetStackInstanceProfile): srmService.vim.ArrayOfNetStackInstanceProfile;
         };
         VlanProfile: {
            (options?: srmService.vim.VlanProfile): srmService.vim.VlanProfile;
         };
         VirtualSwitchSelectionProfile: {
            (options?: srmService.vim.VirtualSwitchSelectionProfile): srmService.vim.VirtualSwitchSelectionProfile;
         };
         PortGroupProfile: {
            (options?: srmService.vim.PortGroupProfile): srmService.vim.PortGroupProfile;
         };
         VmPortGroupProfile: {
            (options?: srmService.vim.VmPortGroupProfile): srmService.vim.VmPortGroupProfile;
         };
         ArrayOfVmPortGroupProfile: {
            (options?: srmService.vim.ArrayOfVmPortGroupProfile): srmService.vim.ArrayOfVmPortGroupProfile;
         };
         HostPortGroupProfile: {
            (options?: srmService.vim.HostPortGroupProfile): srmService.vim.HostPortGroupProfile;
         };
         ArrayOfHostPortGroupProfile: {
            (options?: srmService.vim.ArrayOfHostPortGroupProfile): srmService.vim.ArrayOfHostPortGroupProfile;
         };
         ServiceConsolePortGroupProfile: {
            (options?: srmService.vim.ServiceConsolePortGroupProfile): srmService.vim.ServiceConsolePortGroupProfile;
         };
         ArrayOfServiceConsolePortGroupProfile: {
            (options?: srmService.vim.ArrayOfServiceConsolePortGroupProfile): srmService.vim.ArrayOfServiceConsolePortGroupProfile;
         };
         NetworkPolicyProfile: {
            (options?: srmService.vim.NetworkPolicyProfile): srmService.vim.NetworkPolicyProfile;
         };
         IpAddressProfile: {
            (options?: srmService.vim.IpAddressProfile): srmService.vim.IpAddressProfile;
         };
         AuthenticationProfile: {
            (options?: srmService.vim.AuthenticationProfile): srmService.vim.AuthenticationProfile;
         };
         ActiveDirectoryProfile: {
            (options?: srmService.vim.ActiveDirectoryProfile): srmService.vim.ActiveDirectoryProfile;
         };
         PermissionProfile: {
            (options?: srmService.vim.PermissionProfile): srmService.vim.PermissionProfile;
         };
         ArrayOfPermissionProfile: {
            (options?: srmService.vim.ArrayOfPermissionProfile): srmService.vim.ArrayOfPermissionProfile;
         };
         HostProfileConfigInfo: {
            (options?: srmService.vim.HostProfileConfigInfo): srmService.vim.HostProfileConfigInfo;
         };
         HostProfileConfigSpec: {
            (options?: srmService.vim.HostProfileConfigSpec): srmService.vim.HostProfileConfigSpec;
         };
         HostProfileSerializedHostProfileSpec: {
            (options?: srmService.vim.HostProfileSerializedHostProfileSpec): srmService.vim.HostProfileSerializedHostProfileSpec;
         };
         HostProfileCompleteConfigSpec: {
            (options?: srmService.vim.HostProfileCompleteConfigSpec): srmService.vim.HostProfileCompleteConfigSpec;
         };
         HostProfileHostBasedConfigSpec: {
            (options?: srmService.vim.HostProfileHostBasedConfigSpec): srmService.vim.HostProfileHostBasedConfigSpec;
         };
         HostProfileManagerConfigTaskList: {
            (options?: srmService.vim.HostProfileManagerConfigTaskList): srmService.vim.HostProfileManagerConfigTaskList;
         };
         AnswerFileCreateSpec: {
            (options?: srmService.vim.AnswerFileCreateSpec): srmService.vim.AnswerFileCreateSpec;
         };
         AnswerFileOptionsCreateSpec: {
            (options?: srmService.vim.AnswerFileOptionsCreateSpec): srmService.vim.AnswerFileOptionsCreateSpec;
         };
         AnswerFileSerializedCreateSpec: {
            (options?: srmService.vim.AnswerFileSerializedCreateSpec): srmService.vim.AnswerFileSerializedCreateSpec;
         };
         HostProfileManagerAnswerFileStatus: {
            "valid": string;
            "invalid": string;
            "unknown": string;
         };
         ScheduledTaskDetail: {
            (options?: srmService.vim.ScheduledTaskDetail): srmService.vim.ScheduledTaskDetail;
         };
         ArrayOfScheduledTaskDetail: {
            (options?: srmService.vim.ArrayOfScheduledTaskDetail): srmService.vim.ArrayOfScheduledTaskDetail;
         };
         ScheduledTaskDescription: {
            (options?: srmService.vim.ScheduledTaskDescription): srmService.vim.ScheduledTaskDescription;
         };
         ScheduledTaskInfo: {
            (options?: srmService.vim.ScheduledTaskInfo): srmService.vim.ScheduledTaskInfo;
         };
         TaskScheduler: {
            (options?: srmService.vim.TaskScheduler): srmService.vim.TaskScheduler;
         };
         AfterStartupTaskScheduler: {
            (options?: srmService.vim.AfterStartupTaskScheduler): srmService.vim.AfterStartupTaskScheduler;
         };
         OnceTaskScheduler: {
            (options?: srmService.vim.OnceTaskScheduler): srmService.vim.OnceTaskScheduler;
         };
         RecurrentTaskScheduler: {
            (options?: srmService.vim.RecurrentTaskScheduler): srmService.vim.RecurrentTaskScheduler;
         };
         HourlyTaskScheduler: {
            (options?: srmService.vim.HourlyTaskScheduler): srmService.vim.HourlyTaskScheduler;
         };
         DailyTaskScheduler: {
            (options?: srmService.vim.DailyTaskScheduler): srmService.vim.DailyTaskScheduler;
         };
         WeeklyTaskScheduler: {
            (options?: srmService.vim.WeeklyTaskScheduler): srmService.vim.WeeklyTaskScheduler;
         };
         MonthlyTaskScheduler: {
            (options?: srmService.vim.MonthlyTaskScheduler): srmService.vim.MonthlyTaskScheduler;
         };
         MonthlyByDayTaskScheduler: {
            (options?: srmService.vim.MonthlyByDayTaskScheduler): srmService.vim.MonthlyByDayTaskScheduler;
         };
         DayOfWeek: {
            "sunday": string;
            "monday": string;
            "tuesday": string;
            "wednesday": string;
            "thursday": string;
            "friday": string;
            "saturday": string;
         };
         WeekOfMonth: {
            "first": string;
            "second": string;
            "third": string;
            "fourth": string;
            "last": string;
         };
         MonthlyByWeekdayTaskScheduler: {
            (options?: srmService.vim.MonthlyByWeekdayTaskScheduler): srmService.vim.MonthlyByWeekdayTaskScheduler;
         };
         ScheduledTaskSpec: {
            (options?: srmService.vim.ScheduledTaskSpec): srmService.vim.ScheduledTaskSpec;
         };
         ApplyStorageRecommendationResult: {
            (options?: srmService.vim.ApplyStorageRecommendationResult): srmService.vim.ApplyStorageRecommendationResult;
         };
         StorageDrsConfigInfo: {
            (options?: srmService.vim.StorageDrsConfigInfo): srmService.vim.StorageDrsConfigInfo;
         };
         StorageDrsConfigSpec: {
            (options?: srmService.vim.StorageDrsConfigSpec): srmService.vim.StorageDrsConfigSpec;
         };
         StorageDrsVmConfigSpec: {
            (options?: srmService.vim.StorageDrsVmConfigSpec): srmService.vim.StorageDrsVmConfigSpec;
         };
         ArrayOfStorageDrsVmConfigSpec: {
            (options?: srmService.vim.ArrayOfStorageDrsVmConfigSpec): srmService.vim.ArrayOfStorageDrsVmConfigSpec;
         };
         StorageDrsPodConfigInfoBehavior: {
            "manual": string;
            "automated": string;
         };
         StorageDrsPodConfigInfo: {
            (options?: srmService.vim.StorageDrsPodConfigInfo): srmService.vim.StorageDrsPodConfigInfo;
         };
         StorageDrsSpaceLoadBalanceConfig: {
            (options?: srmService.vim.StorageDrsSpaceLoadBalanceConfig): srmService.vim.StorageDrsSpaceLoadBalanceConfig;
         };
         StorageDrsIoLoadBalanceConfig: {
            (options?: srmService.vim.StorageDrsIoLoadBalanceConfig): srmService.vim.StorageDrsIoLoadBalanceConfig;
         };
         StorageDrsPodConfigSpec: {
            (options?: srmService.vim.StorageDrsPodConfigSpec): srmService.vim.StorageDrsPodConfigSpec;
         };
         StorageDrsOptionSpec: {
            (options?: srmService.vim.StorageDrsOptionSpec): srmService.vim.StorageDrsOptionSpec;
         };
         ArrayOfStorageDrsOptionSpec: {
            (options?: srmService.vim.ArrayOfStorageDrsOptionSpec): srmService.vim.ArrayOfStorageDrsOptionSpec;
         };
         VmPodConfigForPlacement: {
            (options?: srmService.vim.VmPodConfigForPlacement): srmService.vim.VmPodConfigForPlacement;
         };
         ArrayOfVmPodConfigForPlacement: {
            (options?: srmService.vim.ArrayOfVmPodConfigForPlacement): srmService.vim.ArrayOfVmPodConfigForPlacement;
         };
         PodDiskLocator: {
            (options?: srmService.vim.PodDiskLocator): srmService.vim.PodDiskLocator;
         };
         ArrayOfPodDiskLocator: {
            (options?: srmService.vim.ArrayOfPodDiskLocator): srmService.vim.ArrayOfPodDiskLocator;
         };
         StorageDrsPodSelectionSpec: {
            (options?: srmService.vim.StorageDrsPodSelectionSpec): srmService.vim.StorageDrsPodSelectionSpec;
         };
         StorageMigrationAction: {
            (options?: srmService.vim.StorageMigrationAction): srmService.vim.StorageMigrationAction;
         };
         StoragePlacementAction: {
            (options?: srmService.vim.StoragePlacementAction): srmService.vim.StoragePlacementAction;
         };
         StoragePlacementResult: {
            (options?: srmService.vim.StoragePlacementResult): srmService.vim.StoragePlacementResult;
         };
         StoragePlacementSpecPlacementType: {
            "create": string;
            "reconfigure": string;
            "relocate": string;
            "clone": string;
         };
         StoragePlacementSpec: {
            (options?: srmService.vim.StoragePlacementSpec): srmService.vim.StoragePlacementSpec;
         };
         VirtualDiskAntiAffinityRuleSpec: {
            (options?: srmService.vim.VirtualDiskAntiAffinityRuleSpec): srmService.vim.VirtualDiskAntiAffinityRuleSpec;
         };
         StorageDrsVmConfigInfo: {
            (options?: srmService.vim.StorageDrsVmConfigInfo): srmService.vim.StorageDrsVmConfigInfo;
         };
         ArrayOfStorageDrsVmConfigInfo: {
            (options?: srmService.vim.ArrayOfStorageDrsVmConfigInfo): srmService.vim.ArrayOfStorageDrsVmConfigInfo;
         };
         VAppCloneSpecNetworkMappingPair: {
            (options?: srmService.vim.VAppCloneSpecNetworkMappingPair): srmService.vim.VAppCloneSpecNetworkMappingPair;
         };
         ArrayOfVAppCloneSpecNetworkMappingPair: {
            (options?: srmService.vim.ArrayOfVAppCloneSpecNetworkMappingPair): srmService.vim.ArrayOfVAppCloneSpecNetworkMappingPair;
         };
         VAppCloneSpecResourceMap: {
            (options?: srmService.vim.VAppCloneSpecResourceMap): srmService.vim.VAppCloneSpecResourceMap;
         };
         ArrayOfVAppCloneSpecResourceMap: {
            (options?: srmService.vim.ArrayOfVAppCloneSpecResourceMap): srmService.vim.ArrayOfVAppCloneSpecResourceMap;
         };
         VAppCloneSpecProvisioningType: {
            "sameAsSource": string;
            "thin": string;
            "thick": string;
         };
         VAppCloneSpec: {
            (options?: srmService.vim.VAppCloneSpec): srmService.vim.VAppCloneSpec;
         };
         VAppAutoStartAction: {
            "none": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         VAppEntityConfigInfo: {
            (options?: srmService.vim.VAppEntityConfigInfo): srmService.vim.VAppEntityConfigInfo;
         };
         ArrayOfVAppEntityConfigInfo: {
            (options?: srmService.vim.ArrayOfVAppEntityConfigInfo): srmService.vim.ArrayOfVAppEntityConfigInfo;
         };
         VAppIPAssignmentInfoIpAllocationPolicy: {
            "dhcpPolicy": string;
            "transientPolicy": string;
            "fixedPolicy": string;
            "fixedAllocatedPolicy": string;
         };
         VAppIPAssignmentInfoAllocationSchemes: {
            "dhcp": string;
            "ovfenv": string;
         };
         VAppIPAssignmentInfoProtocols: {
            "IPv4": string;
            "IPv6": string;
         };
         VAppIPAssignmentInfo: {
            (options?: srmService.vim.VAppIPAssignmentInfo): srmService.vim.VAppIPAssignmentInfo;
         };
         IpPoolIpPoolConfigInfo: {
            (options?: srmService.vim.IpPoolIpPoolConfigInfo): srmService.vim.IpPoolIpPoolConfigInfo;
         };
         IpPoolAssociation: {
            (options?: srmService.vim.IpPoolAssociation): srmService.vim.IpPoolAssociation;
         };
         ArrayOfIpPoolAssociation: {
            (options?: srmService.vim.ArrayOfIpPoolAssociation): srmService.vim.ArrayOfIpPoolAssociation;
         };
         IpPool: {
            (options?: srmService.vim.IpPool): srmService.vim.IpPool;
         };
         ArrayOfIpPool: {
            (options?: srmService.vim.ArrayOfIpPool): srmService.vim.ArrayOfIpPool;
         };
         VAppOvfSectionInfo: {
            (options?: srmService.vim.VAppOvfSectionInfo): srmService.vim.VAppOvfSectionInfo;
         };
         ArrayOfVAppOvfSectionInfo: {
            (options?: srmService.vim.ArrayOfVAppOvfSectionInfo): srmService.vim.ArrayOfVAppOvfSectionInfo;
         };
         VAppProductInfo: {
            (options?: srmService.vim.VAppProductInfo): srmService.vim.VAppProductInfo;
         };
         ArrayOfVAppProductInfo: {
            (options?: srmService.vim.ArrayOfVAppProductInfo): srmService.vim.ArrayOfVAppProductInfo;
         };
         VAppPropertyInfo: {
            (options?: srmService.vim.VAppPropertyInfo): srmService.vim.VAppPropertyInfo;
         };
         ArrayOfVAppPropertyInfo: {
            (options?: srmService.vim.ArrayOfVAppPropertyInfo): srmService.vim.ArrayOfVAppPropertyInfo;
         };
         VAppConfigInfo: {
            (options?: srmService.vim.VAppConfigInfo): srmService.vim.VAppConfigInfo;
         };
         VAppConfigSpec: {
            (options?: srmService.vim.VAppConfigSpec): srmService.vim.VAppConfigSpec;
         };
         VirtualAppImportSpec: {
            (options?: srmService.vim.VirtualAppImportSpec): srmService.vim.VirtualAppImportSpec;
         };
         VmConfigInfo: {
            (options?: srmService.vim.VmConfigInfo): srmService.vim.VmConfigInfo;
         };
         VmConfigSpec: {
            (options?: srmService.vim.VmConfigSpec): srmService.vim.VmConfigSpec;
         };
         VAppProductSpec: {
            (options?: srmService.vim.VAppProductSpec): srmService.vim.VAppProductSpec;
         };
         ArrayOfVAppProductSpec: {
            (options?: srmService.vim.ArrayOfVAppProductSpec): srmService.vim.ArrayOfVAppProductSpec;
         };
         VAppPropertySpec: {
            (options?: srmService.vim.VAppPropertySpec): srmService.vim.VAppPropertySpec;
         };
         ArrayOfVAppPropertySpec: {
            (options?: srmService.vim.ArrayOfVAppPropertySpec): srmService.vim.ArrayOfVAppPropertySpec;
         };
         VAppOvfSectionSpec: {
            (options?: srmService.vim.VAppOvfSectionSpec): srmService.vim.VAppOvfSectionSpec;
         };
         ArrayOfVAppOvfSectionSpec: {
            (options?: srmService.vim.ArrayOfVAppOvfSectionSpec): srmService.vim.ArrayOfVAppOvfSectionSpec;
         };
         VirtualMachineAffinityInfo: {
            (options?: srmService.vim.VirtualMachineAffinityInfo): srmService.vim.VirtualMachineAffinityInfo;
         };
         VirtualMachineBootOptionsBootableDevice: {
            (options?: srmService.vim.VirtualMachineBootOptionsBootableDevice): srmService.vim.VirtualMachineBootOptionsBootableDevice;
         };
         ArrayOfVirtualMachineBootOptionsBootableDevice: {
            (options?: srmService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice): srmService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice;
         };
         VirtualMachineBootOptionsBootableDiskDevice: {
            (options?: srmService.vim.VirtualMachineBootOptionsBootableDiskDevice): srmService.vim.VirtualMachineBootOptionsBootableDiskDevice;
         };
         VirtualMachineBootOptionsBootableEthernetDevice: {
            (options?: srmService.vim.VirtualMachineBootOptionsBootableEthernetDevice): srmService.vim.VirtualMachineBootOptionsBootableEthernetDevice;
         };
         VirtualMachineBootOptionsBootableFloppyDevice: {
            (options?: srmService.vim.VirtualMachineBootOptionsBootableFloppyDevice): srmService.vim.VirtualMachineBootOptionsBootableFloppyDevice;
         };
         VirtualMachineBootOptionsBootableCdromDevice: {
            (options?: srmService.vim.VirtualMachineBootOptionsBootableCdromDevice): srmService.vim.VirtualMachineBootOptionsBootableCdromDevice;
         };
         VirtualMachineBootOptions: {
            (options?: srmService.vim.VirtualMachineBootOptions): srmService.vim.VirtualMachineBootOptions;
         };
         VirtualMachineCapability: {
            (options?: srmService.vim.VirtualMachineCapability): srmService.vim.VirtualMachineCapability;
         };
         VirtualMachineCdromInfo: {
            (options?: srmService.vim.VirtualMachineCdromInfo): srmService.vim.VirtualMachineCdromInfo;
         };
         ArrayOfVirtualMachineCdromInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineCdromInfo): srmService.vim.ArrayOfVirtualMachineCdromInfo;
         };
         VirtualMachineCloneSpec: {
            (options?: srmService.vim.VirtualMachineCloneSpec): srmService.vim.VirtualMachineCloneSpec;
         };
         VirtualMachineConfigInfoNpivWwnType: {
            "vc": string;
            "host": string;
            "external": string;
         };
         VirtualMachineConfigInfoSwapPlacementType: {
            "inherit": string;
            "vmDirectory": string;
            "hostLocal": string;
         };
         VirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: srmService.vim.VirtualMachineConfigInfoDatastoreUrlPair): srmService.vim.VirtualMachineConfigInfoDatastoreUrlPair;
         };
         ArrayOfVirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: srmService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair): srmService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair;
         };
         VirtualMachineConfigInfoOverheadInfo: {
            (options?: srmService.vim.VirtualMachineConfigInfoOverheadInfo): srmService.vim.VirtualMachineConfigInfoOverheadInfo;
         };
         VirtualMachineConfigInfo: {
            (options?: srmService.vim.VirtualMachineConfigInfo): srmService.vim.VirtualMachineConfigInfo;
         };
         VirtualMachineConfigOption: {
            (options?: srmService.vim.VirtualMachineConfigOption): srmService.vim.VirtualMachineConfigOption;
         };
         VirtualMachineConfigOptionDescriptor: {
            (options?: srmService.vim.VirtualMachineConfigOptionDescriptor): srmService.vim.VirtualMachineConfigOptionDescriptor;
         };
         ArrayOfVirtualMachineConfigOptionDescriptor: {
            (options?: srmService.vim.ArrayOfVirtualMachineConfigOptionDescriptor): srmService.vim.ArrayOfVirtualMachineConfigOptionDescriptor;
         };
         VirtualMachineConfigSpecNpivWwnOp: {
            "generate": string;
            "set": string;
            "remove": string;
            "extend": string;
         };
         VirtualMachineCpuIdInfoSpec: {
            (options?: srmService.vim.VirtualMachineCpuIdInfoSpec): srmService.vim.VirtualMachineCpuIdInfoSpec;
         };
         ArrayOfVirtualMachineCpuIdInfoSpec: {
            (options?: srmService.vim.ArrayOfVirtualMachineCpuIdInfoSpec): srmService.vim.ArrayOfVirtualMachineCpuIdInfoSpec;
         };
         VirtualMachineConfigSpec: {
            (options?: srmService.vim.VirtualMachineConfigSpec): srmService.vim.VirtualMachineConfigSpec;
         };
         ConfigTarget: {
            (options?: srmService.vim.ConfigTarget): srmService.vim.ConfigTarget;
         };
         VirtualMachineConsolePreferences: {
            (options?: srmService.vim.VirtualMachineConsolePreferences): srmService.vim.VirtualMachineConsolePreferences;
         };
         VirtualMachineDatastoreInfo: {
            (options?: srmService.vim.VirtualMachineDatastoreInfo): srmService.vim.VirtualMachineDatastoreInfo;
         };
         ArrayOfVirtualMachineDatastoreInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineDatastoreInfo): srmService.vim.ArrayOfVirtualMachineDatastoreInfo;
         };
         VirtualMachineDatastoreVolumeOption: {
            (options?: srmService.vim.VirtualMachineDatastoreVolumeOption): srmService.vim.VirtualMachineDatastoreVolumeOption;
         };
         ArrayOfVirtualMachineDatastoreVolumeOption: {
            (options?: srmService.vim.ArrayOfVirtualMachineDatastoreVolumeOption): srmService.vim.ArrayOfVirtualMachineDatastoreVolumeOption;
         };
         DatastoreOption: {
            (options?: srmService.vim.DatastoreOption): srmService.vim.DatastoreOption;
         };
         VirtualMachinePowerOpType: {
            "soft": string;
            "hard": string;
            "preset": string;
         };
         VirtualMachineStandbyActionType: {
            "checkpoint": string;
            "powerOnSuspend": string;
         };
         VirtualMachineDefaultPowerOpInfo: {
            (options?: srmService.vim.VirtualMachineDefaultPowerOpInfo): srmService.vim.VirtualMachineDefaultPowerOpInfo;
         };
         VirtualMachineDefinedProfileSpec: {
            (options?: srmService.vim.VirtualMachineDefinedProfileSpec): srmService.vim.VirtualMachineDefinedProfileSpec;
         };
         VirtualMachineDeviceRuntimeInfoDeviceRuntimeState: {
            (options?: srmService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState): srmService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: {
            "vmNptIncompatibleGuest": string;
            "vmNptIncompatibleGuestDriver": string;
            "vmNptIncompatibleAdapterType": string;
            "vmNptDisabledOrDisconnectedAdapter": string;
            "vmNptIncompatibleAdapterFeatures": string;
            "vmNptIncompatibleBackingType": string;
            "vmNptInsufficientMemoryReservation": string;
            "vmNptFaultToleranceOrRecordReplayConfigured": string;
            "vmNptConflictingIOChainConfigured": string;
            "vmNptMonitorBlocks": string;
            "vmNptConflictingOperationInProgress": string;
            "vmNptRuntimeError": string;
            "vmNptOutOfIntrVector": string;
            "vmNptVMCIActive": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: {
            "vmNptIncompatibleHost": string;
            "vmNptIncompatibleNetwork": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState: {
            (options?: srmService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState): srmService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfo: {
            (options?: srmService.vim.VirtualMachineDeviceRuntimeInfo): srmService.vim.VirtualMachineDeviceRuntimeInfo;
         };
         ArrayOfVirtualMachineDeviceRuntimeInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo): srmService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo;
         };
         VirtualMachineDiskDeviceInfo: {
            (options?: srmService.vim.VirtualMachineDiskDeviceInfo): srmService.vim.VirtualMachineDiskDeviceInfo;
         };
         VirtualMachineEmptyProfileSpec: {
            (options?: srmService.vim.VirtualMachineEmptyProfileSpec): srmService.vim.VirtualMachineEmptyProfileSpec;
         };
         FaultToleranceConfigInfo: {
            (options?: srmService.vim.FaultToleranceConfigInfo): srmService.vim.FaultToleranceConfigInfo;
         };
         FaultTolerancePrimaryConfigInfo: {
            (options?: srmService.vim.FaultTolerancePrimaryConfigInfo): srmService.vim.FaultTolerancePrimaryConfigInfo;
         };
         FaultToleranceSecondaryConfigInfo: {
            (options?: srmService.vim.FaultToleranceSecondaryConfigInfo): srmService.vim.FaultToleranceSecondaryConfigInfo;
         };
         FaultToleranceSecondaryOpResult: {
            (options?: srmService.vim.FaultToleranceSecondaryOpResult): srmService.vim.FaultToleranceSecondaryOpResult;
         };
         VirtualMachineFeatureRequirement: {
            (options?: srmService.vim.VirtualMachineFeatureRequirement): srmService.vim.VirtualMachineFeatureRequirement;
         };
         ArrayOfVirtualMachineFeatureRequirement: {
            (options?: srmService.vim.ArrayOfVirtualMachineFeatureRequirement): srmService.vim.ArrayOfVirtualMachineFeatureRequirement;
         };
         VirtualMachineFileInfo: {
            (options?: srmService.vim.VirtualMachineFileInfo): srmService.vim.VirtualMachineFileInfo;
         };
         VirtualMachineFileLayoutDiskLayout: {
            (options?: srmService.vim.VirtualMachineFileLayoutDiskLayout): srmService.vim.VirtualMachineFileLayoutDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutDiskLayout: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout): srmService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout;
         };
         VirtualMachineFileLayoutSnapshotLayout: {
            (options?: srmService.vim.VirtualMachineFileLayoutSnapshotLayout): srmService.vim.VirtualMachineFileLayoutSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutSnapshotLayout: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout): srmService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout;
         };
         VirtualMachineFileLayout: {
            (options?: srmService.vim.VirtualMachineFileLayout): srmService.vim.VirtualMachineFileLayout;
         };
         VirtualMachineFileLayoutExFileType: {
            "config": string;
            "extendedConfig": string;
            "diskDescriptor": string;
            "diskExtent": string;
            "digestDescriptor": string;
            "digestExtent": string;
            "diskReplicationState": string;
            "log": string;
            "stat": string;
            "namespaceData": string;
            "nvram": string;
            "snapshotData": string;
            "snapshotList": string;
            "snapshotManifestList": string;
            "suspend": string;
            "swap": string;
            "uwswap": string;
            "core": string;
            "screenshot": string;
         };
         VirtualMachineFileLayoutExFileInfo: {
            (options?: srmService.vim.VirtualMachineFileLayoutExFileInfo): srmService.vim.VirtualMachineFileLayoutExFileInfo;
         };
         ArrayOfVirtualMachineFileLayoutExFileInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo): srmService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo;
         };
         VirtualMachineFileLayoutExDiskUnit: {
            (options?: srmService.vim.VirtualMachineFileLayoutExDiskUnit): srmService.vim.VirtualMachineFileLayoutExDiskUnit;
         };
         ArrayOfVirtualMachineFileLayoutExDiskUnit: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit): srmService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit;
         };
         VirtualMachineFileLayoutExDiskLayout: {
            (options?: srmService.vim.VirtualMachineFileLayoutExDiskLayout): srmService.vim.VirtualMachineFileLayoutExDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutExDiskLayout: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout): srmService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout;
         };
         VirtualMachineFileLayoutExSnapshotLayout: {
            (options?: srmService.vim.VirtualMachineFileLayoutExSnapshotLayout): srmService.vim.VirtualMachineFileLayoutExSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutExSnapshotLayout: {
            (options?: srmService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout): srmService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout;
         };
         VirtualMachineFileLayoutEx: {
            (options?: srmService.vim.VirtualMachineFileLayoutEx): srmService.vim.VirtualMachineFileLayoutEx;
         };
         VirtualMachineHtSharing: {
            "any": string;
            "none": string;
            "internal": string;
         };
         VirtualMachinePowerOffBehavior: {
            "powerOff": string;
            "revert": string;
            "prompt": string;
         };
         VirtualMachineFlagInfoMonitorType: {
            "release": string;
            "debug": string;
            "stats": string;
         };
         VirtualMachineFlagInfoVirtualMmuUsage: {
            "automatic": string;
            "on": string;
            "off": string;
         };
         VirtualMachineFlagInfoVirtualExecUsage: {
            "hvAuto": string;
            "hvOn": string;
            "hvOff": string;
         };
         VirtualMachineFlagInfo: {
            (options?: srmService.vim.VirtualMachineFlagInfo): srmService.vim.VirtualMachineFlagInfo;
         };
         VirtualMachineFloppyInfo: {
            (options?: srmService.vim.VirtualMachineFloppyInfo): srmService.vim.VirtualMachineFloppyInfo;
         };
         ArrayOfVirtualMachineFloppyInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineFloppyInfo): srmService.vim.ArrayOfVirtualMachineFloppyInfo;
         };
         VirtualMachineToolsStatus: {
            "toolsNotInstalled": string;
            "toolsNotRunning": string;
            "toolsOld": string;
            "toolsOk": string;
         };
         VirtualMachineToolsVersionStatus: {
            "guestToolsNotInstalled": string;
            "guestToolsNeedUpgrade": string;
            "guestToolsCurrent": string;
            "guestToolsUnmanaged": string;
            "guestToolsTooOld": string;
            "guestToolsSupportedOld": string;
            "guestToolsSupportedNew": string;
            "guestToolsTooNew": string;
            "guestToolsBlacklisted": string;
         };
         VirtualMachineToolsRunningStatus: {
            "guestToolsNotRunning": string;
            "guestToolsRunning": string;
            "guestToolsExecutingScripts": string;
         };
         GuestDiskInfo: {
            (options?: srmService.vim.GuestDiskInfo): srmService.vim.GuestDiskInfo;
         };
         ArrayOfGuestDiskInfo: {
            (options?: srmService.vim.ArrayOfGuestDiskInfo): srmService.vim.ArrayOfGuestDiskInfo;
         };
         GuestNicInfo: {
            (options?: srmService.vim.GuestNicInfo): srmService.vim.GuestNicInfo;
         };
         ArrayOfGuestNicInfo: {
            (options?: srmService.vim.ArrayOfGuestNicInfo): srmService.vim.ArrayOfGuestNicInfo;
         };
         GuestStackInfo: {
            (options?: srmService.vim.GuestStackInfo): srmService.vim.GuestStackInfo;
         };
         ArrayOfGuestStackInfo: {
            (options?: srmService.vim.ArrayOfGuestStackInfo): srmService.vim.ArrayOfGuestStackInfo;
         };
         GuestScreenInfo: {
            (options?: srmService.vim.GuestScreenInfo): srmService.vim.GuestScreenInfo;
         };
         VirtualMachineGuestState: {
            "running": string;
            "shuttingDown": string;
            "resetting": string;
            "standby": string;
            "notRunning": string;
            "unknown": string;
         };
         GuestInfoAppStateType: {
            "none": string;
            "appStateOk": string;
            "appStateNeedReset": string;
         };
         GuestInfoNamespaceGenerationInfo: {
            (options?: srmService.vim.GuestInfoNamespaceGenerationInfo): srmService.vim.GuestInfoNamespaceGenerationInfo;
         };
         ArrayOfGuestInfoNamespaceGenerationInfo: {
            (options?: srmService.vim.ArrayOfGuestInfoNamespaceGenerationInfo): srmService.vim.ArrayOfGuestInfoNamespaceGenerationInfo;
         };
         GuestInfo: {
            (options?: srmService.vim.GuestInfo): srmService.vim.GuestInfo;
         };
         VirtualMachineGuestOsFamily: {
            "windowsGuest": string;
            "linuxGuest": string;
            "netwareGuest": string;
            "solarisGuest": string;
            "darwinGuestFamily": string;
            "otherGuestFamily": string;
         };
         VirtualMachineGuestOsIdentifier: {
            "dosGuest": string;
            "win31Guest": string;
            "win95Guest": string;
            "win98Guest": string;
            "winMeGuest": string;
            "winNTGuest": string;
            "win2000ProGuest": string;
            "win2000ServGuest": string;
            "win2000AdvServGuest": string;
            "winXPHomeGuest": string;
            "winXPProGuest": string;
            "winXPPro64Guest": string;
            "winNetWebGuest": string;
            "winNetStandardGuest": string;
            "winNetEnterpriseGuest": string;
            "winNetDatacenterGuest": string;
            "winNetBusinessGuest": string;
            "winNetStandard64Guest": string;
            "winNetEnterprise64Guest": string;
            "winLonghornGuest": string;
            "winLonghorn64Guest": string;
            "winNetDatacenter64Guest": string;
            "winVistaGuest": string;
            "winVista64Guest": string;
            "windows7Guest": string;
            "windows7_64Guest": string;
            "windows7Server64Guest": string;
            "windows8Guest": string;
            "windows8_64Guest": string;
            "windows8Server64Guest": string;
            "windowsHyperVGuest": string;
            "freebsdGuest": string;
            "freebsd64Guest": string;
            "redhatGuest": string;
            "rhel2Guest": string;
            "rhel3Guest": string;
            "rhel3_64Guest": string;
            "rhel4Guest": string;
            "rhel4_64Guest": string;
            "rhel5Guest": string;
            "rhel5_64Guest": string;
            "rhel6Guest": string;
            "rhel6_64Guest": string;
            "rhel7Guest": string;
            "rhel7_64Guest": string;
            "centosGuest": string;
            "centos64Guest": string;
            "oracleLinuxGuest": string;
            "oracleLinux64Guest": string;
            "suseGuest": string;
            "suse64Guest": string;
            "slesGuest": string;
            "sles64Guest": string;
            "sles10Guest": string;
            "sles10_64Guest": string;
            "sles11Guest": string;
            "sles11_64Guest": string;
            "sles12Guest": string;
            "sles12_64Guest": string;
            "nld9Guest": string;
            "oesGuest": string;
            "sjdsGuest": string;
            "mandrakeGuest": string;
            "mandrivaGuest": string;
            "mandriva64Guest": string;
            "turboLinuxGuest": string;
            "turboLinux64Guest": string;
            "ubuntuGuest": string;
            "ubuntu64Guest": string;
            "debian4Guest": string;
            "debian4_64Guest": string;
            "debian5Guest": string;
            "debian5_64Guest": string;
            "debian6Guest": string;
            "debian6_64Guest": string;
            "debian7Guest": string;
            "debian7_64Guest": string;
            "asianux3Guest": string;
            "asianux3_64Guest": string;
            "asianux4Guest": string;
            "asianux4_64Guest": string;
            "opensuseGuest": string;
            "opensuse64Guest": string;
            "fedoraGuest": string;
            "fedora64Guest": string;
            "other24xLinuxGuest": string;
            "other26xLinuxGuest": string;
            "otherLinuxGuest": string;
            "other3xLinuxGuest": string;
            "genericLinuxGuest": string;
            "other24xLinux64Guest": string;
            "other26xLinux64Guest": string;
            "other3xLinux64Guest": string;
            "otherLinux64Guest": string;
            "solaris6Guest": string;
            "solaris7Guest": string;
            "solaris8Guest": string;
            "solaris9Guest": string;
            "solaris10Guest": string;
            "solaris10_64Guest": string;
            "solaris11_64Guest": string;
            "os2Guest": string;
            "eComStationGuest": string;
            "eComStation2Guest": string;
            "netware4Guest": string;
            "netware5Guest": string;
            "netware6Guest": string;
            "openServer5Guest": string;
            "openServer6Guest": string;
            "unixWare7Guest": string;
            "darwinGuest": string;
            "darwin64Guest": string;
            "darwin10Guest": string;
            "darwin10_64Guest": string;
            "darwin11Guest": string;
            "darwin11_64Guest": string;
            "darwin12_64Guest": string;
            "darwin13_64Guest": string;
            "vmkernelGuest": string;
            "vmkernel5Guest": string;
            "otherGuest": string;
            "otherGuest64": string;
         };
         GuestOsDescriptorFirmwareType: {
            "bios": string;
            "efi": string;
         };
         GuestOsDescriptorSupportLevel: {
            "experimental": string;
            "legacy": string;
            "terminated": string;
            "supported": string;
            "unsupported": string;
            "deprecated": string;
            "techPreview": string;
         };
         GuestOsDescriptor: {
            (options?: srmService.vim.GuestOsDescriptor): srmService.vim.GuestOsDescriptor;
         };
         ArrayOfGuestOsDescriptor: {
            (options?: srmService.vim.ArrayOfGuestOsDescriptor): srmService.vim.ArrayOfGuestOsDescriptor;
         };
         VirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: srmService.vim.VirtualMachineIdeDiskDevicePartitionInfo): srmService.vim.VirtualMachineIdeDiskDevicePartitionInfo;
         };
         ArrayOfVirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo): srmService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo;
         };
         VirtualMachineIdeDiskDeviceInfo: {
            (options?: srmService.vim.VirtualMachineIdeDiskDeviceInfo): srmService.vim.VirtualMachineIdeDiskDeviceInfo;
         };
         ArrayOfVirtualMachineIdeDiskDeviceInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo): srmService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo;
         };
         VirtualMachineLegacyNetworkSwitchInfo: {
            (options?: srmService.vim.VirtualMachineLegacyNetworkSwitchInfo): srmService.vim.VirtualMachineLegacyNetworkSwitchInfo;
         };
         ArrayOfVirtualMachineLegacyNetworkSwitchInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo): srmService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo;
         };
         VirtualMachineMessage: {
            (options?: srmService.vim.VirtualMachineMessage): srmService.vim.VirtualMachineMessage;
         };
         ArrayOfVirtualMachineMessage: {
            (options?: srmService.vim.ArrayOfVirtualMachineMessage): srmService.vim.ArrayOfVirtualMachineMessage;
         };
         VirtualMachineMetadataManagerVmMetadataOwnerOwner: {
            "ComVmwareVsphereHA": string;
         };
         VirtualMachineMetadataManagerVmMetadataOwner: {
            (options?: srmService.vim.VirtualMachineMetadataManagerVmMetadataOwner): srmService.vim.VirtualMachineMetadataManagerVmMetadataOwner;
         };
         VirtualMachineMetadataManagerVmMetadataOp: {
            "Update": string;
            "Remove": string;
         };
         VirtualMachineMetadataManagerVmMetadata: {
            (options?: srmService.vim.VirtualMachineMetadataManagerVmMetadata): srmService.vim.VirtualMachineMetadataManagerVmMetadata;
         };
         VirtualMachineMetadataManagerVmMetadataInput: {
            (options?: srmService.vim.VirtualMachineMetadataManagerVmMetadataInput): srmService.vim.VirtualMachineMetadataManagerVmMetadataInput;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataInput: {
            (options?: srmService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput): srmService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput;
         };
         VirtualMachineMetadataManagerVmMetadataResult: {
            (options?: srmService.vim.VirtualMachineMetadataManagerVmMetadataResult): srmService.vim.VirtualMachineMetadataManagerVmMetadataResult;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataResult: {
            (options?: srmService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult): srmService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult;
         };
         VirtualMachineNetworkInfo: {
            (options?: srmService.vim.VirtualMachineNetworkInfo): srmService.vim.VirtualMachineNetworkInfo;
         };
         ArrayOfVirtualMachineNetworkInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineNetworkInfo): srmService.vim.ArrayOfVirtualMachineNetworkInfo;
         };
         VirtualMachineNetworkShaperInfo: {
            (options?: srmService.vim.VirtualMachineNetworkShaperInfo): srmService.vim.VirtualMachineNetworkShaperInfo;
         };
         OpaqueNetworkTargetInfo: {
            (options?: srmService.vim.OpaqueNetworkTargetInfo): srmService.vim.OpaqueNetworkTargetInfo;
         };
         ArrayOfOpaqueNetworkTargetInfo: {
            (options?: srmService.vim.ArrayOfOpaqueNetworkTargetInfo): srmService.vim.ArrayOfOpaqueNetworkTargetInfo;
         };
         VirtualMachineParallelInfo: {
            (options?: srmService.vim.VirtualMachineParallelInfo): srmService.vim.VirtualMachineParallelInfo;
         };
         ArrayOfVirtualMachineParallelInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineParallelInfo): srmService.vim.ArrayOfVirtualMachineParallelInfo;
         };
         VirtualMachinePciPassthroughInfo: {
            (options?: srmService.vim.VirtualMachinePciPassthroughInfo): srmService.vim.VirtualMachinePciPassthroughInfo;
         };
         ArrayOfVirtualMachinePciPassthroughInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachinePciPassthroughInfo): srmService.vim.ArrayOfVirtualMachinePciPassthroughInfo;
         };
         VirtualMachineProfileRawData: {
            (options?: srmService.vim.VirtualMachineProfileRawData): srmService.vim.VirtualMachineProfileRawData;
         };
         VirtualMachineProfileSpec: {
            (options?: srmService.vim.VirtualMachineProfileSpec): srmService.vim.VirtualMachineProfileSpec;
         };
         ArrayOfVirtualMachineProfileSpec: {
            (options?: srmService.vim.ArrayOfVirtualMachineProfileSpec): srmService.vim.ArrayOfVirtualMachineProfileSpec;
         };
         VirtualMachineQuestionInfo: {
            (options?: srmService.vim.VirtualMachineQuestionInfo): srmService.vim.VirtualMachineQuestionInfo;
         };
         VirtualMachineRelocateTransformation: {
            "flat": string;
            "sparse": string;
         };
         VirtualMachineRelocateSpecDiskLocator: {
            (options?: srmService.vim.VirtualMachineRelocateSpecDiskLocator): srmService.vim.VirtualMachineRelocateSpecDiskLocator;
         };
         ArrayOfVirtualMachineRelocateSpecDiskLocator: {
            (options?: srmService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator): srmService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator;
         };
         VirtualMachineRelocateDiskMoveOptions: {
            "moveAllDiskBackingsAndAllowSharing": string;
            "moveAllDiskBackingsAndDisallowSharing": string;
            "moveChildMostDiskBacking": string;
            "createNewChildDiskBacking": string;
            "moveAllDiskBackingsAndConsolidate": string;
         };
         VirtualMachineRelocateSpec: {
            (options?: srmService.vim.VirtualMachineRelocateSpec): srmService.vim.VirtualMachineRelocateSpec;
         };
         ReplicationInfoDiskSettings: {
            (options?: srmService.vim.ReplicationInfoDiskSettings): srmService.vim.ReplicationInfoDiskSettings;
         };
         ArrayOfReplicationInfoDiskSettings: {
            (options?: srmService.vim.ArrayOfReplicationInfoDiskSettings): srmService.vim.ArrayOfReplicationInfoDiskSettings;
         };
         VirtualMachineRuntimeInfoDasProtectionState: {
            (options?: srmService.vim.VirtualMachineRuntimeInfoDasProtectionState): srmService.vim.VirtualMachineRuntimeInfoDasProtectionState;
         };
         VirtualMachineRuntimeInfo: {
            (options?: srmService.vim.VirtualMachineRuntimeInfo): srmService.vim.VirtualMachineRuntimeInfo;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradePolicy: {
            "never": string;
            "onSoftPowerOff": string;
            "always": string;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradeStatus: {
            "none": string;
            "pending": string;
            "success": string;
            "failed": string;
         };
         ScheduledHardwareUpgradeInfo: {
            (options?: srmService.vim.ScheduledHardwareUpgradeInfo): srmService.vim.ScheduledHardwareUpgradeInfo;
         };
         VirtualMachineScsiDiskDeviceInfo: {
            (options?: srmService.vim.VirtualMachineScsiDiskDeviceInfo): srmService.vim.VirtualMachineScsiDiskDeviceInfo;
         };
         ArrayOfVirtualMachineScsiDiskDeviceInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo): srmService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo;
         };
         VirtualMachineScsiPassthroughType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "optical": string;
            "media": string;
            "com": string;
            "raid": string;
            "unknown": string;
         };
         VirtualMachineScsiPassthroughInfo: {
            (options?: srmService.vim.VirtualMachineScsiPassthroughInfo): srmService.vim.VirtualMachineScsiPassthroughInfo;
         };
         ArrayOfVirtualMachineScsiPassthroughInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineScsiPassthroughInfo): srmService.vim.ArrayOfVirtualMachineScsiPassthroughInfo;
         };
         VirtualMachineSerialInfo: {
            (options?: srmService.vim.VirtualMachineSerialInfo): srmService.vim.VirtualMachineSerialInfo;
         };
         ArrayOfVirtualMachineSerialInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineSerialInfo): srmService.vim.ArrayOfVirtualMachineSerialInfo;
         };
         VirtualMachineSnapshotInfo: {
            (options?: srmService.vim.VirtualMachineSnapshotInfo): srmService.vim.VirtualMachineSnapshotInfo;
         };
         VirtualMachineSnapshotTree: {
            (options?: srmService.vim.VirtualMachineSnapshotTree): srmService.vim.VirtualMachineSnapshotTree;
         };
         ArrayOfVirtualMachineSnapshotTree: {
            (options?: srmService.vim.ArrayOfVirtualMachineSnapshotTree): srmService.vim.ArrayOfVirtualMachineSnapshotTree;
         };
         VirtualMachineSoundInfo: {
            (options?: srmService.vim.VirtualMachineSoundInfo): srmService.vim.VirtualMachineSoundInfo;
         };
         ArrayOfVirtualMachineSoundInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineSoundInfo): srmService.vim.ArrayOfVirtualMachineSoundInfo;
         };
         VirtualMachineSriovInfo: {
            (options?: srmService.vim.VirtualMachineSriovInfo): srmService.vim.VirtualMachineSriovInfo;
         };
         ArrayOfVirtualMachineSriovInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineSriovInfo): srmService.vim.ArrayOfVirtualMachineSriovInfo;
         };
         VirtualMachineUsageOnDatastore: {
            (options?: srmService.vim.VirtualMachineUsageOnDatastore): srmService.vim.VirtualMachineUsageOnDatastore;
         };
         ArrayOfVirtualMachineUsageOnDatastore: {
            (options?: srmService.vim.ArrayOfVirtualMachineUsageOnDatastore): srmService.vim.ArrayOfVirtualMachineUsageOnDatastore;
         };
         VirtualMachineStorageInfo: {
            (options?: srmService.vim.VirtualMachineStorageInfo): srmService.vim.VirtualMachineStorageInfo;
         };
         VirtualMachineConfigSummary: {
            (options?: srmService.vim.VirtualMachineConfigSummary): srmService.vim.VirtualMachineConfigSummary;
         };
         VirtualMachineQuickStats: {
            (options?: srmService.vim.VirtualMachineQuickStats): srmService.vim.VirtualMachineQuickStats;
         };
         VirtualMachineGuestSummary: {
            (options?: srmService.vim.VirtualMachineGuestSummary): srmService.vim.VirtualMachineGuestSummary;
         };
         VirtualMachineStorageSummary: {
            (options?: srmService.vim.VirtualMachineStorageSummary): srmService.vim.VirtualMachineStorageSummary;
         };
         VirtualMachineSummary: {
            (options?: srmService.vim.VirtualMachineSummary): srmService.vim.VirtualMachineSummary;
         };
         ArrayOfVirtualMachineSummary: {
            (options?: srmService.vim.ArrayOfVirtualMachineSummary): srmService.vim.ArrayOfVirtualMachineSummary;
         };
         VirtualMachineTargetInfoConfigurationTag: {
            "compliant": string;
            "clusterWide": string;
         };
         VirtualMachineTargetInfo: {
            (options?: srmService.vim.VirtualMachineTargetInfo): srmService.vim.VirtualMachineTargetInfo;
         };
         UpgradePolicy: {
            "manual": string;
            "upgradeAtPowerCycle": string;
         };
         ToolsConfigInfoToolsLastInstallInfo: {
            (options?: srmService.vim.ToolsConfigInfoToolsLastInstallInfo): srmService.vim.ToolsConfigInfoToolsLastInstallInfo;
         };
         ToolsConfigInfo: {
            (options?: srmService.vim.ToolsConfigInfo): srmService.vim.ToolsConfigInfo;
         };
         VirtualMachineUsbInfoSpeed: {
            "low": string;
            "full": string;
            "high": string;
            "superSpeed": string;
            "unknownSpeed": string;
         };
         VirtualMachineUsbInfoFamily: {
            "audio": string;
            "hid": string;
            "hid_bootable": string;
            "physical": string;
            "communication": string;
            "imaging": string;
            "printer": string;
            "storage": string;
            "hub": string;
            "smart_card": string;
            "security": string;
            "video": string;
            "wireless": string;
            "bluetooth": string;
            "wusb": string;
            "pda": string;
            "vendor_specific": string;
            "other": string;
            "unknownFamily": string;
         };
         VirtualMachineUsbInfo: {
            (options?: srmService.vim.VirtualMachineUsbInfo): srmService.vim.VirtualMachineUsbInfo;
         };
         ArrayOfVirtualMachineUsbInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineUsbInfo): srmService.vim.ArrayOfVirtualMachineUsbInfo;
         };
         VirtualMachineVFlashModuleInfo: {
            (options?: srmService.vim.VirtualMachineVFlashModuleInfo): srmService.vim.VirtualMachineVFlashModuleInfo;
         };
         ArrayOfVirtualMachineVFlashModuleInfo: {
            (options?: srmService.vim.ArrayOfVirtualMachineVFlashModuleInfo): srmService.vim.ArrayOfVirtualMachineVFlashModuleInfo;
         };
         VirtualHardware: {
            (options?: srmService.vim.VirtualHardware): srmService.vim.VirtualHardware;
         };
         VirtualHardwareOption: {
            (options?: srmService.vim.VirtualHardwareOption): srmService.vim.VirtualHardwareOption;
         };
         VirtualMachineImportSpec: {
            (options?: srmService.vim.VirtualMachineImportSpec): srmService.vim.VirtualMachineImportSpec;
         };
         CheckResult: {
            (options?: srmService.vim.CheckResult): srmService.vim.CheckResult;
         };
         ArrayOfCheckResult: {
            (options?: srmService.vim.ArrayOfCheckResult): srmService.vim.ArrayOfCheckResult;
         };
         CheckTestType: {
            "sourceTests": string;
            "hostTests": string;
            "resourcePoolTests": string;
            "datastoreTests": string;
            "networkTests": string;
         };
         CustomizationIPSettingsIpV6AddressSpec: {
            (options?: srmService.vim.CustomizationIPSettingsIpV6AddressSpec): srmService.vim.CustomizationIPSettingsIpV6AddressSpec;
         };
         CustomizationNetBIOSMode: {
            "enableNetBIOSViaDhcp": string;
            "enableNetBIOS": string;
            "disableNetBIOS": string;
         };
         CustomizationIPSettings: {
            (options?: srmService.vim.CustomizationIPSettings): srmService.vim.CustomizationIPSettings;
         };
         CustomizationSpec: {
            (options?: srmService.vim.CustomizationSpec): srmService.vim.CustomizationSpec;
         };
         CustomizationName: {
            (options?: srmService.vim.CustomizationName): srmService.vim.CustomizationName;
         };
         CustomizationFixedName: {
            (options?: srmService.vim.CustomizationFixedName): srmService.vim.CustomizationFixedName;
         };
         CustomizationPrefixName: {
            (options?: srmService.vim.CustomizationPrefixName): srmService.vim.CustomizationPrefixName;
         };
         CustomizationVirtualMachineName: {
            (options?: srmService.vim.CustomizationVirtualMachineName): srmService.vim.CustomizationVirtualMachineName;
         };
         CustomizationUnknownName: {
            (options?: srmService.vim.CustomizationUnknownName): srmService.vim.CustomizationUnknownName;
         };
         CustomizationCustomName: {
            (options?: srmService.vim.CustomizationCustomName): srmService.vim.CustomizationCustomName;
         };
         CustomizationPassword: {
            (options?: srmService.vim.CustomizationPassword): srmService.vim.CustomizationPassword;
         };
         CustomizationOptions: {
            (options?: srmService.vim.CustomizationOptions): srmService.vim.CustomizationOptions;
         };
         CustomizationSysprepRebootOption: {
            "reboot": string;
            "noreboot": string;
            "shutdown": string;
         };
         CustomizationWinOptions: {
            (options?: srmService.vim.CustomizationWinOptions): srmService.vim.CustomizationWinOptions;
         };
         CustomizationLinuxOptions: {
            (options?: srmService.vim.CustomizationLinuxOptions): srmService.vim.CustomizationLinuxOptions;
         };
         CustomizationGuiUnattended: {
            (options?: srmService.vim.CustomizationGuiUnattended): srmService.vim.CustomizationGuiUnattended;
         };
         CustomizationUserData: {
            (options?: srmService.vim.CustomizationUserData): srmService.vim.CustomizationUserData;
         };
         CustomizationGuiRunOnce: {
            (options?: srmService.vim.CustomizationGuiRunOnce): srmService.vim.CustomizationGuiRunOnce;
         };
         CustomizationIdentification: {
            (options?: srmService.vim.CustomizationIdentification): srmService.vim.CustomizationIdentification;
         };
         CustomizationLicenseDataMode: {
            "perServer": string;
            "perSeat": string;
         };
         CustomizationLicenseFilePrintData: {
            (options?: srmService.vim.CustomizationLicenseFilePrintData): srmService.vim.CustomizationLicenseFilePrintData;
         };
         CustomizationIdentitySettings: {
            (options?: srmService.vim.CustomizationIdentitySettings): srmService.vim.CustomizationIdentitySettings;
         };
         CustomizationSysprepText: {
            (options?: srmService.vim.CustomizationSysprepText): srmService.vim.CustomizationSysprepText;
         };
         CustomizationSysprep: {
            (options?: srmService.vim.CustomizationSysprep): srmService.vim.CustomizationSysprep;
         };
         CustomizationLinuxPrep: {
            (options?: srmService.vim.CustomizationLinuxPrep): srmService.vim.CustomizationLinuxPrep;
         };
         CustomizationGlobalIPSettings: {
            (options?: srmService.vim.CustomizationGlobalIPSettings): srmService.vim.CustomizationGlobalIPSettings;
         };
         CustomizationIpGenerator: {
            (options?: srmService.vim.CustomizationIpGenerator): srmService.vim.CustomizationIpGenerator;
         };
         CustomizationDhcpIpGenerator: {
            (options?: srmService.vim.CustomizationDhcpIpGenerator): srmService.vim.CustomizationDhcpIpGenerator;
         };
         CustomizationFixedIp: {
            (options?: srmService.vim.CustomizationFixedIp): srmService.vim.CustomizationFixedIp;
         };
         CustomizationUnknownIpGenerator: {
            (options?: srmService.vim.CustomizationUnknownIpGenerator): srmService.vim.CustomizationUnknownIpGenerator;
         };
         CustomizationCustomIpGenerator: {
            (options?: srmService.vim.CustomizationCustomIpGenerator): srmService.vim.CustomizationCustomIpGenerator;
         };
         CustomizationIpV6Generator: {
            (options?: srmService.vim.CustomizationIpV6Generator): srmService.vim.CustomizationIpV6Generator;
         };
         ArrayOfCustomizationIpV6Generator: {
            (options?: srmService.vim.ArrayOfCustomizationIpV6Generator): srmService.vim.ArrayOfCustomizationIpV6Generator;
         };
         CustomizationDhcpIpV6Generator: {
            (options?: srmService.vim.CustomizationDhcpIpV6Generator): srmService.vim.CustomizationDhcpIpV6Generator;
         };
         CustomizationStatelessIpV6Generator: {
            (options?: srmService.vim.CustomizationStatelessIpV6Generator): srmService.vim.CustomizationStatelessIpV6Generator;
         };
         CustomizationFixedIpV6: {
            (options?: srmService.vim.CustomizationFixedIpV6): srmService.vim.CustomizationFixedIpV6;
         };
         CustomizationAutoIpV6Generator: {
            (options?: srmService.vim.CustomizationAutoIpV6Generator): srmService.vim.CustomizationAutoIpV6Generator;
         };
         CustomizationUnknownIpV6Generator: {
            (options?: srmService.vim.CustomizationUnknownIpV6Generator): srmService.vim.CustomizationUnknownIpV6Generator;
         };
         CustomizationCustomIpV6Generator: {
            (options?: srmService.vim.CustomizationCustomIpV6Generator): srmService.vim.CustomizationCustomIpV6Generator;
         };
         CustomizationAdapterMapping: {
            (options?: srmService.vim.CustomizationAdapterMapping): srmService.vim.CustomizationAdapterMapping;
         };
         ArrayOfCustomizationAdapterMapping: {
            (options?: srmService.vim.ArrayOfCustomizationAdapterMapping): srmService.vim.ArrayOfCustomizationAdapterMapping;
         };
         HostDiskMappingPartitionInfo: {
            (options?: srmService.vim.HostDiskMappingPartitionInfo): srmService.vim.HostDiskMappingPartitionInfo;
         };
         HostDiskMappingInfo: {
            (options?: srmService.vim.HostDiskMappingInfo): srmService.vim.HostDiskMappingInfo;
         };
         HostDiskMappingPartitionOption: {
            (options?: srmService.vim.HostDiskMappingPartitionOption): srmService.vim.HostDiskMappingPartitionOption;
         };
         ArrayOfHostDiskMappingPartitionOption: {
            (options?: srmService.vim.ArrayOfHostDiskMappingPartitionOption): srmService.vim.ArrayOfHostDiskMappingPartitionOption;
         };
         HostDiskMappingOption: {
            (options?: srmService.vim.HostDiskMappingOption): srmService.vim.HostDiskMappingOption;
         };
         ParaVirtualSCSIController: {
            (options?: srmService.vim.ParaVirtualSCSIController): srmService.vim.ParaVirtualSCSIController;
         };
         ParaVirtualSCSIControllerOption: {
            (options?: srmService.vim.ParaVirtualSCSIControllerOption): srmService.vim.ParaVirtualSCSIControllerOption;
         };
         VirtualAHCIController: {
            (options?: srmService.vim.VirtualAHCIController): srmService.vim.VirtualAHCIController;
         };
         VirtualAHCIControllerOption: {
            (options?: srmService.vim.VirtualAHCIControllerOption): srmService.vim.VirtualAHCIControllerOption;
         };
         VirtualBusLogicController: {
            (options?: srmService.vim.VirtualBusLogicController): srmService.vim.VirtualBusLogicController;
         };
         VirtualBusLogicControllerOption: {
            (options?: srmService.vim.VirtualBusLogicControllerOption): srmService.vim.VirtualBusLogicControllerOption;
         };
         VirtualCdromIsoBackingInfo: {
            (options?: srmService.vim.VirtualCdromIsoBackingInfo): srmService.vim.VirtualCdromIsoBackingInfo;
         };
         VirtualCdromPassthroughBackingInfo: {
            (options?: srmService.vim.VirtualCdromPassthroughBackingInfo): srmService.vim.VirtualCdromPassthroughBackingInfo;
         };
         VirtualCdromRemotePassthroughBackingInfo: {
            (options?: srmService.vim.VirtualCdromRemotePassthroughBackingInfo): srmService.vim.VirtualCdromRemotePassthroughBackingInfo;
         };
         VirtualCdromAtapiBackingInfo: {
            (options?: srmService.vim.VirtualCdromAtapiBackingInfo): srmService.vim.VirtualCdromAtapiBackingInfo;
         };
         VirtualCdromRemoteAtapiBackingInfo: {
            (options?: srmService.vim.VirtualCdromRemoteAtapiBackingInfo): srmService.vim.VirtualCdromRemoteAtapiBackingInfo;
         };
         VirtualCdrom: {
            (options?: srmService.vim.VirtualCdrom): srmService.vim.VirtualCdrom;
         };
         VirtualCdromIsoBackingOption: {
            (options?: srmService.vim.VirtualCdromIsoBackingOption): srmService.vim.VirtualCdromIsoBackingOption;
         };
         VirtualCdromPassthroughBackingOption: {
            (options?: srmService.vim.VirtualCdromPassthroughBackingOption): srmService.vim.VirtualCdromPassthroughBackingOption;
         };
         VirtualCdromRemotePassthroughBackingOption: {
            (options?: srmService.vim.VirtualCdromRemotePassthroughBackingOption): srmService.vim.VirtualCdromRemotePassthroughBackingOption;
         };
         VirtualCdromAtapiBackingOption: {
            (options?: srmService.vim.VirtualCdromAtapiBackingOption): srmService.vim.VirtualCdromAtapiBackingOption;
         };
         VirtualCdromRemoteAtapiBackingOption: {
            (options?: srmService.vim.VirtualCdromRemoteAtapiBackingOption): srmService.vim.VirtualCdromRemoteAtapiBackingOption;
         };
         VirtualCdromOption: {
            (options?: srmService.vim.VirtualCdromOption): srmService.vim.VirtualCdromOption;
         };
         VirtualController: {
            (options?: srmService.vim.VirtualController): srmService.vim.VirtualController;
         };
         VirtualControllerOption: {
            (options?: srmService.vim.VirtualControllerOption): srmService.vim.VirtualControllerOption;
         };
         VirtualDeviceBackingInfo: {
            (options?: srmService.vim.VirtualDeviceBackingInfo): srmService.vim.VirtualDeviceBackingInfo;
         };
         VirtualDeviceFileBackingInfo: {
            (options?: srmService.vim.VirtualDeviceFileBackingInfo): srmService.vim.VirtualDeviceFileBackingInfo;
         };
         VirtualDeviceDeviceBackingInfo: {
            (options?: srmService.vim.VirtualDeviceDeviceBackingInfo): srmService.vim.VirtualDeviceDeviceBackingInfo;
         };
         VirtualDeviceRemoteDeviceBackingInfo: {
            (options?: srmService.vim.VirtualDeviceRemoteDeviceBackingInfo): srmService.vim.VirtualDeviceRemoteDeviceBackingInfo;
         };
         VirtualDevicePipeBackingInfo: {
            (options?: srmService.vim.VirtualDevicePipeBackingInfo): srmService.vim.VirtualDevicePipeBackingInfo;
         };
         VirtualDeviceURIBackingInfo: {
            (options?: srmService.vim.VirtualDeviceURIBackingInfo): srmService.vim.VirtualDeviceURIBackingInfo;
         };
         VirtualDeviceConnectInfoStatus: {
            "ok": string;
            "recoverableError": string;
            "unrecoverableError": string;
            "untried": string;
         };
         VirtualDeviceConnectInfo: {
            (options?: srmService.vim.VirtualDeviceConnectInfo): srmService.vim.VirtualDeviceConnectInfo;
         };
         VirtualDeviceBusSlotInfo: {
            (options?: srmService.vim.VirtualDeviceBusSlotInfo): srmService.vim.VirtualDeviceBusSlotInfo;
         };
         VirtualDevicePciBusSlotInfo: {
            (options?: srmService.vim.VirtualDevicePciBusSlotInfo): srmService.vim.VirtualDevicePciBusSlotInfo;
         };
         VirtualDevice: {
            (options?: srmService.vim.VirtualDevice): srmService.vim.VirtualDevice;
         };
         ArrayOfVirtualDevice: {
            (options?: srmService.vim.ArrayOfVirtualDevice): srmService.vim.ArrayOfVirtualDevice;
         };
         VirtualDeviceBackingOption: {
            (options?: srmService.vim.VirtualDeviceBackingOption): srmService.vim.VirtualDeviceBackingOption;
         };
         ArrayOfVirtualDeviceBackingOption: {
            (options?: srmService.vim.ArrayOfVirtualDeviceBackingOption): srmService.vim.ArrayOfVirtualDeviceBackingOption;
         };
         VirtualDeviceFileExtension: {
            "iso": string;
            "flp": string;
            "vmdk": string;
            "dsk": string;
            "rdm": string;
         };
         VirtualDeviceFileBackingOption: {
            (options?: srmService.vim.VirtualDeviceFileBackingOption): srmService.vim.VirtualDeviceFileBackingOption;
         };
         VirtualDeviceDeviceBackingOption: {
            (options?: srmService.vim.VirtualDeviceDeviceBackingOption): srmService.vim.VirtualDeviceDeviceBackingOption;
         };
         VirtualDeviceRemoteDeviceBackingOption: {
            (options?: srmService.vim.VirtualDeviceRemoteDeviceBackingOption): srmService.vim.VirtualDeviceRemoteDeviceBackingOption;
         };
         VirtualDevicePipeBackingOption: {
            (options?: srmService.vim.VirtualDevicePipeBackingOption): srmService.vim.VirtualDevicePipeBackingOption;
         };
         VirtualDeviceURIBackingOptionDirection: {
            "server": string;
            "client": string;
         };
         VirtualDeviceURIBackingOption: {
            (options?: srmService.vim.VirtualDeviceURIBackingOption): srmService.vim.VirtualDeviceURIBackingOption;
         };
         VirtualDeviceConnectOption: {
            (options?: srmService.vim.VirtualDeviceConnectOption): srmService.vim.VirtualDeviceConnectOption;
         };
         VirtualDeviceBusSlotOption: {
            (options?: srmService.vim.VirtualDeviceBusSlotOption): srmService.vim.VirtualDeviceBusSlotOption;
         };
         VirtualDeviceOption: {
            (options?: srmService.vim.VirtualDeviceOption): srmService.vim.VirtualDeviceOption;
         };
         ArrayOfVirtualDeviceOption: {
            (options?: srmService.vim.ArrayOfVirtualDeviceOption): srmService.vim.ArrayOfVirtualDeviceOption;
         };
         VirtualDeviceConfigSpecOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         VirtualDeviceConfigSpecFileOperation: {
            "create": string;
            "destroy": string;
            "replace": string;
         };
         VirtualDeviceConfigSpec: {
            (options?: srmService.vim.VirtualDeviceConfigSpec): srmService.vim.VirtualDeviceConfigSpec;
         };
         ArrayOfVirtualDeviceConfigSpec: {
            (options?: srmService.vim.ArrayOfVirtualDeviceConfigSpec): srmService.vim.ArrayOfVirtualDeviceConfigSpec;
         };
         VirtualDiskDeltaDiskFormat: {
            "redoLogFormat": string;
            "nativeFormat": string;
            "seSparseFormat": string;
         };
         VirtualDiskSparseVer1BackingInfo: {
            (options?: srmService.vim.VirtualDiskSparseVer1BackingInfo): srmService.vim.VirtualDiskSparseVer1BackingInfo;
         };
         VirtualDiskSparseVer2BackingInfo: {
            (options?: srmService.vim.VirtualDiskSparseVer2BackingInfo): srmService.vim.VirtualDiskSparseVer2BackingInfo;
         };
         VirtualDiskFlatVer1BackingInfo: {
            (options?: srmService.vim.VirtualDiskFlatVer1BackingInfo): srmService.vim.VirtualDiskFlatVer1BackingInfo;
         };
         VirtualDiskFlatVer2BackingInfo: {
            (options?: srmService.vim.VirtualDiskFlatVer2BackingInfo): srmService.vim.VirtualDiskFlatVer2BackingInfo;
         };
         VirtualDiskSeSparseBackingInfo: {
            (options?: srmService.vim.VirtualDiskSeSparseBackingInfo): srmService.vim.VirtualDiskSeSparseBackingInfo;
         };
         VirtualDiskRawDiskVer2BackingInfo: {
            (options?: srmService.vim.VirtualDiskRawDiskVer2BackingInfo): srmService.vim.VirtualDiskRawDiskVer2BackingInfo;
         };
         VirtualDiskPartitionedRawDiskVer2BackingInfo: {
            (options?: srmService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo): srmService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo;
         };
         VirtualDiskRawDiskMappingVer1BackingInfo: {
            (options?: srmService.vim.VirtualDiskRawDiskMappingVer1BackingInfo): srmService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
         };
         VirtualDiskVFlashCacheConfigInfoCacheConsistencyType: {
            "strong": string;
            "weak": string;
         };
         VirtualDiskVFlashCacheConfigInfoCacheMode: {
            "write_thru": string;
            "write_back": string;
         };
         VirtualDiskVFlashCacheConfigInfo: {
            (options?: srmService.vim.VirtualDiskVFlashCacheConfigInfo): srmService.vim.VirtualDiskVFlashCacheConfigInfo;
         };
         VirtualDisk: {
            (options?: srmService.vim.VirtualDisk): srmService.vim.VirtualDisk;
         };
         ArrayOfVirtualDisk: {
            (options?: srmService.vim.ArrayOfVirtualDisk): srmService.vim.ArrayOfVirtualDisk;
         };
         VirtualDiskId: {
            (options?: srmService.vim.VirtualDiskId): srmService.vim.VirtualDiskId;
         };
         VirtualDiskMode: {
            "persistent": string;
            "nonpersistent": string;
            "undoable": string;
            "independent_persistent": string;
            "independent_nonpersistent": string;
            "append": string;
         };
         VirtualDiskCompatibilityMode: {
            "virtualMode": string;
            "physicalMode": string;
         };
         VirtualDiskSparseVer1BackingOption: {
            (options?: srmService.vim.VirtualDiskSparseVer1BackingOption): srmService.vim.VirtualDiskSparseVer1BackingOption;
         };
         VirtualDiskSparseVer2BackingOption: {
            (options?: srmService.vim.VirtualDiskSparseVer2BackingOption): srmService.vim.VirtualDiskSparseVer2BackingOption;
         };
         VirtualDiskFlatVer1BackingOption: {
            (options?: srmService.vim.VirtualDiskFlatVer1BackingOption): srmService.vim.VirtualDiskFlatVer1BackingOption;
         };
         VirtualDiskDeltaDiskFormatsSupported: {
            (options?: srmService.vim.VirtualDiskDeltaDiskFormatsSupported): srmService.vim.VirtualDiskDeltaDiskFormatsSupported;
         };
         ArrayOfVirtualDiskDeltaDiskFormatsSupported: {
            (options?: srmService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported): srmService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported;
         };
         VirtualDiskFlatVer2BackingOption: {
            (options?: srmService.vim.VirtualDiskFlatVer2BackingOption): srmService.vim.VirtualDiskFlatVer2BackingOption;
         };
         VirtualDiskSeSparseBackingOption: {
            (options?: srmService.vim.VirtualDiskSeSparseBackingOption): srmService.vim.VirtualDiskSeSparseBackingOption;
         };
         VirtualDiskRawDiskVer2BackingOption: {
            (options?: srmService.vim.VirtualDiskRawDiskVer2BackingOption): srmService.vim.VirtualDiskRawDiskVer2BackingOption;
         };
         VirtualDiskPartitionedRawDiskVer2BackingOption: {
            (options?: srmService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption): srmService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption;
         };
         VirtualDiskRawDiskMappingVer1BackingOption: {
            (options?: srmService.vim.VirtualDiskRawDiskMappingVer1BackingOption): srmService.vim.VirtualDiskRawDiskMappingVer1BackingOption;
         };
         VirtualDiskOptionVFlashCacheConfigOption: {
            (options?: srmService.vim.VirtualDiskOptionVFlashCacheConfigOption): srmService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         };
         VirtualDiskOption: {
            (options?: srmService.vim.VirtualDiskOption): srmService.vim.VirtualDiskOption;
         };
         VirtualDiskConfigSpec: {
            (options?: srmService.vim.VirtualDiskConfigSpec): srmService.vim.VirtualDiskConfigSpec;
         };
         VirtualE1000: {
            (options?: srmService.vim.VirtualE1000): srmService.vim.VirtualE1000;
         };
         VirtualE1000Option: {
            (options?: srmService.vim.VirtualE1000Option): srmService.vim.VirtualE1000Option;
         };
         VirtualE1000e: {
            (options?: srmService.vim.VirtualE1000e): srmService.vim.VirtualE1000e;
         };
         VirtualE1000eOption: {
            (options?: srmService.vim.VirtualE1000eOption): srmService.vim.VirtualE1000eOption;
         };
         VirtualEnsoniq1371: {
            (options?: srmService.vim.VirtualEnsoniq1371): srmService.vim.VirtualEnsoniq1371;
         };
         VirtualEnsoniq1371Option: {
            (options?: srmService.vim.VirtualEnsoniq1371Option): srmService.vim.VirtualEnsoniq1371Option;
         };
         VirtualEthernetCardNetworkBackingInfo: {
            (options?: srmService.vim.VirtualEthernetCardNetworkBackingInfo): srmService.vim.VirtualEthernetCardNetworkBackingInfo;
         };
         VirtualEthernetCardLegacyNetworkBackingInfo: {
            (options?: srmService.vim.VirtualEthernetCardLegacyNetworkBackingInfo): srmService.vim.VirtualEthernetCardLegacyNetworkBackingInfo;
         };
         VirtualEthernetCardDistributedVirtualPortBackingInfo: {
            (options?: srmService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo): srmService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo;
         };
         VirtualEthernetCardOpaqueNetworkBackingInfo: {
            (options?: srmService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo): srmService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo;
         };
         VirtualEthernetCard: {
            (options?: srmService.vim.VirtualEthernetCard): srmService.vim.VirtualEthernetCard;
         };
         VirtualEthernetCardNetworkBackingOption: {
            (options?: srmService.vim.VirtualEthernetCardNetworkBackingOption): srmService.vim.VirtualEthernetCardNetworkBackingOption;
         };
         VirtualEthernetCardOpaqueNetworkBackingOption: {
            (options?: srmService.vim.VirtualEthernetCardOpaqueNetworkBackingOption): srmService.vim.VirtualEthernetCardOpaqueNetworkBackingOption;
         };
         VirtualEthernetCardLegacyNetworkDeviceName: {
            "bridged": string;
            "nat": string;
            "hostonly": string;
         };
         VirtualEthernetCardLegacyNetworkBackingOption: {
            (options?: srmService.vim.VirtualEthernetCardLegacyNetworkBackingOption): srmService.vim.VirtualEthernetCardLegacyNetworkBackingOption;
         };
         VirtualEthernetCardDVPortBackingOption: {
            (options?: srmService.vim.VirtualEthernetCardDVPortBackingOption): srmService.vim.VirtualEthernetCardDVPortBackingOption;
         };
         VirtualEthernetCardMacType: {
            "manual": string;
            "generated": string;
            "assigned": string;
         };
         VirtualEthernetCardOption: {
            (options?: srmService.vim.VirtualEthernetCardOption): srmService.vim.VirtualEthernetCardOption;
         };
         VirtualFloppyImageBackingInfo: {
            (options?: srmService.vim.VirtualFloppyImageBackingInfo): srmService.vim.VirtualFloppyImageBackingInfo;
         };
         VirtualFloppyDeviceBackingInfo: {
            (options?: srmService.vim.VirtualFloppyDeviceBackingInfo): srmService.vim.VirtualFloppyDeviceBackingInfo;
         };
         VirtualFloppyRemoteDeviceBackingInfo: {
            (options?: srmService.vim.VirtualFloppyRemoteDeviceBackingInfo): srmService.vim.VirtualFloppyRemoteDeviceBackingInfo;
         };
         VirtualFloppy: {
            (options?: srmService.vim.VirtualFloppy): srmService.vim.VirtualFloppy;
         };
         VirtualFloppyImageBackingOption: {
            (options?: srmService.vim.VirtualFloppyImageBackingOption): srmService.vim.VirtualFloppyImageBackingOption;
         };
         VirtualFloppyDeviceBackingOption: {
            (options?: srmService.vim.VirtualFloppyDeviceBackingOption): srmService.vim.VirtualFloppyDeviceBackingOption;
         };
         VirtualFloppyRemoteDeviceBackingOption: {
            (options?: srmService.vim.VirtualFloppyRemoteDeviceBackingOption): srmService.vim.VirtualFloppyRemoteDeviceBackingOption;
         };
         VirtualFloppyOption: {
            (options?: srmService.vim.VirtualFloppyOption): srmService.vim.VirtualFloppyOption;
         };
         VirtualHdAudioCard: {
            (options?: srmService.vim.VirtualHdAudioCard): srmService.vim.VirtualHdAudioCard;
         };
         VirtualHdAudioCardOption: {
            (options?: srmService.vim.VirtualHdAudioCardOption): srmService.vim.VirtualHdAudioCardOption;
         };
         VirtualIDEController: {
            (options?: srmService.vim.VirtualIDEController): srmService.vim.VirtualIDEController;
         };
         VirtualIDEControllerOption: {
            (options?: srmService.vim.VirtualIDEControllerOption): srmService.vim.VirtualIDEControllerOption;
         };
         VirtualKeyboard: {
            (options?: srmService.vim.VirtualKeyboard): srmService.vim.VirtualKeyboard;
         };
         VirtualKeyboardOption: {
            (options?: srmService.vim.VirtualKeyboardOption): srmService.vim.VirtualKeyboardOption;
         };
         VirtualLsiLogicController: {
            (options?: srmService.vim.VirtualLsiLogicController): srmService.vim.VirtualLsiLogicController;
         };
         VirtualLsiLogicControllerOption: {
            (options?: srmService.vim.VirtualLsiLogicControllerOption): srmService.vim.VirtualLsiLogicControllerOption;
         };
         VirtualLsiLogicSASController: {
            (options?: srmService.vim.VirtualLsiLogicSASController): srmService.vim.VirtualLsiLogicSASController;
         };
         VirtualLsiLogicSASControllerOption: {
            (options?: srmService.vim.VirtualLsiLogicSASControllerOption): srmService.vim.VirtualLsiLogicSASControllerOption;
         };
         VirtualPCIController: {
            (options?: srmService.vim.VirtualPCIController): srmService.vim.VirtualPCIController;
         };
         VirtualPCIControllerOption: {
            (options?: srmService.vim.VirtualPCIControllerOption): srmService.vim.VirtualPCIControllerOption;
         };
         VirtualPCIPassthroughDeviceBackingInfo: {
            (options?: srmService.vim.VirtualPCIPassthroughDeviceBackingInfo): srmService.vim.VirtualPCIPassthroughDeviceBackingInfo;
         };
         VirtualPCIPassthrough: {
            (options?: srmService.vim.VirtualPCIPassthrough): srmService.vim.VirtualPCIPassthrough;
         };
         VirtualPCIPassthroughDeviceBackingOption: {
            (options?: srmService.vim.VirtualPCIPassthroughDeviceBackingOption): srmService.vim.VirtualPCIPassthroughDeviceBackingOption;
         };
         VirtualPCIPassthroughOption: {
            (options?: srmService.vim.VirtualPCIPassthroughOption): srmService.vim.VirtualPCIPassthroughOption;
         };
         VirtualPCNet32: {
            (options?: srmService.vim.VirtualPCNet32): srmService.vim.VirtualPCNet32;
         };
         VirtualPCNet32Option: {
            (options?: srmService.vim.VirtualPCNet32Option): srmService.vim.VirtualPCNet32Option;
         };
         VirtualPS2Controller: {
            (options?: srmService.vim.VirtualPS2Controller): srmService.vim.VirtualPS2Controller;
         };
         VirtualPS2ControllerOption: {
            (options?: srmService.vim.VirtualPS2ControllerOption): srmService.vim.VirtualPS2ControllerOption;
         };
         VirtualParallelPortFileBackingInfo: {
            (options?: srmService.vim.VirtualParallelPortFileBackingInfo): srmService.vim.VirtualParallelPortFileBackingInfo;
         };
         VirtualParallelPortDeviceBackingInfo: {
            (options?: srmService.vim.VirtualParallelPortDeviceBackingInfo): srmService.vim.VirtualParallelPortDeviceBackingInfo;
         };
         VirtualParallelPort: {
            (options?: srmService.vim.VirtualParallelPort): srmService.vim.VirtualParallelPort;
         };
         VirtualParallelPortFileBackingOption: {
            (options?: srmService.vim.VirtualParallelPortFileBackingOption): srmService.vim.VirtualParallelPortFileBackingOption;
         };
         VirtualParallelPortDeviceBackingOption: {
            (options?: srmService.vim.VirtualParallelPortDeviceBackingOption): srmService.vim.VirtualParallelPortDeviceBackingOption;
         };
         VirtualParallelPortOption: {
            (options?: srmService.vim.VirtualParallelPortOption): srmService.vim.VirtualParallelPortOption;
         };
         VirtualPointingDeviceDeviceBackingInfo: {
            (options?: srmService.vim.VirtualPointingDeviceDeviceBackingInfo): srmService.vim.VirtualPointingDeviceDeviceBackingInfo;
         };
         VirtualPointingDevice: {
            (options?: srmService.vim.VirtualPointingDevice): srmService.vim.VirtualPointingDevice;
         };
         VirtualPointingDeviceHostChoice: {
            "autodetect": string;
            "intellimouseExplorer": string;
            "intellimousePs2": string;
            "logitechMouseman": string;
            "microsoft_serial": string;
            "mouseSystems": string;
            "mousemanSerial": string;
            "ps2": string;
         };
         VirtualPointingDeviceBackingOption: {
            (options?: srmService.vim.VirtualPointingDeviceBackingOption): srmService.vim.VirtualPointingDeviceBackingOption;
         };
         VirtualPointingDeviceOption: {
            (options?: srmService.vim.VirtualPointingDeviceOption): srmService.vim.VirtualPointingDeviceOption;
         };
         VirtualSATAController: {
            (options?: srmService.vim.VirtualSATAController): srmService.vim.VirtualSATAController;
         };
         VirtualSATAControllerOption: {
            (options?: srmService.vim.VirtualSATAControllerOption): srmService.vim.VirtualSATAControllerOption;
         };
         VirtualSCSISharing: {
            "noSharing": string;
            "virtualSharing": string;
            "physicalSharing": string;
         };
         ArrayOfVirtualSCSISharing: {
            (options?: srmService.vim.ArrayOfVirtualSCSISharing): srmService.vim.ArrayOfVirtualSCSISharing;
         };
         VirtualSCSIController: {
            (options?: srmService.vim.VirtualSCSIController): srmService.vim.VirtualSCSIController;
         };
         VirtualSCSIControllerOption: {
            (options?: srmService.vim.VirtualSCSIControllerOption): srmService.vim.VirtualSCSIControllerOption;
         };
         VirtualSCSIPassthroughDeviceBackingInfo: {
            (options?: srmService.vim.VirtualSCSIPassthroughDeviceBackingInfo): srmService.vim.VirtualSCSIPassthroughDeviceBackingInfo;
         };
         VirtualSCSIPassthrough: {
            (options?: srmService.vim.VirtualSCSIPassthrough): srmService.vim.VirtualSCSIPassthrough;
         };
         VirtualSCSIPassthroughDeviceBackingOption: {
            (options?: srmService.vim.VirtualSCSIPassthroughDeviceBackingOption): srmService.vim.VirtualSCSIPassthroughDeviceBackingOption;
         };
         VirtualSCSIPassthroughOption: {
            (options?: srmService.vim.VirtualSCSIPassthroughOption): srmService.vim.VirtualSCSIPassthroughOption;
         };
         VirtualSIOController: {
            (options?: srmService.vim.VirtualSIOController): srmService.vim.VirtualSIOController;
         };
         VirtualSIOControllerOption: {
            (options?: srmService.vim.VirtualSIOControllerOption): srmService.vim.VirtualSIOControllerOption;
         };
         VirtualSerialPortFileBackingInfo: {
            (options?: srmService.vim.VirtualSerialPortFileBackingInfo): srmService.vim.VirtualSerialPortFileBackingInfo;
         };
         VirtualSerialPortDeviceBackingInfo: {
            (options?: srmService.vim.VirtualSerialPortDeviceBackingInfo): srmService.vim.VirtualSerialPortDeviceBackingInfo;
         };
         VirtualSerialPortPipeBackingInfo: {
            (options?: srmService.vim.VirtualSerialPortPipeBackingInfo): srmService.vim.VirtualSerialPortPipeBackingInfo;
         };
         VirtualSerialPortURIBackingInfo: {
            (options?: srmService.vim.VirtualSerialPortURIBackingInfo): srmService.vim.VirtualSerialPortURIBackingInfo;
         };
         VirtualSerialPortThinPrintBackingInfo: {
            (options?: srmService.vim.VirtualSerialPortThinPrintBackingInfo): srmService.vim.VirtualSerialPortThinPrintBackingInfo;
         };
         VirtualSerialPort: {
            (options?: srmService.vim.VirtualSerialPort): srmService.vim.VirtualSerialPort;
         };
         VirtualSerialPortEndPoint: {
            "client": string;
            "server": string;
         };
         VirtualSerialPortFileBackingOption: {
            (options?: srmService.vim.VirtualSerialPortFileBackingOption): srmService.vim.VirtualSerialPortFileBackingOption;
         };
         VirtualSerialPortDeviceBackingOption: {
            (options?: srmService.vim.VirtualSerialPortDeviceBackingOption): srmService.vim.VirtualSerialPortDeviceBackingOption;
         };
         VirtualSerialPortPipeBackingOption: {
            (options?: srmService.vim.VirtualSerialPortPipeBackingOption): srmService.vim.VirtualSerialPortPipeBackingOption;
         };
         VirtualSerialPortURIBackingOption: {
            (options?: srmService.vim.VirtualSerialPortURIBackingOption): srmService.vim.VirtualSerialPortURIBackingOption;
         };
         VirtualSerialPortThinPrintBackingOption: {
            (options?: srmService.vim.VirtualSerialPortThinPrintBackingOption): srmService.vim.VirtualSerialPortThinPrintBackingOption;
         };
         VirtualSerialPortOption: {
            (options?: srmService.vim.VirtualSerialPortOption): srmService.vim.VirtualSerialPortOption;
         };
         VirtualSoundBlaster16: {
            (options?: srmService.vim.VirtualSoundBlaster16): srmService.vim.VirtualSoundBlaster16;
         };
         VirtualSoundBlaster16Option: {
            (options?: srmService.vim.VirtualSoundBlaster16Option): srmService.vim.VirtualSoundBlaster16Option;
         };
         VirtualSoundCardDeviceBackingInfo: {
            (options?: srmService.vim.VirtualSoundCardDeviceBackingInfo): srmService.vim.VirtualSoundCardDeviceBackingInfo;
         };
         VirtualSoundCard: {
            (options?: srmService.vim.VirtualSoundCard): srmService.vim.VirtualSoundCard;
         };
         VirtualSoundCardDeviceBackingOption: {
            (options?: srmService.vim.VirtualSoundCardDeviceBackingOption): srmService.vim.VirtualSoundCardDeviceBackingOption;
         };
         VirtualSoundCardOption: {
            (options?: srmService.vim.VirtualSoundCardOption): srmService.vim.VirtualSoundCardOption;
         };
         VirtualSriovEthernetCardSriovBackingInfo: {
            (options?: srmService.vim.VirtualSriovEthernetCardSriovBackingInfo): srmService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         };
         VirtualSriovEthernetCard: {
            (options?: srmService.vim.VirtualSriovEthernetCard): srmService.vim.VirtualSriovEthernetCard;
         };
         VirtualSriovEthernetCardSriovBackingOption: {
            (options?: srmService.vim.VirtualSriovEthernetCardSriovBackingOption): srmService.vim.VirtualSriovEthernetCardSriovBackingOption;
         };
         VirtualSriovEthernetCardOption: {
            (options?: srmService.vim.VirtualSriovEthernetCardOption): srmService.vim.VirtualSriovEthernetCardOption;
         };
         VirtualUSBUSBBackingInfo: {
            (options?: srmService.vim.VirtualUSBUSBBackingInfo): srmService.vim.VirtualUSBUSBBackingInfo;
         };
         VirtualUSBRemoteHostBackingInfo: {
            (options?: srmService.vim.VirtualUSBRemoteHostBackingInfo): srmService.vim.VirtualUSBRemoteHostBackingInfo;
         };
         VirtualUSBRemoteClientBackingInfo: {
            (options?: srmService.vim.VirtualUSBRemoteClientBackingInfo): srmService.vim.VirtualUSBRemoteClientBackingInfo;
         };
         VirtualUSB: {
            (options?: srmService.vim.VirtualUSB): srmService.vim.VirtualUSB;
         };
         VirtualUSBControllerPciBusSlotInfo: {
            (options?: srmService.vim.VirtualUSBControllerPciBusSlotInfo): srmService.vim.VirtualUSBControllerPciBusSlotInfo;
         };
         VirtualUSBController: {
            (options?: srmService.vim.VirtualUSBController): srmService.vim.VirtualUSBController;
         };
         VirtualUSBControllerOption: {
            (options?: srmService.vim.VirtualUSBControllerOption): srmService.vim.VirtualUSBControllerOption;
         };
         VirtualUSBUSBBackingOption: {
            (options?: srmService.vim.VirtualUSBUSBBackingOption): srmService.vim.VirtualUSBUSBBackingOption;
         };
         VirtualUSBRemoteHostBackingOption: {
            (options?: srmService.vim.VirtualUSBRemoteHostBackingOption): srmService.vim.VirtualUSBRemoteHostBackingOption;
         };
         VirtualUSBRemoteClientBackingOption: {
            (options?: srmService.vim.VirtualUSBRemoteClientBackingOption): srmService.vim.VirtualUSBRemoteClientBackingOption;
         };
         VirtualUSBOption: {
            (options?: srmService.vim.VirtualUSBOption): srmService.vim.VirtualUSBOption;
         };
         VirtualUSBXHCIController: {
            (options?: srmService.vim.VirtualUSBXHCIController): srmService.vim.VirtualUSBXHCIController;
         };
         VirtualUSBXHCIControllerOption: {
            (options?: srmService.vim.VirtualUSBXHCIControllerOption): srmService.vim.VirtualUSBXHCIControllerOption;
         };
         VirtualMachineVMCIDevice: {
            (options?: srmService.vim.VirtualMachineVMCIDevice): srmService.vim.VirtualMachineVMCIDevice;
         };
         VirtualMachineVMCIDeviceOption: {
            (options?: srmService.vim.VirtualMachineVMCIDeviceOption): srmService.vim.VirtualMachineVMCIDeviceOption;
         };
         VirtualMachineVMIROM: {
            (options?: srmService.vim.VirtualMachineVMIROM): srmService.vim.VirtualMachineVMIROM;
         };
         VirtualVMIROMOption: {
            (options?: srmService.vim.VirtualVMIROMOption): srmService.vim.VirtualVMIROMOption;
         };
         VirtualMachineVideoCardUse3dRenderer: {
            "automatic": string;
            "software": string;
            "hardware": string;
         };
         VirtualMachineVideoCard: {
            (options?: srmService.vim.VirtualMachineVideoCard): srmService.vim.VirtualMachineVideoCard;
         };
         VirtualVideoCardOption: {
            (options?: srmService.vim.VirtualVideoCardOption): srmService.vim.VirtualVideoCardOption;
         };
         VirtualVmxnet: {
            (options?: srmService.vim.VirtualVmxnet): srmService.vim.VirtualVmxnet;
         };
         VirtualVmxnet2: {
            (options?: srmService.vim.VirtualVmxnet2): srmService.vim.VirtualVmxnet2;
         };
         VirtualVmxnet2Option: {
            (options?: srmService.vim.VirtualVmxnet2Option): srmService.vim.VirtualVmxnet2Option;
         };
         VirtualVmxnet3: {
            (options?: srmService.vim.VirtualVmxnet3): srmService.vim.VirtualVmxnet3;
         };
         VirtualVmxnet3Option: {
            (options?: srmService.vim.VirtualVmxnet3Option): srmService.vim.VirtualVmxnet3Option;
         };
         VirtualVmxnetOption: {
            (options?: srmService.vim.VirtualVmxnetOption): srmService.vim.VirtualVmxnetOption;
         };
         GuestFileAttributes: {
            (options?: srmService.vim.GuestFileAttributes): srmService.vim.GuestFileAttributes;
         };
         GuestPosixFileAttributes: {
            (options?: srmService.vim.GuestPosixFileAttributes): srmService.vim.GuestPosixFileAttributes;
         };
         GuestWindowsFileAttributes: {
            (options?: srmService.vim.GuestWindowsFileAttributes): srmService.vim.GuestWindowsFileAttributes;
         };
         GuestFileType: {
            "file": string;
            "directory": string;
            "symlink": string;
         };
         GuestFileInfo: {
            (options?: srmService.vim.GuestFileInfo): srmService.vim.GuestFileInfo;
         };
         ArrayOfGuestFileInfo: {
            (options?: srmService.vim.ArrayOfGuestFileInfo): srmService.vim.ArrayOfGuestFileInfo;
         };
         GuestListFileInfo: {
            (options?: srmService.vim.GuestListFileInfo): srmService.vim.GuestListFileInfo;
         };
         FileTransferInformation: {
            (options?: srmService.vim.FileTransferInformation): srmService.vim.FileTransferInformation;
         };
         GuestAuthentication: {
            (options?: srmService.vim.GuestAuthentication): srmService.vim.GuestAuthentication;
         };
         NamePasswordAuthentication: {
            (options?: srmService.vim.NamePasswordAuthentication): srmService.vim.NamePasswordAuthentication;
         };
         GuestProgramSpec: {
            (options?: srmService.vim.GuestProgramSpec): srmService.vim.GuestProgramSpec;
         };
         GuestWindowsProgramSpec: {
            (options?: srmService.vim.GuestWindowsProgramSpec): srmService.vim.GuestWindowsProgramSpec;
         };
         GuestProcessInfo: {
            (options?: srmService.vim.GuestProcessInfo): srmService.vim.GuestProcessInfo;
         };
         ArrayOfGuestProcessInfo: {
            (options?: srmService.vim.ArrayOfGuestProcessInfo): srmService.vim.ArrayOfGuestProcessInfo;
         };
         SSPIAuthentication: {
            (options?: srmService.vim.SSPIAuthentication): srmService.vim.SSPIAuthentication;
         };
         TicketedSessionAuthentication: {
            (options?: srmService.vim.TicketedSessionAuthentication): srmService.vim.TicketedSessionAuthentication;
         };
         VsanClusterConfigInfoHostDefaultInfo: {
            (options?: srmService.vim.VsanClusterConfigInfoHostDefaultInfo): srmService.vim.VsanClusterConfigInfoHostDefaultInfo;
         };
         VsanClusterConfigInfo: {
            (options?: srmService.vim.VsanClusterConfigInfo): srmService.vim.VsanClusterConfigInfo;
         };
         VsanHostClusterStatusStateCompletionEstimate: {
            (options?: srmService.vim.VsanHostClusterStatusStateCompletionEstimate): srmService.vim.VsanHostClusterStatusStateCompletionEstimate;
         };
         VsanHostClusterStatusState: {
            (options?: srmService.vim.VsanHostClusterStatusState): srmService.vim.VsanHostClusterStatusState;
         };
         VsanHostClusterStatus: {
            (options?: srmService.vim.VsanHostClusterStatus): srmService.vim.VsanHostClusterStatus;
         };
         VsanHostConfigInfoStorageInfo: {
            (options?: srmService.vim.VsanHostConfigInfoStorageInfo): srmService.vim.VsanHostConfigInfoStorageInfo;
         };
         VsanHostConfigInfoClusterInfo: {
            (options?: srmService.vim.VsanHostConfigInfoClusterInfo): srmService.vim.VsanHostConfigInfoClusterInfo;
         };
         VsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: srmService.vim.VsanHostConfigInfoNetworkInfoPortConfig): srmService.vim.VsanHostConfigInfoNetworkInfoPortConfig;
         };
         ArrayOfVsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: srmService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig): srmService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig;
         };
         VsanHostConfigInfoNetworkInfo: {
            (options?: srmService.vim.VsanHostConfigInfoNetworkInfo): srmService.vim.VsanHostConfigInfoNetworkInfo;
         };
         VsanHostConfigInfo: {
            (options?: srmService.vim.VsanHostConfigInfo): srmService.vim.VsanHostConfigInfo;
         };
         ArrayOfVsanHostConfigInfo: {
            (options?: srmService.vim.ArrayOfVsanHostConfigInfo): srmService.vim.ArrayOfVsanHostConfigInfo;
         };
         VsanHostDecommissionModeObjectAction: {
            "noAction": string;
            "ensureObjectAccessibility": string;
            "evacuateAllData": string;
         };
         VsanHostDecommissionMode: {
            (options?: srmService.vim.VsanHostDecommissionMode): srmService.vim.VsanHostDecommissionMode;
         };
         VsanHostDiskMapResult: {
            (options?: srmService.vim.VsanHostDiskMapResult): srmService.vim.VsanHostDiskMapResult;
         };
         ArrayOfVsanHostDiskMapResult: {
            (options?: srmService.vim.ArrayOfVsanHostDiskMapResult): srmService.vim.ArrayOfVsanHostDiskMapResult;
         };
         VsanHostDiskMapping: {
            (options?: srmService.vim.VsanHostDiskMapping): srmService.vim.VsanHostDiskMapping;
         };
         ArrayOfVsanHostDiskMapping: {
            (options?: srmService.vim.ArrayOfVsanHostDiskMapping): srmService.vim.ArrayOfVsanHostDiskMapping;
         };
         VsanHostDiskResultState: {
            "inUse": string;
            "eligible": string;
            "ineligible": string;
         };
         VsanHostDiskResult: {
            (options?: srmService.vim.VsanHostDiskResult): srmService.vim.VsanHostDiskResult;
         };
         ArrayOfVsanHostDiskResult: {
            (options?: srmService.vim.ArrayOfVsanHostDiskResult): srmService.vim.ArrayOfVsanHostDiskResult;
         };
         VsanHostHealthState: {
            "unknown": string;
            "healthy": string;
            "unhealthy": string;
         };
         VsanHostIpConfig: {
            (options?: srmService.vim.VsanHostIpConfig): srmService.vim.VsanHostIpConfig;
         };
         VsanHostMembershipInfo: {
            (options?: srmService.vim.VsanHostMembershipInfo): srmService.vim.VsanHostMembershipInfo;
         };
         ArrayOfVsanHostMembershipInfo: {
            (options?: srmService.vim.ArrayOfVsanHostMembershipInfo): srmService.vim.ArrayOfVsanHostMembershipInfo;
         };
         VsanHostNodeState: {
            "error": string;
            "disabled": string;
            "agent": string;
            "master": string;
            "backup": string;
            "starting": string;
            "stopping": string;
            "enteringMaintenanceMode": string;
            "exitingMaintenanceMode": string;
            "decommissioning": string;
         };
         VsanDiskIssueType: {
            "nonExist": string;
            "stampMismatch": string;
            "unknown": string;
         };
         VsanHostRuntimeInfoDiskIssue: {
            (options?: srmService.vim.VsanHostRuntimeInfoDiskIssue): srmService.vim.VsanHostRuntimeInfoDiskIssue;
         };
         ArrayOfVsanHostRuntimeInfoDiskIssue: {
            (options?: srmService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue): srmService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue;
         };
         VsanHostRuntimeInfo: {
            (options?: srmService.vim.VsanHostRuntimeInfo): srmService.vim.VsanHostRuntimeInfo;
         };
      }
   }
   namespace srmService {
      interface xs {
      }
      namespace xs {
         interface AnyType {
            value: string;
         }
         interface AnyURI {
            value: string;
         }
         interface Base64Binary {
            value: string;
         }
         interface Boolean {
            value: string;
         }
         interface Byte {
            value: string;
         }
         interface DateTime {
            value: string;
         }
         interface Double {
            value: string;
         }
         interface Float {
            value: string;
         }
         interface ID {
            value: string;
         }
         interface Int {
            value: string;
         }
         interface Integer {
            value: string;
         }
         interface Long {
            value: string;
         }
         interface NCName {
            value: string;
         }
         interface NegativeInteger {
            value: string;
         }
         interface NonNegativeInteger {
            value: string;
         }
         interface NonPositiveInteger {
            value: string;
         }
         interface PositiveInteger {
            value: string;
         }
         interface QName {
            value: string;
         }
         interface Short {
            value: string;
         }
         interface String {
            value: string;
         }
         interface UnsignedLong {
            value: string;
         }
      }
      interface srm {
      }
      namespace srm {
         interface SrmCallout extends srmService.vim.DynamicData {
            description: string;
            uuid: string;
         }
         interface ArrayOfSrmCallout {
            srmCallout?: Array<srmService.srm.SrmCallout>;
         }
         interface SrmCommand extends srmService.srm.SrmCallout {
            command: string;
            timeout: number;
            runInRecoveredVm: boolean;
         }
         enum SrmApiRecoveryMode {
            "recovery",
            "test",
            "migration",
         }
         enum SrmApiRecoveryState {
            "uninitialized",
            "running",
            "cancelled",
            "paused",
            "prompting",
            "completed",
            "error",
         }
         interface SrmApiSettings extends srmService.vim.DynamicData {
            name: string;
            description?: string;
            state: srmService.srm.SrmApiRecoveryState;
         }
         interface SrmPrompt extends srmService.srm.SrmCallout {
            promptText: string;
         }
         interface SrmProtectionInventoryMappingInfo extends srmService.vim.DynamicData {
            pools?: Array<srmService.vim.ManagedObjectReference>;
            folders?: Array<srmService.vim.ManagedObjectReference>;
            networks?: Array<srmService.vim.ManagedObjectReference>;
         }
         enum SrmProtectionGroupProtectionState {
            "ready",
            "failedOver",
            "partiallyRecovered",
            "recovering",
            "recovered",
            "testing",
            "shadowing",
         }
         enum SrmProtectionGroupReplicationType {
            "san",
            "vr",
         }
         interface SrmProtectionGroupInfo extends srmService.vim.DynamicData {
            name: string;
            description?: string;
            type?: string;
         }
         interface SrmProtectionGroupProtectedVm extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            protectedVm: string;
            peerProtectedVm: string;
            state: srmService.srm.SrmProtectionGroupProtectionState;
            peerState: srmService.srm.SrmProtectionGroupProtectionState;
            needsConfiguration: boolean;
            faults?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfSrmProtectionGroupProtectedVm {
            srmProtectionGroupProtectedVm?: Array<srmService.srm.SrmProtectionGroupProtectedVm>;
         }
         enum SrmProtectionGroupVmProtectionInfoProtectionStatus {
            "isProtected",
            "canBeProtected",
            "canNotBeProtected",
            "needsConfiguration",
         }
         interface SrmProtectionGroupVmProtectionInfo extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            protectedVm?: string;
            peerProtectedVm?: string;
            status: srmService.srm.SrmProtectionGroupVmProtectionInfoProtectionStatus;
            protectionGroup?: srmService.vim.ManagedObjectReference;
            protectionGroupName?: string;
            recoveryPlans?: Array<srmService.vim.ManagedObjectReference>;
            recoveryPlanNames?: Array<string>;
            faults?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfSrmProtectionGroupVmProtectionInfo {
            srmProtectionGroupVmProtectionInfo?: Array<srmService.srm.SrmProtectionGroupVmProtectionInfo>;
         }
         interface SrmProtectionGroupVmProtectionSpec extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfSrmProtectionGroupVmProtectionSpec {
            srmProtectionGroupVmProtectionSpec?: Array<srmService.srm.SrmProtectionGroupVmProtectionSpec>;
         }
         interface SrmProtectionGroupPeer extends srmService.vim.DynamicData {
            group: srmService.vim.ManagedObjectReference;
            state: srmService.srm.SrmProtectionGroupProtectionState;
         }
         enum SrmProtectionGroupOperationalLocation {
            "inProtectedSite",
            "notInProtectedSite",
            "unknownLocation",
         }
         interface SrmProtectionTaskVmTask extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            task: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfSrmProtectionTaskVmTask {
            srmProtectionTaskVmTask?: Array<srmService.srm.SrmProtectionTaskVmTask>;
         }
         enum SrmRecoveryPlanRecoveryMode {
            "failover",
            "test",
            "cleanupTest",
            "reprotect",
            "revert",
            "migrate",
         }
         enum SrmRecoveryPlanRecoveryState {
            "ready",
            "protecting",
            "running",
            "cancelling",
            "prompting",
            "failedOver",
            "needsCleanup",
            "needsFailover",
            "needsRollback",
            "needsReprotect",
            "error",
         }
         enum SrmRecoveryPlanRecoveryPlanLocation {
            "localToRecoverySite",
            "notLocalToRecoverySite",
            "unknownLocationNoPgs",
            "unknownLocation",
         }
         interface SrmRecoveryPlanRecoveryPrompt extends srmService.vim.DynamicData {
            key: string;
            data: string;
         }
         interface ArrayOfSrmRecoveryPlanRecoveryPrompt {
            srmRecoveryPlanRecoveryPrompt?: Array<srmService.srm.SrmRecoveryPlanRecoveryPrompt>;
         }
         interface SrmRecoveryPlanInfo extends srmService.vim.DynamicData {
            name: string;
            description?: string;
            state: srmService.srm.SrmRecoveryPlanRecoveryState;
            protectionGroups?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface SrmRecoveryPlanPeer extends srmService.vim.DynamicData {
            plan?: srmService.vim.ManagedObjectReference;
            state?: srmService.srm.SrmRecoveryPlanRecoveryState;
         }
         enum SrmRecoveryResultResultState {
            "success",
            "warnings",
            "errors",
            "cancelled",
         }
         interface SrmRecoveryResult extends srmService.vim.DynamicData {
            key: number;
            plan?: srmService.vim.ManagedObjectReference;
            name: string;
            description?: string;
            startTime: Date;
            stopTime: Date;
            executionTimeInSeconds: number;
            totalPausedTimeInSeconds: number;
            resultState: srmService.srm.SrmRecoveryResultResultState;
            runMode: srmService.srm.SrmRecoveryPlanRecoveryMode;
            warningCount: number;
            errorCount: number;
         }
         interface ArrayOfSrmRecoveryResult {
            srmRecoveryResult?: Array<srmService.srm.SrmRecoveryResult>;
         }
         enum SrmRecoverySettingsStatus {
            "ok",
            "syncConflict",
         }
         enum SrmRecoverySettingsRecoveryPriority {
            "highest",
            "higher",
            "normal",
            "lower",
            "lowest",
         }
         interface SrmRecoverySettings extends srmService.vim.DynamicData {
            changeVersion?: number;
            status: string;
            recoveryPriority: string;
            skipGuestShutdown: boolean;
            powerOffTimeoutSeconds?: number;
            finalPowerState: srmService.vim.VirtualMachinePowerState;
            localFaultToleranceState: boolean;
            remoteFaultToleranceState: boolean;
            powerOnTimeoutSeconds?: number;
            powerOnDelaySeconds?: number;
            prePowerOnCallouts?: Array<srmService.srm.SrmCallout>;
            postPowerOnCallouts?: Array<srmService.srm.SrmCallout>;
         }
         interface SrmRemoteSite extends srmService.vim.DynamicData {
            name: string;
            uuid: string;
            vcHost: string;
            vcPort: number;
            lkpUrl?: string;
            vcInstanceUuid?: string;
         }
         interface SrmServiceInstanceContent extends srmService.vim.DynamicData {
            apiVersion?: string;
            srmApi?: srmService.vim.ManagedObjectReference;
            protection?: srmService.vim.ManagedObjectReference;
            recovery?: srmService.vim.ManagedObjectReference;
            inventoryMapping?: srmService.vim.ManagedObjectReference;
            about?: srmService.vim.AboutInfo;
         }
         interface SrmSolutionUserInfo extends srmService.vim.DynamicData {
            username: string;
            siteUuid: string;
         }
         interface SrmFaultAlreadyLoggedInFault extends srmService.vim.MethodFault {
         }
         interface SrmFaultConnectionDownFault extends srmService.vim.MethodFault {
         }
         interface SrmFaultConnectionLimitReached extends srmService.vim.MethodFault {
            connectionLimit: number;
         }
         interface SrmFaultDependencyConflict extends srmService.vim.MethodFault {
         }
         interface SrmFaultDuplicateName extends srmService.vim.MethodFault {
         }
         interface SrmFaultInsufficientLicensesFault extends srmService.vim.MethodFault {
         }
         interface SrmFaultInternalError extends srmService.vim.MethodFault {
            reason: string;
         }
         interface SrmFaultInvalidArgument extends srmService.vim.MethodFault {
         }
         interface SrmFaultInvalidLogin extends srmService.vim.MethodFault {
         }
         interface SrmFaultInvalidPrimaryFolder extends srmService.vim.MethodFault {
            folder: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultInvalidPrimaryNetwork extends srmService.vim.MethodFault {
            network: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultInvalidSecondaryFolder extends srmService.vim.MethodFault {
            site: srmService.srm.SrmRemoteSite;
            folder: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultInvalidSecondaryNetwork extends srmService.vim.MethodFault {
            site: srmService.srm.SrmRemoteSite;
            network: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultInvalidState extends srmService.vim.MethodFault {
         }
         interface SrmFaultNoPermission extends srmService.vim.RuntimeFault {
            object: srmService.vim.ManagedObjectReference;
            privilegeId: string;
         }
         interface SrmFaultNotAuthenticated extends srmService.vim.MethodFault {
         }
         interface SrmFaultPromptNotFound extends srmService.vim.MethodFault {
            key: string;
         }
         interface SrmFaultProtectionGroupNotEmpty extends srmService.vim.MethodFault {
         }
         interface SrmFaultProtectionGroupNotFound extends srmService.vim.MethodFault {
         }
         interface SrmFaultRecoveryPlanLocked extends srmService.vim.MethodFault {
         }
         interface SrmFaultRecoveryPlanNotFound extends srmService.vim.MethodFault {
         }
         interface SrmFaultRecoveryResultNotFound extends srmService.vim.MethodFault {
            runKey: number;
         }
         interface SrmFaultRemoteSiteNotEnabled extends srmService.vim.MethodFault {
         }
         interface SrmFaultReplicationProviderFault extends srmService.vim.MethodFault {
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface SrmFaultStringArgumentTooLong extends srmService.vim.MethodFault {
            invalidProperty: string;
            maxSize: number;
         }
         interface SrmFaultUnknownPrimaryFolder extends srmService.vim.MethodFault {
            folder: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultUnknownPrimaryNetwork extends srmService.vim.MethodFault {
            network: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultUnknownPrimaryResourcePool extends srmService.vim.MethodFault {
            pool: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultUnknownSecondaryFolder extends srmService.vim.MethodFault {
            site: srmService.srm.SrmRemoteSite;
            primaryObjects?: Array<srmService.vim.ManagedObjectReference>;
            folder: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultUnknownSecondaryNetwork extends srmService.vim.MethodFault {
            site: srmService.srm.SrmRemoteSite;
            primaryObjects?: Array<srmService.vim.ManagedObjectReference>;
            network: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultUnknownSecondaryResourcePool extends srmService.vim.MethodFault {
            site: srmService.srm.SrmRemoteSite;
            primaryObjects?: Array<srmService.vim.ManagedObjectReference>;
            pool: srmService.vim.ManagedObjectReference;
         }
         interface SrmFaultVersionConflict extends srmService.vim.MethodFault {
         }
         interface SrmFaultVmNotFoundInRecoveryPlan extends srmService.vim.MethodFault {
         }
      }
      interface srmPort {
         isCreateProtectionGroupComplete(_this: srmService.vim.ManagedObjectReference): Promise<boolean>;
         getCreateProtectionGroupResult(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.TaskInfo>;
         getNewProtectionGroup(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         srmLogin(_this: srmService.vim.ManagedObjectReference, username: string, password: string): Promise<void>;
         srmLoginByToken(_this: srmService.vim.ManagedObjectReference, samlToken: string): Promise<void>;
         srmLogout(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         getApiVersion(_this: srmService.vim.ManagedObjectReference): Promise<string>;
         listRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<string>>;
         recoveryPlanSettings(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.srm.SrmApiSettings>;
         recoveryPlanStart(_this: srmService.vim.ManagedObjectReference, name: string, mode: srmService.srm.SrmApiRecoveryMode): Promise<void>;
         recoveryPlanPause(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanResume(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanCancel(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         recoveryPlanAnswerPrompt(_this: srmService.vim.ManagedObjectReference, name: string): Promise<void>;
         getFinalStatus(_this: srmService.vim.ManagedObjectReference, name: string, offset: number, maxLines: number): Promise<Array<string>>;
         getName(_this: srmService.vim.ManagedObjectReference): Promise<string>;
         getParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         addFolderMapping(_this: srmService.vim.ManagedObjectReference, primaryFolder: srmService.vim.ManagedObjectReference, secondaryFolder: srmService.vim.ManagedObjectReference): Promise<void>;
         addNetworkMapping(_this: srmService.vim.ManagedObjectReference, primaryNetwork: srmService.vim.ManagedObjectReference, secondaryNetwork: srmService.vim.ManagedObjectReference): Promise<void>;
         addResourcePoolMapping(_this: srmService.vim.ManagedObjectReference, primaryPool: srmService.vim.ManagedObjectReference, secondaryPool: srmService.vim.ManagedObjectReference): Promise<void>;
         getProtectionGroupRootFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listReplicatedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listUnassignedReplicatedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionListProtectedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listProtectionGroups(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listInventoryMappings(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionInventoryMappingInfo>;
         listUnassignedReplicatedVms(_this: srmService.vim.ManagedObjectReference, replicationType: string): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionListProtectedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         createAbrProtectionGroup(_this: srmService.vim.ManagedObjectReference, location: srmService.vim.ManagedObjectReference, name: string, description: string, datastores: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         createHbrProtectionGroup(_this: srmService.vim.ManagedObjectReference, location: srmService.vim.ManagedObjectReference, name: string, description: string, vms: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         getInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupInfo>;
         getPeer(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupPeer>;
         protectionGroupGetParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listProtectedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionGroupProtectedVm>>;
         listProtectedDatastores(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listAssociatedVms(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getProtectionState(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmProtectionGroupProtectionState>;
         protectionGroupListRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         protectionGroupQueryVmProtection(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<Array<srmService.srm.SrmProtectionGroupVmProtectionInfo>>;
         protectVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.srm.SrmProtectionGroupVmProtectionSpec>): Promise<srmService.vim.ManagedObjectReference>;
         unprotectVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<srmService.vim.ManagedObjectReference>;
         associateVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<void>;
         unassociateVms(_this: srmService.vim.ManagedObjectReference, vms: Array<srmService.vim.ManagedObjectReference>): Promise<void>;
         listChildProtectionGroupFolders(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listChildProtectionGroups(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getProtectionGroup(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.vim.ManagedObjectReference>;
         getTasks(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionTaskVmTask>>;
         isComplete(_this: srmService.vim.ManagedObjectReference): Promise<boolean>;
         getResult(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.TaskInfo>>;
         getProtectionStatus(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmProtectionGroupVmProtectionInfo>>;
         getRecoveryPlanRootFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         listPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getHistory(_this: srmService.vim.ManagedObjectReference, plan: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         recoveryPlanGetInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoveryPlanInfo>;
         recoveryPlanGetParentFolder(_this: srmService.vim.ManagedObjectReference): Promise<srmService.vim.ManagedObjectReference>;
         recoveryPlanGetPeer(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoveryPlanPeer>;
         start(_this: srmService.vim.ManagedObjectReference, mode: srmService.srm.SrmRecoveryPlanRecoveryMode): Promise<void>;
         cancel(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         listPrompts(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.srm.SrmRecoveryPlanRecoveryPrompt>>;
         answerPrompt(_this: srmService.vim.ManagedObjectReference, key: string, cancelVmRecovery: boolean, response: string): Promise<void>;
         getRecoverySettings(_this: srmService.vim.ManagedObjectReference, vm: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRecoverySettings>;
         setRecoverySettings(_this: srmService.vim.ManagedObjectReference, vm: srmService.vim.ManagedObjectReference, settings: srmService.srm.SrmRecoverySettings): Promise<void>;
         addProtectionGroup(_this: srmService.vim.ManagedObjectReference, group: srmService.vim.ManagedObjectReference): Promise<void>;
         listChildRecoveryPlanFolders(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         listChildRecoveryPlans(_this: srmService.vim.ManagedObjectReference): Promise<Array<srmService.vim.ManagedObjectReference>>;
         getRecoveryPlan(_this: srmService.vim.ManagedObjectReference, name: string): Promise<srmService.vim.ManagedObjectReference>;
         getResultCount(_this: srmService.vim.ManagedObjectReference): Promise<number>;
         getRecoveryResult(_this: srmService.vim.ManagedObjectReference, length: number): Promise<Array<srmService.srm.SrmRecoveryResult>>;
         getResultLength(_this: srmService.vim.ManagedObjectReference, key: number): Promise<number>;
         retrieveStatus(_this: srmService.vim.ManagedObjectReference, key: number, offset: number, maxLines: number): Promise<Array<string>>;
         retrieveContent(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmServiceInstanceContent>;
         srmLoginLocale(_this: srmService.vim.ManagedObjectReference, username: string, password: string, locale: string): Promise<void>;
         srmLoginByTokenLocale(_this: srmService.vim.ManagedObjectReference, samlToken: string, locale: string): Promise<void>;
         srmLoginSites(_this: srmService.vim.ManagedObjectReference, username: string, password: string, remoteUsername: string, remotePassword: string, locale: string): Promise<void>;
         srmLoginSitesByToken(_this: srmService.vim.ManagedObjectReference, samlToken: string, remoteSamlToken: string, locale: string): Promise<void>;
         srmLoginRemoteSite(_this: srmService.vim.ManagedObjectReference, remoteUsername: string, remotePassword: string, locale: string): Promise<void>;
         srmLoginRemoteSiteByToken(_this: srmService.vim.ManagedObjectReference, remoteSamlToken: string, locale: string): Promise<void>;
         srmLogoutLocale(_this: srmService.vim.ManagedObjectReference): Promise<void>;
         getSolutionUserInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmSolutionUserInfo>;
         getPairedSite(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmRemoteSite>;
         getPairedSiteSolutionUserInfo(_this: srmService.vim.ManagedObjectReference): Promise<srmService.srm.SrmSolutionUserInfo>;
         getSiteName(_this: srmService.vim.ManagedObjectReference): Promise<string>;
      }
      namespace srmPort {
      }
      interface vim {
      }
      namespace vim {
         interface DynamicArray {
            val: Array<any>;
         }
         interface DynamicData {
         }
         interface DynamicProperty {
            name: string;
            val: any;
         }
         interface ArrayOfDynamicProperty {
            dynamicProperty?: Array<srmService.vim.DynamicProperty>;
         }
         interface KeyAnyValue extends srmService.vim.DynamicData {
            key: string;
            value: any;
         }
         interface ArrayOfKeyAnyValue {
            keyAnyValue?: Array<srmService.vim.KeyAnyValue>;
         }
         interface LocalizableMessage extends srmService.vim.DynamicData {
            key: string;
            arg?: Array<srmService.vim.KeyAnyValue>;
            message?: string;
         }
         interface ArrayOfLocalizableMessage {
            localizableMessage?: Array<srmService.vim.LocalizableMessage>;
         }
         interface LocalizedMethodFault extends srmService.vim.DynamicData {
            fault: srmService.vim.MethodFault;
            localizedMessage?: string;
         }
         interface MethodFault {
            faultCause?: srmService.vim.LocalizedMethodFault;
            faultMessage?: Array<srmService.vim.LocalizableMessage>;
         }
         interface ArrayOfMethodFault {
            methodFault?: Array<srmService.vim.MethodFault>;
         }
         interface RuntimeFault extends srmService.vim.MethodFault {
         }
         interface HostCommunication extends srmService.vim.RuntimeFault {
         }
         interface HostNotConnected extends srmService.vim.HostCommunication {
         }
         interface HostNotReachable extends srmService.vim.HostCommunication {
         }
         interface InvalidArgument extends srmService.vim.RuntimeFault {
            invalidProperty?: string;
         }
         interface InvalidRequest extends srmService.vim.RuntimeFault {
         }
         interface InvalidType extends srmService.vim.InvalidRequest {
            argument?: string;
         }
         interface ManagedObjectNotFound extends srmService.vim.RuntimeFault {
            obj: srmService.vim.ManagedObjectReference;
         }
         interface MethodNotFound extends srmService.vim.InvalidRequest {
            receiver: srmService.vim.ManagedObjectReference;
            method: string;
         }
         interface NotEnoughLicenses extends srmService.vim.RuntimeFault {
         }
         interface NotImplemented extends srmService.vim.RuntimeFault {
         }
         interface NotSupported extends srmService.vim.RuntimeFault {
         }
         interface RequestCanceled extends srmService.vim.RuntimeFault {
         }
         interface SecurityError extends srmService.vim.RuntimeFault {
         }
         interface SystemError extends srmService.vim.RuntimeFault {
            reason: string;
         }
         interface UnexpectedFault extends srmService.vim.RuntimeFault {
            faultName: string;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface ManagedObjectReference extends srmService.xs.String {
            type: string;
            value: string;
         }
         interface ArrayOfString {
            string?: Array<string>;
         }
         interface ArrayOfAnyType {
            anyType?: Array<any>;
         }
         interface ArrayOfManagedObjectReference {
            managedObjectReference?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ArrayOfBoolean {
            boolean?: Array<boolean>;
         }
         interface ArrayOfByte {
            byte?: Array<number>;
         }
         interface ArrayOfDouble {
            double?: Array<number>;
         }
         interface ArrayOfInt {
            int?: Array<number>;
         }
         interface ArrayOfLong {
            long?: Array<number>;
         }
         interface ArrayOfShort {
            short?: Array<number>;
         }
         interface AboutInfo extends srmService.vim.DynamicData {
            name: string;
            fullName: string;
            vendor: string;
            version: string;
            build: string;
            localeVersion?: string;
            localeBuild?: string;
            osType: string;
            productLineId: string;
            apiType: string;
            apiVersion: string;
            instanceUuid?: string;
            licenseProductName?: string;
            licenseProductVersion?: string;
         }
         interface AuthorizationDescription extends srmService.vim.DynamicData {
            privilege: Array<srmService.vim.ElementDescription>;
            privilegeGroup: Array<srmService.vim.ElementDescription>;
         }
         interface Permission extends srmService.vim.DynamicData {
            entity?: srmService.vim.ManagedObjectReference;
            principal: string;
            group: boolean;
            roleId: number;
            propagate: boolean;
         }
         interface ArrayOfPermission {
            permission?: Array<srmService.vim.Permission>;
         }
         interface AuthorizationRole extends srmService.vim.DynamicData {
            roleId: number;
            system: boolean;
            name: string;
            info: srmService.vim.Description;
            privilege?: Array<string>;
         }
         interface ArrayOfAuthorizationRole {
            authorizationRole?: Array<srmService.vim.AuthorizationRole>;
         }
         interface AuthorizationPrivilege extends srmService.vim.DynamicData {
            privId: string;
            onParent: boolean;
            name: string;
            privGroupName: string;
         }
         interface ArrayOfAuthorizationPrivilege {
            authorizationPrivilege?: Array<srmService.vim.AuthorizationPrivilege>;
         }
         interface PrivilegeAvailability extends srmService.vim.DynamicData {
            privId: string;
            isGranted: boolean;
         }
         interface ArrayOfPrivilegeAvailability {
            privilegeAvailability?: Array<srmService.vim.PrivilegeAvailability>;
         }
         interface EntityPrivilege extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            privAvailability: Array<srmService.vim.PrivilegeAvailability>;
         }
         interface ArrayOfEntityPrivilege {
            entityPrivilege?: Array<srmService.vim.EntityPrivilege>;
         }
         interface BoolPolicy extends srmService.vim.InheritablePolicy {
            value?: boolean;
         }
         interface Capability extends srmService.vim.DynamicData {
            provisioningSupported: boolean;
            multiHostSupported: boolean;
            userShellAccessSupported: boolean;
            supportedEVCMode?: Array<srmService.vim.EVCMode>;
            networkBackupAndRestoreSupported?: boolean;
         }
         interface ClusterComputeResourceSummary extends srmService.vim.ComputeResourceSummary {
            currentFailoverLevel: number;
            admissionControlInfo?: srmService.vim.ClusterDasAdmissionControlInfo;
            numVmotions: number;
            targetBalance?: number;
            currentBalance?: number;
            currentEVCModeKey?: string;
            dasData?: srmService.vim.ClusterDasData;
         }
         interface ComputeResourceSummary extends srmService.vim.DynamicData {
            totalCpu: number;
            totalMemory: number;
            numCpuCores: number;
            numCpuThreads: number;
            effectiveCpu: number;
            effectiveMemory: number;
            numHosts: number;
            numEffectiveHosts: number;
            overallStatus: srmService.vim.ManagedEntityStatus;
         }
         interface ComputeResourceConfigInfo extends srmService.vim.DynamicData {
            vmSwapPlacement: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState {
            "licensed",
            "unlicensed",
            "unknown",
         }
         interface ComputeResourceHostSPBMLicenseInfo extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            licenseState: srmService.vim.ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
         }
         interface ArrayOfComputeResourceHostSPBMLicenseInfo {
            computeResourceHostSPBMLicenseInfo?: Array<srmService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface ComputeResourceConfigSpec extends srmService.vim.DynamicData {
            vmSwapPlacement?: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ConfigSpecOperation {
            "add",
            "edit",
            "remove",
         }
         interface CustomFieldDef extends srmService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            managedObjectType?: string;
            fieldDefPrivileges?: srmService.vim.PrivilegePolicyDef;
            fieldInstancePrivileges?: srmService.vim.PrivilegePolicyDef;
         }
         interface ArrayOfCustomFieldDef {
            customFieldDef?: Array<srmService.vim.CustomFieldDef>;
         }
         interface CustomFieldValue extends srmService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfCustomFieldValue {
            customFieldValue?: Array<srmService.vim.CustomFieldValue>;
         }
         interface CustomFieldStringValue extends srmService.vim.CustomFieldValue {
            value: string;
         }
         interface CustomizationSpecInfo extends srmService.vim.DynamicData {
            name: string;
            description: string;
            type: string;
            changeVersion?: string;
            lastUpdateTime?: Date;
         }
         interface ArrayOfCustomizationSpecInfo {
            customizationSpecInfo?: Array<srmService.vim.CustomizationSpecInfo>;
         }
         interface CustomizationSpecItem extends srmService.vim.DynamicData {
            info: srmService.vim.CustomizationSpecInfo;
            spec: srmService.vim.CustomizationSpec;
         }
         interface DatacenterConfigInfo extends srmService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         interface DatacenterConfigSpec extends srmService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         enum DatastoreAccessible {
            "True",
            "False",
         }
         enum DatastoreSummaryMaintenanceModeState {
            "normal",
            "enteringMaintenance",
            "inMaintenance",
         }
         interface DatastoreSummary extends srmService.vim.DynamicData {
            datastore?: srmService.vim.ManagedObjectReference;
            name: string;
            url: string;
            capacity: number;
            freeSpace: number;
            uncommitted?: number;
            accessible: boolean;
            multipleHostAccess?: boolean;
            type: string;
            maintenanceMode?: string;
         }
         interface DatastoreInfo extends srmService.vim.DynamicData {
            name: string;
            url: string;
            freeSpace: number;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            timestamp?: Date;
            containerId?: string;
         }
         interface DatastoreCapability extends srmService.vim.DynamicData {
            directoryHierarchySupported: boolean;
            rawDiskMappingsSupported: boolean;
            perFileThinProvisioningSupported: boolean;
            storageIORMSupported?: boolean;
            nativeSnapshotSupported?: boolean;
            topLevelDirectoryCreateSupported?: boolean;
            seSparseSupported?: boolean;
         }
         interface DatastoreHostMount extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            mountInfo: srmService.vim.HostMountInfo;
         }
         interface ArrayOfDatastoreHostMount {
            datastoreHostMount?: Array<srmService.vim.DatastoreHostMount>;
         }
         interface DatastoreMountPathDatastorePair extends srmService.vim.DynamicData {
            oldMountPath: string;
            datastore: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatastoreMountPathDatastorePair {
            datastoreMountPathDatastorePair?: Array<srmService.vim.DatastoreMountPathDatastorePair>;
         }
         interface Description extends srmService.vim.DynamicData {
            label: string;
            summary: string;
         }
         enum DiagnosticManagerLogCreator {
            "vpxd",
            "vpxa",
            "hostd",
            "serverd",
            "install",
            "vpxClient",
            "recordLog",
         }
         enum DiagnosticManagerLogFormat {
            "plain",
         }
         interface DiagnosticManagerLogDescriptor extends srmService.vim.DynamicData {
            key: string;
            fileName: string;
            creator: string;
            format: string;
            mimeType: string;
            info: srmService.vim.Description;
         }
         interface ArrayOfDiagnosticManagerLogDescriptor {
            diagnosticManagerLogDescriptor?: Array<srmService.vim.DiagnosticManagerLogDescriptor>;
         }
         interface DiagnosticManagerLogHeader extends srmService.vim.DynamicData {
            lineStart: number;
            lineEnd: number;
            lineText?: Array<string>;
         }
         interface DiagnosticManagerBundleInfo extends srmService.vim.DynamicData {
            system?: srmService.vim.ManagedObjectReference;
            url: string;
         }
         interface ArrayOfDiagnosticManagerBundleInfo {
            diagnosticManagerBundleInfo?: Array<srmService.vim.DiagnosticManagerBundleInfo>;
         }
         enum DistributedVirtualSwitchProductSpecOperationType {
            "preInstall",
            "upgrade",
            "notifyAvailableUpgrade",
            "proceedWithUpgrade",
            "updateBundleInfo",
         }
         interface DVSContactInfo extends srmService.vim.DynamicData {
            name?: string;
            contact?: string;
         }
         enum DistributedVirtualSwitchNicTeamingPolicyMode {
            "loadbalance_ip",
            "loadbalance_srcmac",
            "loadbalance_srcid",
            "failover_explicit",
            "loadbalance_loadbased",
         }
         interface DVSNetworkResourceManagementCapability extends srmService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            networkResourcePoolHighShareValue: number;
            qosSupported: boolean;
            userDefinedNetworkResourcePoolsSupported: boolean;
         }
         interface DVSRollbackCapability extends srmService.vim.DynamicData {
            rollbackSupported: boolean;
         }
         interface DVSBackupRestoreCapability extends srmService.vim.DynamicData {
            backupRestoreSupported: boolean;
         }
         interface DVSFeatureCapability extends srmService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            vmDirectPathGen2Supported: boolean;
            nicTeamingPolicy?: Array<string>;
            networkResourcePoolHighShareValue?: number;
            networkResourceManagementCapability?: srmService.vim.DVSNetworkResourceManagementCapability;
            healthCheckCapability?: srmService.vim.DVSHealthCheckCapability;
            rollbackCapability?: srmService.vim.DVSRollbackCapability;
            backupRestoreCapability?: srmService.vim.DVSBackupRestoreCapability;
            networkFilterSupported?: boolean;
         }
         interface DVSHealthCheckCapability extends srmService.vim.DynamicData {
         }
         interface DVSCapability extends srmService.vim.DynamicData {
            dvsOperationSupported?: boolean;
            dvPortGroupOperationSupported?: boolean;
            dvPortOperationSupported?: boolean;
            compatibleHostComponentProductInfo?: Array<srmService.vim.DistributedVirtualSwitchHostProductSpec>;
            featuresSupported?: srmService.vim.DVSFeatureCapability;
         }
         interface DVSSummary extends srmService.vim.DynamicData {
            name: string;
            uuid: string;
            numPorts: number;
            productInfo?: srmService.vim.DistributedVirtualSwitchProductSpec;
            hostMember?: Array<srmService.vim.ManagedObjectReference>;
            vm?: Array<srmService.vim.ManagedObjectReference>;
            host?: Array<srmService.vim.ManagedObjectReference>;
            portgroupName?: Array<string>;
            description?: string;
            contact?: srmService.vim.DVSContactInfo;
            numHosts?: number;
         }
         interface DVSPolicy extends srmService.vim.DynamicData {
            autoPreInstallAllowed?: boolean;
            autoUpgradeAllowed?: boolean;
            partialUpgradeAllowed?: boolean;
         }
         interface DVSUplinkPortPolicy extends srmService.vim.DynamicData {
         }
         interface DVSNameArrayUplinkPortPolicy extends srmService.vim.DVSUplinkPortPolicy {
            uplinkPortName: Array<string>;
         }
         interface DVSConfigSpec extends srmService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numStandalonePorts?: number;
            maxPorts?: number;
            uplinkPortPolicy?: srmService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<srmService.vim.ManagedObjectReference>;
            defaultPortConfig?: srmService.vim.DVPortSetting;
            host?: Array<srmService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
            extensionKey?: string;
            description?: string;
            policy?: srmService.vim.DVSPolicy;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            contact?: srmService.vim.DVSContactInfo;
            switchIpAddress?: string;
            defaultProxySwitchMaxNumPorts?: number;
         }
         interface DVSCreateSpec extends srmService.vim.DynamicData {
            configSpec: srmService.vim.DVSConfigSpec;
            productInfo?: srmService.vim.DistributedVirtualSwitchProductSpec;
            capability?: srmService.vim.DVSCapability;
         }
         interface DVSConfigInfo extends srmService.vim.DynamicData {
            uuid: string;
            name: string;
            numStandalonePorts: number;
            numPorts: number;
            maxPorts: number;
            uplinkPortPolicy: srmService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<srmService.vim.ManagedObjectReference>;
            defaultPortConfig: srmService.vim.DVPortSetting;
            host?: Array<srmService.vim.DistributedVirtualSwitchHostMember>;
            productInfo: srmService.vim.DistributedVirtualSwitchProductSpec;
            targetInfo?: srmService.vim.DistributedVirtualSwitchProductSpec;
            extensionKey?: string;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            policy?: srmService.vim.DVSPolicy;
            description?: string;
            configVersion: string;
            contact: srmService.vim.DVSContactInfo;
            switchIpAddress?: string;
            createTime: Date;
            networkResourceManagementEnabled?: boolean;
            defaultProxySwitchMaxNumPorts?: number;
            healthCheckConfig?: Array<srmService.vim.DVSHealthCheckConfig>;
         }
         enum DistributedVirtualSwitchHostInfrastructureTrafficClass {
            "management",
            "faultTolerance",
            "vmotion",
            "virtualMachine",
            "iSCSI",
            "nfs",
            "hbr",
            "vsan",
         }
         interface DVSHealthCheckConfig extends srmService.vim.DynamicData {
            enable?: boolean;
            interval?: number;
         }
         interface ArrayOfDVSHealthCheckConfig {
            dVSHealthCheckConfig?: Array<srmService.vim.DVSHealthCheckConfig>;
         }
         interface DVSRuntimeInfo extends srmService.vim.DynamicData {
            hostMemberRuntime?: Array<srmService.vim.HostMemberRuntimeInfo>;
         }
         enum DrsInjectorWorkloadCorrelationState {
            "Correlated",
            "Uncorrelated",
         }
         interface EVCMode extends srmService.vim.ElementDescription {
            guaranteedCPUFeatures?: Array<srmService.vim.HostCpuIdInfo>;
            featureCapability?: Array<srmService.vim.HostFeatureCapability>;
            featureMask?: Array<srmService.vim.HostFeatureMask>;
            featureRequirement?: Array<srmService.vim.VirtualMachineFeatureRequirement>;
            vendor: string;
            track?: Array<string>;
            vendorTier: number;
         }
         interface ArrayOfEVCMode {
            eVCMode?: Array<srmService.vim.EVCMode>;
         }
         interface ElementDescription extends srmService.vim.Description {
            key: string;
         }
         interface ArrayOfElementDescription {
            elementDescription?: Array<srmService.vim.ElementDescription>;
         }
         interface EnumDescription extends srmService.vim.DynamicData {
            key: string;
            tags: Array<srmService.vim.ElementDescription>;
         }
         interface ArrayOfEnumDescription {
            enumDescription?: Array<srmService.vim.EnumDescription>;
         }
         interface ExtendedDescription extends srmService.vim.Description {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ExtendedElementDescription extends srmService.vim.ElementDescription {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ExtensionServerInfo extends srmService.vim.DynamicData {
            url: string;
            description: srmService.vim.Description;
            company: string;
            type: string;
            adminEmail: Array<string>;
            serverThumbprint?: string;
         }
         interface ArrayOfExtensionServerInfo {
            extensionServerInfo?: Array<srmService.vim.ExtensionServerInfo>;
         }
         interface ExtensionClientInfo extends srmService.vim.DynamicData {
            version: string;
            description: srmService.vim.Description;
            company: string;
            type: string;
            url: string;
         }
         interface ArrayOfExtensionClientInfo {
            extensionClientInfo?: Array<srmService.vim.ExtensionClientInfo>;
         }
         interface ExtensionTaskTypeInfo extends srmService.vim.DynamicData {
            taskID: string;
         }
         interface ArrayOfExtensionTaskTypeInfo {
            extensionTaskTypeInfo?: Array<srmService.vim.ExtensionTaskTypeInfo>;
         }
         interface ExtensionEventTypeInfo extends srmService.vim.DynamicData {
            eventID: string;
            eventTypeSchema?: string;
         }
         interface ArrayOfExtensionEventTypeInfo {
            extensionEventTypeInfo?: Array<srmService.vim.ExtensionEventTypeInfo>;
         }
         interface ExtensionFaultTypeInfo extends srmService.vim.DynamicData {
            faultID: string;
         }
         interface ArrayOfExtensionFaultTypeInfo {
            extensionFaultTypeInfo?: Array<srmService.vim.ExtensionFaultTypeInfo>;
         }
         interface ExtensionPrivilegeInfo extends srmService.vim.DynamicData {
            privID: string;
            privGroupName: string;
         }
         interface ArrayOfExtensionPrivilegeInfo {
            extensionPrivilegeInfo?: Array<srmService.vim.ExtensionPrivilegeInfo>;
         }
         interface ExtensionResourceInfo extends srmService.vim.DynamicData {
            locale: string;
            module: string;
            data: Array<srmService.vim.KeyValue>;
         }
         interface ArrayOfExtensionResourceInfo {
            extensionResourceInfo?: Array<srmService.vim.ExtensionResourceInfo>;
         }
         interface ExtensionHealthInfo extends srmService.vim.DynamicData {
            url: string;
         }
         interface ExtensionOvfConsumerInfo extends srmService.vim.DynamicData {
            callbackUrl: string;
            sectionType: Array<string>;
         }
         interface Extension extends srmService.vim.DynamicData {
            description: srmService.vim.Description;
            key: string;
            company?: string;
            type?: string;
            version: string;
            subjectName?: string;
            server?: Array<srmService.vim.ExtensionServerInfo>;
            client?: Array<srmService.vim.ExtensionClientInfo>;
            taskList?: Array<srmService.vim.ExtensionTaskTypeInfo>;
            eventList?: Array<srmService.vim.ExtensionEventTypeInfo>;
            faultList?: Array<srmService.vim.ExtensionFaultTypeInfo>;
            privilegeList?: Array<srmService.vim.ExtensionPrivilegeInfo>;
            resourceList?: Array<srmService.vim.ExtensionResourceInfo>;
            lastHeartbeatTime: Date;
            healthInfo?: srmService.vim.ExtensionHealthInfo;
            ovfConsumerInfo?: srmService.vim.ExtensionOvfConsumerInfo;
            extendedProductInfo?: srmService.vim.ExtExtendedProductInfo;
            managedEntityInfo?: Array<srmService.vim.ExtManagedEntityInfo>;
            shownInSolutionManager?: boolean;
            solutionManagerInfo?: srmService.vim.ExtSolutionManagerInfo;
         }
         interface ArrayOfExtension {
            extension?: Array<srmService.vim.Extension>;
         }
         interface ExtensionManagerIpAllocationUsage extends srmService.vim.DynamicData {
            extensionKey: string;
            numAddresses: number;
         }
         interface ArrayOfExtensionManagerIpAllocationUsage {
            extensionManagerIpAllocationUsage?: Array<srmService.vim.ExtensionManagerIpAllocationUsage>;
         }
         enum ReplicationVmState {
            "none",
            "paused",
            "syncing",
            "idle",
            "active",
            "error",
         }
         interface ReplicationVmProgressInfo extends srmService.vim.DynamicData {
            progress: number;
            bytesTransferred: number;
            bytesToTransfer: number;
            checksumTotalBytes?: number;
            checksumComparedBytes?: number;
         }
         interface HbrManagerReplicationVmInfo extends srmService.vim.DynamicData {
            state: string;
            progressInfo?: srmService.vim.ReplicationVmProgressInfo;
            imageId?: string;
            lastError?: srmService.vim.LocalizedMethodFault;
         }
         interface HostServiceTicket extends srmService.vim.DynamicData {
            host?: string;
            port?: number;
            sslThumbprint?: string;
            service: string;
            serviceVersion: string;
            sessionId: string;
         }
         enum HostSystemConnectionState {
            "connected",
            "notResponding",
            "disconnected",
         }
         enum HostSystemPowerState {
            "poweredOn",
            "poweredOff",
            "standBy",
            "unknown",
         }
         enum HostStandbyMode {
            "entering",
            "exiting",
            "in",
            "none",
         }
         interface HostSystemReconnectSpec extends srmService.vim.DynamicData {
            syncState?: boolean;
         }
         enum HttpNfcLeaseState {
            "initializing",
            "ready",
            "done",
            "error",
         }
         interface HttpNfcLeaseDatastoreLeaseInfo extends srmService.vim.DynamicData {
            datastoreKey: string;
            hosts: Array<srmService.vim.HttpNfcLeaseHostInfo>;
         }
         interface ArrayOfHttpNfcLeaseDatastoreLeaseInfo {
            httpNfcLeaseDatastoreLeaseInfo?: Array<srmService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseHostInfo extends srmService.vim.DynamicData {
            url: string;
            sslThumbprint: string;
         }
         interface ArrayOfHttpNfcLeaseHostInfo {
            httpNfcLeaseHostInfo?: Array<srmService.vim.HttpNfcLeaseHostInfo>;
         }
         interface HttpNfcLeaseInfo extends srmService.vim.DynamicData {
            lease: srmService.vim.ManagedObjectReference;
            entity: srmService.vim.ManagedObjectReference;
            deviceUrl?: Array<srmService.vim.HttpNfcLeaseDeviceUrl>;
            totalDiskCapacityInKB: number;
            leaseTimeout: number;
            hostMap?: Array<srmService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseDeviceUrl extends srmService.vim.DynamicData {
            key: string;
            importKey: string;
            url: string;
            sslThumbprint: string;
            disk?: boolean;
            targetId?: string;
            datastoreKey?: string;
            fileSize?: number;
         }
         interface ArrayOfHttpNfcLeaseDeviceUrl {
            httpNfcLeaseDeviceUrl?: Array<srmService.vim.HttpNfcLeaseDeviceUrl>;
         }
         interface HttpNfcLeaseManifestEntry extends srmService.vim.DynamicData {
            key: string;
            sha1: string;
            size: number;
            disk: boolean;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfHttpNfcLeaseManifestEntry {
            httpNfcLeaseManifestEntry?: Array<srmService.vim.HttpNfcLeaseManifestEntry>;
         }
         interface ImportSpec extends srmService.vim.DynamicData {
            entityConfig?: srmService.vim.VAppEntityConfigInfo;
            instantiationOst?: srmService.vim.OvfConsumerOstNode;
         }
         interface ArrayOfImportSpec {
            importSpec?: Array<srmService.vim.ImportSpec>;
         }
         interface InheritablePolicy extends srmService.vim.DynamicData {
            inherited: boolean;
         }
         interface IntExpression extends srmService.vim.NegatableExpression {
            value?: number;
         }
         interface IntPolicy extends srmService.vim.InheritablePolicy {
            value?: number;
         }
         interface IpAddress extends srmService.vim.NegatableExpression {
         }
         interface IpPoolManagerIpAllocation extends srmService.vim.DynamicData {
            ipAddress: string;
            allocationId: string;
         }
         interface ArrayOfIpPoolManagerIpAllocation {
            ipPoolManagerIpAllocation?: Array<srmService.vim.IpPoolManagerIpAllocation>;
         }
         interface IpRange extends srmService.vim.IpAddress {
            addressPrefix: string;
            prefixLength?: number;
         }
         interface KeyValue extends srmService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfKeyValue {
            keyValue?: Array<srmService.vim.KeyValue>;
         }
         enum LatencySensitivitySensitivityLevel {
            "low",
            "normal",
            "medium",
            "high",
            "custom",
         }
         interface LatencySensitivity extends srmService.vim.DynamicData {
            level: srmService.vim.LatencySensitivitySensitivityLevel;
            sensitivity?: number;
         }
         interface LicenseAssignmentManagerLicenseAssignment extends srmService.vim.DynamicData {
            entityId: string;
            scope?: string;
            entityDisplayName?: string;
            assignedLicense: srmService.vim.LicenseManagerLicenseInfo;
            properties?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ArrayOfLicenseAssignmentManagerLicenseAssignment {
            licenseAssignmentManagerLicenseAssignment?: Array<srmService.vim.LicenseAssignmentManagerLicenseAssignment>;
         }
         enum LicenseManagerState {
            "initializing",
            "normal",
            "marginal",
            "fault",
         }
         enum LicenseManagerLicenseKey {
            "esxFull",
            "esxVmtn",
            "esxExpress",
            "san",
            "iscsi",
            "nas",
            "vsmp",
            "backup",
            "vc",
            "vcExpress",
            "esxHost",
            "gsxHost",
            "serverHost",
            "drsPower",
            "vmotion",
            "drs",
            "das",
         }
         interface LicenseSource extends srmService.vim.DynamicData {
         }
         interface LicenseServerSource extends srmService.vim.LicenseSource {
            licenseServer: string;
         }
         interface LocalLicenseSource extends srmService.vim.LicenseSource {
            licenseKeys: string;
         }
         interface EvaluationLicenseSource extends srmService.vim.LicenseSource {
            remainingHours?: number;
         }
         enum LicenseFeatureInfoUnit {
            "host",
            "cpuCore",
            "cpuPackage",
            "server",
            "vm",
         }
         enum LicenseFeatureInfoState {
            "enabled",
            "disabled",
            "optional",
         }
         enum LicenseFeatureInfoSourceRestriction {
            "unrestricted",
            "served",
            "file",
         }
         interface LicenseFeatureInfo extends srmService.vim.DynamicData {
            key: string;
            featureName: string;
            featureDescription?: string;
            state?: srmService.vim.LicenseFeatureInfoState;
            costUnit: string;
            sourceRestriction?: string;
            dependentKey?: Array<string>;
            edition?: boolean;
            expiresOn?: Date;
         }
         interface ArrayOfLicenseFeatureInfo {
            licenseFeatureInfo?: Array<srmService.vim.LicenseFeatureInfo>;
         }
         enum LicenseReservationInfoState {
            "notUsed",
            "noLicense",
            "unlicensedUse",
            "licensed",
         }
         interface LicenseReservationInfo extends srmService.vim.DynamicData {
            key: string;
            state: srmService.vim.LicenseReservationInfoState;
            required: number;
         }
         interface ArrayOfLicenseReservationInfo {
            licenseReservationInfo?: Array<srmService.vim.LicenseReservationInfo>;
         }
         interface LicenseAvailabilityInfo extends srmService.vim.DynamicData {
            feature: srmService.vim.LicenseFeatureInfo;
            total: number;
            available: number;
         }
         interface ArrayOfLicenseAvailabilityInfo {
            licenseAvailabilityInfo?: Array<srmService.vim.LicenseAvailabilityInfo>;
         }
         interface LicenseDiagnostics extends srmService.vim.DynamicData {
            sourceLastChanged: Date;
            sourceLost: string;
            sourceLatency: number;
            licenseRequests: string;
            licenseRequestFailures: string;
            licenseFeatureUnknowns: string;
            opState: srmService.vim.LicenseManagerState;
            lastStatusUpdate: Date;
            opFailureMessage: string;
         }
         interface LicenseUsageInfo extends srmService.vim.DynamicData {
            source: srmService.vim.LicenseSource;
            sourceAvailable: boolean;
            reservationInfo?: Array<srmService.vim.LicenseReservationInfo>;
            featureInfo?: Array<srmService.vim.LicenseFeatureInfo>;
         }
         interface LicenseManagerEvaluationInfo extends srmService.vim.DynamicData {
            properties: Array<srmService.vim.KeyAnyValue>;
         }
         enum HostLicensableResourceKey {
            "numCpuPackages",
            "numCpuCores",
            "memorySize",
            "memoryForVms",
            "numVmsStarted",
            "numVmsStarting",
         }
         interface HostLicensableResourceInfo extends srmService.vim.DynamicData {
            resource: Array<srmService.vim.KeyAnyValue>;
         }
         interface LicenseManagerLicenseInfo extends srmService.vim.DynamicData {
            licenseKey: string;
            editionKey: string;
            name: string;
            total: number;
            used?: number;
            costUnit: string;
            properties?: Array<srmService.vim.KeyAnyValue>;
            labels?: Array<srmService.vim.KeyValue>;
         }
         interface ArrayOfLicenseManagerLicenseInfo {
            licenseManagerLicenseInfo?: Array<srmService.vim.LicenseManagerLicenseInfo>;
         }
         interface LocalizationManagerMessageCatalog extends srmService.vim.DynamicData {
            moduleName: string;
            catalogName: string;
            locale: string;
            catalogUri: string;
            lastModified?: Date;
            md5sum?: string;
            version?: string;
         }
         interface ArrayOfLocalizationManagerMessageCatalog {
            localizationManagerMessageCatalog?: Array<srmService.vim.LocalizationManagerMessageCatalog>;
         }
         interface LongPolicy extends srmService.vim.InheritablePolicy {
            value?: number;
         }
         interface MacAddress extends srmService.vim.NegatableExpression {
         }
         interface MacRange extends srmService.vim.MacAddress {
            address: string;
            mask: string;
         }
         enum ManagedEntityStatus {
            "gray",
            "green",
            "yellow",
            "red",
         }
         interface MethodDescription extends srmService.vim.Description {
            key: string;
         }
         interface NegatableExpression extends srmService.vim.DynamicData {
            negate?: boolean;
         }
         interface NetworkSummary extends srmService.vim.DynamicData {
            network?: srmService.vim.ManagedObjectReference;
            name: string;
            accessible: boolean;
            ipPoolName?: string;
            ipPoolId?: number;
         }
         interface NumericRange extends srmService.vim.DynamicData {
            start: number;
            end: number;
         }
         interface ArrayOfNumericRange {
            numericRange?: Array<srmService.vim.NumericRange>;
         }
         interface OpaqueNetworkSummary extends srmService.vim.NetworkSummary {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface OvfConsumerOvfSection extends srmService.vim.DynamicData {
            lineNumber: number;
            xml: string;
         }
         interface ArrayOfOvfConsumerOvfSection {
            ovfConsumerOvfSection?: Array<srmService.vim.OvfConsumerOvfSection>;
         }
         enum OvfConsumerOstNodeType {
            "envelope",
            "virtualSystem",
            "virtualSystemCollection",
         }
         interface OvfConsumerOstNode extends srmService.vim.DynamicData {
            id: string;
            type: string;
            section?: Array<srmService.vim.OvfConsumerOvfSection>;
            child?: Array<srmService.vim.OvfConsumerOstNode>;
            entity?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfConsumerOstNode {
            ovfConsumerOstNode?: Array<srmService.vim.OvfConsumerOstNode>;
         }
         interface OvfOptionInfo extends srmService.vim.DynamicData {
            option: string;
            description: srmService.vim.LocalizableMessage;
         }
         interface ArrayOfOvfOptionInfo {
            ovfOptionInfo?: Array<srmService.vim.OvfOptionInfo>;
         }
         interface OvfDeploymentOption extends srmService.vim.DynamicData {
            key: string;
            label: string;
            description: string;
         }
         interface ArrayOfOvfDeploymentOption {
            ovfDeploymentOption?: Array<srmService.vim.OvfDeploymentOption>;
         }
         interface OvfManagerCommonParams extends srmService.vim.DynamicData {
            locale: string;
            deploymentOption: string;
            msgBundle?: Array<srmService.vim.KeyValue>;
            importOption?: Array<string>;
         }
         interface OvfValidateHostParams extends srmService.vim.OvfManagerCommonParams {
         }
         interface OvfValidateHostResult extends srmService.vim.DynamicData {
            downloadSize?: number;
            flatDeploymentSize?: number;
            sparseDeploymentSize?: number;
            error?: Array<srmService.vim.LocalizedMethodFault>;
            warning?: Array<srmService.vim.LocalizedMethodFault>;
            supportedDiskProvisioning?: Array<string>;
         }
         interface OvfParseDescriptorParams extends srmService.vim.OvfManagerCommonParams {
         }
         interface OvfParseDescriptorResult extends srmService.vim.DynamicData {
            eula?: Array<string>;
            network?: Array<srmService.vim.OvfNetworkInfo>;
            ipAllocationScheme?: Array<string>;
            ipProtocols?: Array<string>;
            property?: Array<srmService.vim.VAppPropertyInfo>;
            productInfo?: srmService.vim.VAppProductInfo;
            annotation: string;
            approximateDownloadSize?: number;
            approximateFlatDeploymentSize?: number;
            approximateSparseDeploymentSize?: number;
            defaultEntityName: string;
            virtualApp: boolean;
            deploymentOption?: Array<srmService.vim.OvfDeploymentOption>;
            defaultDeploymentOption: string;
            entityName?: Array<srmService.vim.KeyValue>;
            annotatedOst?: srmService.vim.OvfConsumerOstNode;
            error?: Array<srmService.vim.LocalizedMethodFault>;
            warning?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface OvfNetworkInfo extends srmService.vim.DynamicData {
            name: string;
            description: string;
         }
         interface ArrayOfOvfNetworkInfo {
            ovfNetworkInfo?: Array<srmService.vim.OvfNetworkInfo>;
         }
         enum OvfCreateImportSpecParamsDiskProvisioningType {
            "monolithicSparse",
            "monolithicFlat",
            "twoGbMaxExtentSparse",
            "twoGbMaxExtentFlat",
            "thin",
            "thick",
            "seSparse",
            "eagerZeroedThick",
            "sparse",
            "flat",
         }
         interface OvfCreateImportSpecParams extends srmService.vim.OvfManagerCommonParams {
            entityName: string;
            hostSystem?: srmService.vim.ManagedObjectReference;
            networkMapping?: Array<srmService.vim.OvfNetworkMapping>;
            ipAllocationPolicy?: string;
            ipProtocol?: string;
            propertyMapping?: Array<srmService.vim.KeyValue>;
            resourceMapping?: Array<srmService.vim.OvfResourceMap>;
            diskProvisioning?: string;
            instantiationOst?: srmService.vim.OvfConsumerOstNode;
         }
         interface OvfResourceMap extends srmService.vim.DynamicData {
            source: string;
            parent?: srmService.vim.ManagedObjectReference;
            resourceSpec?: srmService.vim.ResourceConfigSpec;
            datastore?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfResourceMap {
            ovfResourceMap?: Array<srmService.vim.OvfResourceMap>;
         }
         interface OvfNetworkMapping extends srmService.vim.DynamicData {
            name: string;
            network: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfNetworkMapping {
            ovfNetworkMapping?: Array<srmService.vim.OvfNetworkMapping>;
         }
         interface OvfCreateImportSpecResult extends srmService.vim.DynamicData {
            importSpec?: srmService.vim.ImportSpec;
            fileItem?: Array<srmService.vim.OvfFileItem>;
            warning?: Array<srmService.vim.LocalizedMethodFault>;
            error?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface OvfFileItem extends srmService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size?: number;
            cimType: number;
            create: boolean;
         }
         interface ArrayOfOvfFileItem {
            ovfFileItem?: Array<srmService.vim.OvfFileItem>;
         }
         interface OvfCreateDescriptorParams extends srmService.vim.DynamicData {
            ovfFiles?: Array<srmService.vim.OvfFile>;
            name?: string;
            description?: string;
            includeImageFiles?: boolean;
            exportOption?: Array<string>;
            snapshot?: srmService.vim.ManagedObjectReference;
         }
         interface OvfCreateDescriptorResult extends srmService.vim.DynamicData {
            ovfDescriptor: string;
            error?: Array<srmService.vim.LocalizedMethodFault>;
            warning?: Array<srmService.vim.LocalizedMethodFault>;
            includeImageFiles?: boolean;
         }
         interface OvfFile extends srmService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size: number;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfOvfFile {
            ovfFile?: Array<srmService.vim.OvfFile>;
         }
         interface PasswordField extends srmService.vim.DynamicData {
            value: string;
         }
         interface PerformanceDescription extends srmService.vim.DynamicData {
            counterType: Array<srmService.vim.ElementDescription>;
            statsType: Array<srmService.vim.ElementDescription>;
         }
         enum PerfFormat {
            "normal",
            "csv",
         }
         interface PerfProviderSummary extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            currentSupported: boolean;
            summarySupported: boolean;
            refreshRate?: number;
         }
         enum PerfSummaryType {
            "average",
            "maximum",
            "minimum",
            "latest",
            "summation",
            "none",
         }
         enum PerfStatsType {
            "absolute",
            "delta",
            "rate",
         }
         enum PerformanceManagerUnit {
            "percent",
            "kiloBytes",
            "megaBytes",
            "megaHertz",
            "number",
            "microsecond",
            "millisecond",
            "second",
            "kiloBytesPerSecond",
            "megaBytesPerSecond",
            "watt",
            "joule",
         }
         interface PerfCounterInfo extends srmService.vim.DynamicData {
            key: number;
            nameInfo: srmService.vim.ElementDescription;
            groupInfo: srmService.vim.ElementDescription;
            unitInfo: srmService.vim.ElementDescription;
            rollupType: srmService.vim.PerfSummaryType;
            statsType: srmService.vim.PerfStatsType;
            level?: number;
            perDeviceLevel?: number;
            associatedCounterId?: Array<number>;
         }
         interface ArrayOfPerfCounterInfo {
            perfCounterInfo?: Array<srmService.vim.PerfCounterInfo>;
         }
         interface PerfMetricId extends srmService.vim.DynamicData {
            counterId: number;
            instance: string;
         }
         interface ArrayOfPerfMetricId {
            perfMetricId?: Array<srmService.vim.PerfMetricId>;
         }
         interface PerfQuerySpec extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            startTime?: Date;
            endTime?: Date;
            maxSample?: number;
            metricId?: Array<srmService.vim.PerfMetricId>;
            intervalId?: number;
            format?: string;
         }
         interface ArrayOfPerfQuerySpec {
            perfQuerySpec?: Array<srmService.vim.PerfQuerySpec>;
         }
         interface PerfSampleInfo extends srmService.vim.DynamicData {
            timestamp: Date;
            interval: number;
         }
         interface ArrayOfPerfSampleInfo {
            perfSampleInfo?: Array<srmService.vim.PerfSampleInfo>;
         }
         interface PerfMetricSeries extends srmService.vim.DynamicData {
            id: srmService.vim.PerfMetricId;
         }
         interface ArrayOfPerfMetricSeries {
            perfMetricSeries?: Array<srmService.vim.PerfMetricSeries>;
         }
         interface PerfMetricIntSeries extends srmService.vim.PerfMetricSeries {
            value?: Array<number>;
         }
         interface PerfMetricSeriesCSV extends srmService.vim.PerfMetricSeries {
            value?: string;
         }
         interface ArrayOfPerfMetricSeriesCSV {
            perfMetricSeriesCSV?: Array<srmService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfEntityMetricBase extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfPerfEntityMetricBase {
            perfEntityMetricBase?: Array<srmService.vim.PerfEntityMetricBase>;
         }
         interface PerfEntityMetric extends srmService.vim.PerfEntityMetricBase {
            sampleInfo?: Array<srmService.vim.PerfSampleInfo>;
            value?: Array<srmService.vim.PerfMetricSeries>;
         }
         interface PerfEntityMetricCSV extends srmService.vim.PerfEntityMetricBase {
            sampleInfoCSV: string;
            value?: Array<srmService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfCompositeMetric extends srmService.vim.DynamicData {
            entity?: srmService.vim.PerfEntityMetricBase;
            childEntity?: Array<srmService.vim.PerfEntityMetricBase>;
         }
         interface PerformanceManagerCounterLevelMapping extends srmService.vim.DynamicData {
            counterId: number;
            aggregateLevel?: number;
            perDeviceLevel?: number;
         }
         interface ArrayOfPerformanceManagerCounterLevelMapping {
            performanceManagerCounterLevelMapping?: Array<srmService.vim.PerformanceManagerCounterLevelMapping>;
         }
         interface PerfInterval extends srmService.vim.DynamicData {
            key: number;
            samplingPeriod: number;
            name: string;
            length: number;
            level?: number;
            enabled: boolean;
         }
         interface ArrayOfPerfInterval {
            perfInterval?: Array<srmService.vim.PerfInterval>;
         }
         interface PosixUserSearchResult extends srmService.vim.UserSearchResult {
            id: number;
            shellAccess?: boolean;
         }
         interface PrivilegePolicyDef extends srmService.vim.DynamicData {
            createPrivilege: string;
            readPrivilege: string;
            updatePrivilege: string;
            deletePrivilege: string;
         }
         interface ResourceAllocationInfo extends srmService.vim.DynamicData {
            reservation?: number;
            expandableReservation?: boolean;
            limit?: number;
            shares?: srmService.vim.SharesInfo;
            overheadLimit?: number;
         }
         interface ResourceAllocationOption extends srmService.vim.DynamicData {
            sharesOption: srmService.vim.SharesOption;
         }
         interface ResourceConfigOption extends srmService.vim.DynamicData {
            cpuAllocationOption: srmService.vim.ResourceAllocationOption;
            memoryAllocationOption: srmService.vim.ResourceAllocationOption;
         }
         interface ResourceConfigSpec extends srmService.vim.DynamicData {
            entity?: srmService.vim.ManagedObjectReference;
            changeVersion?: string;
            lastModified?: Date;
            cpuAllocation: srmService.vim.ResourceAllocationInfo;
            memoryAllocation: srmService.vim.ResourceAllocationInfo;
         }
         interface ArrayOfResourceConfigSpec {
            resourceConfigSpec?: Array<srmService.vim.ResourceConfigSpec>;
         }
         interface DatabaseSizeParam extends srmService.vim.DynamicData {
            inventoryDesc: srmService.vim.InventoryDescription;
            perfStatsDesc?: srmService.vim.PerformanceStatisticsDescription;
         }
         interface InventoryDescription extends srmService.vim.DynamicData {
            numHosts: number;
            numVirtualMachines: number;
            numResourcePools?: number;
            numClusters?: number;
            numCpuDev?: number;
            numNetDev?: number;
            numDiskDev?: number;
            numvCpuDev?: number;
            numvNetDev?: number;
            numvDiskDev?: number;
         }
         interface PerformanceStatisticsDescription extends srmService.vim.DynamicData {
            intervals?: Array<srmService.vim.PerfInterval>;
         }
         interface DatabaseSizeEstimate extends srmService.vim.DynamicData {
            size: number;
         }
         interface ResourcePoolResourceUsage extends srmService.vim.DynamicData {
            reservationUsed: number;
            reservationUsedForVm: number;
            unreservedForPool: number;
            unreservedForVm: number;
            overallUsage: number;
            maxUsage: number;
         }
         interface ResourcePoolRuntimeInfo extends srmService.vim.DynamicData {
            memory: srmService.vim.ResourcePoolResourceUsage;
            cpu: srmService.vim.ResourcePoolResourceUsage;
            overallStatus: srmService.vim.ManagedEntityStatus;
         }
         interface ResourcePoolQuickStats extends srmService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            overheadMemory?: number;
            consumedOverheadMemory?: number;
            compressedMemory?: number;
         }
         interface ResourcePoolSummary extends srmService.vim.DynamicData {
            name: string;
            config: srmService.vim.ResourceConfigSpec;
            runtime: srmService.vim.ResourcePoolRuntimeInfo;
            quickStats?: srmService.vim.ResourcePoolQuickStats;
            configuredMemoryMB?: number;
         }
         interface SelectionSet extends srmService.vim.DynamicData {
         }
         interface ArrayOfSelectionSet {
            selectionSet?: Array<srmService.vim.SelectionSet>;
         }
         interface ServiceManagerServiceInfo extends srmService.vim.DynamicData {
            serviceName: string;
            location?: Array<string>;
            service: srmService.vim.ManagedObjectReference;
            description: string;
         }
         interface ArrayOfServiceManagerServiceInfo {
            serviceManagerServiceInfo?: Array<srmService.vim.ServiceManagerServiceInfo>;
         }
         interface SessionManagerLocalTicket extends srmService.vim.DynamicData {
            userName: string;
            passwordFilePath: string;
         }
         interface SessionManagerGenericServiceTicket extends srmService.vim.DynamicData {
            id: string;
            hostName?: string;
            sslThumbprint?: string;
         }
         interface SessionManagerServiceRequestSpec extends srmService.vim.DynamicData {
         }
         interface SessionManagerVmomiServiceRequestSpec extends srmService.vim.SessionManagerServiceRequestSpec {
            method: string;
         }
         enum SessionManagerHttpServiceRequestSpecMethod {
            "httpOptions",
            "httpGet",
            "httpHead",
            "httpPost",
            "httpPut",
            "httpDelete",
            "httpTrace",
            "httpConnect",
         }
         interface SessionManagerHttpServiceRequestSpec extends srmService.vim.SessionManagerServiceRequestSpec {
            method?: string;
            url: string;
         }
         enum SharesLevel {
            "low",
            "normal",
            "high",
            "custom",
         }
         interface SharesInfo extends srmService.vim.DynamicData {
            shares: number;
            level: srmService.vim.SharesLevel;
         }
         interface SharesOption extends srmService.vim.DynamicData {
            sharesOption: srmService.vim.IntOption;
            defaultLevel: srmService.vim.SharesLevel;
         }
         enum SimpleCommandEncoding {
            "CSV",
            "HEX",
            "STRING",
         }
         interface SingleIp extends srmService.vim.IpAddress {
            address: string;
         }
         interface SingleMac extends srmService.vim.MacAddress {
            address: string;
         }
         interface StoragePodSummary extends srmService.vim.DynamicData {
            name: string;
            capacity: number;
            freeSpace: number;
         }
         interface StorageIOAllocationInfo extends srmService.vim.DynamicData {
            limit?: number;
            shares?: srmService.vim.SharesInfo;
            reservation?: number;
         }
         interface StorageIOAllocationOption extends srmService.vim.DynamicData {
            limitOption: srmService.vim.LongOption;
            sharesOption: srmService.vim.SharesOption;
         }
         enum StorageIORMThresholdMode {
            "automatic",
            "manual",
         }
         interface StorageIORMInfo extends srmService.vim.DynamicData {
            enabled: boolean;
            congestionThresholdMode?: string;
            congestionThreshold: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            statsAggregationDisabled?: boolean;
         }
         interface StorageIORMConfigSpec extends srmService.vim.DynamicData {
            enabled?: boolean;
            congestionThresholdMode?: string;
            congestionThreshold?: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            statsAggregationDisabled?: boolean;
         }
         interface StorageIORMConfigOption extends srmService.vim.DynamicData {
            enabledOption: srmService.vim.BoolOption;
            congestionThresholdOption: srmService.vim.IntOption;
            statsCollectionEnabledOption?: srmService.vim.BoolOption;
         }
         interface StoragePerformanceSummary extends srmService.vim.DynamicData {
            interval: number;
            percentile: Array<number>;
            datastoreReadLatency: Array<number>;
            datastoreWriteLatency: Array<number>;
            datastoreVmLatency: Array<number>;
            datastoreReadIops: Array<number>;
            datastoreWriteIops: Array<number>;
            siocActivityDuration: number;
         }
         interface ArrayOfStoragePerformanceSummary {
            storagePerformanceSummary?: Array<srmService.vim.StoragePerformanceSummary>;
         }
         interface PodStorageDrsEntry extends srmService.vim.DynamicData {
            storageDrsConfig: srmService.vim.StorageDrsConfigInfo;
            recommendation?: Array<srmService.vim.ClusterRecommendation>;
            drsFault?: Array<srmService.vim.ClusterDrsFaults>;
            actionHistory?: Array<srmService.vim.ClusterActionHistory>;
         }
         interface StringExpression extends srmService.vim.NegatableExpression {
            value?: string;
         }
         interface StringPolicy extends srmService.vim.InheritablePolicy {
            value?: string;
         }
         interface Tag extends srmService.vim.DynamicData {
            key: string;
         }
         interface ArrayOfTag {
            tag?: Array<srmService.vim.Tag>;
         }
         interface TaskDescription extends srmService.vim.DynamicData {
            methodInfo: Array<srmService.vim.ElementDescription>;
            state: Array<srmService.vim.ElementDescription>;
            reason: Array<srmService.vim.TypeDescription>;
         }
         enum TaskFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         enum TaskFilterSpecTimeOption {
            "queuedTime",
            "startedTime",
            "completedTime",
         }
         interface TaskFilterSpecByEntity extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            recursion: srmService.vim.TaskFilterSpecRecursionOption;
         }
         interface TaskFilterSpecByTime extends srmService.vim.DynamicData {
            timeType: srmService.vim.TaskFilterSpecTimeOption;
            beginTime?: Date;
            endTime?: Date;
         }
         interface TaskFilterSpecByUsername extends srmService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface TaskFilterSpec extends srmService.vim.DynamicData {
            entity?: srmService.vim.TaskFilterSpecByEntity;
            time?: srmService.vim.TaskFilterSpecByTime;
            userName?: srmService.vim.TaskFilterSpecByUsername;
            state?: Array<srmService.vim.TaskInfoState>;
            alarm?: srmService.vim.ManagedObjectReference;
            scheduledTask?: srmService.vim.ManagedObjectReference;
            eventChainId?: Array<number>;
            tag?: Array<string>;
            parentTaskKey?: Array<string>;
            rootTaskKey?: Array<string>;
         }
         enum TaskInfoState {
            "queued",
            "running",
            "success",
            "error",
         }
         interface ArrayOfTaskInfoState {
            taskInfoState?: Array<srmService.vim.TaskInfoState>;
         }
         interface TaskInfo extends srmService.vim.DynamicData {
            key: string;
            task: srmService.vim.ManagedObjectReference;
            description?: srmService.vim.LocalizableMessage;
            name?: string;
            descriptionId: string;
            entity?: srmService.vim.ManagedObjectReference;
            entityName?: string;
            locked?: Array<srmService.vim.ManagedObjectReference>;
            state: srmService.vim.TaskInfoState;
            cancelled: boolean;
            cancelable: boolean;
            error?: srmService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            reason: srmService.vim.TaskReason;
            queueTime: Date;
            startTime?: Date;
            completeTime?: Date;
            eventChainId: number;
            changeTag?: string;
            parentTaskKey?: string;
            rootTaskKey?: string;
         }
         interface ArrayOfTaskInfo {
            taskInfo?: Array<srmService.vim.TaskInfo>;
         }
         interface TaskReason extends srmService.vim.DynamicData {
         }
         interface TaskReasonSystem extends srmService.vim.TaskReason {
         }
         interface TaskReasonUser extends srmService.vim.TaskReason {
            userName: string;
         }
         interface TaskReasonAlarm extends srmService.vim.TaskReason {
            alarmName: string;
            alarm: srmService.vim.ManagedObjectReference;
            entityName: string;
            entity: srmService.vim.ManagedObjectReference;
         }
         interface TaskReasonSchedule extends srmService.vim.TaskReason {
            name: string;
            scheduledTask: srmService.vim.ManagedObjectReference;
         }
         interface TypeDescription extends srmService.vim.Description {
            key: string;
         }
         interface ArrayOfTypeDescription {
            typeDescription?: Array<srmService.vim.TypeDescription>;
         }
         interface UpdateVirtualMachineFilesResultFailedVmFileInfo extends srmService.vim.DynamicData {
            vmFile: string;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo {
            updateVirtualMachineFilesResultFailedVmFileInfo?: Array<srmService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UpdateVirtualMachineFilesResult extends srmService.vim.DynamicData {
            failedVmFile?: Array<srmService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UserSearchResult extends srmService.vim.DynamicData {
            principal: string;
            fullName?: string;
            group: boolean;
         }
         interface ArrayOfUserSearchResult {
            userSearchResult?: Array<srmService.vim.UserSearchResult>;
         }
         interface UserSession extends srmService.vim.DynamicData {
            key: string;
            userName: string;
            fullName: string;
            loginTime: Date;
            lastActiveTime: Date;
            locale: string;
            messageLocale: string;
            extensionSession?: boolean;
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
         }
         interface ArrayOfUserSession {
            userSession?: Array<srmService.vim.UserSession>;
         }
         enum VirtualAppVAppState {
            "started",
            "stopped",
            "starting",
            "stopping",
         }
         interface VirtualAppSummary extends srmService.vim.ResourcePoolSummary {
            product?: srmService.vim.VAppProductInfo;
            vAppState?: srmService.vim.VirtualAppVAppState;
            suspended?: boolean;
            installBootRequired?: boolean;
            instanceUuid?: string;
         }
         interface VirtualAppLinkInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVirtualAppLinkInfo {
            virtualAppLinkInfo?: Array<srmService.vim.VirtualAppLinkInfo>;
         }
         enum VirtualDiskType {
            "preallocated",
            "thin",
            "seSparse",
            "rdm",
            "rdmp",
            "raw",
            "delta",
            "sparse2Gb",
            "thick2Gb",
            "eagerZeroedThick",
            "sparseMonolithic",
            "flatMonolithic",
            "thick",
         }
         enum VirtualDiskAdapterType {
            "ide",
            "busLogic",
            "lsiLogic",
         }
         interface VirtualDiskSpec extends srmService.vim.DynamicData {
            diskType: string;
            adapterType: string;
         }
         interface FileBackedVirtualDiskSpec extends srmService.vim.VirtualDiskSpec {
            capacityKb: number;
            profile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface SeSparseVirtualDiskSpec extends srmService.vim.FileBackedVirtualDiskSpec {
            grainSizeKb?: number;
         }
         interface DeviceBackedVirtualDiskSpec extends srmService.vim.VirtualDiskSpec {
            device: string;
         }
         interface StorageRequirement extends srmService.vim.DynamicData {
            datastore: srmService.vim.ManagedObjectReference;
            freeSpaceRequiredInKb: number;
         }
         interface ArrayOfStorageRequirement {
            storageRequirement?: Array<srmService.vim.StorageRequirement>;
         }
         enum VirtualMachinePowerState {
            "poweredOff",
            "poweredOn",
            "suspended",
         }
         enum VirtualMachineAppHeartbeatStatusType {
            "appStatusGray",
            "appStatusGreen",
            "appStatusRed",
         }
         enum VirtualMachineConnectionState {
            "connected",
            "disconnected",
            "orphaned",
            "inaccessible",
            "invalid",
         }
         enum VirtualMachineMovePriority {
            "lowPriority",
            "highPriority",
            "defaultPriority",
         }
         interface VirtualMachineTicket extends srmService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         interface VirtualMachineMksTicket extends srmService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         enum VirtualMachineFaultToleranceState {
            "notConfigured",
            "disabled",
            "enabled",
            "needSecondary",
            "starting",
            "running",
         }
         enum VirtualMachineRecordReplayState {
            "recording",
            "replaying",
            "inactive",
         }
         enum VirtualMachineNeedSecondaryReason {
            "initializing",
            "divergence",
            "lostConnection",
            "partialHardwareFailure",
            "userAction",
            "other",
         }
         enum VirtualMachineTicketType {
            "mks",
            "device",
            "guestControl",
         }
         interface VirtualMachineDisplayTopology extends srmService.vim.DynamicData {
            x: number;
            y: number;
            width: number;
            height: number;
         }
         interface ArrayOfVirtualMachineDisplayTopology {
            virtualMachineDisplayTopology?: Array<srmService.vim.VirtualMachineDisplayTopology>;
         }
         interface DiskChangeExtent extends srmService.vim.DynamicData {
            start: number;
            length: number;
         }
         interface ArrayOfDiskChangeExtent {
            diskChangeExtent?: Array<srmService.vim.DiskChangeExtent>;
         }
         interface DiskChangeInfo extends srmService.vim.DynamicData {
            startOffset: number;
            length: number;
            changedArea?: Array<srmService.vim.DiskChangeExtent>;
         }
         interface VirtualMachineWipeResult extends srmService.vim.DynamicData {
            diskId: number;
            shrinkableDiskSpace: number;
         }
         enum ActionParameter {
            "targetName",
            "alarmName",
            "oldStatus",
            "newStatus",
            "triggeringSummary",
            "declaringSummary",
            "eventDescription",
            "target",
            "alarm",
         }
         interface Action extends srmService.vim.DynamicData {
         }
         interface MethodActionArgument extends srmService.vim.DynamicData {
            value?: any;
         }
         interface ArrayOfMethodActionArgument {
            methodActionArgument?: Array<srmService.vim.MethodActionArgument>;
         }
         interface MethodAction extends srmService.vim.Action {
            name: string;
            argument?: Array<srmService.vim.MethodActionArgument>;
         }
         interface SendEmailAction extends srmService.vim.Action {
            toList: string;
            ccList: string;
            subject: string;
            body: string;
         }
         interface SendSNMPAction extends srmService.vim.Action {
         }
         interface RunScriptAction extends srmService.vim.Action {
            script: string;
         }
         interface CreateTaskAction extends srmService.vim.Action {
            taskTypeId: string;
            cancelable: boolean;
         }
         interface AlarmAction extends srmService.vim.DynamicData {
         }
         interface ArrayOfAlarmAction {
            alarmAction?: Array<srmService.vim.AlarmAction>;
         }
         interface AlarmTriggeringActionTransitionSpec extends srmService.vim.DynamicData {
            startState: srmService.vim.ManagedEntityStatus;
            finalState: srmService.vim.ManagedEntityStatus;
            repeats: boolean;
         }
         interface ArrayOfAlarmTriggeringActionTransitionSpec {
            alarmTriggeringActionTransitionSpec?: Array<srmService.vim.AlarmTriggeringActionTransitionSpec>;
         }
         interface AlarmTriggeringAction extends srmService.vim.AlarmAction {
            action: srmService.vim.Action;
            transitionSpecs?: Array<srmService.vim.AlarmTriggeringActionTransitionSpec>;
            green2yellow: boolean;
            yellow2red: boolean;
            red2yellow: boolean;
            yellow2green: boolean;
         }
         interface GroupAlarmAction extends srmService.vim.AlarmAction {
            action: Array<srmService.vim.AlarmAction>;
         }
         interface AlarmDescription extends srmService.vim.DynamicData {
            expr: Array<srmService.vim.TypeDescription>;
            stateOperator: Array<srmService.vim.ElementDescription>;
            metricOperator: Array<srmService.vim.ElementDescription>;
            hostSystemConnectionState: Array<srmService.vim.ElementDescription>;
            virtualMachinePowerState: Array<srmService.vim.ElementDescription>;
            datastoreConnectionState?: Array<srmService.vim.ElementDescription>;
            hostSystemPowerState?: Array<srmService.vim.ElementDescription>;
            virtualMachineGuestHeartbeatStatus?: Array<srmService.vim.ElementDescription>;
            entityStatus: Array<srmService.vim.ElementDescription>;
            action: Array<srmService.vim.TypeDescription>;
         }
         interface AlarmExpression extends srmService.vim.DynamicData {
         }
         interface ArrayOfAlarmExpression {
            alarmExpression?: Array<srmService.vim.AlarmExpression>;
         }
         interface AndAlarmExpression extends srmService.vim.AlarmExpression {
            expression: Array<srmService.vim.AlarmExpression>;
         }
         interface OrAlarmExpression extends srmService.vim.AlarmExpression {
            expression: Array<srmService.vim.AlarmExpression>;
         }
         enum StateAlarmOperator {
            "isEqual",
            "isUnequal",
         }
         interface StateAlarmExpression extends srmService.vim.AlarmExpression {
            operator: srmService.vim.StateAlarmOperator;
            type: string;
            statePath: string;
            yellow?: string;
            red?: string;
         }
         enum EventAlarmExpressionComparisonOperator {
            "equals",
            "notEqualTo",
            "startsWith",
            "doesNotStartWith",
            "endsWith",
            "doesNotEndWith",
         }
         interface EventAlarmExpressionComparison extends srmService.vim.DynamicData {
            attributeName: string;
            operator: string;
            value: string;
         }
         interface ArrayOfEventAlarmExpressionComparison {
            eventAlarmExpressionComparison?: Array<srmService.vim.EventAlarmExpressionComparison>;
         }
         interface EventAlarmExpression extends srmService.vim.AlarmExpression {
            comparisons?: Array<srmService.vim.EventAlarmExpressionComparison>;
            eventType: string;
            eventTypeId?: string;
            objectType?: string;
            status?: srmService.vim.ManagedEntityStatus;
         }
         enum MetricAlarmOperator {
            "isAbove",
            "isBelow",
         }
         interface MetricAlarmExpression extends srmService.vim.AlarmExpression {
            operator: srmService.vim.MetricAlarmOperator;
            type: string;
            metric: srmService.vim.PerfMetricId;
            yellow?: number;
            yellowInterval?: number;
            red?: number;
            redInterval?: number;
         }
         interface AlarmInfo extends srmService.vim.AlarmSpec {
            key: string;
            alarm: srmService.vim.ManagedObjectReference;
            entity: srmService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            creationEventId: number;
         }
         interface AlarmSetting extends srmService.vim.DynamicData {
            toleranceRange: number;
            reportingFrequency: number;
         }
         interface AlarmSpec extends srmService.vim.DynamicData {
            name: string;
            systemName?: string;
            description: string;
            enabled: boolean;
            expression: srmService.vim.AlarmExpression;
            action?: srmService.vim.AlarmAction;
            actionFrequency?: number;
            setting?: srmService.vim.AlarmSetting;
         }
         interface AlarmState extends srmService.vim.DynamicData {
            key: string;
            entity: srmService.vim.ManagedObjectReference;
            alarm: srmService.vim.ManagedObjectReference;
            overallStatus: srmService.vim.ManagedEntityStatus;
            time: Date;
            acknowledged?: boolean;
            acknowledgedByUser?: string;
            acknowledgedTime?: Date;
         }
         interface ArrayOfAlarmState {
            alarmState?: Array<srmService.vim.AlarmState>;
         }
         enum ActionType {
            "MigrationV1",
            "VmPowerV1",
            "HostPowerV1",
            "HostMaintenanceV1",
            "StorageMigrationV1",
            "StoragePlacementV1",
         }
         interface ClusterAction extends srmService.vim.DynamicData {
            type: string;
            target?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAction {
            clusterAction?: Array<srmService.vim.ClusterAction>;
         }
         interface ClusterActionHistory extends srmService.vim.DynamicData {
            action: srmService.vim.ClusterAction;
            time: Date;
         }
         interface ArrayOfClusterActionHistory {
            clusterActionHistory?: Array<srmService.vim.ClusterActionHistory>;
         }
         interface ClusterAffinityRuleSpec extends srmService.vim.ClusterRuleInfo {
            vm: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ClusterAntiAffinityRuleSpec extends srmService.vim.ClusterRuleInfo {
            vm: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ClusterAttemptedVmInfo extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            task?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAttemptedVmInfo {
            clusterAttemptedVmInfo?: Array<srmService.vim.ClusterAttemptedVmInfo>;
         }
         interface ClusterConfigInfo extends srmService.vim.DynamicData {
            dasConfig: srmService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<srmService.vim.ClusterDasVmConfigInfo>;
            drsConfig: srmService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<srmService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<srmService.vim.ClusterRuleInfo>;
         }
         enum DrsBehavior {
            "manual",
            "partiallyAutomated",
            "fullyAutomated",
         }
         interface ClusterDrsConfigInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            enableVmBehaviorOverrides?: boolean;
            defaultVmBehavior?: srmService.vim.DrsBehavior;
            vmotionRate?: number;
            option?: Array<srmService.vim.OptionValue>;
         }
         interface ClusterDrsVmConfigInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: srmService.vim.DrsBehavior;
         }
         interface ArrayOfClusterDrsVmConfigInfo {
            clusterDrsVmConfigInfo?: Array<srmService.vim.ClusterDrsVmConfigInfo>;
         }
         interface ClusterConfigInfoEx extends srmService.vim.ComputeResourceConfigInfo {
            dasConfig: srmService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<srmService.vim.ClusterDasVmConfigInfo>;
            drsConfig: srmService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<srmService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<srmService.vim.ClusterRuleInfo>;
            dpmConfigInfo?: srmService.vim.ClusterDpmConfigInfo;
            dpmHostConfig?: Array<srmService.vim.ClusterDpmHostConfigInfo>;
            vsanConfigInfo?: srmService.vim.VsanClusterConfigInfo;
            vsanHostConfig?: Array<srmService.vim.VsanHostConfigInfo>;
            group?: Array<srmService.vim.ClusterGroupInfo>;
         }
         enum DpmBehavior {
            "manual",
            "automated",
         }
         interface ClusterDpmConfigInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            defaultDpmBehavior?: srmService.vim.DpmBehavior;
            hostPowerActionRate?: number;
            option?: Array<srmService.vim.OptionValue>;
         }
         interface ClusterDpmHostConfigInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: srmService.vim.DpmBehavior;
         }
         interface ArrayOfClusterDpmHostConfigInfo {
            clusterDpmHostConfigInfo?: Array<srmService.vim.ClusterDpmHostConfigInfo>;
         }
         interface ClusterConfigSpec extends srmService.vim.DynamicData {
            dasConfig?: srmService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<srmService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: srmService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<srmService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<srmService.vim.ClusterRuleSpec>;
         }
         interface ClusterDasVmConfigSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.ClusterDasVmConfigInfo;
         }
         interface ArrayOfClusterDasVmConfigSpec {
            clusterDasVmConfigSpec?: Array<srmService.vim.ClusterDasVmConfigSpec>;
         }
         interface ClusterDrsVmConfigSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.ClusterDrsVmConfigInfo;
         }
         interface ArrayOfClusterDrsVmConfigSpec {
            clusterDrsVmConfigSpec?: Array<srmService.vim.ClusterDrsVmConfigSpec>;
         }
         interface ClusterConfigSpecEx extends srmService.vim.ComputeResourceConfigSpec {
            dasConfig?: srmService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<srmService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: srmService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<srmService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<srmService.vim.ClusterRuleSpec>;
            dpmConfig?: srmService.vim.ClusterDpmConfigInfo;
            dpmHostConfigSpec?: Array<srmService.vim.ClusterDpmHostConfigSpec>;
            vsanConfig?: srmService.vim.VsanClusterConfigInfo;
            vsanHostConfigSpec?: Array<srmService.vim.VsanHostConfigInfo>;
            groupSpec?: Array<srmService.vim.ClusterGroupSpec>;
         }
         interface ClusterDpmHostConfigSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.ClusterDpmHostConfigInfo;
         }
         interface ArrayOfClusterDpmHostConfigSpec {
            clusterDpmHostConfigSpec?: Array<srmService.vim.ClusterDpmHostConfigSpec>;
         }
         interface ClusterGroupSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.ClusterGroupInfo;
         }
         interface ArrayOfClusterGroupSpec {
            clusterGroupSpec?: Array<srmService.vim.ClusterGroupSpec>;
         }
         interface ClusterDasAamHostInfo extends srmService.vim.ClusterDasHostInfo {
            hostDasState?: Array<srmService.vim.ClusterDasAamNodeState>;
            primaryHosts?: Array<string>;
         }
         enum ClusterDasAamNodeStateDasState {
            "uninitialized",
            "initialized",
            "configuring",
            "unconfiguring",
            "running",
            "error",
            "agentShutdown",
            "nodeFailed",
         }
         interface ClusterDasAamNodeState extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            name: string;
            configState: string;
            runtimeState: string;
         }
         interface ArrayOfClusterDasAamNodeState {
            clusterDasAamNodeState?: Array<srmService.vim.ClusterDasAamNodeState>;
         }
         interface ClusterDasAdmissionControlInfo extends srmService.vim.DynamicData {
         }
         interface ClusterDasAdmissionControlPolicy extends srmService.vim.DynamicData {
         }
         interface DasHeartbeatDatastoreInfo extends srmService.vim.DynamicData {
            datastore: srmService.vim.ManagedObjectReference;
            hosts: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ArrayOfDasHeartbeatDatastoreInfo {
            dasHeartbeatDatastoreInfo?: Array<srmService.vim.DasHeartbeatDatastoreInfo>;
         }
         interface ClusterDasAdvancedRuntimeInfo extends srmService.vim.DynamicData {
            dasHostInfo?: srmService.vim.ClusterDasHostInfo;
            heartbeatDatastoreInfo?: Array<srmService.vim.DasHeartbeatDatastoreInfo>;
         }
         enum ClusterDasConfigInfoServiceState {
            "disabled",
            "enabled",
         }
         enum ClusterDasConfigInfoVmMonitoringState {
            "vmMonitoringDisabled",
            "vmMonitoringOnly",
            "vmAndAppMonitoring",
         }
         enum ClusterDasConfigInfoHBDatastoreCandidate {
            "userSelectedDs",
            "allFeasibleDs",
            "allFeasibleDsWithUserPreference",
         }
         interface ClusterDasConfigInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            hostMonitoring?: string;
            failoverLevel?: number;
            admissionControlPolicy?: srmService.vim.ClusterDasAdmissionControlPolicy;
            admissionControlEnabled?: boolean;
            defaultVmSettings?: srmService.vim.ClusterDasVmSettings;
            option?: Array<srmService.vim.OptionValue>;
            heartbeatDatastore?: Array<srmService.vim.ManagedObjectReference>;
            hBDatastoreCandidatePolicy?: string;
         }
         interface ClusterDasData extends srmService.vim.DynamicData {
         }
         interface ClusterDasDataSummary extends srmService.vim.ClusterDasData {
            hostListVersion: number;
            clusterConfigVersion: number;
            compatListVersion: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo extends srmService.vim.DynamicData {
            numVcpus: number;
            cpuMHz: number;
            memoryMB: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots {
            clusterDasFailoverLevelAdvancedRuntimeInfoHostSlots?: Array<srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots {
            clusterDasFailoverLevelAdvancedRuntimeInfoVmSlots?: Array<srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfo extends srmService.vim.ClusterDasAdvancedRuntimeInfo {
            slotInfo: srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
            totalSlots: number;
            usedSlots: number;
            unreservedSlots: number;
            totalVms: number;
            totalHosts: number;
            totalGoodHosts: number;
            hostSlots?: Array<srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
            vmsRequiringMultipleSlots?: Array<srmService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         enum ClusterDasFdmAvailabilityState {
            "uninitialized",
            "election",
            "master",
            "connectedToMaster",
            "networkPartitionedFromMaster",
            "networkIsolated",
            "hostDown",
            "initializationError",
            "uninitializationError",
            "fdmUnreachable",
         }
         interface ClusterDasFdmHostState extends srmService.vim.DynamicData {
            state: string;
            stateReporter?: srmService.vim.ManagedObjectReference;
         }
         interface ClusterDasHostInfo extends srmService.vim.DynamicData {
         }
         interface ClusterDasHostRecommendation extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            drsRating?: number;
         }
         enum DasVmPriority {
            "disabled",
            "low",
            "medium",
            "high",
         }
         interface ClusterDasVmConfigInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            restartPriority?: srmService.vim.DasVmPriority;
            powerOffOnIsolation?: boolean;
            dasSettings?: srmService.vim.ClusterDasVmSettings;
         }
         interface ArrayOfClusterDasVmConfigInfo {
            clusterDasVmConfigInfo?: Array<srmService.vim.ClusterDasVmConfigInfo>;
         }
         enum ClusterDasVmSettingsRestartPriority {
            "disabled",
            "low",
            "medium",
            "high",
            "clusterRestartPriority",
         }
         enum ClusterDasVmSettingsIsolationResponse {
            "none",
            "powerOff",
            "shutdown",
            "clusterIsolationResponse",
         }
         interface ClusterDasVmSettings extends srmService.vim.DynamicData {
            restartPriority?: string;
            isolationResponse?: string;
            vmToolsMonitoringSettings?: srmService.vim.ClusterVmToolsMonitoringSettings;
         }
         interface ClusterDrsFaultsFaultsByVm extends srmService.vim.DynamicData {
            vm?: srmService.vim.ManagedObjectReference;
            fault: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfClusterDrsFaultsFaultsByVm {
            clusterDrsFaultsFaultsByVm?: Array<srmService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ClusterDrsFaultsFaultsByVirtualDisk extends srmService.vim.ClusterDrsFaultsFaultsByVm {
            disk?: srmService.vim.VirtualDiskId;
         }
         interface ClusterDrsFaults extends srmService.vim.DynamicData {
            reason: string;
            faultsByVm: Array<srmService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ArrayOfClusterDrsFaults {
            clusterDrsFaults?: Array<srmService.vim.ClusterDrsFaults>;
         }
         interface ClusterDrsMigration extends srmService.vim.DynamicData {
            key: string;
            time: Date;
            vm: srmService.vim.ManagedObjectReference;
            cpuLoad?: number;
            memoryLoad?: number;
            source: srmService.vim.ManagedObjectReference;
            sourceCpuLoad?: number;
            sourceMemoryLoad?: number;
            destination: srmService.vim.ManagedObjectReference;
            destinationCpuLoad?: number;
            destinationMemoryLoad?: number;
         }
         interface ArrayOfClusterDrsMigration {
            clusterDrsMigration?: Array<srmService.vim.ClusterDrsMigration>;
         }
         enum DrsRecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
         }
         interface ClusterDrsRecommendation extends srmService.vim.DynamicData {
            key: string;
            rating: number;
            reason: string;
            reasonText: string;
            migrationList: Array<srmService.vim.ClusterDrsMigration>;
         }
         interface ArrayOfClusterDrsRecommendation {
            clusterDrsRecommendation?: Array<srmService.vim.ClusterDrsRecommendation>;
         }
         interface ClusterEnterMaintenanceResult extends srmService.vim.DynamicData {
            recommendations?: Array<srmService.vim.ClusterRecommendation>;
            fault?: srmService.vim.ClusterDrsFaults;
         }
         interface ClusterFailoverHostAdmissionControlInfoHostStatus extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            status: srmService.vim.ManagedEntityStatus;
         }
         interface ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus {
            clusterFailoverHostAdmissionControlInfoHostStatus?: Array<srmService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlInfo extends srmService.vim.ClusterDasAdmissionControlInfo {
            hostStatus?: Array<srmService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlPolicy extends srmService.vim.ClusterDasAdmissionControlPolicy {
            failoverHosts?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ClusterFailoverLevelAdmissionControlInfo extends srmService.vim.ClusterDasAdmissionControlInfo {
            currentFailoverLevel: number;
         }
         interface ClusterFailoverLevelAdmissionControlPolicy extends srmService.vim.ClusterDasAdmissionControlPolicy {
            failoverLevel: number;
            slotPolicy?: srmService.vim.ClusterSlotPolicy;
         }
         interface ClusterFailoverResourcesAdmissionControlInfo extends srmService.vim.ClusterDasAdmissionControlInfo {
            currentCpuFailoverResourcesPercent: number;
            currentMemoryFailoverResourcesPercent: number;
         }
         interface ClusterFailoverResourcesAdmissionControlPolicy extends srmService.vim.ClusterDasAdmissionControlPolicy {
            cpuFailoverResourcesPercent: number;
            memoryFailoverResourcesPercent: number;
         }
         interface ClusterGroupInfo extends srmService.vim.DynamicData {
            name: string;
            userCreated?: boolean;
         }
         interface ArrayOfClusterGroupInfo {
            clusterGroupInfo?: Array<srmService.vim.ClusterGroupInfo>;
         }
         interface ClusterHostGroup extends srmService.vim.ClusterGroupInfo {
            host?: Array<srmService.vim.ManagedObjectReference>;
         }
         enum HostPowerOperationType {
            "powerOn",
            "powerOff",
         }
         interface ClusterHostPowerAction extends srmService.vim.ClusterAction {
            operationType: srmService.vim.HostPowerOperationType;
            powerConsumptionWatt?: number;
            cpuCapacityMHz?: number;
            memCapacityMB?: number;
         }
         interface ClusterHostRecommendation extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            rating: number;
         }
         interface ArrayOfClusterHostRecommendation {
            clusterHostRecommendation?: Array<srmService.vim.ClusterHostRecommendation>;
         }
         interface ClusterInitialPlacementAction extends srmService.vim.ClusterAction {
            targetHost: srmService.vim.ManagedObjectReference;
            pool?: srmService.vim.ManagedObjectReference;
         }
         interface ClusterMigrationAction extends srmService.vim.ClusterAction {
            drsMigration?: srmService.vim.ClusterDrsMigration;
         }
         interface ClusterNotAttemptedVmInfo extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfClusterNotAttemptedVmInfo {
            clusterNotAttemptedVmInfo?: Array<srmService.vim.ClusterNotAttemptedVmInfo>;
         }
         enum ClusterPowerOnVmOption {
            "OverrideAutomationLevel",
            "ReserveResources",
         }
         interface ClusterPowerOnVmResult extends srmService.vim.DynamicData {
            attempted?: Array<srmService.vim.ClusterAttemptedVmInfo>;
            notAttempted?: Array<srmService.vim.ClusterNotAttemptedVmInfo>;
            recommendations?: Array<srmService.vim.ClusterRecommendation>;
         }
         enum RecommendationType {
            "V1",
         }
         enum RecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
            "enterStandby",
            "reservationCpu",
            "reservationMem",
            "powerOnVm",
            "powerSaving",
            "increaseCapacity",
            "checkResource",
            "unreservedCapacity",
            "vmHostHardAffinity",
            "vmHostSoftAffinity",
            "balanceDatastoreSpaceUsage",
            "balanceDatastoreIOLoad",
            "datastoreMaint",
            "virtualDiskJointAffin",
            "virtualDiskAntiAffin",
            "datastoreSpaceOutage",
            "storagePlacement",
            "iolbDisabledInternal",
         }
         interface ClusterRecommendation extends srmService.vim.DynamicData {
            key: string;
            type: string;
            time: Date;
            rating: number;
            reason: string;
            reasonText: string;
            prerequisite?: Array<string>;
            action?: Array<srmService.vim.ClusterAction>;
            target?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterRecommendation {
            clusterRecommendation?: Array<srmService.vim.ClusterRecommendation>;
         }
         interface ClusterRuleInfo extends srmService.vim.DynamicData {
            key?: number;
            status?: srmService.vim.ManagedEntityStatus;
            enabled?: boolean;
            name?: string;
            mandatory?: boolean;
            userCreated?: boolean;
            inCompliance?: boolean;
         }
         interface ArrayOfClusterRuleInfo {
            clusterRuleInfo?: Array<srmService.vim.ClusterRuleInfo>;
         }
         interface ClusterRuleSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.ClusterRuleInfo;
         }
         interface ArrayOfClusterRuleSpec {
            clusterRuleSpec?: Array<srmService.vim.ClusterRuleSpec>;
         }
         interface ClusterSlotPolicy extends srmService.vim.DynamicData {
         }
         interface ClusterFixedSizeSlotPolicy extends srmService.vim.ClusterSlotPolicy {
            cpu: number;
            memory: number;
         }
         interface ClusterVmGroup extends srmService.vim.ClusterGroupInfo {
            vm?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ClusterVmHostRuleInfo extends srmService.vim.ClusterRuleInfo {
            vmGroupName?: string;
            affineHostGroupName?: string;
            antiAffineHostGroupName?: string;
         }
         interface ClusterVmToolsMonitoringSettings extends srmService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            clusterSettings?: boolean;
            failureInterval?: number;
            minUpTime?: number;
            maxFailures?: number;
            maxFailureWindow?: number;
         }
         interface DVPortConfigSpec extends srmService.vim.DynamicData {
            operation: string;
            key?: string;
            name?: string;
            scope?: Array<srmService.vim.ManagedObjectReference>;
            description?: string;
            setting?: srmService.vim.DVPortSetting;
            configVersion?: string;
         }
         interface ArrayOfDVPortConfigSpec {
            dVPortConfigSpec?: Array<srmService.vim.DVPortConfigSpec>;
         }
         interface DVPortConfigInfo extends srmService.vim.DynamicData {
            name?: string;
            scope?: Array<srmService.vim.ManagedObjectReference>;
            description?: string;
            setting?: srmService.vim.DVPortSetting;
            configVersion: string;
         }
         interface DVSTrafficShapingPolicy extends srmService.vim.InheritablePolicy {
            enabled?: srmService.vim.BoolPolicy;
            averageBandwidth?: srmService.vim.LongPolicy;
            peakBandwidth?: srmService.vim.LongPolicy;
            burstSize?: srmService.vim.LongPolicy;
         }
         interface DVSHostLocalPortInfo extends srmService.vim.DynamicData {
            switchUuid: string;
            portKey: string;
            setting: srmService.vim.DVPortSetting;
            vnic: string;
         }
         interface DVSVendorSpecificConfig extends srmService.vim.InheritablePolicy {
            keyValue?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DvsFilterParameter extends srmService.vim.DynamicData {
            parameters?: Array<string>;
         }
         enum DvsFilterOnFailure {
            "failOpen",
            "failClosed",
         }
         interface DvsFilterConfig extends srmService.vim.InheritablePolicy {
            key?: string;
            agentName?: string;
            slotNumber?: string;
            parameters?: srmService.vim.DvsFilterParameter;
            onFailure?: string;
         }
         interface ArrayOfDvsFilterConfig {
            dvsFilterConfig?: Array<srmService.vim.DvsFilterConfig>;
         }
         interface DvsTrafficFilterConfig extends srmService.vim.DvsFilterConfig {
            trafficRuleset?: srmService.vim.DvsTrafficRuleset;
         }
         interface DvsFilterConfigSpec extends srmService.vim.DvsFilterConfig {
            operation: string;
         }
         interface DvsTrafficFilterConfigSpec extends srmService.vim.DvsTrafficFilterConfig {
            operation: string;
         }
         interface DvsFilterPolicy extends srmService.vim.InheritablePolicy {
            filterConfig?: Array<srmService.vim.DvsFilterConfig>;
         }
         interface DVPortSetting extends srmService.vim.DynamicData {
            blocked?: srmService.vim.BoolPolicy;
            vmDirectPathGen2Allowed?: srmService.vim.BoolPolicy;
            inShapingPolicy?: srmService.vim.DVSTrafficShapingPolicy;
            outShapingPolicy?: srmService.vim.DVSTrafficShapingPolicy;
            vendorSpecificConfig?: srmService.vim.DVSVendorSpecificConfig;
            networkResourcePoolKey?: srmService.vim.StringPolicy;
            filterPolicy?: srmService.vim.DvsFilterPolicy;
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonNetwork {
            "portNptIncompatibleDvs",
            "portNptNoCompatibleNics",
            "portNptNoVirtualFunctionsAvailable",
            "portNptDisabledForPort",
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonOther {
            "portNptIncompatibleHost",
            "portNptIncompatibleConnectee",
         }
         interface DVPortStatus extends srmService.vim.DynamicData {
            linkUp: boolean;
            blocked: boolean;
            vlanIds?: Array<srmService.vim.NumericRange>;
            trunkingMode?: boolean;
            mtu?: number;
            linkPeer?: string;
            macAddress?: string;
            statusDetail?: string;
            vmDirectPathGen2Active?: boolean;
            vmDirectPathGen2InactiveReasonNetwork?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
         }
         interface DVPortState extends srmService.vim.DynamicData {
            runtimeInfo?: srmService.vim.DVPortStatus;
            stats: srmService.vim.DistributedVirtualSwitchPortStatistics;
            vendorSpecificState?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DistributedVirtualPort extends srmService.vim.DynamicData {
            key: string;
            config: srmService.vim.DVPortConfigInfo;
            dvsUuid: string;
            portgroupKey?: string;
            proxyHost?: srmService.vim.ManagedObjectReference;
            connectee?: srmService.vim.DistributedVirtualSwitchPortConnectee;
            conflict: boolean;
            conflictPortKey?: string;
            state?: srmService.vim.DVPortState;
            connectionCookie?: number;
            lastStatusChange: Date;
            hostLocalPort?: boolean;
         }
         interface ArrayOfDistributedVirtualPort {
            distributedVirtualPort?: Array<srmService.vim.DistributedVirtualPort>;
         }
         enum DistributedVirtualPortgroupPortgroupType {
            "earlyBinding",
            "lateBinding",
            "ephemeral",
         }
         interface DVPortgroupPolicy extends srmService.vim.DynamicData {
            blockOverrideAllowed: boolean;
            shapingOverrideAllowed: boolean;
            vendorConfigOverrideAllowed: boolean;
            livePortMovingAllowed: boolean;
            portConfigResetAtDisconnect: boolean;
            networkResourcePoolOverrideAllowed?: boolean;
            trafficFilterOverrideAllowed?: boolean;
         }
         enum DistributedVirtualPortgroupMetaTagName {
            "dvsName",
            "portgroupName",
            "portIndex",
         }
         interface DVPortgroupConfigSpec extends srmService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numPorts?: number;
            portNameFormat?: string;
            defaultPortConfig?: srmService.vim.DVPortSetting;
            description?: string;
            type?: string;
            scope?: Array<srmService.vim.ManagedObjectReference>;
            policy?: srmService.vim.DVPortgroupPolicy;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            autoExpand?: boolean;
         }
         interface ArrayOfDVPortgroupConfigSpec {
            dVPortgroupConfigSpec?: Array<srmService.vim.DVPortgroupConfigSpec>;
         }
         interface DVPortgroupConfigInfo extends srmService.vim.DynamicData {
            key: string;
            name: string;
            numPorts: number;
            distributedVirtualSwitch?: srmService.vim.ManagedObjectReference;
            defaultPortConfig?: srmService.vim.DVPortSetting;
            description?: string;
            type: string;
            policy: srmService.vim.DVPortgroupPolicy;
            portNameFormat?: string;
            scope?: Array<srmService.vim.ManagedObjectReference>;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            configVersion?: string;
            autoExpand?: boolean;
         }
         interface DistributedVirtualPortgroupInfo extends srmService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            portgroupName: string;
            portgroupKey: string;
            portgroupType: string;
            uplinkPortgroup: boolean;
            portgroup: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfDistributedVirtualPortgroupInfo {
            distributedVirtualPortgroupInfo?: Array<srmService.vim.DistributedVirtualPortgroupInfo>;
         }
         interface DVPortgroupSelection extends srmService.vim.SelectionSet {
            dvsUuid: string;
            portgroupKey: Array<string>;
         }
         interface DistributedVirtualSwitchInfo extends srmService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            distributedVirtualSwitch: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfDistributedVirtualSwitchInfo {
            distributedVirtualSwitchInfo?: Array<srmService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DVSManagerDvsConfigTarget extends srmService.vim.DynamicData {
            distributedVirtualPortgroup?: Array<srmService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<srmService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DistributedVirtualSwitchManagerCompatibilityResult extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            error?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfDistributedVirtualSwitchManagerCompatibilityResult {
            distributedVirtualSwitchManagerCompatibilityResult?: Array<srmService.vim.DistributedVirtualSwitchManagerCompatibilityResult>;
         }
         interface DistributedVirtualSwitchManagerHostContainer extends srmService.vim.DynamicData {
            container: srmService.vim.ManagedObjectReference;
            recursive: boolean;
         }
         interface DistributedVirtualSwitchManagerHostDvsFilterSpec extends srmService.vim.DynamicData {
            inclusive: boolean;
         }
         interface ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec {
            distributedVirtualSwitchManagerHostDvsFilterSpec?: Array<srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>;
         }
         interface DistributedVirtualSwitchManagerHostArrayFilter extends srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            host: Array<srmService.vim.ManagedObjectReference>;
         }
         interface DistributedVirtualSwitchManagerHostContainerFilter extends srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            hostContainer: srmService.vim.DistributedVirtualSwitchManagerHostContainer;
         }
         interface DistributedVirtualSwitchManagerHostDvsMembershipFilter extends srmService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            distributedVirtualSwitch: srmService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerDvsProductSpec extends srmService.vim.DynamicData {
            newSwitchProductSpec?: srmService.vim.DistributedVirtualSwitchProductSpec;
            distributedVirtualSwitch?: srmService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerImportResult extends srmService.vim.DynamicData {
            distributedVirtualSwitch?: Array<srmService.vim.ManagedObjectReference>;
            distributedVirtualPortgroup?: Array<srmService.vim.ManagedObjectReference>;
            importFault?: Array<srmService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface DVSSelection extends srmService.vim.SelectionSet {
            dvsUuid: string;
         }
         interface EntityBackupConfig extends srmService.vim.DynamicData {
            entityType: string;
            configBlob: string;
            key?: string;
            name?: string;
            container?: srmService.vim.ManagedObjectReference;
            configVersion?: string;
         }
         interface ArrayOfEntityBackupConfig {
            entityBackupConfig?: Array<srmService.vim.EntityBackupConfig>;
         }
         enum EntityType {
            "distributedVirtualSwitch",
            "distributedVirtualPortgroup",
         }
         enum EntityImportType {
            "createEntityWithNewIdentifier",
            "createEntityWithOriginalIdentifier",
            "applyToEntitySpecified",
         }
         interface EntityBackup extends srmService.vim.DynamicData {
         }
         enum DistributedVirtualSwitchHostMemberHostComponentState {
            "up",
            "pending",
            "outOfSync",
            "warning",
            "disconnected",
            "down",
         }
         interface DistributedVirtualSwitchHostMemberConfigSpec extends srmService.vim.DynamicData {
            operation: string;
            host: srmService.vim.ManagedObjectReference;
            backing?: srmService.vim.DistributedVirtualSwitchHostMemberBacking;
            maxProxySwitchPorts?: number;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberConfigSpec {
            distributedVirtualSwitchHostMemberConfigSpec?: Array<srmService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
         }
         interface DistributedVirtualSwitchHostMemberPnicSpec extends srmService.vim.DynamicData {
            pnicDevice: string;
            uplinkPortKey?: string;
            uplinkPortgroupKey?: string;
            connectionCookie?: number;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberPnicSpec {
            distributedVirtualSwitchHostMemberPnicSpec?: Array<srmService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberBacking extends srmService.vim.DynamicData {
         }
         interface DistributedVirtualSwitchHostMemberPnicBacking extends srmService.vim.DistributedVirtualSwitchHostMemberBacking {
            pnicSpec?: Array<srmService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberRuntimeState extends srmService.vim.DynamicData {
            currentMaxProxySwitchPorts: number;
         }
         interface DistributedVirtualSwitchHostMemberConfigInfo extends srmService.vim.DynamicData {
            host?: srmService.vim.ManagedObjectReference;
            maxProxySwitchPorts: number;
            vendorSpecificConfig?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            backing: srmService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostMemberRuntimeInfo extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            status?: string;
            statusDetail?: string;
            healthCheckResult?: Array<srmService.vim.HostMemberHealthCheckResult>;
         }
         interface ArrayOfHostMemberRuntimeInfo {
            hostMemberRuntimeInfo?: Array<srmService.vim.HostMemberRuntimeInfo>;
         }
         interface HostMemberHealthCheckResult extends srmService.vim.DynamicData {
            summary?: string;
         }
         interface ArrayOfHostMemberHealthCheckResult {
            hostMemberHealthCheckResult?: Array<srmService.vim.HostMemberHealthCheckResult>;
         }
         interface HostMemberUplinkHealthCheckResult extends srmService.vim.HostMemberHealthCheckResult {
            uplinkPortKey: string;
         }
         interface DistributedVirtualSwitchHostMember extends srmService.vim.DynamicData {
            runtimeState?: srmService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
            config: srmService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
            productInfo?: srmService.vim.DistributedVirtualSwitchProductSpec;
            uplinkPortKey?: Array<string>;
            status: string;
            statusDetail?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostMember {
            distributedVirtualSwitchHostMember?: Array<srmService.vim.DistributedVirtualSwitchHostMember>;
         }
         interface DistributedVirtualSwitchHostProductSpec extends srmService.vim.DynamicData {
            productLineId?: string;
            version?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostProductSpec {
            distributedVirtualSwitchHostProductSpec?: Array<srmService.vim.DistributedVirtualSwitchHostProductSpec>;
         }
         interface DistributedVirtualSwitchKeyedOpaqueBlob extends srmService.vim.DynamicData {
            key: string;
            opaqueData: string;
         }
         interface ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob {
            distributedVirtualSwitchKeyedOpaqueBlob?: Array<srmService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DVSNetworkResourcePoolAllocationInfo extends srmService.vim.DynamicData {
            limit?: number;
            shares?: srmService.vim.SharesInfo;
            priorityTag?: number;
         }
         interface DVSNetworkResourcePoolConfigSpec extends srmService.vim.DynamicData {
            key: string;
            configVersion?: string;
            allocationInfo?: srmService.vim.DVSNetworkResourcePoolAllocationInfo;
            name?: string;
            description?: string;
         }
         interface ArrayOfDVSNetworkResourcePoolConfigSpec {
            dVSNetworkResourcePoolConfigSpec?: Array<srmService.vim.DVSNetworkResourcePoolConfigSpec>;
         }
         interface DVSNetworkResourcePool extends srmService.vim.DynamicData {
            key: string;
            name?: string;
            description?: string;
            configVersion: string;
            allocationInfo: srmService.vim.DVSNetworkResourcePoolAllocationInfo;
         }
         interface ArrayOfDVSNetworkResourcePool {
            dVSNetworkResourcePool?: Array<srmService.vim.DVSNetworkResourcePool>;
         }
         enum DistributedVirtualSwitchPortConnecteeConnecteeType {
            "pnic",
            "vmVnic",
            "hostConsoleVnic",
            "hostVmkVnic",
         }
         interface DistributedVirtualSwitchPortConnectee extends srmService.vim.DynamicData {
            connectedEntity?: srmService.vim.ManagedObjectReference;
            nicKey?: string;
            type?: string;
            addressHint?: string;
         }
         interface DistributedVirtualSwitchPortConnection extends srmService.vim.DynamicData {
            switchUuid: string;
            portgroupKey?: string;
            portKey?: string;
            connectionCookie?: number;
         }
         interface DistributedVirtualSwitchPortCriteria extends srmService.vim.DynamicData {
            connected?: boolean;
            active?: boolean;
            uplinkPort?: boolean;
            scope?: srmService.vim.ManagedObjectReference;
            portgroupKey?: Array<string>;
            inside?: boolean;
            portKey?: Array<string>;
         }
         interface DistributedVirtualSwitchPortStatistics extends srmService.vim.DynamicData {
            packetsInMulticast: number;
            packetsOutMulticast: number;
            bytesInMulticast: number;
            bytesOutMulticast: number;
            packetsInUnicast: number;
            packetsOutUnicast: number;
            bytesInUnicast: number;
            bytesOutUnicast: number;
            packetsInBroadcast: number;
            packetsOutBroadcast: number;
            bytesInBroadcast: number;
            bytesOutBroadcast: number;
            packetsInDropped: number;
            packetsOutDropped: number;
            packetsInException: number;
            packetsOutException: number;
         }
         interface DistributedVirtualSwitchProductSpec extends srmService.vim.DynamicData {
            name?: string;
            vendor?: string;
            version?: string;
            build?: string;
            forwardingClass?: string;
            bundleId?: string;
            bundleUrl?: string;
         }
         interface ArrayOfDistributedVirtualSwitchProductSpec {
            distributedVirtualSwitchProductSpec?: Array<srmService.vim.DistributedVirtualSwitchProductSpec>;
         }
         interface DvsNetworkRuleQualifier extends srmService.vim.DynamicData {
            key?: string;
         }
         interface ArrayOfDvsNetworkRuleQualifier {
            dvsNetworkRuleQualifier?: Array<srmService.vim.DvsNetworkRuleQualifier>;
         }
         interface DvsNetworkRuleAction extends srmService.vim.DynamicData {
         }
         enum DvsNetworkRuleDirectionType {
            "incomingPackets",
            "outgoingPackets",
            "both",
         }
         interface DvsIpNetworkRuleQualifier extends srmService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: srmService.vim.IpAddress;
            destinationAddress?: srmService.vim.IpAddress;
            protocol?: srmService.vim.IntExpression;
            sourceIpPort?: srmService.vim.DvsIpPort;
            destinationIpPort?: srmService.vim.DvsIpPort;
            tcpFlags?: srmService.vim.IntExpression;
         }
         interface DvsIpPort extends srmService.vim.NegatableExpression {
         }
         interface DvsSingleIpPort extends srmService.vim.DvsIpPort {
            portNumber: number;
         }
         interface DvsIpPortRange extends srmService.vim.DvsIpPort {
            startPortNumber: number;
            endPortNumber: number;
         }
         interface DvsMacNetworkRuleQualifier extends srmService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: srmService.vim.MacAddress;
            destinationAddress?: srmService.vim.MacAddress;
            protocol?: srmService.vim.IntExpression;
            vlanId?: srmService.vim.IntExpression;
         }
         interface DvsSystemTrafficNetworkRuleQualifier extends srmService.vim.DvsNetworkRuleQualifier {
            typeOfSystemTraffic?: srmService.vim.StringExpression;
         }
         interface DvsDropNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
         }
         interface DvsAcceptNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
         }
         interface DvsUpdateTagNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
            qosTag?: number;
            dscpTag?: number;
         }
         interface DvsRateLimitNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
            packetsPerSecond: number;
         }
         interface DvsLogNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
         }
         interface DvsGreEncapNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
            encapsulationIp: srmService.vim.SingleIp;
         }
         interface DvsMacRewriteNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
            rewriteMac: string;
         }
         interface DvsPuntNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
         }
         interface DvsCopyNetworkRuleAction extends srmService.vim.DvsNetworkRuleAction {
         }
         interface DvsTrafficRule extends srmService.vim.DynamicData {
            key?: string;
            description?: string;
            sequence?: number;
            qualifier?: Array<srmService.vim.DvsNetworkRuleQualifier>;
            action?: srmService.vim.DvsNetworkRuleAction;
            direction?: string;
         }
         interface ArrayOfDvsTrafficRule {
            dvsTrafficRule?: Array<srmService.vim.DvsTrafficRule>;
         }
         interface DvsTrafficRuleset extends srmService.vim.DynamicData {
            key?: string;
            enabled?: boolean;
            precedence?: number;
            rules?: Array<srmService.vim.DvsTrafficRule>;
         }
         interface VMwareDVSFeatureCapability extends srmService.vim.DVSFeatureCapability {
            vspanSupported?: boolean;
            lldpSupported?: boolean;
            ipfixSupported?: boolean;
            vspanCapability?: srmService.vim.VMwareDVSVspanCapability;
            lacpCapability?: srmService.vim.VMwareDvsLacpCapability;
         }
         interface VMwareDvsLacpCapability extends srmService.vim.DynamicData {
            lacpSupported?: boolean;
            multiLacpGroupSupported?: boolean;
         }
         interface VMwareDVSHealthCheckCapability extends srmService.vim.DVSHealthCheckCapability {
            vlanMtuSupported: boolean;
            teamingSupported: boolean;
         }
         interface VMwareDVSVspanCapability extends srmService.vim.DynamicData {
            mixedDestSupported: boolean;
            dvportSupported: boolean;
            remoteSourceSupported: boolean;
            remoteDestSupported: boolean;
            encapRemoteSourceSupported: boolean;
         }
         interface VMwareVspanPort extends srmService.vim.DynamicData {
            portKey?: Array<string>;
            uplinkPortName?: Array<string>;
            wildcardPortConnecteeType?: Array<string>;
            vlans?: Array<number>;
            ipAddress?: Array<string>;
         }
         interface VMwareVspanSession extends srmService.vim.DynamicData {
            key?: string;
            name?: string;
            description?: string;
            enabled: boolean;
            sourcePortTransmitted?: srmService.vim.VMwareVspanPort;
            sourcePortReceived?: srmService.vim.VMwareVspanPort;
            destinationPort?: srmService.vim.VMwareVspanPort;
            encapsulationVlanId?: number;
            stripOriginalVlan: boolean;
            mirroredPacketLength?: number;
            normalTrafficAllowed: boolean;
            sessionType?: string;
            samplingRate?: number;
         }
         interface ArrayOfVMwareVspanSession {
            vMwareVspanSession?: Array<srmService.vim.VMwareVspanSession>;
         }
         interface VMwareIpfixConfig extends srmService.vim.DynamicData {
            collectorIpAddress?: string;
            collectorPort?: number;
            activeFlowTimeout: number;
            idleFlowTimeout: number;
            samplingRate: number;
            internalFlowsOnly: boolean;
         }
         interface VMwareDVSConfigInfo extends srmService.vim.DVSConfigInfo {
            vspanSession?: Array<srmService.vim.VMwareVspanSession>;
            pvlanConfig?: Array<srmService.vim.VMwareDVSPvlanMapEntry>;
            maxMtu: number;
            linkDiscoveryProtocolConfig?: srmService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: srmService.vim.VMwareIpfixConfig;
            lacpGroupConfig?: Array<srmService.vim.VMwareDvsLacpGroupConfig>;
            lacpApiVersion?: string;
         }
         interface VMwareDVSConfigSpec extends srmService.vim.DVSConfigSpec {
            pvlanConfigSpec?: Array<srmService.vim.VMwareDVSPvlanConfigSpec>;
            vspanConfigSpec?: Array<srmService.vim.VMwareDVSVspanConfigSpec>;
            maxMtu?: number;
            linkDiscoveryProtocolConfig?: srmService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: srmService.vim.VMwareIpfixConfig;
            lacpApiVersion?: string;
         }
         interface VMwareUplinkPortOrderPolicy extends srmService.vim.InheritablePolicy {
            activeUplinkPort?: Array<string>;
            standbyUplinkPort?: Array<string>;
         }
         interface DVSFailureCriteria extends srmService.vim.InheritablePolicy {
            checkSpeed?: srmService.vim.StringPolicy;
            speed?: srmService.vim.IntPolicy;
            checkDuplex?: srmService.vim.BoolPolicy;
            fullDuplex?: srmService.vim.BoolPolicy;
            checkErrorPercent?: srmService.vim.BoolPolicy;
            percentage?: srmService.vim.IntPolicy;
            checkBeacon?: srmService.vim.BoolPolicy;
         }
         interface VmwareUplinkPortTeamingPolicy extends srmService.vim.InheritablePolicy {
            policy?: srmService.vim.StringPolicy;
            reversePolicy?: srmService.vim.BoolPolicy;
            notifySwitches?: srmService.vim.BoolPolicy;
            rollingOrder?: srmService.vim.BoolPolicy;
            failureCriteria?: srmService.vim.DVSFailureCriteria;
            uplinkPortOrder?: srmService.vim.VMwareUplinkPortOrderPolicy;
         }
         interface VmwareDistributedVirtualSwitchVlanSpec extends srmService.vim.InheritablePolicy {
         }
         interface VmwareDistributedVirtualSwitchPvlanSpec extends srmService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            pvlanId: number;
         }
         interface VmwareDistributedVirtualSwitchVlanIdSpec extends srmService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: number;
         }
         interface VmwareDistributedVirtualSwitchTrunkVlanSpec extends srmService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: Array<srmService.vim.NumericRange>;
         }
         interface DVSSecurityPolicy extends srmService.vim.InheritablePolicy {
            allowPromiscuous?: srmService.vim.BoolPolicy;
            macChanges?: srmService.vim.BoolPolicy;
            forgedTransmits?: srmService.vim.BoolPolicy;
         }
         interface VMwareDVSPortSetting extends srmService.vim.DVPortSetting {
            vlan?: srmService.vim.VmwareDistributedVirtualSwitchVlanSpec;
            qosTag?: srmService.vim.IntPolicy;
            uplinkTeamingPolicy?: srmService.vim.VmwareUplinkPortTeamingPolicy;
            securityPolicy?: srmService.vim.DVSSecurityPolicy;
            ipfixEnabled?: srmService.vim.BoolPolicy;
            txUplink?: srmService.vim.BoolPolicy;
            lacpPolicy?: srmService.vim.VMwareUplinkLacpPolicy;
         }
         interface VMwareDVSPortgroupPolicy extends srmService.vim.DVPortgroupPolicy {
            vlanOverrideAllowed: boolean;
            uplinkTeamingOverrideAllowed: boolean;
            securityPolicyOverrideAllowed: boolean;
            ipfixOverrideAllowed?: boolean;
         }
         enum VmwareDistributedVirtualSwitchPvlanPortType {
            "promiscuous",
            "isolated",
            "community",
         }
         interface VMwareDVSPvlanConfigSpec extends srmService.vim.DynamicData {
            pvlanEntry: srmService.vim.VMwareDVSPvlanMapEntry;
            operation: string;
         }
         interface ArrayOfVMwareDVSPvlanConfigSpec {
            vMwareDVSPvlanConfigSpec?: Array<srmService.vim.VMwareDVSPvlanConfigSpec>;
         }
         interface VMwareDVSPvlanMapEntry extends srmService.vim.DynamicData {
            primaryVlanId: number;
            secondaryVlanId: number;
            pvlanType: string;
         }
         interface ArrayOfVMwareDVSPvlanMapEntry {
            vMwareDVSPvlanMapEntry?: Array<srmService.vim.VMwareDVSPvlanMapEntry>;
         }
         interface VMwareDVSVspanConfigSpec extends srmService.vim.DynamicData {
            vspanSession: srmService.vim.VMwareVspanSession;
            operation: string;
         }
         interface ArrayOfVMwareDVSVspanConfigSpec {
            vMwareDVSVspanConfigSpec?: Array<srmService.vim.VMwareDVSVspanConfigSpec>;
         }
         enum VMwareDVSVspanSessionType {
            "mixedDestMirror",
            "dvPortMirror",
            "remoteMirrorSource",
            "remoteMirrorDest",
            "encapsulatedRemoteMirrorSource",
         }
         interface VMwareDVSHealthCheckConfig extends srmService.vim.DVSHealthCheckConfig {
         }
         interface VMwareDVSVlanMtuHealthCheckConfig extends srmService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSTeamingHealthCheckConfig extends srmService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSVlanHealthCheckResult extends srmService.vim.HostMemberUplinkHealthCheckResult {
            trunkedVlan?: Array<srmService.vim.NumericRange>;
            untrunkedVlan?: Array<srmService.vim.NumericRange>;
         }
         interface VMwareDVSMtuHealthCheckResult extends srmService.vim.HostMemberUplinkHealthCheckResult {
            mtuMismatch: boolean;
            vlanSupportSwitchMtu?: Array<srmService.vim.NumericRange>;
            vlanNotSupportSwitchMtu?: Array<srmService.vim.NumericRange>;
         }
         enum VMwareDVSTeamingMatchStatus {
            "iphashMatch",
            "nonIphashMatch",
            "iphashMismatch",
            "nonIphashMismatch",
         }
         interface VMwareDVSTeamingHealthCheckResult extends srmService.vim.HostMemberHealthCheckResult {
            teamingStatus: string;
         }
         interface VMwareUplinkLacpPolicy extends srmService.vim.InheritablePolicy {
            enable?: srmService.vim.BoolPolicy;
            mode?: srmService.vim.StringPolicy;
         }
         interface VMwareDvsLacpGroupConfig extends srmService.vim.DynamicData {
            key?: string;
            name?: string;
            mode?: string;
            uplinkNum?: number;
            loadbalanceAlgorithm?: string;
            vlan?: srmService.vim.VMwareDvsLagVlanConfig;
            ipfix?: srmService.vim.VMwareDvsLagIpfixConfig;
            uplinkName?: Array<string>;
            uplinkPortKey?: Array<string>;
         }
         interface ArrayOfVMwareDvsLacpGroupConfig {
            vMwareDvsLacpGroupConfig?: Array<srmService.vim.VMwareDvsLacpGroupConfig>;
         }
         interface VMwareDvsLagVlanConfig extends srmService.vim.DynamicData {
            vlanId?: Array<srmService.vim.NumericRange>;
         }
         interface VMwareDvsLagIpfixConfig extends srmService.vim.DynamicData {
            ipfixEnabled?: boolean;
         }
         enum VMwareUplinkLacpMode {
            "active",
            "passive",
         }
         interface VMwareDvsLacpGroupSpec extends srmService.vim.DynamicData {
            lacpGroupConfig: srmService.vim.VMwareDvsLacpGroupConfig;
            operation: string;
         }
         interface ArrayOfVMwareDvsLacpGroupSpec {
            vMwareDvsLacpGroupSpec?: Array<srmService.vim.VMwareDvsLacpGroupSpec>;
         }
         enum VMwareDvsLacpLoadBalanceAlgorithm {
            "srcMac",
            "destMac",
            "srcDestMac",
            "destIpVlan",
            "srcIpVlan",
            "srcDestIpVlan",
            "destTcpUdpPort",
            "srcTcpUdpPort",
            "srcDestTcpUdpPort",
            "destIpTcpUdpPort",
            "srcIpTcpUdpPort",
            "srcDestIpTcpUdpPort",
            "destIpTcpUdpPortVlan",
            "srcIpTcpUdpPortVlan",
            "srcDestIpTcpUdpPortVlan",
            "destIp",
            "srcIp",
            "srcDestIp",
            "vlan",
            "srcPortId",
         }
         enum VMwareDvsLacpApiVersion {
            "singleLag",
            "multipleLag",
         }
         enum EventEventSeverity {
            "error",
            "warning",
            "info",
            "user",
         }
         interface Event extends srmService.vim.DynamicData {
            key: number;
            chainId: number;
            createdTime: Date;
            userName: string;
            datacenter?: srmService.vim.DatacenterEventArgument;
            computeResource?: srmService.vim.ComputeResourceEventArgument;
            host?: srmService.vim.HostEventArgument;
            vm?: srmService.vim.VmEventArgument;
            ds?: srmService.vim.DatastoreEventArgument;
            net?: srmService.vim.NetworkEventArgument;
            dvs?: srmService.vim.DvsEventArgument;
            fullFormattedMessage?: string;
            changeTag?: string;
         }
         interface ArrayOfEvent {
            event?: Array<srmService.vim.Event>;
         }
         interface GeneralEvent extends srmService.vim.Event {
            message: string;
         }
         interface GeneralHostInfoEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralHostWarningEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralHostErrorEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralVmInfoEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralVmWarningEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralVmErrorEvent extends srmService.vim.GeneralEvent {
         }
         interface GeneralUserEvent extends srmService.vim.GeneralEvent {
            entity?: srmService.vim.ManagedEntityEventArgument;
         }
         interface ExtendedEventPair extends srmService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfExtendedEventPair {
            extendedEventPair?: Array<srmService.vim.ExtendedEventPair>;
         }
         interface ExtendedEvent extends srmService.vim.GeneralEvent {
            eventTypeId: string;
            managedObject: srmService.vim.ManagedObjectReference;
            data?: Array<srmService.vim.ExtendedEventPair>;
         }
         interface HealthStatusChangedEvent extends srmService.vim.Event {
            componentId: string;
            oldStatus: string;
            newStatus: string;
            componentName: string;
         }
         interface HostInventoryUnreadableEvent extends srmService.vim.Event {
         }
         interface DatacenterEvent extends srmService.vim.Event {
         }
         interface DatacenterCreatedEvent extends srmService.vim.DatacenterEvent {
            parent: srmService.vim.FolderEventArgument;
         }
         interface DatacenterRenamedEvent extends srmService.vim.DatacenterEvent {
            oldName: string;
            newName: string;
         }
         interface SessionEvent extends srmService.vim.Event {
         }
         interface ServerStartedSessionEvent extends srmService.vim.SessionEvent {
         }
         interface UserLoginSessionEvent extends srmService.vim.SessionEvent {
            ipAddress: string;
            userAgent?: string;
            locale: string;
            sessionId: string;
         }
         interface UserLogoutSessionEvent extends srmService.vim.SessionEvent {
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
            sessionId?: string;
            loginTime?: Date;
         }
         interface BadUsernameSessionEvent extends srmService.vim.SessionEvent {
            ipAddress: string;
         }
         interface AlreadyAuthenticatedSessionEvent extends srmService.vim.SessionEvent {
         }
         interface NoAccessUserEvent extends srmService.vim.SessionEvent {
            ipAddress: string;
         }
         interface SessionTerminatedEvent extends srmService.vim.SessionEvent {
            sessionId: string;
            terminatedUsername: string;
         }
         interface GlobalMessageChangedEvent extends srmService.vim.SessionEvent {
            message: string;
         }
         interface UpgradeEvent extends srmService.vim.Event {
            message: string;
         }
         interface InfoUpgradeEvent extends srmService.vim.UpgradeEvent {
         }
         interface WarningUpgradeEvent extends srmService.vim.UpgradeEvent {
         }
         interface ErrorUpgradeEvent extends srmService.vim.UpgradeEvent {
         }
         interface UserUpgradeEvent extends srmService.vim.UpgradeEvent {
         }
         interface HostEvent extends srmService.vim.Event {
         }
         interface HostDasEvent extends srmService.vim.HostEvent {
         }
         interface HostConnectedEvent extends srmService.vim.HostEvent {
         }
         enum HostDisconnectedEventReasonCode {
            "sslThumbprintVerifyFailed",
            "licenseExpired",
            "agentUpgrade",
            "userRequest",
            "insufficientLicenses",
            "agentOutOfDate",
            "passwordDecryptFailure",
            "unknown",
            "vcVRAMCapacityExceeded",
         }
         interface HostDisconnectedEvent extends srmService.vim.HostEvent {
            reason?: string;
         }
         interface HostSyncFailedEvent extends srmService.vim.HostEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface HostConnectionLostEvent extends srmService.vim.HostEvent {
         }
         interface HostReconnectionFailedEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedNoConnectionEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedBadUsernameEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedBadVersionEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedAlreadyManagedEvent extends srmService.vim.HostEvent {
            serverName: string;
         }
         interface HostCnxFailedNoLicenseEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedNetworkErrorEvent extends srmService.vim.HostEvent {
         }
         interface HostRemovedEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedCcagentUpgradeEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedBadCcagentEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedAccountFailedEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedNoAccessEvent extends srmService.vim.HostEvent {
         }
         interface HostShutdownEvent extends srmService.vim.HostEvent {
            reason: string;
         }
         interface HostCnxFailedNotFoundEvent extends srmService.vim.HostEvent {
         }
         interface HostCnxFailedTimeoutEvent extends srmService.vim.HostEvent {
         }
         interface HostUpgradeFailedEvent extends srmService.vim.HostEvent {
         }
         interface EnteringMaintenanceModeEvent extends srmService.vim.HostEvent {
         }
         interface EnteredMaintenanceModeEvent extends srmService.vim.HostEvent {
         }
         interface ExitMaintenanceModeEvent extends srmService.vim.HostEvent {
         }
         interface CanceledHostOperationEvent extends srmService.vim.HostEvent {
         }
         interface TimedOutHostOperationEvent extends srmService.vim.HostEvent {
         }
         interface HostDasEnabledEvent extends srmService.vim.HostEvent {
         }
         interface HostDasDisabledEvent extends srmService.vim.HostEvent {
         }
         interface HostDasEnablingEvent extends srmService.vim.HostEvent {
         }
         interface HostDasDisablingEvent extends srmService.vim.HostEvent {
         }
         enum HostDasErrorEventHostDasErrorReason {
            "configFailed",
            "timeout",
            "communicationInitFailed",
            "healthCheckScriptFailed",
            "agentFailed",
            "agentShutdown",
            "isolationAddressUnpingable",
            "other",
         }
         interface HostDasErrorEvent extends srmService.vim.HostEvent {
            message?: string;
            reason?: string;
         }
         interface HostDasOkEvent extends srmService.vim.HostEvent {
         }
         interface VcAgentUpgradedEvent extends srmService.vim.HostEvent {
         }
         interface VcAgentUninstalledEvent extends srmService.vim.HostEvent {
         }
         interface VcAgentUpgradeFailedEvent extends srmService.vim.HostEvent {
            reason?: string;
         }
         interface VcAgentUninstallFailedEvent extends srmService.vim.HostEvent {
            reason?: string;
         }
         interface HostAddedEvent extends srmService.vim.HostEvent {
         }
         interface HostAddFailedEvent extends srmService.vim.HostEvent {
            hostname: string;
         }
         interface HostIpChangedEvent extends srmService.vim.HostEvent {
            oldIP: string;
            newIP: string;
         }
         interface EnteringStandbyModeEvent extends srmService.vim.HostEvent {
         }
         interface DrsEnteringStandbyModeEvent extends srmService.vim.EnteringStandbyModeEvent {
         }
         interface EnteredStandbyModeEvent extends srmService.vim.HostEvent {
         }
         interface DrsEnteredStandbyModeEvent extends srmService.vim.EnteredStandbyModeEvent {
         }
         interface ExitingStandbyModeEvent extends srmService.vim.HostEvent {
         }
         interface DrsExitingStandbyModeEvent extends srmService.vim.ExitingStandbyModeEvent {
         }
         interface ExitedStandbyModeEvent extends srmService.vim.HostEvent {
         }
         interface DrsExitedStandbyModeEvent extends srmService.vim.ExitedStandbyModeEvent {
         }
         interface ExitStandbyModeFailedEvent extends srmService.vim.HostEvent {
         }
         interface DrsExitStandbyModeFailedEvent extends srmService.vim.ExitStandbyModeFailedEvent {
         }
         interface UpdatedAgentBeingRestartedEvent extends srmService.vim.HostEvent {
         }
         interface AccountCreatedEvent extends srmService.vim.HostEvent {
            spec: srmService.vim.HostAccountSpec;
            group: boolean;
         }
         interface AccountRemovedEvent extends srmService.vim.HostEvent {
            account: string;
            group: boolean;
         }
         interface UserPasswordChanged extends srmService.vim.HostEvent {
            userLogin: string;
         }
         interface AccountUpdatedEvent extends srmService.vim.HostEvent {
            spec: srmService.vim.HostAccountSpec;
            group: boolean;
         }
         interface UserAssignedToGroup extends srmService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface UserUnassignedFromGroup extends srmService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface DatastorePrincipalConfigured extends srmService.vim.HostEvent {
            datastorePrincipal: string;
         }
         interface VMFSDatastoreCreatedEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface NASDatastoreCreatedEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface LocalDatastoreCreatedEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface VMFSDatastoreExtendedEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface VMFSDatastoreExpandedEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface DatastoreRemovedOnHostEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface DatastoreRenamedOnHostEvent extends srmService.vim.HostEvent {
            oldName: string;
            newName: string;
         }
         interface DuplicateIpDetectedEvent extends srmService.vim.HostEvent {
            duplicateIP: string;
            macAddress: string;
         }
         interface DatastoreDiscoveredEvent extends srmService.vim.HostEvent {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface DrsResourceConfigureFailedEvent extends srmService.vim.HostEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface DrsResourceConfigureSyncedEvent extends srmService.vim.HostEvent {
         }
         interface HostGetShortNameFailedEvent extends srmService.vim.HostEvent {
         }
         interface HostShortNameToIpFailedEvent extends srmService.vim.HostEvent {
            shortName: string;
         }
         interface HostIpToShortNameFailedEvent extends srmService.vim.HostEvent {
         }
         interface HostPrimaryAgentNotShortNameEvent extends srmService.vim.HostDasEvent {
            primaryAgent: string;
         }
         interface HostNotInClusterEvent extends srmService.vim.HostDasEvent {
         }
         interface HostIsolationIpPingFailedEvent extends srmService.vim.HostDasEvent {
            isolationIp: string;
         }
         interface HostIpInconsistentEvent extends srmService.vim.HostEvent {
            ipAddress: string;
            ipAddress2: string;
         }
         interface HostUserWorldSwapNotEnabledEvent extends srmService.vim.HostEvent {
         }
         interface HostNonCompliantEvent extends srmService.vim.HostEvent {
         }
         interface HostCompliantEvent extends srmService.vim.HostEvent {
         }
         interface HostComplianceCheckedEvent extends srmService.vim.HostEvent {
            profile: srmService.vim.ProfileEventArgument;
         }
         interface ClusterComplianceCheckedEvent extends srmService.vim.ClusterEvent {
            profile: srmService.vim.ProfileEventArgument;
         }
         interface ProfileEvent extends srmService.vim.Event {
            profile: srmService.vim.ProfileEventArgument;
         }
         interface ProfileCreatedEvent extends srmService.vim.ProfileEvent {
         }
         interface ProfileRemovedEvent extends srmService.vim.ProfileEvent {
         }
         interface ProfileAssociatedEvent extends srmService.vim.ProfileEvent {
         }
         interface ProfileDissociatedEvent extends srmService.vim.ProfileEvent {
         }
         interface HostConfigAppliedEvent extends srmService.vim.HostEvent {
         }
         interface ProfileReferenceHostChangedEvent extends srmService.vim.ProfileEvent {
            referenceHost?: srmService.vim.ManagedObjectReference;
         }
         interface ProfileChangedEvent extends srmService.vim.ProfileEvent {
         }
         interface HostProfileAppliedEvent extends srmService.vim.HostEvent {
            profile: srmService.vim.ProfileEventArgument;
         }
         interface HostShortNameInconsistentEvent extends srmService.vim.HostDasEvent {
            shortName: string;
            shortName2: string;
         }
         interface HostNoRedundantManagementNetworkEvent extends srmService.vim.HostDasEvent {
         }
         interface HostNoAvailableNetworksEvent extends srmService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostExtraNetworksEvent extends srmService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostNoHAEnabledPortGroupsEvent extends srmService.vim.HostDasEvent {
         }
         interface HostMissingNetworksEvent extends srmService.vim.HostDasEvent {
            ips?: string;
         }
         interface VnicPortArgument extends srmService.vim.DynamicData {
            vnic: string;
            port: srmService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface ArrayOfVnicPortArgument {
            vnicPortArgument?: Array<srmService.vim.VnicPortArgument>;
         }
         interface HostVnicConnectedToCustomizedDVPortEvent extends srmService.vim.HostEvent {
            vnic: srmService.vim.VnicPortArgument;
         }
         interface GhostDvsProxySwitchDetectedEvent extends srmService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface GhostDvsProxySwitchRemovedEvent extends srmService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface VmEvent extends srmService.vim.Event {
            template: boolean;
         }
         interface VmPoweredOffEvent extends srmService.vim.VmEvent {
         }
         interface VmPoweredOnEvent extends srmService.vim.VmEvent {
         }
         interface VmSuspendedEvent extends srmService.vim.VmEvent {
         }
         interface VmStartingEvent extends srmService.vim.VmEvent {
         }
         interface VmStoppingEvent extends srmService.vim.VmEvent {
         }
         interface VmSuspendingEvent extends srmService.vim.VmEvent {
         }
         interface VmResumingEvent extends srmService.vim.VmEvent {
         }
         interface VmDisconnectedEvent extends srmService.vim.VmEvent {
         }
         interface VmRemoteConsoleConnectedEvent extends srmService.vim.VmEvent {
         }
         interface VmRemoteConsoleDisconnectedEvent extends srmService.vim.VmEvent {
         }
         interface VmDiscoveredEvent extends srmService.vim.VmEvent {
         }
         interface VmOrphanedEvent extends srmService.vim.VmEvent {
         }
         interface VmBeingCreatedEvent extends srmService.vim.VmEvent {
            configSpec?: srmService.vim.VirtualMachineConfigSpec;
         }
         interface VmCreatedEvent extends srmService.vim.VmEvent {
         }
         interface VmStartRecordingEvent extends srmService.vim.VmEvent {
         }
         interface VmEndRecordingEvent extends srmService.vim.VmEvent {
         }
         interface VmStartReplayingEvent extends srmService.vim.VmEvent {
         }
         interface VmEndReplayingEvent extends srmService.vim.VmEvent {
         }
         interface VmRegisteredEvent extends srmService.vim.VmEvent {
         }
         interface VmAutoRenameEvent extends srmService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmBeingHotMigratedEvent extends srmService.vim.VmEvent {
            destHost: srmService.vim.HostEventArgument;
            destDatacenter?: srmService.vim.DatacenterEventArgument;
            destDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmResettingEvent extends srmService.vim.VmEvent {
         }
         interface VmStaticMacConflictEvent extends srmService.vim.VmEvent {
            conflictedVm: srmService.vim.VmEventArgument;
            mac: string;
         }
         interface VmMacConflictEvent extends srmService.vim.VmEvent {
            conflictedVm: srmService.vim.VmEventArgument;
            mac: string;
         }
         interface VmBeingDeployedEvent extends srmService.vim.VmEvent {
            srcTemplate: srmService.vim.VmEventArgument;
         }
         interface VmDeployFailedEvent extends srmService.vim.VmEvent {
            destDatastore: srmService.vim.EntityEventArgument;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmDeployedEvent extends srmService.vim.VmEvent {
            srcTemplate: srmService.vim.VmEventArgument;
         }
         interface VmMacChangedEvent extends srmService.vim.VmEvent {
            adapter: string;
            oldMac: string;
            newMac: string;
         }
         interface VmMacAssignedEvent extends srmService.vim.VmEvent {
            adapter: string;
            mac: string;
         }
         interface VmUuidConflictEvent extends srmService.vim.VmEvent {
            conflictedVm: srmService.vim.VmEventArgument;
            uuid: string;
         }
         interface VmInstanceUuidConflictEvent extends srmService.vim.VmEvent {
            conflictedVm: srmService.vim.VmEventArgument;
            instanceUuid: string;
         }
         interface VmBeingMigratedEvent extends srmService.vim.VmEvent {
            destHost: srmService.vim.HostEventArgument;
            destDatacenter?: srmService.vim.DatacenterEventArgument;
            destDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmFailedMigrateEvent extends srmService.vim.VmEvent {
            destHost: srmService.vim.HostEventArgument;
            reason: srmService.vim.LocalizedMethodFault;
            destDatacenter?: srmService.vim.DatacenterEventArgument;
            destDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmMigratedEvent extends srmService.vim.VmEvent {
            sourceHost: srmService.vim.HostEventArgument;
            sourceDatacenter?: srmService.vim.DatacenterEventArgument;
            sourceDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmUnsupportedStartingEvent extends srmService.vim.VmStartingEvent {
            guestId: string;
         }
         interface DrsVmMigratedEvent extends srmService.vim.VmMigratedEvent {
         }
         interface DrsVmPoweredOnEvent extends srmService.vim.VmPoweredOnEvent {
         }
         interface DrsRuleViolationEvent extends srmService.vim.VmEvent {
         }
         interface DrsRuleComplianceEvent extends srmService.vim.VmEvent {
         }
         interface VmRelocateSpecEvent extends srmService.vim.VmEvent {
         }
         interface VmBeingRelocatedEvent extends srmService.vim.VmRelocateSpecEvent {
            destHost: srmService.vim.HostEventArgument;
            destDatacenter?: srmService.vim.DatacenterEventArgument;
            destDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmRelocatedEvent extends srmService.vim.VmRelocateSpecEvent {
            sourceHost: srmService.vim.HostEventArgument;
            sourceDatacenter?: srmService.vim.DatacenterEventArgument;
            sourceDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmRelocateFailedEvent extends srmService.vim.VmRelocateSpecEvent {
            destHost: srmService.vim.HostEventArgument;
            reason: srmService.vim.LocalizedMethodFault;
            destDatacenter?: srmService.vim.DatacenterEventArgument;
            destDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface VmEmigratingEvent extends srmService.vim.VmEvent {
         }
         interface VmCloneEvent extends srmService.vim.VmEvent {
         }
         interface VmBeingClonedEvent extends srmService.vim.VmCloneEvent {
            destFolder: srmService.vim.FolderEventArgument;
            destName: string;
            destHost: srmService.vim.HostEventArgument;
         }
         interface VmBeingClonedNoFolderEvent extends srmService.vim.VmCloneEvent {
            destName: string;
            destHost: srmService.vim.HostEventArgument;
         }
         interface VmCloneFailedEvent extends srmService.vim.VmCloneEvent {
            destFolder: srmService.vim.FolderEventArgument;
            destName: string;
            destHost: srmService.vim.HostEventArgument;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmClonedEvent extends srmService.vim.VmCloneEvent {
            sourceVm: srmService.vim.VmEventArgument;
         }
         interface VmResourceReallocatedEvent extends srmService.vim.VmEvent {
         }
         interface VmRenamedEvent extends srmService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmDateRolledBackEvent extends srmService.vim.VmEvent {
         }
         interface VmNoNetworkAccessEvent extends srmService.vim.VmEvent {
            destHost: srmService.vim.HostEventArgument;
         }
         interface VmDiskFailedEvent extends srmService.vim.VmEvent {
            disk: string;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOnEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOffEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToSuspendEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToResetEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToShutdownGuestEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToRebootGuestEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmFailedToStandbyGuestEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmRemovedEvent extends srmService.vim.VmEvent {
         }
         interface VmGuestShutdownEvent extends srmService.vim.VmEvent {
         }
         interface VmGuestRebootEvent extends srmService.vim.VmEvent {
         }
         interface VmGuestStandbyEvent extends srmService.vim.VmEvent {
         }
         interface VmUpgradingEvent extends srmService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeCompleteEvent extends srmService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeFailedEvent extends srmService.vim.VmEvent {
         }
         interface VmRestartedOnAlternateHostEvent extends srmService.vim.VmPoweredOnEvent {
            sourceHost: srmService.vim.HostEventArgument;
         }
         interface VmReconfiguredEvent extends srmService.vim.VmEvent {
            configSpec: srmService.vim.VirtualMachineConfigSpec;
         }
         interface VmMessageEvent extends srmService.vim.VmEvent {
            message: string;
            messageInfo?: Array<srmService.vim.VirtualMachineMessage>;
         }
         interface VmMessageWarningEvent extends srmService.vim.VmEvent {
            message: string;
            messageInfo?: Array<srmService.vim.VirtualMachineMessage>;
         }
         interface VmMessageErrorEvent extends srmService.vim.VmEvent {
            message: string;
            messageInfo?: Array<srmService.vim.VirtualMachineMessage>;
         }
         interface VmConfigMissingEvent extends srmService.vim.VmEvent {
         }
         interface VmPowerOffOnIsolationEvent extends srmService.vim.VmPoweredOffEvent {
            isolatedHost: srmService.vim.HostEventArgument;
         }
         enum VmShutdownOnIsolationEventOperation {
            "shutdown",
            "poweredOff",
         }
         interface VmShutdownOnIsolationEvent extends srmService.vim.VmPoweredOffEvent {
            isolatedHost: srmService.vim.HostEventArgument;
            shutdownResult?: string;
         }
         interface VmFailoverFailed extends srmService.vim.VmEvent {
            reason?: srmService.vim.LocalizedMethodFault;
         }
         enum VmDasBeingResetEventReasonCode {
            "vmtoolsHeartbeatFailure",
            "appHeartbeatFailure",
            "appImmediateResetRequest",
         }
         interface VmDasBeingResetEvent extends srmService.vim.VmEvent {
            reason?: string;
         }
         interface VmDasResetFailedEvent extends srmService.vim.VmEvent {
         }
         interface VmMaxRestartCountReached extends srmService.vim.VmEvent {
         }
         interface VmMaxFTRestartCountReached extends srmService.vim.VmEvent {
         }
         interface VmDasBeingResetWithScreenshotEvent extends srmService.vim.VmDasBeingResetEvent {
            screenshotFilePath: string;
         }
         interface NotEnoughResourcesToStartVmEvent extends srmService.vim.VmEvent {
         }
         interface VmUuidAssignedEvent extends srmService.vim.VmEvent {
            uuid: string;
         }
         interface VmInstanceUuidAssignedEvent extends srmService.vim.VmEvent {
            instanceUuid: string;
         }
         interface VmUuidChangedEvent extends srmService.vim.VmEvent {
            oldUuid: string;
            newUuid: string;
         }
         interface VmInstanceUuidChangedEvent extends srmService.vim.VmEvent {
            oldInstanceUuid: string;
            newInstanceUuid: string;
         }
         interface VmWwnConflictEvent extends srmService.vim.VmEvent {
            conflictedVms?: Array<srmService.vim.VmEventArgument>;
            conflictedHosts?: Array<srmService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmAcquiredMksTicketEvent extends srmService.vim.VmEvent {
         }
         interface VmAcquiredTicketEvent extends srmService.vim.VmEvent {
            ticketType: string;
         }
         interface HostWwnConflictEvent extends srmService.vim.HostEvent {
            conflictedVms?: Array<srmService.vim.VmEventArgument>;
            conflictedHosts?: Array<srmService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmWwnAssignedEvent extends srmService.vim.VmEvent {
            nodeWwns: Array<number>;
            portWwns: Array<number>;
         }
         interface VmWwnChangedEvent extends srmService.vim.VmEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface VmSecondaryAddedEvent extends srmService.vim.VmEvent {
         }
         interface VmFaultToleranceTurnedOffEvent extends srmService.vim.VmEvent {
         }
         interface VmFaultToleranceStateChangedEvent extends srmService.vim.VmEvent {
            oldState: srmService.vim.VirtualMachineFaultToleranceState;
            newState: srmService.vim.VirtualMachineFaultToleranceState;
         }
         interface VmSecondaryDisabledEvent extends srmService.vim.VmEvent {
         }
         interface VmSecondaryDisabledBySystemEvent extends srmService.vim.VmEvent {
            reason?: srmService.vim.LocalizedMethodFault;
         }
         interface VmSecondaryEnabledEvent extends srmService.vim.VmEvent {
         }
         interface VmStartingSecondaryEvent extends srmService.vim.VmEvent {
         }
         interface VmSecondaryStartedEvent extends srmService.vim.VmEvent {
         }
         interface VmFailedUpdatingSecondaryConfig extends srmService.vim.VmEvent {
         }
         enum VmFailedStartingSecondaryEventFailureReason {
            "incompatibleHost",
            "loginFailed",
            "registerVmFailed",
            "migrateFailed",
         }
         interface VmFailedStartingSecondaryEvent extends srmService.vim.VmEvent {
            reason?: string;
         }
         interface VmTimedoutStartingSecondaryEvent extends srmService.vim.VmEvent {
            timeout?: number;
         }
         interface VmNoCompatibleHostForSecondaryEvent extends srmService.vim.VmEvent {
         }
         interface VmPrimaryFailoverEvent extends srmService.vim.VmEvent {
            reason?: string;
         }
         interface VmFaultToleranceVmTerminatedEvent extends srmService.vim.VmEvent {
            reason?: string;
         }
         interface HostWwnChangedEvent extends srmService.vim.HostEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface HostAdminDisableEvent extends srmService.vim.HostEvent {
         }
         interface HostAdminEnableEvent extends srmService.vim.HostEvent {
         }
         interface HostEnableAdminFailedEvent extends srmService.vim.HostEvent {
            permissions: Array<srmService.vim.Permission>;
         }
         interface VmFailedRelayoutOnVmfs2DatastoreEvent extends srmService.vim.VmEvent {
         }
         interface VmFailedRelayoutEvent extends srmService.vim.VmEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface VmRelayoutSuccessfulEvent extends srmService.vim.VmEvent {
         }
         interface VmRelayoutUpToDateEvent extends srmService.vim.VmEvent {
         }
         interface VmConnectedEvent extends srmService.vim.VmEvent {
         }
         interface VmPoweringOnWithCustomizedDVPortEvent extends srmService.vim.VmEvent {
            vnic: Array<srmService.vim.VnicPortArgument>;
         }
         interface VmDasUpdateErrorEvent extends srmService.vim.VmEvent {
         }
         interface NoMaintenanceModeDrsRecommendationForVM extends srmService.vim.VmEvent {
         }
         interface VmDasUpdateOkEvent extends srmService.vim.VmEvent {
         }
         interface ScheduledTaskEvent extends srmService.vim.Event {
            scheduledTask: srmService.vim.ScheduledTaskEventArgument;
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface ScheduledTaskCreatedEvent extends srmService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskStartedEvent extends srmService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskRemovedEvent extends srmService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskReconfiguredEvent extends srmService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskCompletedEvent extends srmService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskFailedEvent extends srmService.vim.ScheduledTaskEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface ScheduledTaskEmailCompletedEvent extends srmService.vim.ScheduledTaskEvent {
            to: string;
         }
         interface ScheduledTaskEmailFailedEvent extends srmService.vim.ScheduledTaskEvent {
            to: string;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface AlarmEvent extends srmService.vim.Event {
            alarm: srmService.vim.AlarmEventArgument;
         }
         interface AlarmCreatedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmStatusChangedEvent extends srmService.vim.AlarmEvent {
            source: srmService.vim.ManagedEntityEventArgument;
            entity: srmService.vim.ManagedEntityEventArgument;
            from: string;
            to: string;
         }
         interface AlarmActionTriggeredEvent extends srmService.vim.AlarmEvent {
            source: srmService.vim.ManagedEntityEventArgument;
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmEmailCompletedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            to: string;
         }
         interface AlarmEmailFailedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            to: string;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface AlarmSnmpCompletedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmSnmpFailedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface AlarmScriptCompleteEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            script: string;
         }
         interface AlarmScriptFailedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            script: string;
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface AlarmRemovedEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmReconfiguredEvent extends srmService.vim.AlarmEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmAcknowledgedEvent extends srmService.vim.AlarmEvent {
            source: srmService.vim.ManagedEntityEventArgument;
            entity: srmService.vim.ManagedEntityEventArgument;
         }
         interface AlarmClearedEvent extends srmService.vim.AlarmEvent {
            source: srmService.vim.ManagedEntityEventArgument;
            entity: srmService.vim.ManagedEntityEventArgument;
            from: string;
         }
         interface CustomFieldEvent extends srmService.vim.Event {
         }
         interface CustomFieldDefEvent extends srmService.vim.CustomFieldEvent {
            fieldKey: number;
            name: string;
         }
         interface CustomFieldDefAddedEvent extends srmService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRemovedEvent extends srmService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRenamedEvent extends srmService.vim.CustomFieldDefEvent {
            newName: string;
         }
         interface CustomFieldValueChangedEvent extends srmService.vim.CustomFieldEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            fieldKey: number;
            name: string;
            value: string;
         }
         interface AuthorizationEvent extends srmService.vim.Event {
         }
         interface PermissionEvent extends srmService.vim.AuthorizationEvent {
            entity: srmService.vim.ManagedEntityEventArgument;
            principal: string;
            group: boolean;
         }
         interface PermissionAddedEvent extends srmService.vim.PermissionEvent {
            role: srmService.vim.RoleEventArgument;
            propagate: boolean;
         }
         interface PermissionUpdatedEvent extends srmService.vim.PermissionEvent {
            role: srmService.vim.RoleEventArgument;
            propagate: boolean;
         }
         interface PermissionRemovedEvent extends srmService.vim.PermissionEvent {
         }
         interface RoleEvent extends srmService.vim.AuthorizationEvent {
            role: srmService.vim.RoleEventArgument;
         }
         interface RoleAddedEvent extends srmService.vim.RoleEvent {
            privilegeList?: Array<string>;
         }
         interface RoleUpdatedEvent extends srmService.vim.RoleEvent {
            privilegeList?: Array<string>;
         }
         interface RoleRemovedEvent extends srmService.vim.RoleEvent {
         }
         interface DatastoreEvent extends srmService.vim.Event {
            datastore?: srmService.vim.DatastoreEventArgument;
         }
         interface DatastoreDestroyedEvent extends srmService.vim.DatastoreEvent {
         }
         interface DatastoreRenamedEvent extends srmService.vim.DatastoreEvent {
            oldName: string;
            newName: string;
         }
         interface DatastoreCapacityIncreasedEvent extends srmService.vim.DatastoreEvent {
            oldCapacity: number;
            newCapacity: number;
         }
         interface DatastoreDuplicatedEvent extends srmService.vim.DatastoreEvent {
         }
         interface DatastoreFileEvent extends srmService.vim.DatastoreEvent {
            targetFile: string;
         }
         interface DatastoreFileCopiedEvent extends srmService.vim.DatastoreFileEvent {
            sourceDatastore: srmService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileMovedEvent extends srmService.vim.DatastoreFileEvent {
            sourceDatastore: srmService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileDeletedEvent extends srmService.vim.DatastoreFileEvent {
         }
         interface NonVIWorkloadDetectedOnDatastoreEvent extends srmService.vim.DatastoreEvent {
         }
         interface DatastoreIORMReconfiguredEvent extends srmService.vim.DatastoreEvent {
         }
         interface TaskEvent extends srmService.vim.Event {
            info: srmService.vim.TaskInfo;
         }
         interface TaskTimeoutEvent extends srmService.vim.TaskEvent {
         }
         interface LicenseEvent extends srmService.vim.Event {
         }
         interface ServerLicenseExpiredEvent extends srmService.vim.LicenseEvent {
            product: string;
         }
         interface HostLicenseExpiredEvent extends srmService.vim.LicenseEvent {
         }
         interface VMotionLicenseExpiredEvent extends srmService.vim.LicenseEvent {
         }
         interface NoLicenseEvent extends srmService.vim.LicenseEvent {
            feature: srmService.vim.LicenseFeatureInfo;
         }
         interface LicenseServerUnavailableEvent extends srmService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseServerAvailableEvent extends srmService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseExpiredEvent extends srmService.vim.Event {
            feature: srmService.vim.LicenseFeatureInfo;
         }
         interface InvalidEditionEvent extends srmService.vim.LicenseEvent {
            feature: string;
         }
         interface HostInventoryFullEvent extends srmService.vim.LicenseEvent {
            capacity: number;
         }
         interface LicenseRestrictedEvent extends srmService.vim.LicenseEvent {
         }
         interface IncorrectHostInformationEvent extends srmService.vim.LicenseEvent {
         }
         interface UnlicensedVirtualMachinesEvent extends srmService.vim.LicenseEvent {
            unlicensed: number;
            available: number;
         }
         interface UnlicensedVirtualMachinesFoundEvent extends srmService.vim.LicenseEvent {
            available: number;
         }
         interface AllVirtualMachinesLicensedEvent extends srmService.vim.LicenseEvent {
         }
         interface LicenseNonComplianceEvent extends srmService.vim.LicenseEvent {
            url: string;
         }
         interface MigrationEvent extends srmService.vim.VmEvent {
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface MigrationWarningEvent extends srmService.vim.MigrationEvent {
         }
         interface MigrationErrorEvent extends srmService.vim.MigrationEvent {
         }
         interface MigrationHostWarningEvent extends srmService.vim.MigrationEvent {
            dstHost: srmService.vim.HostEventArgument;
         }
         interface MigrationHostErrorEvent extends srmService.vim.MigrationEvent {
            dstHost: srmService.vim.HostEventArgument;
         }
         interface MigrationResourceWarningEvent extends srmService.vim.MigrationEvent {
            dstPool: srmService.vim.ResourcePoolEventArgument;
            dstHost: srmService.vim.HostEventArgument;
         }
         interface MigrationResourceErrorEvent extends srmService.vim.MigrationEvent {
            dstPool: srmService.vim.ResourcePoolEventArgument;
            dstHost: srmService.vim.HostEventArgument;
         }
         interface ClusterEvent extends srmService.vim.Event {
         }
         interface DasEnabledEvent extends srmService.vim.ClusterEvent {
         }
         interface DasDisabledEvent extends srmService.vim.ClusterEvent {
         }
         interface DasAdmissionControlDisabledEvent extends srmService.vim.ClusterEvent {
         }
         interface DasAdmissionControlEnabledEvent extends srmService.vim.ClusterEvent {
         }
         interface DasHostFailedEvent extends srmService.vim.ClusterEvent {
            failedHost: srmService.vim.HostEventArgument;
         }
         interface DasHostIsolatedEvent extends srmService.vim.ClusterEvent {
            isolatedHost: srmService.vim.HostEventArgument;
         }
         interface DasClusterIsolatedEvent extends srmService.vim.ClusterEvent {
         }
         interface DasAgentUnavailableEvent extends srmService.vim.ClusterEvent {
         }
         interface DasAgentFoundEvent extends srmService.vim.ClusterEvent {
         }
         interface InsufficientFailoverResourcesEvent extends srmService.vim.ClusterEvent {
         }
         interface FailoverLevelRestored extends srmService.vim.ClusterEvent {
         }
         interface ClusterOvercommittedEvent extends srmService.vim.ClusterEvent {
         }
         interface HostOvercommittedEvent extends srmService.vim.ClusterOvercommittedEvent {
         }
         interface ClusterStatusChangedEvent extends srmService.vim.ClusterEvent {
            oldStatus: string;
            newStatus: string;
         }
         interface HostStatusChangedEvent extends srmService.vim.ClusterStatusChangedEvent {
         }
         interface ClusterCreatedEvent extends srmService.vim.ClusterEvent {
            parent: srmService.vim.FolderEventArgument;
         }
         interface ClusterDestroyedEvent extends srmService.vim.ClusterEvent {
         }
         interface DrsEnabledEvent extends srmService.vim.ClusterEvent {
            behavior: string;
         }
         interface DrsDisabledEvent extends srmService.vim.ClusterEvent {
         }
         interface ClusterReconfiguredEvent extends srmService.vim.ClusterEvent {
         }
         interface HostMonitoringStateChangedEvent extends srmService.vim.ClusterEvent {
            state: string;
         }
         interface VmHealthMonitoringStateChangedEvent extends srmService.vim.ClusterEvent {
            state: string;
         }
         interface ResourcePoolEvent extends srmService.vim.Event {
            resourcePool: srmService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolCreatedEvent extends srmService.vim.ResourcePoolEvent {
            parent: srmService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolDestroyedEvent extends srmService.vim.ResourcePoolEvent {
         }
         interface ResourcePoolMovedEvent extends srmService.vim.ResourcePoolEvent {
            oldParent: srmService.vim.ResourcePoolEventArgument;
            newParent: srmService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolReconfiguredEvent extends srmService.vim.ResourcePoolEvent {
         }
         interface ResourceViolatedEvent extends srmService.vim.ResourcePoolEvent {
         }
         interface VmResourcePoolMovedEvent extends srmService.vim.VmEvent {
            oldParent: srmService.vim.ResourcePoolEventArgument;
            newParent: srmService.vim.ResourcePoolEventArgument;
         }
         interface TemplateUpgradeEvent extends srmService.vim.Event {
            legacyTemplate: string;
         }
         interface TemplateBeingUpgradedEvent extends srmService.vim.TemplateUpgradeEvent {
         }
         interface TemplateUpgradeFailedEvent extends srmService.vim.TemplateUpgradeEvent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface TemplateUpgradedEvent extends srmService.vim.TemplateUpgradeEvent {
         }
         interface CustomizationEvent extends srmService.vim.VmEvent {
            logLocation?: string;
         }
         interface CustomizationStartedEvent extends srmService.vim.CustomizationEvent {
         }
         interface CustomizationSucceeded extends srmService.vim.CustomizationEvent {
         }
         interface CustomizationFailed extends srmService.vim.CustomizationEvent {
         }
         interface CustomizationUnknownFailure extends srmService.vim.CustomizationFailed {
         }
         interface CustomizationSysprepFailed extends srmService.vim.CustomizationFailed {
            sysprepVersion: string;
            systemVersion: string;
         }
         interface CustomizationLinuxIdentityFailed extends srmService.vim.CustomizationFailed {
         }
         interface CustomizationNetworkSetupFailed extends srmService.vim.CustomizationFailed {
         }
         interface LockerMisconfiguredEvent extends srmService.vim.Event {
            datastore: srmService.vim.DatastoreEventArgument;
         }
         interface LockerReconfiguredEvent extends srmService.vim.Event {
            oldDatastore?: srmService.vim.DatastoreEventArgument;
            newDatastore?: srmService.vim.DatastoreEventArgument;
         }
         interface NoDatastoresConfiguredEvent extends srmService.vim.HostEvent {
         }
         interface AdminPasswordNotChangedEvent extends srmService.vim.HostEvent {
         }
         interface HostInAuditModeEvent extends srmService.vim.HostEvent {
         }
         interface LocalTSMEnabledEvent extends srmService.vim.HostEvent {
         }
         interface RemoteTSMEnabledEvent extends srmService.vim.HostEvent {
         }
         interface VimAccountPasswordChangedEvent extends srmService.vim.HostEvent {
         }
         interface IScsiBootFailureEvent extends srmService.vim.HostEvent {
         }
         interface DvsHealthStatusChangeEvent extends srmService.vim.HostEvent {
            switchUuid: string;
            healthResult?: srmService.vim.HostMemberHealthCheckResult;
         }
         interface NetworkRollbackEvent extends srmService.vim.Event {
            methodName: string;
            transactionId: string;
         }
         interface UplinkPortVlanTrunkedEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortVlanUntrunkedEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMatchEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMismatchEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuNotSupportEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuSupportEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMatchEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMisMatchEvent extends srmService.vim.DvsHealthStatusChangeEvent {
         }
         interface DvsEvent extends srmService.vim.Event {
         }
         interface DvsCreatedEvent extends srmService.vim.DvsEvent {
            parent: srmService.vim.FolderEventArgument;
         }
         interface DvsRenamedEvent extends srmService.vim.DvsEvent {
            oldName: string;
            newName: string;
         }
         interface DvsReconfiguredEvent extends srmService.vim.DvsEvent {
            configSpec: srmService.vim.DVSConfigSpec;
         }
         interface DvsUpgradeAvailableEvent extends srmService.vim.DvsEvent {
            productInfo: srmService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeInProgressEvent extends srmService.vim.DvsEvent {
            productInfo: srmService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeRejectedEvent extends srmService.vim.DvsEvent {
            productInfo: srmService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradedEvent extends srmService.vim.DvsEvent {
            productInfo: srmService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsHostJoinedEvent extends srmService.vim.DvsEvent {
            hostJoined: srmService.vim.HostEventArgument;
         }
         interface DvsHostLeftEvent extends srmService.vim.DvsEvent {
            hostLeft: srmService.vim.HostEventArgument;
         }
         interface DvsOutOfSyncHostArgument extends srmService.vim.DynamicData {
            outOfSyncHost: srmService.vim.HostEventArgument;
            configParamters: Array<string>;
         }
         interface ArrayOfDvsOutOfSyncHostArgument {
            dvsOutOfSyncHostArgument?: Array<srmService.vim.DvsOutOfSyncHostArgument>;
         }
         interface OutOfSyncDvsHost extends srmService.vim.DvsEvent {
            hostOutOfSync: Array<srmService.vim.DvsOutOfSyncHostArgument>;
         }
         interface DvsHostWentOutOfSyncEvent extends srmService.vim.DvsEvent {
            hostOutOfSync: srmService.vim.DvsOutOfSyncHostArgument;
         }
         interface DvsHostBackInSyncEvent extends srmService.vim.DvsEvent {
            hostBackInSync: srmService.vim.HostEventArgument;
         }
         interface DvsHostStatusUpdated extends srmService.vim.DvsEvent {
            hostMember: srmService.vim.HostEventArgument;
            oldStatus?: string;
            newStatus?: string;
            oldStatusDetail?: string;
            newStatusDetail?: string;
         }
         interface DvsPortCreatedEvent extends srmService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortReconfiguredEvent extends srmService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortDeletedEvent extends srmService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortConnectedEvent extends srmService.vim.DvsEvent {
            portKey: string;
            connectee?: srmService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortDisconnectedEvent extends srmService.vim.DvsEvent {
            portKey: string;
            connectee?: srmService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortVendorSpecificStateChangeEvent extends srmService.vim.DvsEvent {
            portKey: string;
         }
         interface DvsPortRuntimeChangeEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo: srmService.vim.DVPortStatus;
         }
         interface DvsPortLinkUpEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsPortLinkDownEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsPortJoinPortgroupEvent extends srmService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortLeavePortgroupEvent extends srmService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortBlockedEvent extends srmService.vim.DvsEvent {
            portKey: string;
            statusDetail?: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsPortUnblockedEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsPortEnteredPassthruEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsPortExitedPassthruEvent extends srmService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: srmService.vim.DVPortStatus;
         }
         interface DvsDestroyedEvent extends srmService.vim.DvsEvent {
         }
         interface DvsMergedEvent extends srmService.vim.DvsEvent {
            sourceDvs: srmService.vim.DvsEventArgument;
            destinationDvs: srmService.vim.DvsEventArgument;
         }
         interface HostLocalPortCreatedEvent extends srmService.vim.DvsEvent {
            hostLocalPort: srmService.vim.DVSHostLocalPortInfo;
         }
         interface RollbackEvent extends srmService.vim.DvsEvent {
            hostName: string;
            methodName?: string;
         }
         interface RecoveryEvent extends srmService.vim.DvsEvent {
            hostName: string;
            portKey: string;
            dvsUuid?: string;
            vnic?: string;
         }
         interface DvsImportEvent extends srmService.vim.DvsEvent {
            importType: string;
         }
         interface DvsRestoreEvent extends srmService.vim.DvsEvent {
         }
         interface DVPortgroupEvent extends srmService.vim.Event {
         }
         interface DVPortgroupCreatedEvent extends srmService.vim.DVPortgroupEvent {
         }
         interface DVPortgroupRenamedEvent extends srmService.vim.DVPortgroupEvent {
            oldName: string;
            newName: string;
         }
         interface DVPortgroupReconfiguredEvent extends srmService.vim.DVPortgroupEvent {
            configSpec: srmService.vim.DVPortgroupConfigSpec;
         }
         interface DVPortgroupDestroyedEvent extends srmService.vim.DVPortgroupEvent {
         }
         interface DvpgImportEvent extends srmService.vim.DVPortgroupEvent {
            importType: string;
         }
         interface DvpgRestoreEvent extends srmService.vim.DVPortgroupEvent {
         }
         interface DrsInvocationFailedEvent extends srmService.vim.ClusterEvent {
         }
         interface DrsRecoveredFromFailureEvent extends srmService.vim.ClusterEvent {
         }
         interface VmReloadFromPathEvent extends srmService.vim.VmEvent {
            configPath: string;
         }
         interface VmReloadFromPathFailedEvent extends srmService.vim.VmEvent {
            configPath: string;
         }
         interface VmRequirementsExceedCurrentEVCModeEvent extends srmService.vim.VmEvent {
         }
         interface EventArgument extends srmService.vim.DynamicData {
         }
         interface RoleEventArgument extends srmService.vim.EventArgument {
            roleId: number;
            name: string;
         }
         interface EntityEventArgument extends srmService.vim.EventArgument {
            name: string;
         }
         interface ManagedEntityEventArgument extends srmService.vim.EntityEventArgument {
            entity: srmService.vim.ManagedObjectReference;
         }
         interface FolderEventArgument extends srmService.vim.EntityEventArgument {
            folder: srmService.vim.ManagedObjectReference;
         }
         interface DatacenterEventArgument extends srmService.vim.EntityEventArgument {
            datacenter: srmService.vim.ManagedObjectReference;
         }
         interface ComputeResourceEventArgument extends srmService.vim.EntityEventArgument {
            computeResource: srmService.vim.ManagedObjectReference;
         }
         interface ResourcePoolEventArgument extends srmService.vim.EntityEventArgument {
            resourcePool: srmService.vim.ManagedObjectReference;
         }
         interface HostEventArgument extends srmService.vim.EntityEventArgument {
            host: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfHostEventArgument {
            hostEventArgument?: Array<srmService.vim.HostEventArgument>;
         }
         interface VmEventArgument extends srmService.vim.EntityEventArgument {
            vm: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfVmEventArgument {
            vmEventArgument?: Array<srmService.vim.VmEventArgument>;
         }
         interface DatastoreEventArgument extends srmService.vim.EntityEventArgument {
            datastore: srmService.vim.ManagedObjectReference;
         }
         interface NetworkEventArgument extends srmService.vim.EntityEventArgument {
            network: srmService.vim.ManagedObjectReference;
         }
         interface AlarmEventArgument extends srmService.vim.EntityEventArgument {
            alarm: srmService.vim.ManagedObjectReference;
         }
         interface ScheduledTaskEventArgument extends srmService.vim.EntityEventArgument {
            scheduledTask: srmService.vim.ManagedObjectReference;
         }
         interface ProfileEventArgument extends srmService.vim.EventArgument {
            profile: srmService.vim.ManagedObjectReference;
            name: string;
         }
         interface DvsEventArgument extends srmService.vim.EntityEventArgument {
            dvs: srmService.vim.ManagedObjectReference;
         }
         enum EventCategory {
            "info",
            "warning",
            "error",
            "user",
         }
         interface EventArgDesc extends srmService.vim.DynamicData {
            name: string;
            type: string;
            description?: srmService.vim.ElementDescription;
         }
         interface ArrayOfEventArgDesc {
            eventArgDesc?: Array<srmService.vim.EventArgDesc>;
         }
         interface EventDescriptionEventDetail extends srmService.vim.DynamicData {
            key: string;
            description?: string;
            category: string;
            formatOnDatacenter: string;
            formatOnComputeResource: string;
            formatOnHost: string;
            formatOnVm: string;
            fullFormat: string;
            longDescription?: string;
         }
         interface ArrayOfEventDescriptionEventDetail {
            eventDescriptionEventDetail?: Array<srmService.vim.EventDescriptionEventDetail>;
         }
         interface EventDescription extends srmService.vim.DynamicData {
            category: Array<srmService.vim.ElementDescription>;
            eventInfo: Array<srmService.vim.EventDescriptionEventDetail>;
            enumeratedTypes?: Array<srmService.vim.EnumDescription>;
         }
         interface EventEx extends srmService.vim.Event {
            eventTypeId: string;
            severity?: string;
            message?: string;
            arguments?: Array<srmService.vim.KeyAnyValue>;
            objectId?: string;
            objectType?: string;
            objectName?: string;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         enum EventFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         interface EventFilterSpecByEntity extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            recursion: srmService.vim.EventFilterSpecRecursionOption;
         }
         interface EventFilterSpecByTime extends srmService.vim.DynamicData {
            beginTime?: Date;
            endTime?: Date;
         }
         interface EventFilterSpecByUsername extends srmService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface EventFilterSpec extends srmService.vim.DynamicData {
            entity?: srmService.vim.EventFilterSpecByEntity;
            time?: srmService.vim.EventFilterSpecByTime;
            userName?: srmService.vim.EventFilterSpecByUsername;
            eventChainId?: number;
            alarm?: srmService.vim.ManagedObjectReference;
            scheduledTask?: srmService.vim.ManagedObjectReference;
            disableFullMessage?: boolean;
            category?: Array<string>;
            type?: Array<string>;
            tag?: Array<string>;
            eventTypeId?: Array<string>;
         }
         interface ExtExtendedProductInfo extends srmService.vim.DynamicData {
            companyUrl?: string;
            productUrl?: string;
            managementUrl?: string;
            self?: srmService.vim.ManagedObjectReference;
         }
         interface ManagedByInfo extends srmService.vim.DynamicData {
            extensionKey: string;
            type: string;
         }
         interface ExtManagedEntityInfo extends srmService.vim.DynamicData {
            type: string;
            smallIconUrl?: string;
            iconUrl?: string;
            description?: string;
         }
         interface ArrayOfExtManagedEntityInfo {
            extManagedEntityInfo?: Array<srmService.vim.ExtManagedEntityInfo>;
         }
         interface ExtSolutionManagerInfoTabInfo extends srmService.vim.DynamicData {
            label: string;
            url: string;
         }
         interface ArrayOfExtSolutionManagerInfoTabInfo {
            extSolutionManagerInfoTabInfo?: Array<srmService.vim.ExtSolutionManagerInfoTabInfo>;
         }
         interface ExtSolutionManagerInfo extends srmService.vim.DynamicData {
            tab?: Array<srmService.vim.ExtSolutionManagerInfoTabInfo>;
            smallIconUrl?: string;
         }
         interface ActiveDirectoryFault extends srmService.vim.VimFault {
            errorCode?: number;
         }
         interface AdminDisabled extends srmService.vim.HostConfigFault {
         }
         interface AdminNotDisabled extends srmService.vim.HostConfigFault {
         }
         enum AffinityType {
            "memory",
            "cpu",
         }
         interface AffinityConfigured extends srmService.vim.MigrationFault {
            configuredAffinity: Array<string>;
         }
         enum AgentInstallFailedReason {
            "NotEnoughSpaceOnDevice",
            "PrepareToUpgradeFailed",
            "AgentNotRunning",
            "AgentNotReachable",
            "InstallTimedout",
            "SignatureVerificationFailed",
            "AgentUploadFailed",
            "AgentUploadTimedout",
            "UnknownInstallerError",
         }
         interface AgentInstallFailed extends srmService.vim.HostConnectFault {
            reason?: string;
            statusCode?: number;
            installerOutput?: string;
         }
         interface AlreadyBeingManaged extends srmService.vim.HostConnectFault {
            ipAddress: string;
         }
         interface AlreadyConnected extends srmService.vim.HostConnectFault {
            name: string;
         }
         interface AlreadyExists extends srmService.vim.VimFault {
            name?: string;
         }
         interface AlreadyUpgraded extends srmService.vim.VimFault {
         }
         interface AnswerFileUpdateFailure extends srmService.vim.DynamicData {
            userInputPath: srmService.vim.ProfilePropertyPath;
            errMsg: srmService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileUpdateFailure {
            answerFileUpdateFailure?: Array<srmService.vim.AnswerFileUpdateFailure>;
         }
         interface AnswerFileUpdateFailed extends srmService.vim.VimFault {
            failure: Array<srmService.vim.AnswerFileUpdateFailure>;
         }
         interface ApplicationQuiesceFault extends srmService.vim.SnapshotFault {
         }
         interface AuthMinimumAdminPermission extends srmService.vim.VimFault {
         }
         interface BackupBlobReadFailure extends srmService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface BackupBlobWriteFailure extends srmService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface BlockedByFirewall extends srmService.vim.HostConfigFault {
         }
         interface CAMServerRefusedConnection extends srmService.vim.InvalidCAMServer {
         }
         interface CannotAccessFile extends srmService.vim.FileFault {
         }
         interface CannotAccessLocalSource extends srmService.vim.VimFault {
         }
         interface CannotAccessNetwork extends srmService.vim.CannotAccessVmDevice {
         }
         interface CannotAccessVmComponent extends srmService.vim.VmConfigFault {
         }
         interface CannotAccessVmConfig extends srmService.vim.CannotAccessVmComponent {
            reason: srmService.vim.LocalizedMethodFault;
         }
         interface CannotAccessVmDevice extends srmService.vim.CannotAccessVmComponent {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface CannotAccessVmDisk extends srmService.vim.CannotAccessVmDevice {
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface CannotAddHostWithFTVmAsStandalone extends srmService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToDifferentCluster extends srmService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToNonHACluster extends srmService.vim.HostConnectFault {
         }
         interface CannotChangeDrsBehaviorForFtSecondary extends srmService.vim.VmFaultToleranceIssue {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeHaSettingsForFtSecondary extends srmService.vim.VmFaultToleranceIssue {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeVsanClusterUuid extends srmService.vim.VsanFault {
         }
         interface CannotChangeVsanNodeUuid extends srmService.vim.VsanFault {
         }
         interface CannotCreateFile extends srmService.vim.FileFault {
         }
         interface CannotDecryptPasswords extends srmService.vim.CustomizationFault {
         }
         interface CannotDeleteFile extends srmService.vim.FileFault {
         }
         interface CannotDisableDrsOnClustersWithVApps extends srmService.vim.RuntimeFault {
         }
         interface CannotDisableSnapshot extends srmService.vim.VmConfigFault {
         }
         interface CannotDisconnectHostWithFaultToleranceVm extends srmService.vim.VimFault {
            hostName: string;
         }
         interface CannotModifyConfigCpuRequirements extends srmService.vim.MigrationFault {
         }
         enum CannotMoveFaultToleranceVmMoveType {
            "resourcePool",
            "cluster",
         }
         interface CannotMoveFaultToleranceVm extends srmService.vim.VimFault {
            moveType: string;
            vmName: string;
         }
         interface CannotMoveHostWithFaultToleranceVm extends srmService.vim.VimFault {
         }
         interface CannotMoveVmWithDeltaDisk extends srmService.vim.MigrationFault {
            device: string;
         }
         interface CannotMoveVmWithNativeDeltaDisk extends srmService.vim.MigrationFault {
         }
         interface CannotMoveVsanEnabledHost extends srmService.vim.VsanFault {
         }
         interface CannotPlaceWithoutPrerequisiteMoves extends srmService.vim.VimFault {
         }
         enum CannotPowerOffVmInClusterOperation {
            "suspend",
            "powerOff",
            "guestShutdown",
            "guestSuspend",
         }
         interface CannotPowerOffVmInCluster extends srmService.vim.InvalidState {
            operation: string;
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotReconfigureVsanWhenHaEnabled extends srmService.vim.VsanFault {
         }
         enum CannotUseNetworkReason {
            "NetworkReservationNotSupported",
            "MismatchedNetworkPolicies",
            "MismatchedDvsVersionOrVendor",
            "VMotionToUnsupportedNetworkType",
         }
         interface CannotUseNetwork extends srmService.vim.VmConfigFault {
            device: string;
            backing: string;
            connected: boolean;
            reason: string;
         }
         interface ClockSkew extends srmService.vim.HostConfigFault {
         }
         interface CloneFromSnapshotNotSupported extends srmService.vim.MigrationFault {
         }
         interface CollectorAddressUnset extends srmService.vim.DvsFault {
         }
         interface ConcurrentAccess extends srmService.vim.VimFault {
         }
         interface ConflictingConfigurationConfig extends srmService.vim.DynamicData {
            entity?: srmService.vim.ManagedObjectReference;
            propertyPath: string;
         }
         interface ArrayOfConflictingConfigurationConfig {
            conflictingConfigurationConfig?: Array<srmService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingConfiguration extends srmService.vim.DvsFault {
            configInConflict: Array<srmService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingDatastoreFound extends srmService.vim.RuntimeFault {
            name: string;
            url: string;
         }
         interface ConnectedIso extends srmService.vim.OvfExport {
            cdrom: srmService.vim.VirtualCdrom;
            filename: string;
         }
         interface CpuCompatibilityUnknown extends srmService.vim.CpuIncompatible {
         }
         interface CpuHotPlugNotSupported extends srmService.vim.VmConfigFault {
         }
         interface CpuIncompatible extends srmService.vim.VirtualHardwareCompatibilityIssue {
            level: number;
            registerName: string;
            registerBits?: string;
            desiredBits?: string;
            host?: srmService.vim.ManagedObjectReference;
         }
         interface CpuIncompatible1ECX extends srmService.vim.CpuIncompatible {
            sse3: boolean;
            pclmulqdq?: boolean;
            ssse3: boolean;
            sse41: boolean;
            sse42: boolean;
            aes?: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CpuIncompatible81EDX extends srmService.vim.CpuIncompatible {
            nx: boolean;
            ffxsr: boolean;
            rdtscp: boolean;
            lm: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CustomizationFault extends srmService.vim.VimFault {
         }
         interface CustomizationPending extends srmService.vim.CustomizationFault {
         }
         interface DVPortNotSupported extends srmService.vim.DeviceBackingNotSupported {
         }
         enum DasConfigFaultDasConfigFaultReason {
            "HostNetworkMisconfiguration",
            "HostMisconfiguration",
            "InsufficientPrivileges",
            "NoPrimaryAgentAvailable",
            "Other",
            "NoDatastoresConfigured",
            "VSanNotSupportedOnHost",
         }
         interface DasConfigFault extends srmService.vim.VimFault {
            reason?: string;
            output?: string;
            event?: Array<srmService.vim.Event>;
         }
         interface DatabaseError extends srmService.vim.RuntimeFault {
         }
         interface DatacenterMismatchArgument extends srmService.vim.DynamicData {
            entity: srmService.vim.ManagedObjectReference;
            inputDatacenter?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatacenterMismatchArgument {
            datacenterMismatchArgument?: Array<srmService.vim.DatacenterMismatchArgument>;
         }
         interface DatacenterMismatch extends srmService.vim.MigrationFault {
            invalidArgument: Array<srmService.vim.DatacenterMismatchArgument>;
            expectedDatacenter: srmService.vim.ManagedObjectReference;
         }
         interface DatastoreNotWritableOnHost extends srmService.vim.InvalidDatastore {
            host: srmService.vim.ManagedObjectReference;
         }
         interface DeltaDiskFormatNotSupported extends srmService.vim.VmConfigFault {
            datastore?: Array<srmService.vim.ManagedObjectReference>;
            deltaDiskFormat: string;
         }
         interface DestinationSwitchFull extends srmService.vim.CannotAccessNetwork {
         }
         interface DestinationVsanDisabled extends srmService.vim.CannotMoveVsanEnabledHost {
            destinationCluster: string;
         }
         interface DeviceBackingNotSupported extends srmService.vim.DeviceNotSupported {
            backing: string;
         }
         interface DeviceControllerNotSupported extends srmService.vim.DeviceNotSupported {
            controller: string;
         }
         interface DeviceHotPlugNotSupported extends srmService.vim.InvalidDeviceSpec {
         }
         interface DeviceNotFound extends srmService.vim.InvalidDeviceSpec {
         }
         enum DeviceNotSupportedReason {
            "host",
            "guest",
         }
         interface DeviceNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            device: string;
            reason?: string;
         }
         interface DeviceUnsupportedForVmPlatform extends srmService.vim.InvalidDeviceSpec {
         }
         interface DeviceUnsupportedForVmVersion extends srmService.vim.InvalidDeviceSpec {
            currentVersion: string;
            expectedVersion: string;
         }
         interface DirectoryNotEmpty extends srmService.vim.FileFault {
         }
         interface DisableAdminNotSupported extends srmService.vim.HostConfigFault {
         }
         enum DisallowedChangeByServiceDisallowedChange {
            "hotExtendDisk",
         }
         interface DisallowedChangeByService extends srmService.vim.RuntimeFault {
            serviceName: string;
            disallowedChange?: string;
         }
         interface DisallowedDiskModeChange extends srmService.vim.InvalidDeviceSpec {
         }
         interface DisallowedMigrationDeviceAttached extends srmService.vim.MigrationFault {
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface DisallowedOperationOnFailoverHost extends srmService.vim.RuntimeFault {
            host: srmService.vim.ManagedObjectReference;
            hostname: string;
         }
         interface DiskHasPartitions extends srmService.vim.VsanDiskFault {
         }
         interface DiskIsLastRemainingNonSSD extends srmService.vim.VsanDiskFault {
         }
         interface DiskIsNonLocal extends srmService.vim.VsanDiskFault {
         }
         interface DiskIsUSB extends srmService.vim.VsanDiskFault {
         }
         interface DiskMoveTypeNotSupported extends srmService.vim.MigrationFault {
         }
         interface DiskNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            disk: number;
         }
         interface DiskTooSmall extends srmService.vim.VsanDiskFault {
         }
         interface DomainNotFound extends srmService.vim.ActiveDirectoryFault {
            domainName: string;
         }
         interface DrsDisabledOnVm extends srmService.vim.VimFault {
         }
         interface DrsVmotionIncompatibleFault extends srmService.vim.VirtualHardwareCompatibilityIssue {
            host: srmService.vim.ManagedObjectReference;
         }
         interface DuplicateDisks extends srmService.vim.VsanDiskFault {
         }
         interface DuplicateName extends srmService.vim.VimFault {
            name: string;
            object: srmService.vim.ManagedObjectReference;
         }
         interface DuplicateVsanNetworkInterface extends srmService.vim.VsanFault {
            device: string;
         }
         interface DvsApplyOperationFaultFaultOnObject extends srmService.vim.DynamicData {
            objectId: string;
            type: string;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsApplyOperationFaultFaultOnObject {
            dvsApplyOperationFaultFaultOnObject?: Array<srmService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsApplyOperationFault extends srmService.vim.DvsFault {
            objectFault: Array<srmService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsFault extends srmService.vim.VimFault {
         }
         interface DvsNotAuthorized extends srmService.vim.DvsFault {
            sessionExtensionKey?: string;
            dvsExtensionKey?: string;
         }
         interface DvsOperationBulkFaultFaultOnHost extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsOperationBulkFaultFaultOnHost {
            dvsOperationBulkFaultFaultOnHost?: Array<srmService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsOperationBulkFault extends srmService.vim.DvsFault {
            hostFault: Array<srmService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsScopeViolated extends srmService.vim.DvsFault {
            scope: Array<srmService.vim.ManagedObjectReference>;
            entity: srmService.vim.ManagedObjectReference;
         }
         interface EVCAdmissionFailed extends srmService.vim.NotSupportedHostInCluster {
            faults?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface EVCAdmissionFailedCPUFeaturesForMode extends srmService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUModel extends srmService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedCPUModelForMode extends srmService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUVendor extends srmService.vim.EVCAdmissionFailed {
            clusterCPUVendor: string;
            hostCPUVendor: string;
         }
         interface EVCAdmissionFailedCPUVendorUnknown extends srmService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostDisconnected extends srmService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftware extends srmService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftwareForMode extends srmService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedVmActive extends srmService.vim.EVCAdmissionFailed {
         }
         interface EightHostLimitViolated extends srmService.vim.VmConfigFault {
         }
         interface ExpiredAddonLicense extends srmService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredEditionLicense extends srmService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredFeatureLicense extends srmService.vim.NotEnoughLicenses {
            feature: string;
            count: number;
            expirationDate: Date;
         }
         interface ExtendedFault extends srmService.vim.VimFault {
            faultTypeId: string;
            data?: Array<srmService.vim.KeyValue>;
         }
         interface FailToEnableSPBM extends srmService.vim.NotEnoughLicenses {
            cs: srmService.vim.ManagedObjectReference;
            csName: string;
            hostLicenseStates: Array<srmService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface FailToLockFaultToleranceVMs extends srmService.vim.RuntimeFault {
            vmName: string;
            vm: srmService.vim.ManagedObjectReference;
            alreadyLockedVm: srmService.vim.ManagedObjectReference;
         }
         interface FaultToleranceAntiAffinityViolated extends srmService.vim.MigrationFault {
            hostName: string;
            host: srmService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCannotEditMem extends srmService.vim.VmConfigFault {
            vmName: string;
            vm: srmService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCpuIncompatible extends srmService.vim.CpuIncompatible {
            model: boolean;
            family: boolean;
            stepping: boolean;
         }
         interface FaultToleranceNeedsThickDisk extends srmService.vim.MigrationFault {
            vmName: string;
         }
         interface FaultToleranceNotLicensed extends srmService.vim.VmFaultToleranceIssue {
            hostName?: string;
         }
         interface FaultToleranceNotSameBuild extends srmService.vim.MigrationFault {
            build: string;
         }
         interface FaultTolerancePrimaryPowerOnNotAttempted extends srmService.vim.VmFaultToleranceIssue {
            secondaryVm: srmService.vim.ManagedObjectReference;
            primaryVm: srmService.vim.ManagedObjectReference;
         }
         interface FaultToleranceVmNotDasProtected extends srmService.vim.VimFault {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface FcoeFault extends srmService.vim.VimFault {
         }
         interface FcoeFaultPnicHasNoPortSet extends srmService.vim.FcoeFault {
            nicDevice: string;
         }
         interface FeatureRequirementsNotMet extends srmService.vim.VirtualHardwareCompatibilityIssue {
            featureRequirement?: Array<srmService.vim.VirtualMachineFeatureRequirement>;
            vm?: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
         }
         interface FileAlreadyExists extends srmService.vim.FileFault {
         }
         interface FileBackedPortNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface FileFault extends srmService.vim.VimFault {
            file: string;
         }
         interface FileLocked extends srmService.vim.FileFault {
         }
         interface FileNameTooLong extends srmService.vim.FileFault {
         }
         interface FileNotFound extends srmService.vim.FileFault {
         }
         interface FileNotWritable extends srmService.vim.FileFault {
         }
         interface FileTooLarge extends srmService.vim.FileFault {
            datastore: string;
            fileSize: number;
            maxFileSize?: number;
         }
         interface FilesystemQuiesceFault extends srmService.vim.SnapshotFault {
         }
         enum FtIssuesOnHostHostSelectionType {
            "user",
            "vc",
            "drs",
         }
         interface FtIssuesOnHost extends srmService.vim.VmFaultToleranceIssue {
            host: srmService.vim.ManagedObjectReference;
            hostName: string;
            errors?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface FullStorageVMotionNotSupported extends srmService.vim.MigrationFeatureNotSupported {
         }
         interface GenericDrsFault extends srmService.vim.VimFault {
            hostFaults?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface GenericVmConfigFault extends srmService.vim.VmConfigFault {
            reason: string;
         }
         interface GuestAuthenticationChallenge extends srmService.vim.GuestOperationsFault {
            serverChallenge: srmService.vim.GuestAuthentication;
            sessionID: number;
         }
         interface GuestComponentsOutOfDate extends srmService.vim.GuestOperationsFault {
         }
         interface GuestOperationsFault extends srmService.vim.VimFault {
         }
         interface GuestOperationsUnavailable extends srmService.vim.GuestOperationsFault {
         }
         interface GuestPermissionDenied extends srmService.vim.GuestOperationsFault {
         }
         interface GuestProcessNotFound extends srmService.vim.GuestOperationsFault {
            pid: number;
         }
         interface HAErrorsAtDest extends srmService.vim.MigrationFault {
         }
         interface HostAccessRestrictedToManagementServer extends srmService.vim.NotSupported {
            managementServer: string;
         }
         interface HostConfigFailed extends srmService.vim.HostConfigFault {
            failure: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface HostConfigFault extends srmService.vim.VimFault {
         }
         interface HostConnectFault extends srmService.vim.VimFault {
         }
         interface HostInDomain extends srmService.vim.HostConfigFault {
         }
         enum HostIncompatibleForFaultToleranceReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForFaultTolerance extends srmService.vim.VmFaultToleranceIssue {
            hostName?: string;
            reason?: string;
         }
         enum HostIncompatibleForRecordReplayReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForRecordReplay extends srmService.vim.VimFault {
            hostName?: string;
            reason?: string;
         }
         interface HostInventoryFull extends srmService.vim.NotEnoughLicenses {
            capacity: number;
         }
         interface HostPowerOpFailed extends srmService.vim.VimFault {
         }
         interface HotSnapshotMoveNotSupported extends srmService.vim.SnapshotCopyNotSupported {
         }
         interface IDEDiskNotSupported extends srmService.vim.DiskNotSupported {
         }
         interface IORMNotSupportedHostOnDatastore extends srmService.vim.VimFault {
            datastore: srmService.vim.ManagedObjectReference;
            datastoreName: string;
            host?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ImportHostAddFailure extends srmService.vim.DvsFault {
            hostIp: Array<string>;
         }
         interface ImportOperationBulkFaultFaultOnImport extends srmService.vim.DynamicData {
            entityType?: string;
            key?: string;
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfImportOperationBulkFaultFaultOnImport {
            importOperationBulkFaultFaultOnImport?: Array<srmService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface ImportOperationBulkFault extends srmService.vim.DvsFault {
            importFaults: Array<srmService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface InUseFeatureManipulationDisallowed extends srmService.vim.NotEnoughLicenses {
         }
         interface InaccessibleDatastore extends srmService.vim.InvalidDatastore {
            detail?: string;
         }
         interface InaccessibleVFlashSource extends srmService.vim.VimFault {
            hostName: string;
         }
         interface IncompatibleDefaultDevice extends srmService.vim.MigrationFault {
            device: string;
         }
         interface IncompatibleHostForFtSecondary extends srmService.vim.VmFaultToleranceIssue {
            host: srmService.vim.ManagedObjectReference;
            error?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface IncompatibleSetting extends srmService.vim.InvalidArgument {
            conflictingProperty: string;
         }
         interface IncorrectFileType extends srmService.vim.FileFault {
         }
         interface IncorrectHostInformation extends srmService.vim.NotEnoughLicenses {
         }
         interface IndependentDiskVMotionNotSupported extends srmService.vim.MigrationFeatureNotSupported {
         }
         interface InsufficientAgentVmsDeployed extends srmService.vim.InsufficientResourcesFault {
            hostName: string;
            requiredNumAgentVms: number;
            currentNumAgentVms: number;
         }
         interface InsufficientCpuResourcesFault extends srmService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientDisks extends srmService.vim.VsanDiskFault {
         }
         interface InsufficientFailoverResourcesFault extends srmService.vim.InsufficientResourcesFault {
         }
         interface InsufficientHostCapacityFault extends srmService.vim.InsufficientResourcesFault {
            host?: srmService.vim.ManagedObjectReference;
         }
         interface InsufficientHostCpuCapacityFault extends srmService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientHostMemoryCapacityFault extends srmService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientMemoryResourcesFault extends srmService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientPerCpuCapacity extends srmService.vim.InsufficientHostCapacityFault {
         }
         interface InsufficientResourcesFault extends srmService.vim.VimFault {
         }
         interface InsufficientStandbyCpuResource extends srmService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyMemoryResource extends srmService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyResource extends srmService.vim.InsufficientResourcesFault {
         }
         interface InsufficientStorageSpace extends srmService.vim.InsufficientResourcesFault {
         }
         interface InsufficientVFlashResourcesFault extends srmService.vim.InsufficientResourcesFault {
            freeSpace: number;
            requestedSpace: number;
         }
         interface InvalidAffinitySettingFault extends srmService.vim.VimFault {
         }
         interface InvalidBmcRole extends srmService.vim.VimFault {
         }
         interface InvalidBundle extends srmService.vim.PlatformConfigFault {
         }
         interface InvalidCAMCertificate extends srmService.vim.InvalidCAMServer {
         }
         interface InvalidCAMServer extends srmService.vim.ActiveDirectoryFault {
            camServer: string;
         }
         interface InvalidClientCertificate extends srmService.vim.InvalidLogin {
         }
         interface InvalidController extends srmService.vim.InvalidDeviceSpec {
            controllerKey: number;
         }
         enum InvalidDasConfigArgumentEntryForInvalidArgument {
            "admissionControl",
            "userHeartbeatDs",
            "vmConfig",
         }
         interface InvalidDasConfigArgument extends srmService.vim.InvalidArgument {
            entry?: string;
            clusterName?: string;
         }
         interface InvalidDasRestartPriorityForFtVm extends srmService.vim.InvalidArgument {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidDatastore extends srmService.vim.VimFault {
            datastore?: srmService.vim.ManagedObjectReference;
            name?: string;
         }
         interface InvalidDatastorePath extends srmService.vim.InvalidDatastore {
            datastorePath: string;
         }
         interface InvalidDatastoreState extends srmService.vim.InvalidState {
            datastoreName?: string;
         }
         interface InvalidDeviceBacking extends srmService.vim.InvalidDeviceSpec {
         }
         interface InvalidDeviceOperation extends srmService.vim.InvalidDeviceSpec {
            badOp?: srmService.vim.VirtualDeviceConfigSpecOperation;
            badFileOp?: srmService.vim.VirtualDeviceConfigSpecFileOperation;
         }
         interface InvalidDeviceSpec extends srmService.vim.InvalidVmConfig {
            deviceIndex: number;
         }
         interface InvalidDiskFormat extends srmService.vim.InvalidFormat {
         }
         interface InvalidDrsBehaviorForFtVm extends srmService.vim.InvalidArgument {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidEditionLicense extends srmService.vim.NotEnoughLicenses {
            feature: string;
         }
         interface InvalidEvent extends srmService.vim.VimFault {
         }
         interface InvalidFolder extends srmService.vim.VimFault {
            target: srmService.vim.ManagedObjectReference;
         }
         interface InvalidFormat extends srmService.vim.VmConfigFault {
         }
         interface InvalidGuestLogin extends srmService.vim.GuestOperationsFault {
         }
         interface InvalidHostConnectionState extends srmService.vim.InvalidHostState {
         }
         interface InvalidHostName extends srmService.vim.HostConfigFault {
         }
         interface InvalidHostState extends srmService.vim.InvalidState {
            host?: srmService.vim.ManagedObjectReference;
         }
         interface InvalidIndexArgument extends srmService.vim.InvalidArgument {
            key: string;
         }
         interface InvalidIpfixConfig extends srmService.vim.DvsFault {
            property?: string;
         }
         interface InvalidIpmiLoginInfo extends srmService.vim.VimFault {
         }
         interface InvalidIpmiMacAddress extends srmService.vim.VimFault {
            userProvidedMacAddress: string;
            observedMacAddress: string;
         }
         interface InvalidLicense extends srmService.vim.VimFault {
            licenseContent: string;
         }
         interface InvalidLocale extends srmService.vim.VimFault {
         }
         interface InvalidLogin extends srmService.vim.VimFault {
         }
         interface InvalidName extends srmService.vim.VimFault {
            name: string;
            entity?: srmService.vim.ManagedObjectReference;
         }
         interface InvalidNasCredentials extends srmService.vim.NasConfigFault {
            userName: string;
         }
         interface InvalidNetworkInType extends srmService.vim.VAppPropertyFault {
         }
         interface InvalidNetworkResource extends srmService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface InvalidOperationOnSecondaryVm extends srmService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface InvalidPowerState extends srmService.vim.InvalidState {
            requestedState?: srmService.vim.VirtualMachinePowerState;
            existingState: srmService.vim.VirtualMachinePowerState;
         }
         interface InvalidPrivilege extends srmService.vim.VimFault {
            privilege: string;
         }
         enum InvalidProfileReferenceHostReason {
            "incompatibleVersion",
            "missingReferenceHost",
         }
         interface InvalidProfileReferenceHost extends srmService.vim.RuntimeFault {
            reason?: string;
            host?: srmService.vim.ManagedObjectReference;
            profile?: srmService.vim.ManagedObjectReference;
         }
         interface InvalidPropertyType extends srmService.vim.VAppPropertyFault {
         }
         interface InvalidPropertyValue extends srmService.vim.VAppPropertyFault {
         }
         interface InvalidResourcePoolStructureFault extends srmService.vim.InsufficientResourcesFault {
         }
         interface InvalidSnapshotFormat extends srmService.vim.InvalidFormat {
         }
         interface InvalidState extends srmService.vim.VimFault {
         }
         interface InvalidVmConfig extends srmService.vim.VmConfigFault {
            property?: string;
         }
         interface InventoryHasStandardAloneHosts extends srmService.vim.NotEnoughLicenses {
            hosts: Array<string>;
         }
         interface IpHostnameGeneratorError extends srmService.vim.CustomizationFault {
         }
         interface IscsiFault extends srmService.vim.VimFault {
         }
         interface IscsiFaultInvalidVnic extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultPnicInUse extends srmService.vim.IscsiFault {
            pnicDevice: string;
         }
         interface IscsiFaultVnicAlreadyBound extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasActivePaths extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasMultipleUplinks extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasNoUplinks extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasWrongUplink extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicInUse extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicIsLastPath extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotBound extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotFound extends srmService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface LargeRDMConversionNotSupported extends srmService.vim.MigrationFault {
            device: string;
         }
         interface LargeRDMNotSupportedOnDatastore extends srmService.vim.VmConfigFault {
            device: string;
            datastore: srmService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface LegacyNetworkInterfaceInUse extends srmService.vim.CannotAccessNetwork {
         }
         enum LicenseAssignmentFailedReason {
            "keyEntityMismatch",
            "downgradeDisallowed",
            "inventoryNotManageableByVirtualCenter",
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer",
         }
         interface LicenseAssignmentFailed extends srmService.vim.RuntimeFault {
            reason?: string;
         }
         interface LicenseDowngradeDisallowed extends srmService.vim.NotEnoughLicenses {
            edition: string;
            entityId: string;
            features: Array<srmService.vim.KeyAnyValue>;
         }
         interface LicenseEntityNotFound extends srmService.vim.VimFault {
            entityId: string;
         }
         interface LicenseExpired extends srmService.vim.NotEnoughLicenses {
            licenseKey: string;
         }
         interface LicenseKeyEntityMismatch extends srmService.vim.NotEnoughLicenses {
         }
         interface LicenseRestricted extends srmService.vim.NotEnoughLicenses {
         }
         interface LicenseServerUnavailable extends srmService.vim.VimFault {
            licenseServer: string;
         }
         interface LicenseSourceUnavailable extends srmService.vim.NotEnoughLicenses {
            licenseSource: srmService.vim.LicenseSource;
         }
         interface LimitExceeded extends srmService.vim.VimFault {
            property?: string;
            limit?: number;
         }
         interface LinuxVolumeNotClean extends srmService.vim.CustomizationFault {
         }
         interface LogBundlingFailed extends srmService.vim.VimFault {
         }
         interface MaintenanceModeFileMove extends srmService.vim.MigrationFault {
         }
         interface MemoryHotPlugNotSupported extends srmService.vim.VmConfigFault {
         }
         interface MemorySizeNotRecommended extends srmService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupportedByDatastore extends srmService.vim.VirtualHardwareCompatibilityIssue {
            datastore: srmService.vim.ManagedObjectReference;
            memorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySnapshotOnIndependentDisk extends srmService.vim.SnapshotFault {
         }
         interface MethodAlreadyDisabledFault extends srmService.vim.RuntimeFault {
            sourceId: string;
         }
         interface MethodDisabled extends srmService.vim.RuntimeFault {
            source?: string;
         }
         interface MigrationDisabled extends srmService.vim.MigrationFault {
         }
         interface MigrationFault extends srmService.vim.VimFault {
         }
         interface MigrationFeatureNotSupported extends srmService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHostName: string;
            failedHost: srmService.vim.ManagedObjectReference;
         }
         interface MigrationNotReady extends srmService.vim.MigrationFault {
            reason: string;
         }
         interface MismatchedBundle extends srmService.vim.VimFault {
            bundleUuid: string;
            hostUuid: string;
            bundleBuildNumber: number;
            hostBuildNumber: number;
         }
         interface MismatchedNetworkPolicies extends srmService.vim.MigrationFault {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface MismatchedVMotionNetworkNames extends srmService.vim.MigrationFault {
            sourceNetwork: string;
            destNetwork: string;
         }
         interface MissingBmcSupport extends srmService.vim.VimFault {
         }
         interface MissingController extends srmService.vim.InvalidDeviceSpec {
         }
         interface MissingIpPool extends srmService.vim.VAppPropertyFault {
         }
         interface MissingLinuxCustResources extends srmService.vim.CustomizationFault {
         }
         interface MissingNetworkIpConfig extends srmService.vim.VAppPropertyFault {
         }
         interface MissingPowerOffConfiguration extends srmService.vim.VAppConfigFault {
         }
         interface MissingPowerOnConfiguration extends srmService.vim.VAppConfigFault {
         }
         interface MissingWindowsCustResources extends srmService.vim.CustomizationFault {
         }
         interface MksConnectionLimitReached extends srmService.vim.InvalidState {
            connectionLimit: number;
         }
         interface MountError extends srmService.vim.CustomizationFault {
            vm: srmService.vim.ManagedObjectReference;
            diskIndex: number;
         }
         interface MultipleCertificatesVerifyFaultThumbprintData extends srmService.vim.DynamicData {
            port: number;
            thumbprint: string;
         }
         interface ArrayOfMultipleCertificatesVerifyFaultThumbprintData {
            multipleCertificatesVerifyFaultThumbprintData?: Array<srmService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleCertificatesVerifyFault extends srmService.vim.HostConnectFault {
            thumbprintData: Array<srmService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleSnapshotsNotSupported extends srmService.vim.SnapshotFault {
         }
         interface NamespaceFull extends srmService.vim.VimFault {
            name: string;
            currentMaxSize: number;
            requiredSize?: number;
         }
         interface NamespaceLimitReached extends srmService.vim.VimFault {
            limit?: number;
         }
         interface NamespaceWriteProtected extends srmService.vim.VimFault {
            name: string;
         }
         interface NasConfigFault extends srmService.vim.HostConfigFault {
            name: string;
         }
         interface NasConnectionLimitReached extends srmService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NasSessionCredentialConflict extends srmService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
            userName: string;
         }
         interface NasVolumeNotMounted extends srmService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NetworkCopyFault extends srmService.vim.FileFault {
         }
         interface NetworkDisruptedAndConfigRolledBack extends srmService.vim.VimFault {
            host: string;
         }
         interface NetworkInaccessible extends srmService.vim.NasConfigFault {
         }
         interface NetworksMayNotBeTheSame extends srmService.vim.MigrationFault {
            name?: string;
         }
         interface NicSettingMismatch extends srmService.vim.CustomizationFault {
            numberOfNicsInSpec: number;
            numberOfNicsInVM: number;
         }
         interface NoActiveHostInCluster extends srmService.vim.InvalidState {
            computeResource: srmService.vim.ManagedObjectReference;
         }
         interface NoAvailableIp extends srmService.vim.VAppPropertyFault {
            network: srmService.vim.ManagedObjectReference;
         }
         interface NoClientCertificate extends srmService.vim.VimFault {
         }
         interface NoCompatibleDatastore extends srmService.vim.VimFault {
         }
         interface NoCompatibleHardAffinityHost extends srmService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoCompatibleHost extends srmService.vim.VimFault {
            host?: Array<srmService.vim.ManagedObjectReference>;
            error?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface NoCompatibleHostWithAccessToDevice extends srmService.vim.NoCompatibleHost {
         }
         interface NoCompatibleSoftAffinityHost extends srmService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoConnectedDatastore extends srmService.vim.VimFault {
         }
         interface NoDiskFound extends srmService.vim.VimFault {
         }
         interface NoDiskSpace extends srmService.vim.FileFault {
            datastore: string;
         }
         interface NoDisksToCustomize extends srmService.vim.CustomizationFault {
         }
         interface NoGateway extends srmService.vim.HostConfigFault {
         }
         interface NoGuestHeartbeat extends srmService.vim.MigrationFault {
         }
         interface NoHost extends srmService.vim.HostConnectFault {
            name?: string;
         }
         interface NoHostSuitableForFtSecondary extends srmService.vim.VmFaultToleranceIssue {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface NoLicenseServerConfigured extends srmService.vim.NotEnoughLicenses {
         }
         interface NoPeerHostFound extends srmService.vim.HostPowerOpFailed {
         }
         interface NoPermission extends srmService.vim.SecurityError {
            object: srmService.vim.ManagedObjectReference;
            privilegeId: string;
         }
         interface NoPermissionOnAD extends srmService.vim.ActiveDirectoryFault {
         }
         interface NoPermissionOnHost extends srmService.vim.HostConnectFault {
         }
         interface NoPermissionOnNasVolume extends srmService.vim.NasConfigFault {
            userName?: string;
         }
         interface NoSubjectName extends srmService.vim.VimFault {
         }
         interface NoVcManagedIpConfigured extends srmService.vim.VAppPropertyFault {
         }
         interface NoVirtualNic extends srmService.vim.HostConfigFault {
         }
         interface NoVmInVApp extends srmService.vim.VAppConfigFault {
         }
         interface NonADUserRequired extends srmService.vim.ActiveDirectoryFault {
         }
         interface NonHomeRDMVMotionNotSupported extends srmService.vim.MigrationFeatureNotSupported {
            device: string;
         }
         interface NonPersistentDisksNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface NonVmwareOuiMacNotSupportedHost extends srmService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotADirectory extends srmService.vim.FileFault {
         }
         interface NotAFile extends srmService.vim.FileFault {
         }
         interface NotAuthenticated extends srmService.vim.NoPermission {
         }
         interface NotEnoughCpus extends srmService.vim.VirtualHardwareCompatibilityIssue {
            numCpuDest: number;
            numCpuVm: number;
         }
         interface NotEnoughLogicalCpus extends srmService.vim.NotEnoughCpus {
            host?: srmService.vim.ManagedObjectReference;
         }
         interface NotFound extends srmService.vim.VimFault {
         }
         enum NotSupportedDeviceForFTDeviceType {
            "virtualVmxnet3",
            "paraVirtualSCSIController",
         }
         interface NotSupportedDeviceForFT extends srmService.vim.VmFaultToleranceIssue {
            host: srmService.vim.ManagedObjectReference;
            hostName?: string;
            vm: srmService.vim.ManagedObjectReference;
            vmName?: string;
            deviceType: string;
            deviceLabel?: string;
         }
         interface NotSupportedHost extends srmService.vim.HostConnectFault {
            productName?: string;
            productVersion?: string;
         }
         interface NotSupportedHostForVFlash extends srmService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVsan extends srmService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostInCluster extends srmService.vim.NotSupportedHost {
         }
         interface NotSupportedHostInDvs extends srmService.vim.NotSupportedHost {
            switchProductSpec: srmService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface NotSupportedHostInHACluster extends srmService.vim.NotSupportedHost {
            hostName: string;
            build: string;
         }
         interface NotUserConfigurableProperty extends srmService.vim.VAppPropertyFault {
         }
         interface NumVirtualCoresPerSocketNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedCoresPerSocketDest: number;
            numCoresPerSocketVm: number;
         }
         interface NumVirtualCpusExceedsLimit extends srmService.vim.InsufficientResourcesFault {
            maxSupportedVcpus: number;
         }
         enum NumVirtualCpusIncompatibleReason {
            "recordReplay",
            "faultTolerance",
         }
         interface NumVirtualCpusIncompatible extends srmService.vim.VmConfigFault {
            reason: string;
            numCpu: number;
         }
         interface NumVirtualCpusNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedVcpusDest: number;
            numCpuVm: number;
         }
         interface OperationDisabledByGuest extends srmService.vim.GuestOperationsFault {
         }
         interface OperationDisallowedOnHost extends srmService.vim.RuntimeFault {
         }
         interface OperationNotSupportedByGuest extends srmService.vim.GuestOperationsFault {
         }
         interface OutOfBounds extends srmService.vim.VimFault {
            argumentName: string;
         }
         interface OvfAttribute extends srmService.vim.OvfInvalidPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfConnectedDevice extends srmService.vim.OvfHardwareExport {
         }
         interface OvfConnectedDeviceFloppy extends srmService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConnectedDeviceIso extends srmService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConstraint extends srmService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfConsumerCallbackFault extends srmService.vim.OvfFault {
            extensionKey: string;
            extensionName: string;
         }
         interface OvfConsumerCommunicationError extends srmService.vim.OvfConsumerCallbackFault {
            description: string;
         }
         interface OvfConsumerFault extends srmService.vim.OvfConsumerCallbackFault {
            errorKey: string;
            message: string;
            params?: Array<srmService.vim.KeyValue>;
         }
         interface OvfConsumerInvalidSection extends srmService.vim.OvfConsumerCallbackFault {
            lineNumber: number;
            description: string;
         }
         interface OvfConsumerPowerOnFault extends srmService.vim.InvalidState {
            extensionKey: string;
            extensionName: string;
            description: string;
         }
         interface OvfConsumerUndeclaredSection extends srmService.vim.OvfConsumerCallbackFault {
            qualifiedSectionType: string;
         }
         interface OvfConsumerUndefinedPrefix extends srmService.vim.OvfConsumerCallbackFault {
            prefix: string;
         }
         interface OvfConsumerValidationFault extends srmService.vim.VmConfigFault {
            extensionKey: string;
            extensionName: string;
            message: string;
         }
         interface OvfCpuCompatibility extends srmService.vim.OvfImport {
            registerName: string;
            level: number;
            registerValue: string;
            desiredRegisterValue: string;
         }
         interface OvfCpuCompatibilityCheckNotSupported extends srmService.vim.OvfImport {
         }
         interface OvfDiskMappingNotFound extends srmService.vim.OvfSystemFault {
            diskName: string;
            vmName: string;
         }
         interface OvfDiskOrderConstraint extends srmService.vim.OvfConstraint {
         }
         interface OvfDuplicateElement extends srmService.vim.OvfElement {
         }
         interface OvfDuplicatedElementBoundary extends srmService.vim.OvfElement {
            boundary: string;
         }
         interface OvfDuplicatedPropertyIdExport extends srmService.vim.OvfExport {
            fqid: string;
         }
         interface OvfDuplicatedPropertyIdImport extends srmService.vim.OvfExport {
         }
         interface OvfElement extends srmService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfElementInvalidValue extends srmService.vim.OvfElement {
            value: string;
         }
         interface OvfExport extends srmService.vim.OvfFault {
         }
         interface OvfExportFailed extends srmService.vim.OvfExport {
         }
         interface OvfFault extends srmService.vim.VimFault {
         }
         interface OvfHardwareCheck extends srmService.vim.OvfImport {
         }
         interface OvfHardwareExport extends srmService.vim.OvfExport {
            device?: srmService.vim.VirtualDevice;
            vmPath: string;
         }
         interface OvfHostResourceConstraint extends srmService.vim.OvfConstraint {
            value: string;
         }
         interface OvfHostValueNotParsed extends srmService.vim.OvfSystemFault {
            property: string;
            value: string;
         }
         interface OvfImport extends srmService.vim.OvfFault {
         }
         interface OvfImportFailed extends srmService.vim.OvfImport {
         }
         interface OvfInternalError extends srmService.vim.OvfSystemFault {
         }
         interface OvfInvalidPackage extends srmService.vim.OvfFault {
            lineNumber: number;
         }
         interface OvfInvalidValue extends srmService.vim.OvfAttribute {
            value: string;
         }
         interface OvfInvalidValueConfiguration extends srmService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueEmpty extends srmService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueFormatMalformed extends srmService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueReference extends srmService.vim.OvfInvalidValue {
         }
         interface OvfInvalidVmName extends srmService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfMappedOsId extends srmService.vim.OvfImport {
            ovfId: number;
            ovfDescription: string;
            targetDescription: string;
         }
         interface OvfMissingAttribute extends srmService.vim.OvfAttribute {
         }
         interface OvfMissingElement extends srmService.vim.OvfElement {
         }
         interface OvfMissingElementNormalBoundary extends srmService.vim.OvfMissingElement {
            boundary: string;
         }
         interface OvfMissingHardware extends srmService.vim.OvfImport {
            name: string;
            resourceType: number;
         }
         interface OvfNetworkMappingNotSupported extends srmService.vim.OvfImport {
         }
         interface OvfNoHostNic extends srmService.vim.OvfUnsupportedPackage {
         }
         interface OvfNoSpaceOnController extends srmService.vim.OvfUnsupportedElement {
            parent: string;
         }
         interface OvfNoSupportedHardwareFamily extends srmService.vim.OvfUnsupportedPackage {
            version: string;
         }
         interface OvfProperty extends srmService.vim.OvfInvalidPackage {
            type: string;
            value: string;
         }
         interface OvfPropertyExport extends srmService.vim.OvfExport {
            type: string;
            value: string;
         }
         interface OvfPropertyNetwork extends srmService.vim.OvfProperty {
         }
         interface OvfPropertyNetworkExport extends srmService.vim.OvfExport {
            network: string;
         }
         interface OvfPropertyQualifier extends srmService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierDuplicate extends srmService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierIgnored extends srmService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyType extends srmService.vim.OvfProperty {
         }
         interface OvfPropertyValue extends srmService.vim.OvfProperty {
         }
         interface OvfSystemFault extends srmService.vim.OvfFault {
         }
         interface OvfToXmlUnsupportedElement extends srmService.vim.OvfSystemFault {
            name?: string;
         }
         interface OvfUnableToExportDisk extends srmService.vim.OvfHardwareExport {
            diskName: string;
         }
         interface OvfUnexpectedElement extends srmService.vim.OvfElement {
         }
         interface OvfUnknownDevice extends srmService.vim.OvfSystemFault {
            device?: srmService.vim.VirtualDevice;
            vmName: string;
         }
         interface OvfUnknownDeviceBacking extends srmService.vim.OvfHardwareExport {
            backing: srmService.vim.VirtualDeviceBackingInfo;
         }
         interface OvfUnknownEntity extends srmService.vim.OvfSystemFault {
            lineNumber: number;
         }
         interface OvfUnsupportedAttribute extends srmService.vim.OvfUnsupportedPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfUnsupportedAttributeValue extends srmService.vim.OvfUnsupportedAttribute {
            value: string;
         }
         interface OvfUnsupportedDeviceBackingInfo extends srmService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceBackingOption extends srmService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceExport extends srmService.vim.OvfHardwareExport {
         }
         interface OvfUnsupportedDiskProvisioning extends srmService.vim.OvfImport {
            diskProvisioning: string;
            supportedDiskProvisioning: string;
         }
         interface OvfUnsupportedElement extends srmService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfUnsupportedElementValue extends srmService.vim.OvfUnsupportedElement {
            value: string;
         }
         interface OvfUnsupportedPackage extends srmService.vim.OvfFault {
            lineNumber?: number;
         }
         interface OvfUnsupportedSection extends srmService.vim.OvfUnsupportedElement {
            info: string;
         }
         interface OvfUnsupportedSubType extends srmService.vim.OvfUnsupportedPackage {
            elementName: string;
            instanceId: string;
            deviceType: number;
            deviceSubType: string;
         }
         interface OvfUnsupportedType extends srmService.vim.OvfUnsupportedPackage {
            name: string;
            instanceId: string;
            deviceType: number;
         }
         interface OvfWrongElement extends srmService.vim.OvfElement {
         }
         interface OvfWrongNamespace extends srmService.vim.OvfInvalidPackage {
            namespaceName: string;
         }
         interface OvfXmlFormat extends srmService.vim.OvfInvalidPackage {
            description: string;
         }
         interface PatchAlreadyInstalled extends srmService.vim.PatchNotApplicable {
         }
         interface PatchBinariesNotFound extends srmService.vim.VimFault {
            patchID: string;
            binary?: Array<string>;
         }
         interface PatchInstallFailed extends srmService.vim.PlatformConfigFault {
            rolledBack: boolean;
         }
         interface PatchIntegrityError extends srmService.vim.PlatformConfigFault {
         }
         interface PatchMetadataCorrupted extends srmService.vim.PatchMetadataInvalid {
         }
         interface PatchMetadataInvalid extends srmService.vim.VimFault {
            patchID: string;
            metaData?: Array<string>;
         }
         interface PatchMetadataNotFound extends srmService.vim.PatchMetadataInvalid {
         }
         interface PatchMissingDependencies extends srmService.vim.PatchNotApplicable {
            prerequisitePatch?: Array<string>;
            prerequisiteLib?: Array<string>;
         }
         interface PatchNotApplicable extends srmService.vim.VimFault {
            patchID: string;
         }
         interface PatchSuperseded extends srmService.vim.PatchNotApplicable {
            supersede?: Array<string>;
         }
         interface PhysCompatRDMNotSupported extends srmService.vim.RDMNotSupported {
         }
         interface PlatformConfigFault extends srmService.vim.HostConfigFault {
            text: string;
         }
         interface PowerOnFtSecondaryFailed extends srmService.vim.VmFaultToleranceIssue {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
            hostSelectionBy: srmService.vim.FtIssuesOnHostHostSelectionType;
            hostErrors?: Array<srmService.vim.LocalizedMethodFault>;
            rootCause: srmService.vim.LocalizedMethodFault;
         }
         interface PowerOnFtSecondaryTimedout extends srmService.vim.Timedout {
            vm: srmService.vim.ManagedObjectReference;
            vmName: string;
            timeout: number;
         }
         interface ProfileUpdateFailedUpdateFailure extends srmService.vim.DynamicData {
            profilePath: srmService.vim.ProfilePropertyPath;
            errMsg: srmService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileUpdateFailedUpdateFailure {
            profileUpdateFailedUpdateFailure?: Array<srmService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         interface ProfileUpdateFailed extends srmService.vim.VimFault {
            failure: Array<srmService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         interface QuestionPending extends srmService.vim.InvalidState {
            text: string;
         }
         interface QuiesceDatastoreIOForHAFailed extends srmService.vim.ResourceInUse {
            host: srmService.vim.ManagedObjectReference;
            hostName: string;
            ds: srmService.vim.ManagedObjectReference;
            dsName: string;
         }
         interface RDMConversionNotSupported extends srmService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotPreserved extends srmService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface RDMNotSupportedOnDatastore extends srmService.vim.VmConfigFault {
            device: string;
            datastore: srmService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface RDMPointsToInaccessibleDisk extends srmService.vim.CannotAccessVmDisk {
         }
         interface RawDiskNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface ReadHostResourcePoolTreeFailed extends srmService.vim.HostConnectFault {
         }
         interface ReadOnlyDisksWithLegacyDestination extends srmService.vim.MigrationFault {
            roDiskCount: number;
            timeoutDanger: boolean;
         }
         interface RebootRequired extends srmService.vim.VimFault {
            patch?: string;
         }
         interface RecordReplayDisabled extends srmService.vim.VimFault {
         }
         interface RemoteDeviceNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface RemoveFailed extends srmService.vim.VimFault {
         }
         interface ReplicationConfigFault extends srmService.vim.ReplicationFault {
         }
         enum ReplicationDiskConfigFaultReasonForFault {
            "diskNotFound",
            "diskTypeNotSupported",
            "invalidDiskKey",
            "invalidDiskReplicationId",
            "duplicateDiskReplicationId",
            "invalidPersistentFilePath",
            "reconfigureDiskReplicationIdNotAllowed",
         }
         interface ReplicationDiskConfigFault extends srmService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: srmService.vim.ManagedObjectReference;
            key?: number;
         }
         interface ReplicationFault extends srmService.vim.VimFault {
         }
         interface ReplicationIncompatibleWithFT extends srmService.vim.ReplicationFault {
         }
         interface ReplicationInvalidOptions extends srmService.vim.ReplicationFault {
            options: string;
            entity?: srmService.vim.ManagedObjectReference;
         }
         interface ReplicationNotSupportedOnHost extends srmService.vim.ReplicationFault {
         }
         enum ReplicationVmConfigFaultReasonForFault {
            "incompatibleHwVersion",
            "invalidVmReplicationId",
            "invalidGenerationNumber",
            "outOfBoundsRpoValue",
            "invalidDestinationIpAddress",
            "invalidDestinationPort",
            "invalidExtraVmOptions",
            "staleGenerationNumber",
            "reconfigureVmReplicationIdNotAllowed",
            "cannotRetrieveVmReplicationConfiguration",
            "replicationAlreadyEnabled",
            "invalidPriorConfiguration",
            "replicationNotEnabled",
            "replicationConfigurationFailed",
         }
         interface ReplicationVmConfigFault extends srmService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: srmService.vim.ManagedObjectReference;
         }
         enum ReplicationVmFaultReasonForFault {
            "notConfigured",
            "poweredOff",
            "suspended",
            "poweredOn",
            "offlineReplicating",
            "invalidState",
            "invalidInstanceId",
         }
         interface ReplicationVmFault extends srmService.vim.ReplicationFault {
            reason?: string;
            state?: string;
            instanceId?: string;
            vm?: srmService.vim.ManagedObjectReference;
         }
         interface ResourceInUse extends srmService.vim.VimFault {
            type?: string;
            name?: string;
         }
         interface ResourceNotAvailable extends srmService.vim.VimFault {
            containerType?: string;
            containerName?: string;
            type?: string;
         }
         interface RestrictedVersion extends srmService.vim.SecurityError {
         }
         interface RollbackFailure extends srmService.vim.DvsFault {
            entityName: string;
            entityType: string;
         }
         interface RuleViolation extends srmService.vim.VmConfigFault {
            host?: srmService.vim.ManagedObjectReference;
            rule?: srmService.vim.ClusterRuleInfo;
         }
         interface SSLDisabledFault extends srmService.vim.HostConnectFault {
         }
         interface SSLVerifyFault extends srmService.vim.HostConnectFault {
            selfSigned: boolean;
            thumbprint: string;
         }
         interface SSPIChallenge extends srmService.vim.VimFault {
            base64Token: string;
         }
         interface SecondaryVmAlreadyDisabled extends srmService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyEnabled extends srmService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyRegistered extends srmService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SecondaryVmNotRegistered extends srmService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SharedBusControllerNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface ShrinkDiskFault extends srmService.vim.VimFault {
            diskId?: number;
         }
         interface SnapshotCloneNotSupported extends srmService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotCopyNotSupported extends srmService.vim.MigrationFault {
         }
         interface SnapshotDisabled extends srmService.vim.SnapshotFault {
         }
         interface SnapshotFault extends srmService.vim.VimFault {
         }
         interface SnapshotIncompatibleDeviceInVm extends srmService.vim.SnapshotFault {
            fault: srmService.vim.LocalizedMethodFault;
         }
         interface SnapshotLocked extends srmService.vim.SnapshotFault {
         }
         interface SnapshotMoveFromNonHomeNotSupported extends srmService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveNotSupported extends srmService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveToNonHomeNotSupported extends srmService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotNoChange extends srmService.vim.SnapshotFault {
         }
         interface SnapshotRevertIssue extends srmService.vim.MigrationFault {
            snapshotName?: string;
            event?: Array<srmService.vim.Event>;
            errors: boolean;
         }
         interface SoftRuleVioCorrectionDisallowed extends srmService.vim.VmConfigFault {
            vmName: string;
         }
         interface SoftRuleVioCorrectionImpact extends srmService.vim.VmConfigFault {
            vmName: string;
         }
         interface SsdDiskNotAvailable extends srmService.vim.VimFault {
            devicePath: string;
         }
         interface StorageDrsCannotMoveDiskInMultiWriterMode extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveFTVm extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveIndependentDisk extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedSwapFile extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedVm extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveSharedDisk extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveTemplate extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmInUserFolder extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithMountedCDROM extends srmService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithNoFilesInLayout extends srmService.vim.VimFault {
         }
         interface StorageDrsDatacentersCannotShareDatastore extends srmService.vim.VimFault {
         }
         interface StorageDrsDisabledOnVm extends srmService.vim.VimFault {
         }
         interface StorageDrsIolbDisabledInternally extends srmService.vim.VimFault {
         }
         interface StorageDrsUnableToMoveFiles extends srmService.vim.VimFault {
         }
         interface StorageVMotionNotSupported extends srmService.vim.MigrationFeatureNotSupported {
         }
         interface StorageVmotionIncompatible extends srmService.vim.VirtualHardwareCompatibilityIssue {
            datastore?: srmService.vim.ManagedObjectReference;
         }
         interface SuspendedRelocateNotSupported extends srmService.vim.MigrationFault {
         }
         interface SwapDatastoreNotWritableOnHost extends srmService.vim.DatastoreNotWritableOnHost {
         }
         interface SwapDatastoreUnset extends srmService.vim.VimFault {
         }
         interface SwapPlacementOverrideNotSupported extends srmService.vim.InvalidVmConfig {
         }
         interface SwitchIpUnset extends srmService.vim.DvsFault {
         }
         interface SwitchNotInUpgradeMode extends srmService.vim.DvsFault {
         }
         interface TaskInProgress extends srmService.vim.VimFault {
            task: srmService.vim.ManagedObjectReference;
         }
         enum ThirdPartyLicenseAssignmentFailedReason {
            "licenseAssignmentFailed",
            "moduleNotInstalled",
         }
         interface ThirdPartyLicenseAssignmentFailed extends srmService.vim.RuntimeFault {
            host: srmService.vim.ManagedObjectReference;
            module: string;
            reason?: string;
         }
         interface Timedout extends srmService.vim.VimFault {
         }
         interface TooManyConcurrentNativeClones extends srmService.vim.FileFault {
         }
         interface TooManyConsecutiveOverrides extends srmService.vim.VimFault {
         }
         interface TooManyDevices extends srmService.vim.InvalidVmConfig {
         }
         interface TooManyDisksOnLegacyHost extends srmService.vim.MigrationFault {
            diskCount: number;
            timeoutDanger: boolean;
         }
         interface TooManyGuestLogons extends srmService.vim.GuestOperationsFault {
         }
         interface TooManyHosts extends srmService.vim.HostConnectFault {
         }
         interface TooManyNativeCloneLevels extends srmService.vim.FileFault {
         }
         interface TooManyNativeClonesOnFile extends srmService.vim.FileFault {
         }
         interface TooManySnapshotLevels extends srmService.vim.SnapshotFault {
         }
         interface ToolsAlreadyUpgraded extends srmService.vim.VmToolsUpgradeFault {
         }
         interface ToolsAutoUpgradeNotSupported extends srmService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageCopyFailed extends srmService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageNotAvailable extends srmService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageSignatureCheckFailed extends srmService.vim.VmToolsUpgradeFault {
         }
         interface ToolsInstallationInProgress extends srmService.vim.MigrationFault {
         }
         interface ToolsUnavailable extends srmService.vim.VimFault {
         }
         interface ToolsUpgradeCancelled extends srmService.vim.VmToolsUpgradeFault {
         }
         interface UnSupportedDatastoreForVFlash extends srmService.vim.UnsupportedDatastore {
            datastoreName: string;
            type: string;
         }
         interface UncommittedUndoableDisk extends srmService.vim.MigrationFault {
         }
         interface UnconfiguredPropertyValue extends srmService.vim.InvalidPropertyValue {
         }
         interface UncustomizableGuest extends srmService.vim.CustomizationFault {
            uncustomizableGuestOS: string;
         }
         interface UnexpectedCustomizationFault extends srmService.vim.CustomizationFault {
         }
         interface UnrecognizedHost extends srmService.vim.VimFault {
            hostName: string;
         }
         interface UnsharedSwapVMotionNotSupported extends srmService.vim.MigrationFeatureNotSupported {
         }
         interface UnsupportedDatastore extends srmService.vim.VmConfigFault {
            datastore?: srmService.vim.ManagedObjectReference;
         }
         interface UnsupportedGuest extends srmService.vim.InvalidVmConfig {
            unsupportedGuestOS: string;
         }
         interface UnsupportedVimApiVersion extends srmService.vim.VimFault {
            version?: string;
         }
         interface UnsupportedVmxLocation extends srmService.vim.VmConfigFault {
         }
         interface UnusedVirtualDiskBlocksNotScrubbed extends srmService.vim.DeviceBackingNotSupported {
         }
         interface UserNotFound extends srmService.vim.VimFault {
            principal: string;
            unresolved: boolean;
         }
         interface VAppConfigFault extends srmService.vim.VimFault {
         }
         interface VAppNotRunning extends srmService.vim.VmConfigFault {
         }
         interface VAppOperationInProgress extends srmService.vim.RuntimeFault {
         }
         interface VAppPropertyFault extends srmService.vim.VmConfigFault {
            id: string;
            category: string;
            label: string;
            type: string;
            value: string;
         }
         interface VAppTaskInProgress extends srmService.vim.TaskInProgress {
         }
         enum VFlashModuleNotSupportedReason {
            "CacheModeNotSupported",
            "CacheConsistencyTypeNotSupported",
            "CacheBlockSizeNotSupported",
            "CacheReservationNotSupported",
            "DiskSizeNotSupported",
         }
         interface VFlashModuleNotSupported extends srmService.vim.VmConfigFault {
            vmName: string;
            moduleName: string;
            reason: string;
            hostName: string;
         }
         interface VFlashModuleVersionIncompatible extends srmService.vim.VimFault {
            moduleName: string;
            vmRequestModuleVersion: string;
            hostMinSupportedVerson: string;
            hostModuleVersion: string;
         }
         interface VMINotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface VMOnConflictDVPort extends srmService.vim.CannotAccessNetwork {
         }
         interface VMOnVirtualIntranet extends srmService.vim.CannotAccessNetwork {
         }
         interface VMotionAcrossNetworkNotSupported extends srmService.vim.MigrationFeatureNotSupported {
         }
         interface VMotionInterfaceIssue extends srmService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHost: string;
            failedHostEntity?: srmService.vim.ManagedObjectReference;
         }
         interface VMotionLinkCapacityLow extends srmService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionLinkDown extends srmService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionNotConfigured extends srmService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotLicensed extends srmService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotSupported extends srmService.vim.VMotionInterfaceIssue {
         }
         interface VMotionProtocolIncompatible extends srmService.vim.MigrationFault {
         }
         interface VimFault extends srmService.vim.MethodFault {
         }
         interface VirtualDiskBlocksNotFullyProvisioned extends srmService.vim.DeviceBackingNotSupported {
         }
         interface VirtualDiskModeNotSupported extends srmService.vim.DeviceNotSupported {
            mode: string;
         }
         interface VirtualEthernetCardNotSupported extends srmService.vim.DeviceNotSupported {
         }
         interface VirtualHardwareCompatibilityIssue extends srmService.vim.VmConfigFault {
         }
         interface VirtualHardwareVersionNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
            hostName: string;
            host: srmService.vim.ManagedObjectReference;
         }
         interface VmAlreadyExistsInDatacenter extends srmService.vim.InvalidFolder {
            host: srmService.vim.ManagedObjectReference;
            hostname: string;
            vm: Array<srmService.vim.ManagedObjectReference>;
         }
         interface VmConfigFault extends srmService.vim.VimFault {
         }
         interface VmConfigIncompatibleForFaultTolerance extends srmService.vim.VmConfigFault {
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface VmConfigIncompatibleForRecordReplay extends srmService.vim.VmConfigFault {
            fault?: srmService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceConfigIssueReasonForIssue {
            "haNotEnabled",
            "moreThanOneSecondary",
            "recordReplayNotSupported",
            "replayNotSupported",
            "templateVm",
            "multipleVCPU",
            "hostInactive",
            "ftUnsupportedHardware",
            "ftUnsupportedProduct",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "thinDisk",
            "verifySSLCertificateFlagNotSet",
            "hasSnapshots",
            "noConfig",
            "ftSecondaryVm",
            "hasLocalDisk",
            "esxAgentVm",
            "video3dEnabled",
            "hasUnsupportedDisk",
            "hasNestedHVConfiguration",
            "hasVFlashConfiguration",
         }
         interface VmFaultToleranceConfigIssue extends srmService.vim.VmFaultToleranceIssue {
            reason?: string;
            entityName?: string;
            entity?: srmService.vim.ManagedObjectReference;
         }
         interface VmFaultToleranceConfigIssueWrapper extends srmService.vim.VmFaultToleranceIssue {
            entityName?: string;
            entity?: srmService.vim.ManagedObjectReference;
            error?: srmService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceInvalidFileBackingDeviceType {
            "virtualFloppy",
            "virtualCdrom",
            "virtualSerialPort",
            "virtualParallelPort",
            "virtualDisk",
         }
         interface VmFaultToleranceInvalidFileBacking extends srmService.vim.VmFaultToleranceIssue {
            backingType?: string;
            backingFilename?: string;
         }
         interface VmFaultToleranceIssue extends srmService.vim.VimFault {
         }
         interface VmFaultToleranceOpIssuesList extends srmService.vim.VmFaultToleranceIssue {
            errors?: Array<srmService.vim.LocalizedMethodFault>;
            warnings?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface VmFaultToleranceTooManyVMsOnHost extends srmService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumFtVms: number;
         }
         interface VmHostAffinityRuleViolation extends srmService.vim.VmConfigFault {
            vmName: string;
            hostName: string;
         }
         interface VmLimitLicense extends srmService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VmMetadataManagerFault extends srmService.vim.VimFault {
         }
         interface VmMonitorIncompatibleForFaultTolerance extends srmService.vim.VimFault {
         }
         interface VmPowerOnDisabled extends srmService.vim.InvalidState {
         }
         interface VmToolsUpgradeFault extends srmService.vim.VimFault {
         }
         interface VmValidateMaxDevice extends srmService.vim.VimFault {
            device: string;
            max: number;
            count: number;
         }
         interface VmWwnConflict extends srmService.vim.InvalidVmConfig {
            vm?: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
            name?: string;
            wwn?: number;
         }
         interface VmfsAlreadyMounted extends srmService.vim.VmfsMountFault {
         }
         interface VmfsAmbiguousMount extends srmService.vim.VmfsMountFault {
         }
         interface VmfsMountFault extends srmService.vim.HostConfigFault {
            uuid: string;
         }
         interface VmotionInterfaceNotEnabled extends srmService.vim.HostPowerOpFailed {
         }
         interface VolumeEditorError extends srmService.vim.CustomizationFault {
         }
         interface VramLimitLicense extends srmService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VsanClusterUuidMismatch extends srmService.vim.CannotMoveVsanEnabledHost {
            hostClusterUuid: string;
            destinationClusterUuid: string;
         }
         interface VsanDiskFault extends srmService.vim.VsanFault {
            device?: string;
         }
         interface VsanFault extends srmService.vim.VimFault {
         }
         interface VspanDestPortConflict extends srmService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortConflict extends srmService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortMoveFault extends srmService.vim.DvsFault {
            srcPortgroupName: string;
            destPortgroupName: string;
            portKey: string;
         }
         interface VspanPortPromiscChangeFault extends srmService.vim.DvsFault {
            portKey: string;
         }
         interface VspanPortgroupPromiscChangeFault extends srmService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPortgroupTypeChangeFault extends srmService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPromiscuousPortNotSupported extends srmService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface VspanSameSessionPortConflict extends srmService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface WakeOnLanNotSupported extends srmService.vim.VirtualHardwareCompatibilityIssue {
         }
         interface WakeOnLanNotSupportedByVmotionNIC extends srmService.vim.HostPowerOpFailed {
         }
         enum WillLoseHAProtectionResolution {
            "svmotion",
            "relocate",
         }
         interface WillLoseHAProtection extends srmService.vim.MigrationFault {
            resolution: string;
         }
         interface WillModifyConfigCpuRequirements extends srmService.vim.MigrationFault {
         }
         interface WillResetSnapshotDirectory extends srmService.vim.MigrationFault {
         }
         interface WipeDiskFault extends srmService.vim.VimFault {
         }
         enum HostActiveDirectoryInfoDomainMembershipStatus {
            "unknown",
            "ok",
            "noServers",
            "clientTrustBroken",
            "serverTrustBroken",
            "inconsistentTrust",
            "otherProblem",
         }
         interface HostActiveDirectoryInfo extends srmService.vim.HostDirectoryStoreInfo {
            joinedDomain?: string;
            trustedDomain?: Array<string>;
            domainMembershipStatus?: string;
         }
         interface HostActiveDirectorySpec extends srmService.vim.DynamicData {
            domainName?: string;
            userName?: string;
            password?: string;
            camServer?: string;
            thumbprint?: string;
         }
         interface HostActiveDirectory extends srmService.vim.DynamicData {
            changeOperation: string;
            spec?: srmService.vim.HostActiveDirectorySpec;
         }
         interface ArrayOfHostActiveDirectory {
            hostActiveDirectory?: Array<srmService.vim.HostActiveDirectory>;
         }
         interface HostAuthenticationManagerInfo extends srmService.vim.DynamicData {
            authConfig: Array<srmService.vim.HostAuthenticationStoreInfo>;
         }
         interface HostAuthenticationStoreInfo extends srmService.vim.DynamicData {
            enabled: boolean;
         }
         interface ArrayOfHostAuthenticationStoreInfo {
            hostAuthenticationStoreInfo?: Array<srmService.vim.HostAuthenticationStoreInfo>;
         }
         enum AutoStartAction {
            "none",
            "systemDefault",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface AutoStartDefaults extends srmService.vim.DynamicData {
            enabled?: boolean;
            startDelay?: number;
            stopDelay?: number;
            waitForHeartbeat?: boolean;
            stopAction?: string;
         }
         enum AutoStartWaitHeartbeatSetting {
            "yes",
            "no",
            "systemDefault",
         }
         interface AutoStartPowerInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            startOrder: number;
            startDelay: number;
            waitForHeartbeat: srmService.vim.AutoStartWaitHeartbeatSetting;
            startAction: string;
            stopDelay: number;
            stopAction: string;
         }
         interface ArrayOfAutoStartPowerInfo {
            autoStartPowerInfo?: Array<srmService.vim.AutoStartPowerInfo>;
         }
         interface HostAutoStartManagerConfig extends srmService.vim.DynamicData {
            defaults?: srmService.vim.AutoStartDefaults;
            powerInfo?: Array<srmService.vim.AutoStartPowerInfo>;
         }
         interface HostBootDeviceInfo extends srmService.vim.DynamicData {
            bootDevices?: Array<srmService.vim.HostBootDevice>;
            currentBootDeviceKey?: string;
         }
         interface HostBootDevice extends srmService.vim.DynamicData {
            key: string;
            description: string;
         }
         interface ArrayOfHostBootDevice {
            hostBootDevice?: Array<srmService.vim.HostBootDevice>;
         }
         interface HostCacheConfigurationSpec extends srmService.vim.DynamicData {
            datastore: srmService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface HostCacheConfigurationInfo extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface ArrayOfHostCacheConfigurationInfo {
            hostCacheConfigurationInfo?: Array<srmService.vim.HostCacheConfigurationInfo>;
         }
         enum HostReplayUnsupportedReason {
            "incompatibleProduct",
            "incompatibleCpu",
            "hvDisabled",
            "cpuidLimitSet",
            "oldBIOS",
            "unknown",
         }
         enum HostCapabilityFtUnsupportedReason {
            "vMotionNotLicensed",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "ftNotLicensed",
            "haAgentIssue",
         }
         enum HostCapabilityVmDirectPathGen2UnsupportedReason {
            "hostNptIncompatibleProduct",
            "hostNptIncompatibleHardware",
            "hostNptDisabled",
         }
         interface HostCapability extends srmService.vim.DynamicData {
            recursiveResourcePoolsSupported: boolean;
            cpuMemoryResourceConfigurationSupported: boolean;
            rebootSupported: boolean;
            shutdownSupported: boolean;
            vmotionSupported: boolean;
            standbySupported: boolean;
            ipmiSupported?: boolean;
            maxSupportedVMs?: number;
            maxRunningVMs?: number;
            maxSupportedVcpus?: number;
            maxRegisteredVMs?: number;
            datastorePrincipalSupported: boolean;
            sanSupported: boolean;
            nfsSupported: boolean;
            iscsiSupported: boolean;
            vlanTaggingSupported: boolean;
            nicTeamingSupported: boolean;
            highGuestMemSupported: boolean;
            maintenanceModeSupported: boolean;
            suspendedRelocateSupported: boolean;
            restrictedSnapshotRelocateSupported: boolean;
            perVmSwapFiles: boolean;
            localSwapDatastoreSupported: boolean;
            unsharedSwapVMotionSupported: boolean;
            backgroundSnapshotsSupported: boolean;
            preAssignedPCIUnitNumbersSupported: boolean;
            screenshotSupported: boolean;
            scaledScreenshotSupported: boolean;
            storageVMotionSupported?: boolean;
            vmotionWithStorageVMotionSupported?: boolean;
            vmotionAcrossNetworkSupported?: boolean;
            hbrNicSelectionSupported?: boolean;
            recordReplaySupported?: boolean;
            ftSupported?: boolean;
            replayUnsupportedReason?: string;
            replayCompatibilityIssues?: Array<string>;
            ftCompatibilityIssues?: Array<string>;
            loginBySSLThumbprintSupported?: boolean;
            cloneFromSnapshotSupported?: boolean;
            deltaDiskBackingsSupported?: boolean;
            perVMNetworkTrafficShapingSupported?: boolean;
            tpmSupported?: boolean;
            supportedCpuFeature?: Array<srmService.vim.HostCpuIdInfo>;
            virtualExecUsageSupported?: boolean;
            storageIORMSupported?: boolean;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2UnsupportedReason?: Array<string>;
            vmDirectPathGen2UnsupportedReasonExtended?: string;
            supportedVmfsMajorVersion?: Array<number>;
            vStorageCapable?: boolean;
            snapshotRelayoutSupported?: boolean;
            firewallIpRulesSupported?: boolean;
            servicePackageInfoSupported?: boolean;
            maxHostRunningVms?: number;
            maxHostSupportedVcpus?: number;
            vmfsDatastoreMountCapable?: boolean;
            eightPlusHostVmfsSharedAccessSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
            interVMCommunicationThroughVMCISupported?: boolean;
            scheduledHardwareUpgradeSupported?: boolean;
            featureCapabilitiesSupported?: boolean;
            latencySensitivitySupported?: boolean;
            storagePolicySupported?: boolean;
            accel3dSupported?: boolean;
            reliableMemoryAware?: boolean;
            multipleNetworkStackInstanceSupported?: boolean;
            vsanSupported?: boolean;
            vFlashSupported?: boolean;
         }
         enum HostConfigChangeMode {
            "modify",
            "replace",
         }
         enum HostConfigChangeOperation {
            "add",
            "remove",
            "edit",
         }
         interface HostConfigChange extends srmService.vim.DynamicData {
         }
         interface HostConfigInfo extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            product: srmService.vim.AboutInfo;
            hyperThread?: srmService.vim.HostHyperThreadScheduleInfo;
            consoleReservation?: srmService.vim.ServiceConsoleReservationInfo;
            virtualMachineReservation?: srmService.vim.VirtualMachineMemoryReservationInfo;
            storageDevice?: srmService.vim.HostStorageDeviceInfo;
            multipathState?: srmService.vim.HostMultipathStateInfo;
            fileSystemVolume?: srmService.vim.HostFileSystemVolumeInfo;
            systemFile?: Array<string>;
            network?: srmService.vim.HostNetworkInfo;
            vmotion?: srmService.vim.HostVMotionInfo;
            virtualNicManagerInfo?: srmService.vim.HostVirtualNicManagerInfo;
            capabilities?: srmService.vim.HostNetCapabilities;
            datastoreCapabilities?: srmService.vim.HostDatastoreSystemCapabilities;
            offloadCapabilities?: srmService.vim.HostNetOffloadCapabilities;
            service?: srmService.vim.HostServiceInfo;
            firewall?: srmService.vim.HostFirewallInfo;
            autoStart?: srmService.vim.HostAutoStartManagerConfig;
            activeDiagnosticPartition?: srmService.vim.HostDiagnosticPartition;
            option?: Array<srmService.vim.OptionValue>;
            optionDef?: Array<srmService.vim.OptionDef>;
            datastorePrincipal?: string;
            localSwapDatastore?: srmService.vim.ManagedObjectReference;
            systemSwapConfiguration?: srmService.vim.HostSystemSwapConfiguration;
            systemResources?: srmService.vim.HostSystemResourceInfo;
            dateTimeInfo?: srmService.vim.HostDateTimeInfo;
            flags?: srmService.vim.HostFlagInfo;
            adminDisabled?: boolean;
            ipmi?: srmService.vim.HostIpmiInfo;
            sslThumbprintInfo?: srmService.vim.HostSslThumbprintInfo;
            sslThumbprintData?: Array<srmService.vim.HostSslThumbprintInfo>;
            certificate?: Array<number>;
            pciPassthruInfo?: Array<srmService.vim.HostPciPassthruInfo>;
            authenticationManagerInfo?: srmService.vim.HostAuthenticationManagerInfo;
            featureVersion?: Array<srmService.vim.HostFeatureVersionInfo>;
            powerSystemCapability?: srmService.vim.PowerSystemCapability;
            powerSystemInfo?: srmService.vim.PowerSystemInfo;
            cacheConfigurationInfo?: Array<srmService.vim.HostCacheConfigurationInfo>;
            wakeOnLanCapable?: boolean;
            featureCapability?: Array<srmService.vim.HostFeatureCapability>;
            maskedFeatureCapability?: Array<srmService.vim.HostFeatureCapability>;
            vFlashConfigInfo?: srmService.vim.HostVFlashManagerVFlashConfigInfo;
            vsanHostConfig?: srmService.vim.VsanHostConfigInfo;
            graphicsInfo?: Array<srmService.vim.HostGraphicsInfo>;
         }
         interface HostConfigManager extends srmService.vim.DynamicData {
            cpuScheduler?: srmService.vim.ManagedObjectReference;
            datastoreSystem?: srmService.vim.ManagedObjectReference;
            memoryManager?: srmService.vim.ManagedObjectReference;
            storageSystem?: srmService.vim.ManagedObjectReference;
            networkSystem?: srmService.vim.ManagedObjectReference;
            vmotionSystem?: srmService.vim.ManagedObjectReference;
            virtualNicManager?: srmService.vim.ManagedObjectReference;
            serviceSystem?: srmService.vim.ManagedObjectReference;
            firewallSystem?: srmService.vim.ManagedObjectReference;
            advancedOption?: srmService.vim.ManagedObjectReference;
            diagnosticSystem?: srmService.vim.ManagedObjectReference;
            autoStartManager?: srmService.vim.ManagedObjectReference;
            snmpSystem?: srmService.vim.ManagedObjectReference;
            dateTimeSystem?: srmService.vim.ManagedObjectReference;
            patchManager?: srmService.vim.ManagedObjectReference;
            imageConfigManager?: srmService.vim.ManagedObjectReference;
            bootDeviceSystem?: srmService.vim.ManagedObjectReference;
            firmwareSystem?: srmService.vim.ManagedObjectReference;
            healthStatusSystem?: srmService.vim.ManagedObjectReference;
            pciPassthruSystem?: srmService.vim.ManagedObjectReference;
            licenseManager?: srmService.vim.ManagedObjectReference;
            kernelModuleSystem?: srmService.vim.ManagedObjectReference;
            authenticationManager?: srmService.vim.ManagedObjectReference;
            powerSystem?: srmService.vim.ManagedObjectReference;
            cacheConfigurationManager?: srmService.vim.ManagedObjectReference;
            esxAgentHostManager?: srmService.vim.ManagedObjectReference;
            iscsiManager?: srmService.vim.ManagedObjectReference;
            vFlashManager?: srmService.vim.ManagedObjectReference;
            vsanSystem?: srmService.vim.ManagedObjectReference;
            graphicsManager?: srmService.vim.ManagedObjectReference;
            vsanInternalSystem?: srmService.vim.ManagedObjectReference;
         }
         interface HostConfigSpec extends srmService.vim.DynamicData {
            nasDatastore?: Array<srmService.vim.HostNasVolumeConfig>;
            network?: srmService.vim.HostNetworkConfig;
            nicTypeSelection?: Array<srmService.vim.HostVirtualNicManagerNicTypeSelection>;
            service?: Array<srmService.vim.HostServiceConfig>;
            firewall?: srmService.vim.HostFirewallConfig;
            option?: Array<srmService.vim.OptionValue>;
            datastorePrincipal?: string;
            datastorePrincipalPasswd?: string;
            datetime?: srmService.vim.HostDateTimeConfig;
            storageDevice?: srmService.vim.HostStorageDeviceInfo;
            license?: srmService.vim.HostLicenseSpec;
            security?: srmService.vim.HostSecuritySpec;
            userAccount?: Array<srmService.vim.HostAccountSpec>;
            usergroupAccount?: Array<srmService.vim.HostAccountSpec>;
            memory?: srmService.vim.HostMemorySpec;
            activeDirectory?: Array<srmService.vim.HostActiveDirectory>;
            genericConfig?: Array<srmService.vim.KeyAnyValue>;
         }
         interface HostConnectInfoNetworkInfo extends srmService.vim.DynamicData {
            summary: srmService.vim.NetworkSummary;
         }
         interface ArrayOfHostConnectInfoNetworkInfo {
            hostConnectInfoNetworkInfo?: Array<srmService.vim.HostConnectInfoNetworkInfo>;
         }
         interface HostNewNetworkConnectInfo extends srmService.vim.HostConnectInfoNetworkInfo {
         }
         interface HostDatastoreConnectInfo extends srmService.vim.DynamicData {
            summary: srmService.vim.DatastoreSummary;
         }
         interface ArrayOfHostDatastoreConnectInfo {
            hostDatastoreConnectInfo?: Array<srmService.vim.HostDatastoreConnectInfo>;
         }
         interface HostDatastoreExistsConnectInfo extends srmService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostDatastoreNameConflictConnectInfo extends srmService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostLicenseConnectInfo extends srmService.vim.DynamicData {
            license: srmService.vim.LicenseManagerLicenseInfo;
            evaluation: srmService.vim.LicenseManagerEvaluationInfo;
            resource?: srmService.vim.HostLicensableResourceInfo;
         }
         interface HostConnectInfo extends srmService.vim.DynamicData {
            serverIp?: string;
            inDasCluster?: boolean;
            host: srmService.vim.HostListSummary;
            vm?: Array<srmService.vim.VirtualMachineSummary>;
            vimAccountNameRequired?: boolean;
            clusterSupported?: boolean;
            network?: Array<srmService.vim.HostConnectInfoNetworkInfo>;
            datastore?: Array<srmService.vim.HostDatastoreConnectInfo>;
            license?: srmService.vim.HostLicenseConnectInfo;
         }
         interface HostConnectSpec extends srmService.vim.DynamicData {
            hostName?: string;
            port?: number;
            sslThumbprint?: string;
            userName?: string;
            password?: string;
            vmFolder?: srmService.vim.ManagedObjectReference;
            force: boolean;
            vimAccountName?: string;
            vimAccountPassword?: string;
            managementIp?: string;
         }
         interface HostCpuIdInfo extends srmService.vim.DynamicData {
            level: number;
            vendor?: string;
            eax?: string;
            ebx?: string;
            ecx?: string;
            edx?: string;
         }
         interface ArrayOfHostCpuIdInfo {
            hostCpuIdInfo?: Array<srmService.vim.HostCpuIdInfo>;
         }
         interface HostHyperThreadScheduleInfo extends srmService.vim.DynamicData {
            available: boolean;
            active: boolean;
            config: boolean;
         }
         interface FileQueryFlags extends srmService.vim.DynamicData {
            fileType: boolean;
            fileSize: boolean;
            modification: boolean;
            fileOwner?: boolean;
         }
         interface FileInfo extends srmService.vim.DynamicData {
            path: string;
            fileSize?: number;
            modification?: Date;
            owner?: string;
         }
         interface ArrayOfFileInfo {
            fileInfo?: Array<srmService.vim.FileInfo>;
         }
         interface FileQuery extends srmService.vim.DynamicData {
         }
         interface ArrayOfFileQuery {
            fileQuery?: Array<srmService.vim.FileQuery>;
         }
         interface VmConfigFileQueryFilter extends srmService.vim.DynamicData {
            matchConfigVersion?: Array<number>;
         }
         interface VmConfigFileQueryFlags extends srmService.vim.DynamicData {
            configVersion: boolean;
         }
         interface VmConfigFileQuery extends srmService.vim.FileQuery {
            filter?: srmService.vim.VmConfigFileQueryFilter;
            details?: srmService.vim.VmConfigFileQueryFlags;
         }
         interface TemplateConfigFileQuery extends srmService.vim.VmConfigFileQuery {
         }
         interface VmDiskFileQueryFilter extends srmService.vim.DynamicData {
            diskType?: Array<string>;
            matchHardwareVersion?: Array<number>;
            controllerType?: Array<string>;
            thin?: boolean;
         }
         interface VmDiskFileQueryFlags extends srmService.vim.DynamicData {
            diskType: boolean;
            capacityKb: boolean;
            hardwareVersion: boolean;
            controllerType?: boolean;
            diskExtents?: boolean;
            thin?: boolean;
         }
         interface VmDiskFileQuery extends srmService.vim.FileQuery {
            filter?: srmService.vim.VmDiskFileQueryFilter;
            details?: srmService.vim.VmDiskFileQueryFlags;
         }
         interface FolderFileQuery extends srmService.vim.FileQuery {
         }
         interface VmSnapshotFileQuery extends srmService.vim.FileQuery {
         }
         interface IsoImageFileQuery extends srmService.vim.FileQuery {
         }
         interface FloppyImageFileQuery extends srmService.vim.FileQuery {
         }
         interface VmNvramFileQuery extends srmService.vim.FileQuery {
         }
         interface VmLogFileQuery extends srmService.vim.FileQuery {
         }
         interface VmConfigFileInfo extends srmService.vim.FileInfo {
            configVersion?: number;
         }
         interface TemplateConfigFileInfo extends srmService.vim.VmConfigFileInfo {
         }
         interface VmDiskFileInfo extends srmService.vim.FileInfo {
            diskType?: string;
            capacityKb?: number;
            hardwareVersion?: number;
            controllerType?: string;
            diskExtents?: Array<string>;
            thin?: boolean;
         }
         interface FolderFileInfo extends srmService.vim.FileInfo {
         }
         interface VmSnapshotFileInfo extends srmService.vim.FileInfo {
         }
         interface IsoImageFileInfo extends srmService.vim.FileInfo {
         }
         interface FloppyImageFileInfo extends srmService.vim.FileInfo {
         }
         interface VmNvramFileInfo extends srmService.vim.FileInfo {
         }
         interface VmLogFileInfo extends srmService.vim.FileInfo {
         }
         interface HostDatastoreBrowserSearchSpec extends srmService.vim.DynamicData {
            query?: Array<srmService.vim.FileQuery>;
            details?: srmService.vim.FileQueryFlags;
            searchCaseInsensitive?: boolean;
            matchPattern?: Array<string>;
            sortFoldersFirst?: boolean;
         }
         interface HostDatastoreBrowserSearchResults extends srmService.vim.DynamicData {
            datastore?: srmService.vim.ManagedObjectReference;
            folderPath?: string;
            file?: Array<srmService.vim.FileInfo>;
         }
         interface ArrayOfHostDatastoreBrowserSearchResults {
            hostDatastoreBrowserSearchResults?: Array<srmService.vim.HostDatastoreBrowserSearchResults>;
         }
         interface HostDatastoreSystemCapabilities extends srmService.vim.DynamicData {
            nfsMountCreationRequired: boolean;
            nfsMountCreationSupported: boolean;
            localDatastoreSupported: boolean;
            vmfsExtentExpansionSupported?: boolean;
         }
         interface VmfsDatastoreInfo extends srmService.vim.DatastoreInfo {
            maxPhysicalRDMFileSize?: number;
            maxVirtualRDMFileSize?: number;
            vmfs?: srmService.vim.HostVmfsVolume;
         }
         interface NasDatastoreInfo extends srmService.vim.DatastoreInfo {
            nas?: srmService.vim.HostNasVolume;
         }
         interface LocalDatastoreInfo extends srmService.vim.DatastoreInfo {
            path?: string;
         }
         interface VmfsDatastoreSpec extends srmService.vim.DynamicData {
            diskUuid: string;
         }
         interface VmfsDatastoreCreateSpec extends srmService.vim.VmfsDatastoreSpec {
            partition: srmService.vim.HostDiskPartitionSpec;
            vmfs: srmService.vim.HostVmfsSpec;
            extent?: Array<srmService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExtendSpec extends srmService.vim.VmfsDatastoreSpec {
            partition: srmService.vim.HostDiskPartitionSpec;
            extent: Array<srmService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExpandSpec extends srmService.vim.VmfsDatastoreSpec {
            partition: srmService.vim.HostDiskPartitionSpec;
            extent: srmService.vim.HostScsiDiskPartition;
         }
         interface VmfsDatastoreBaseOption extends srmService.vim.DynamicData {
            layout: srmService.vim.HostDiskPartitionLayout;
            partitionFormatChange?: boolean;
         }
         interface VmfsDatastoreSingleExtentOption extends srmService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: srmService.vim.HostDiskPartitionBlockRange;
         }
         interface VmfsDatastoreAllExtentOption extends srmService.vim.VmfsDatastoreSingleExtentOption {
         }
         interface VmfsDatastoreMultipleExtentOption extends srmService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: Array<srmService.vim.HostDiskPartitionBlockRange>;
         }
         interface VmfsDatastoreOption extends srmService.vim.DynamicData {
            info: srmService.vim.VmfsDatastoreBaseOption;
            spec: srmService.vim.VmfsDatastoreSpec;
         }
         interface ArrayOfVmfsDatastoreOption {
            vmfsDatastoreOption?: Array<srmService.vim.VmfsDatastoreOption>;
         }
         interface HostDateTimeConfig extends srmService.vim.DynamicData {
            timeZone?: string;
            ntpConfig?: srmService.vim.HostNtpConfig;
         }
         interface HostDateTimeInfo extends srmService.vim.DynamicData {
            timeZone: srmService.vim.HostDateTimeSystemTimeZone;
            ntpConfig?: srmService.vim.HostNtpConfig;
         }
         interface HostDateTimeSystemTimeZone extends srmService.vim.DynamicData {
            key: string;
            name: string;
            description: string;
            gmtOffset: number;
         }
         interface ArrayOfHostDateTimeSystemTimeZone {
            hostDateTimeSystemTimeZone?: Array<srmService.vim.HostDateTimeSystemTimeZone>;
         }
         interface HostDevice extends srmService.vim.DynamicData {
            deviceName: string;
            deviceType: string;
         }
         interface HostDhcpServiceSpec extends srmService.vim.DynamicData {
            virtualSwitch: string;
            defaultLeaseDuration: number;
            leaseBeginIp: string;
            leaseEndIp: string;
            maxLeaseDuration: number;
            unlimitedLease: boolean;
            ipSubnetAddr: string;
            ipSubnetMask: string;
         }
         interface HostDhcpServiceConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: srmService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpServiceConfig {
            hostDhcpServiceConfig?: Array<srmService.vim.HostDhcpServiceConfig>;
         }
         interface HostDhcpService extends srmService.vim.DynamicData {
            key: string;
            spec: srmService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpService {
            hostDhcpService?: Array<srmService.vim.HostDhcpService>;
         }
         enum DiagnosticPartitionStorageType {
            "directAttached",
            "networkAttached",
         }
         enum DiagnosticPartitionType {
            "singleHost",
            "multiHost",
         }
         interface HostDiagnosticPartitionCreateOption extends srmService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            disk: srmService.vim.HostScsiDisk;
         }
         interface ArrayOfHostDiagnosticPartitionCreateOption {
            hostDiagnosticPartitionCreateOption?: Array<srmService.vim.HostDiagnosticPartitionCreateOption>;
         }
         interface HostDiagnosticPartitionCreateSpec extends srmService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            id: srmService.vim.HostScsiDiskPartition;
            partition: srmService.vim.HostDiskPartitionSpec;
            active?: boolean;
         }
         interface HostDiagnosticPartitionCreateDescription extends srmService.vim.DynamicData {
            layout: srmService.vim.HostDiskPartitionLayout;
            diskUuid: string;
            spec: srmService.vim.HostDiagnosticPartitionCreateSpec;
         }
         interface HostDiagnosticPartition extends srmService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            slots: number;
            id: srmService.vim.HostScsiDiskPartition;
         }
         interface ArrayOfHostDiagnosticPartition {
            hostDiagnosticPartition?: Array<srmService.vim.HostDiagnosticPartition>;
         }
         interface HostDirectoryStoreInfo extends srmService.vim.HostAuthenticationStoreInfo {
         }
         interface HostDiskConfigurationResult extends srmService.vim.DynamicData {
            devicePath?: string;
            success?: boolean;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostDiskConfigurationResult {
            hostDiskConfigurationResult?: Array<srmService.vim.HostDiskConfigurationResult>;
         }
         interface HostDiskDimensionsChs extends srmService.vim.DynamicData {
            cylinder: number;
            head: number;
            sector: number;
         }
         interface HostDiskDimensionsLba extends srmService.vim.DynamicData {
            blockSize: number;
            block: number;
         }
         interface HostDiskDimensions extends srmService.vim.DynamicData {
         }
         enum HostDiskPartitionInfoPartitionFormat {
            "gpt",
            "mbr",
            "unknown",
         }
         enum HostDiskPartitionInfoType {
            "none",
            "vmfs",
            "linuxNative",
            "linuxSwap",
            "extended",
            "ntfs",
            "vmkDiagnostic",
            "vffs",
         }
         interface HostDiskPartitionAttributes extends srmService.vim.DynamicData {
            partition: number;
            startSector: number;
            endSector: number;
            type: string;
            guid?: string;
            logical: boolean;
            attributes: number;
            partitionAlignment?: number;
         }
         interface ArrayOfHostDiskPartitionAttributes {
            hostDiskPartitionAttributes?: Array<srmService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionBlockRange extends srmService.vim.DynamicData {
            partition?: number;
            type: string;
            start: srmService.vim.HostDiskDimensionsLba;
            end: srmService.vim.HostDiskDimensionsLba;
         }
         interface ArrayOfHostDiskPartitionBlockRange {
            hostDiskPartitionBlockRange?: Array<srmService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionSpec extends srmService.vim.DynamicData {
            partitionFormat?: string;
            chs?: srmService.vim.HostDiskDimensionsChs;
            totalSectors?: number;
            partition?: Array<srmService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionLayout extends srmService.vim.DynamicData {
            total?: srmService.vim.HostDiskDimensionsLba;
            partition: Array<srmService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionInfo extends srmService.vim.DynamicData {
            deviceName: string;
            spec: srmService.vim.HostDiskPartitionSpec;
            layout: srmService.vim.HostDiskPartitionLayout;
         }
         interface ArrayOfHostDiskPartitionInfo {
            hostDiskPartitionInfo?: Array<srmService.vim.HostDiskPartitionInfo>;
         }
         interface HostDnsConfig extends srmService.vim.DynamicData {
            dhcp: boolean;
            virtualNicDevice?: string;
            hostName: string;
            domainName: string;
            address?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface HostDnsConfigSpec extends srmService.vim.HostDnsConfig {
            virtualNicConnection?: srmService.vim.HostVirtualNicConnection;
         }
         interface HostEsxAgentHostManagerConfigInfo extends srmService.vim.DynamicData {
            agentVmDatastore?: srmService.vim.ManagedObjectReference;
            agentVmNetwork?: srmService.vim.ManagedObjectReference;
         }
         interface FcoeConfigVlanRange extends srmService.vim.DynamicData {
            vlanLow: number;
            vlanHigh: number;
         }
         interface ArrayOfFcoeConfigVlanRange {
            fcoeConfigVlanRange?: Array<srmService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfigFcoeCapabilities extends srmService.vim.DynamicData {
            priorityClass: boolean;
            sourceMacAddress: boolean;
            vlanRange: boolean;
         }
         interface FcoeConfigFcoeSpecification extends srmService.vim.DynamicData {
            underlyingPnic: string;
            priorityClass?: number;
            sourceMac?: string;
            vlanRange?: Array<srmService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfig extends srmService.vim.DynamicData {
            priorityClass: number;
            sourceMac: string;
            vlanRange: Array<srmService.vim.FcoeConfigVlanRange>;
            capabilities: srmService.vim.FcoeConfigFcoeCapabilities;
            fcoeActive: boolean;
         }
         interface HostFeatureCapability extends srmService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureCapability {
            hostFeatureCapability?: Array<srmService.vim.HostFeatureCapability>;
         }
         interface HostFeatureMask extends srmService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureMask {
            hostFeatureMask?: Array<srmService.vim.HostFeatureMask>;
         }
         enum HostFeatureVersionKey {
            "faultTolerance",
         }
         interface HostFeatureVersionInfo extends srmService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfHostFeatureVersionInfo {
            hostFeatureVersionInfo?: Array<srmService.vim.HostFeatureVersionInfo>;
         }
         interface ModeInfo extends srmService.vim.DynamicData {
            browse?: string;
            read: string;
            modify: string;
            use: string;
            admin?: string;
            full: string;
         }
         interface HostFileAccess extends srmService.vim.DynamicData {
            who: string;
            what: string;
         }
         interface HostFileSystemVolumeInfo extends srmService.vim.DynamicData {
            volumeTypeList?: Array<string>;
            mountInfo?: Array<srmService.vim.HostFileSystemMountInfo>;
         }
         enum FileSystemMountInfoVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface HostFileSystemMountInfo extends srmService.vim.DynamicData {
            mountInfo: srmService.vim.HostMountInfo;
            volume: srmService.vim.HostFileSystemVolume;
            vStorageSupport?: string;
         }
         interface ArrayOfHostFileSystemMountInfo {
            hostFileSystemMountInfo?: Array<srmService.vim.HostFileSystemMountInfo>;
         }
         interface HostFileSystemVolume extends srmService.vim.DynamicData {
            type: string;
            name: string;
            capacity: number;
         }
         interface HostNasVolumeSpec extends srmService.vim.DynamicData {
            remoteHost: string;
            remotePath: string;
            localPath: string;
            accessMode: string;
            type?: string;
            userName?: string;
            password?: string;
         }
         interface HostNasVolumeConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            spec?: srmService.vim.HostNasVolumeSpec;
         }
         interface ArrayOfHostNasVolumeConfig {
            hostNasVolumeConfig?: Array<srmService.vim.HostNasVolumeConfig>;
         }
         interface HostNasVolume extends srmService.vim.HostFileSystemVolume {
            remoteHost: string;
            remotePath: string;
            userName?: string;
         }
         interface HostLocalFileSystemVolumeSpec extends srmService.vim.DynamicData {
            device: string;
            localPath: string;
         }
         interface HostLocalFileSystemVolume extends srmService.vim.HostFileSystemVolume {
            device: string;
         }
         interface HostVfatVolume extends srmService.vim.HostFileSystemVolume {
         }
         interface HostFirewallConfigRuleSetConfig extends srmService.vim.DynamicData {
            rulesetId: string;
            enabled: boolean;
            allowedHosts?: srmService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallConfigRuleSetConfig {
            hostFirewallConfigRuleSetConfig?: Array<srmService.vim.HostFirewallConfigRuleSetConfig>;
         }
         interface HostFirewallConfig extends srmService.vim.DynamicData {
            rule?: Array<srmService.vim.HostFirewallConfigRuleSetConfig>;
            defaultBlockingPolicy: srmService.vim.HostFirewallDefaultPolicy;
         }
         interface HostFirewallDefaultPolicy extends srmService.vim.DynamicData {
            incomingBlocked?: boolean;
            outgoingBlocked?: boolean;
         }
         interface HostFirewallInfo extends srmService.vim.DynamicData {
            defaultPolicy: srmService.vim.HostFirewallDefaultPolicy;
            ruleset?: Array<srmService.vim.HostFirewallRuleset>;
         }
         interface HostFlagInfo extends srmService.vim.DynamicData {
            backgroundSnapshotsEnabled?: boolean;
         }
         interface HostForceMountedInfo extends srmService.vim.DynamicData {
            persist: boolean;
            mounted: boolean;
         }
         enum HostGraphicsInfoGraphicsType {
            "basic",
            "shared",
            "direct",
         }
         interface HostGraphicsInfo extends srmService.vim.DynamicData {
            deviceName: string;
            vendorName: string;
            pciId: string;
            graphicsType: string;
            memorySizeInKB: number;
            vm?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface ArrayOfHostGraphicsInfo {
            hostGraphicsInfo?: Array<srmService.vim.HostGraphicsInfo>;
         }
         interface HostHardwareInfo extends srmService.vim.DynamicData {
            systemInfo: srmService.vim.HostSystemInfo;
            cpuPowerManagementInfo?: srmService.vim.HostCpuPowerManagementInfo;
            cpuInfo: srmService.vim.HostCpuInfo;
            cpuPkg: Array<srmService.vim.HostCpuPackage>;
            memorySize: number;
            numaInfo?: srmService.vim.HostNumaInfo;
            smcPresent?: boolean;
            pciDevice?: Array<srmService.vim.HostPciDevice>;
            cpuFeature?: Array<srmService.vim.HostCpuIdInfo>;
            biosInfo?: srmService.vim.HostBIOSInfo;
            reliableMemoryInfo?: srmService.vim.HostReliableMemoryInfo;
         }
         interface HostSystemInfo extends srmService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<srmService.vim.HostSystemIdentificationInfo>;
         }
         enum HostCpuPowerManagementInfoPolicyType {
            "off",
            "staticPolicy",
            "dynamicPolicy",
         }
         interface HostCpuPowerManagementInfo extends srmService.vim.DynamicData {
            currentPolicy?: string;
            hardwareSupport?: string;
         }
         interface HostCpuInfo extends srmService.vim.DynamicData {
            numCpuPackages: number;
            numCpuCores: number;
            numCpuThreads: number;
            hz: number;
         }
         enum HostCpuPackageVendor {
            "unknown",
            "intel",
            "amd",
         }
         interface HostCpuPackage extends srmService.vim.DynamicData {
            index: number;
            vendor: string;
            hz: number;
            busHz: number;
            description: string;
            threadId: Array<number>;
            cpuFeature?: Array<srmService.vim.HostCpuIdInfo>;
         }
         interface ArrayOfHostCpuPackage {
            hostCpuPackage?: Array<srmService.vim.HostCpuPackage>;
         }
         interface HostNumaInfo extends srmService.vim.DynamicData {
            type: string;
            numNodes: number;
            numaNode?: Array<srmService.vim.HostNumaNode>;
         }
         interface HostNumaNode extends srmService.vim.DynamicData {
            typeId: number;
            cpuID: Array<number>;
            memoryRangeBegin: number;
            memoryRangeLength: number;
         }
         interface ArrayOfHostNumaNode {
            hostNumaNode?: Array<srmService.vim.HostNumaNode>;
         }
         interface HostBIOSInfo extends srmService.vim.DynamicData {
            biosVersion?: string;
            releaseDate?: Date;
         }
         interface HostReliableMemoryInfo extends srmService.vim.DynamicData {
            memorySize: number;
         }
         enum HostHardwareElementStatus {
            "Unknown",
            "Green",
            "Yellow",
            "Red",
         }
         interface HostHardwareElementInfo extends srmService.vim.DynamicData {
            name: string;
            status: srmService.vim.ElementDescription;
         }
         interface ArrayOfHostHardwareElementInfo {
            hostHardwareElementInfo?: Array<srmService.vim.HostHardwareElementInfo>;
         }
         interface HostStorageOperationalInfo extends srmService.vim.DynamicData {
            property: string;
            value: string;
         }
         interface ArrayOfHostStorageOperationalInfo {
            hostStorageOperationalInfo?: Array<srmService.vim.HostStorageOperationalInfo>;
         }
         interface HostStorageElementInfo extends srmService.vim.HostHardwareElementInfo {
            operationalInfo?: Array<srmService.vim.HostStorageOperationalInfo>;
         }
         interface ArrayOfHostStorageElementInfo {
            hostStorageElementInfo?: Array<srmService.vim.HostStorageElementInfo>;
         }
         interface HostHardwareStatusInfo extends srmService.vim.DynamicData {
            memoryStatusInfo?: Array<srmService.vim.HostHardwareElementInfo>;
            cpuStatusInfo?: Array<srmService.vim.HostHardwareElementInfo>;
            storageStatusInfo?: Array<srmService.vim.HostStorageElementInfo>;
         }
         interface HealthSystemRuntime extends srmService.vim.DynamicData {
            systemHealthInfo?: srmService.vim.HostSystemHealthInfo;
            hardwareStatusInfo?: srmService.vim.HostHardwareStatusInfo;
         }
         interface HostHostBusAdapter extends srmService.vim.DynamicData {
            key?: string;
            device: string;
            bus: number;
            status: string;
            model: string;
            driver?: string;
            pci?: string;
         }
         interface ArrayOfHostHostBusAdapter {
            hostHostBusAdapter?: Array<srmService.vim.HostHostBusAdapter>;
         }
         interface HostParallelScsiHba extends srmService.vim.HostHostBusAdapter {
         }
         interface HostBlockHba extends srmService.vim.HostHostBusAdapter {
         }
         enum FibreChannelPortType {
            "fabric",
            "loop",
            "pointToPoint",
            "unknown",
         }
         interface HostFibreChannelHba extends srmService.vim.HostHostBusAdapter {
            portWorldWideName: number;
            nodeWorldWideName: number;
            portType: srmService.vim.FibreChannelPortType;
            speed: number;
         }
         interface HostInternetScsiHbaParamValue extends srmService.vim.OptionValue {
            isInherited?: boolean;
         }
         interface ArrayOfHostInternetScsiHbaParamValue {
            hostInternetScsiHbaParamValue?: Array<srmService.vim.HostInternetScsiHbaParamValue>;
         }
         interface HostInternetScsiHbaDiscoveryCapabilities extends srmService.vim.DynamicData {
            iSnsDiscoverySettable: boolean;
            slpDiscoverySettable: boolean;
            staticTargetDiscoverySettable: boolean;
            sendTargetsDiscoverySettable: boolean;
         }
         enum InternetScsiSnsDiscoveryMethod {
            "isnsStatic",
            "isnsDhcp",
            "isnsSlp",
         }
         enum SlpDiscoveryMethod {
            "slpDhcp",
            "slpAutoUnicast",
            "slpAutoMulticast",
            "slpManual",
         }
         interface HostInternetScsiHbaDiscoveryProperties extends srmService.vim.DynamicData {
            iSnsDiscoveryEnabled: boolean;
            iSnsDiscoveryMethod?: string;
            iSnsHost?: string;
            slpDiscoveryEnabled: boolean;
            slpDiscoveryMethod?: string;
            slpHost?: string;
            staticTargetDiscoveryEnabled: boolean;
            sendTargetsDiscoveryEnabled: boolean;
         }
         enum HostInternetScsiHbaChapAuthenticationType {
            "chapProhibited",
            "chapDiscouraged",
            "chapPreferred",
            "chapRequired",
         }
         interface HostInternetScsiHbaAuthenticationCapabilities extends srmService.vim.DynamicData {
            chapAuthSettable: boolean;
            krb5AuthSettable: boolean;
            srpAuthSettable: boolean;
            spkmAuthSettable: boolean;
            mutualChapSettable?: boolean;
            targetChapSettable?: boolean;
            targetMutualChapSettable?: boolean;
         }
         interface HostInternetScsiHbaAuthenticationProperties extends srmService.vim.DynamicData {
            chapAuthEnabled: boolean;
            chapName?: string;
            chapSecret?: string;
            chapAuthenticationType?: string;
            chapInherited?: boolean;
            mutualChapName?: string;
            mutualChapSecret?: string;
            mutualChapAuthenticationType?: string;
            mutualChapInherited?: boolean;
         }
         enum HostInternetScsiHbaDigestType {
            "digestProhibited",
            "digestDiscouraged",
            "digestPreferred",
            "digestRequired",
         }
         interface HostInternetScsiHbaDigestCapabilities extends srmService.vim.DynamicData {
            headerDigestSettable?: boolean;
            dataDigestSettable?: boolean;
            targetHeaderDigestSettable?: boolean;
            targetDataDigestSettable?: boolean;
         }
         interface HostInternetScsiHbaDigestProperties extends srmService.vim.DynamicData {
            headerDigestType?: string;
            headerDigestInherited?: boolean;
            dataDigestType?: string;
            dataDigestInherited?: boolean;
         }
         interface HostInternetScsiHbaIPCapabilities extends srmService.vim.DynamicData {
            addressSettable: boolean;
            ipConfigurationMethodSettable: boolean;
            subnetMaskSettable: boolean;
            defaultGatewaySettable: boolean;
            primaryDnsServerAddressSettable: boolean;
            alternateDnsServerAddressSettable: boolean;
            ipv6Supported?: boolean;
            arpRedirectSettable?: boolean;
            mtuSettable?: boolean;
            hostNameAsTargetAddress?: boolean;
            nameAliasSettable?: boolean;
         }
         interface HostInternetScsiHbaIPProperties extends srmService.vim.DynamicData {
            mac?: string;
            address?: string;
            dhcpConfigurationEnabled: boolean;
            subnetMask?: string;
            defaultGateway?: string;
            primaryDnsServerAddress?: string;
            alternateDnsServerAddress?: string;
            ipv6Address?: string;
            ipv6SubnetMask?: string;
            ipv6DefaultGateway?: string;
            arpRedirectEnabled?: boolean;
            mtu?: number;
            jumboFramesEnabled?: boolean;
         }
         interface HostInternetScsiHbaSendTarget extends srmService.vim.DynamicData {
            address: string;
            port?: number;
            authenticationProperties?: srmService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: srmService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<srmService.vim.OptionDef>;
            advancedOptions?: Array<srmService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaSendTarget {
            hostInternetScsiHbaSendTarget?: Array<srmService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaStaticTargetTargetDiscoveryMethod {
            "staticMethod",
            "sendTargetMethod",
            "slpMethod",
            "isnsMethod",
            "unknownMethod",
         }
         interface HostInternetScsiHbaStaticTarget extends srmService.vim.DynamicData {
            address: string;
            port?: number;
            iScsiName: string;
            discoveryMethod?: string;
            authenticationProperties?: srmService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: srmService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<srmService.vim.OptionDef>;
            advancedOptions?: Array<srmService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaStaticTarget {
            hostInternetScsiHbaStaticTarget?: Array<srmService.vim.HostInternetScsiHbaStaticTarget>;
         }
         interface HostInternetScsiHbaTargetSet extends srmService.vim.DynamicData {
            staticTargets?: Array<srmService.vim.HostInternetScsiHbaStaticTarget>;
            sendTargets?: Array<srmService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaNetworkBindingSupportType {
            "notsupported",
            "optional",
            "required",
         }
         interface HostInternetScsiHba extends srmService.vim.HostHostBusAdapter {
            isSoftwareBased: boolean;
            canBeDisabled?: boolean;
            networkBindingSupport?: srmService.vim.HostInternetScsiHbaNetworkBindingSupportType;
            discoveryCapabilities: srmService.vim.HostInternetScsiHbaDiscoveryCapabilities;
            discoveryProperties: srmService.vim.HostInternetScsiHbaDiscoveryProperties;
            authenticationCapabilities: srmService.vim.HostInternetScsiHbaAuthenticationCapabilities;
            authenticationProperties: srmService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestCapabilities?: srmService.vim.HostInternetScsiHbaDigestCapabilities;
            digestProperties?: srmService.vim.HostInternetScsiHbaDigestProperties;
            ipCapabilities: srmService.vim.HostInternetScsiHbaIPCapabilities;
            ipProperties: srmService.vim.HostInternetScsiHbaIPProperties;
            supportedAdvancedOptions?: Array<srmService.vim.OptionDef>;
            advancedOptions?: Array<srmService.vim.HostInternetScsiHbaParamValue>;
            iScsiName: string;
            iScsiAlias?: string;
            configuredSendTarget?: Array<srmService.vim.HostInternetScsiHbaSendTarget>;
            configuredStaticTarget?: Array<srmService.vim.HostInternetScsiHbaStaticTarget>;
            maxSpeedMb?: number;
            currentSpeedMb?: number;
         }
         interface HostFibreChannelOverEthernetHbaLinkInfo extends srmService.vim.DynamicData {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostFibreChannelOverEthernetHba extends srmService.vim.HostFibreChannelHba {
            underlyingNic: string;
            linkInfo: srmService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
            isSoftwareFcoe: boolean;
            markedForRemoval: boolean;
         }
         interface HostProxySwitchSpec extends srmService.vim.DynamicData {
            backing?: srmService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostProxySwitchConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            uuid: string;
            spec?: srmService.vim.HostProxySwitchSpec;
         }
         interface ArrayOfHostProxySwitchConfig {
            hostProxySwitchConfig?: Array<srmService.vim.HostProxySwitchConfig>;
         }
         interface HostProxySwitchHostLagConfig extends srmService.vim.DynamicData {
            lagKey: string;
            lagName?: string;
            uplinkPort?: Array<srmService.vim.KeyValue>;
         }
         interface ArrayOfHostProxySwitchHostLagConfig {
            hostProxySwitchHostLagConfig?: Array<srmService.vim.HostProxySwitchHostLagConfig>;
         }
         interface HostProxySwitch extends srmService.vim.DynamicData {
            dvsUuid: string;
            dvsName: string;
            key: string;
            numPorts: number;
            configNumPorts?: number;
            numPortsAvailable: number;
            uplinkPort?: Array<srmService.vim.KeyValue>;
            mtu?: number;
            pnic?: Array<string>;
            spec: srmService.vim.HostProxySwitchSpec;
            hostLag?: Array<srmService.vim.HostProxySwitchHostLagConfig>;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfHostProxySwitch {
            hostProxySwitch?: Array<srmService.vim.HostProxySwitch>;
         }
         enum HostImageAcceptanceLevel {
            "vmware_certified",
            "vmware_accepted",
            "partner",
            "community",
         }
         interface HostImageProfileSummary extends srmService.vim.DynamicData {
            name: string;
            vendor: string;
         }
         enum HostIpConfigIpV6AddressConfigType {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum HostIpConfigIpV6AddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface HostIpConfigIpV6Address extends srmService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            dadState?: string;
            lifetime?: Date;
            operation?: string;
         }
         interface ArrayOfHostIpConfigIpV6Address {
            hostIpConfigIpV6Address?: Array<srmService.vim.HostIpConfigIpV6Address>;
         }
         interface HostIpConfigIpV6AddressConfiguration extends srmService.vim.DynamicData {
            ipV6Address?: Array<srmService.vim.HostIpConfigIpV6Address>;
            autoConfigurationEnabled?: boolean;
            dhcpV6Enabled?: boolean;
         }
         interface HostIpConfig extends srmService.vim.DynamicData {
            dhcp: boolean;
            ipAddress?: string;
            subnetMask?: string;
            ipV6Config?: srmService.vim.HostIpConfigIpV6AddressConfiguration;
         }
         interface HostIpRouteConfig extends srmService.vim.DynamicData {
            defaultGateway?: string;
            gatewayDevice?: string;
            ipV6DefaultGateway?: string;
            ipV6GatewayDevice?: string;
         }
         interface HostIpRouteConfigSpec extends srmService.vim.HostIpRouteConfig {
            gatewayDeviceConnection?: srmService.vim.HostVirtualNicConnection;
            ipV6GatewayDeviceConnection?: srmService.vim.HostVirtualNicConnection;
         }
         interface HostIpRouteEntry extends srmService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: string;
            deviceName?: string;
         }
         interface ArrayOfHostIpRouteEntry {
            hostIpRouteEntry?: Array<srmService.vim.HostIpRouteEntry>;
         }
         interface HostIpRouteOp extends srmService.vim.DynamicData {
            changeOperation: string;
            route: srmService.vim.HostIpRouteEntry;
         }
         interface ArrayOfHostIpRouteOp {
            hostIpRouteOp?: Array<srmService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableConfig extends srmService.vim.DynamicData {
            ipRoute?: Array<srmService.vim.HostIpRouteOp>;
            ipv6Route?: Array<srmService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableInfo extends srmService.vim.DynamicData {
            ipRoute?: Array<srmService.vim.HostIpRouteEntry>;
            ipv6Route?: Array<srmService.vim.HostIpRouteEntry>;
         }
         interface HostIpmiInfo extends srmService.vim.DynamicData {
            bmcIpAddress?: string;
            bmcMacAddress?: string;
            login?: string;
            password?: string;
         }
         interface IscsiStatus extends srmService.vim.DynamicData {
            reason?: Array<srmService.vim.LocalizedMethodFault>;
         }
         enum IscsiPortInfoPathStatus {
            "notUsed",
            "active",
            "standBy",
            "lastActive",
         }
         interface IscsiPortInfo extends srmService.vim.DynamicData {
            vnicDevice?: string;
            vnic?: srmService.vim.HostVirtualNic;
            pnicDevice?: string;
            pnic?: srmService.vim.PhysicalNic;
            switchName?: string;
            switchUuid?: string;
            portgroupName?: string;
            portgroupKey?: string;
            portKey?: string;
            complianceStatus?: srmService.vim.IscsiStatus;
            pathStatus?: string;
         }
         interface ArrayOfIscsiPortInfo {
            iscsiPortInfo?: Array<srmService.vim.IscsiPortInfo>;
         }
         interface IscsiDependencyEntity extends srmService.vim.DynamicData {
            pnicDevice: string;
            vnicDevice: string;
            vmhbaName: string;
         }
         interface ArrayOfIscsiDependencyEntity {
            iscsiDependencyEntity?: Array<srmService.vim.IscsiDependencyEntity>;
         }
         interface IscsiMigrationDependency extends srmService.vim.DynamicData {
            migrationAllowed: boolean;
            disallowReason?: srmService.vim.IscsiStatus;
            dependency?: Array<srmService.vim.IscsiDependencyEntity>;
         }
         interface KernelModuleSectionInfo extends srmService.vim.DynamicData {
            address: number;
            length?: number;
         }
         interface KernelModuleInfo extends srmService.vim.DynamicData {
            id: number;
            name: string;
            version: string;
            filename: string;
            optionString: string;
            loaded: boolean;
            enabled: boolean;
            useCount: number;
            readOnlySection: srmService.vim.KernelModuleSectionInfo;
            writableSection: srmService.vim.KernelModuleSectionInfo;
            textSection: srmService.vim.KernelModuleSectionInfo;
            dataSection: srmService.vim.KernelModuleSectionInfo;
            bssSection: srmService.vim.KernelModuleSectionInfo;
         }
         interface ArrayOfKernelModuleInfo {
            kernelModuleInfo?: Array<srmService.vim.KernelModuleInfo>;
         }
         interface HostLicenseSpec extends srmService.vim.DynamicData {
            source?: srmService.vim.LicenseSource;
            editionKey?: string;
            disabledFeatureKey?: Array<string>;
            enabledFeatureKey?: Array<string>;
         }
         enum LinkDiscoveryProtocolConfigProtocolType {
            "cdp",
            "lldp",
         }
         enum LinkDiscoveryProtocolConfigOperationType {
            "none",
            "listen",
            "advertise",
            "both",
         }
         interface LinkDiscoveryProtocolConfig extends srmService.vim.DynamicData {
            protocol: string;
            operation: string;
         }
         interface HostAccountSpec extends srmService.vim.DynamicData {
            id: string;
            password?: string;
            description?: string;
         }
         interface ArrayOfHostAccountSpec {
            hostAccountSpec?: Array<srmService.vim.HostAccountSpec>;
         }
         interface HostPosixAccountSpec extends srmService.vim.HostAccountSpec {
            posixId?: number;
            shellAccess?: boolean;
         }
         interface HostLocalAuthenticationInfo extends srmService.vim.HostAuthenticationStoreInfo {
         }
         interface HostLowLevelProvisioningManagerVmRecoveryInfo extends srmService.vim.DynamicData {
            version: string;
            biosUUID: string;
            instanceUUID: string;
            ftInfo?: srmService.vim.FaultToleranceConfigInfo;
         }
         interface HostLowLevelProvisioningManagerVmMigrationStatus extends srmService.vim.DynamicData {
            migrationId: number;
            type: string;
            source: boolean;
            consideredSuccessful: boolean;
         }
         enum HostLowLevelProvisioningManagerReloadTarget {
            "currentConfig",
            "snapshotConfig",
         }
         interface HostLowLevelProvisioningManagerDiskLayoutSpec extends srmService.vim.DynamicData {
            controllerType: string;
            busNumber: number;
            unitNumber: number;
            srcFilename: string;
            dstFilename: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec {
            hostLowLevelProvisioningManagerDiskLayoutSpec?: Array<srmService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface HostLowLevelProvisioningManagerSnapshotLayoutSpec extends srmService.vim.DynamicData {
            id: number;
            srcFilename: string;
            dstFilename: string;
            disk?: Array<srmService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec {
            hostLowLevelProvisioningManagerSnapshotLayoutSpec?: Array<srmService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec>;
         }
         interface HostMaintenanceSpec extends srmService.vim.DynamicData {
            vsanMode?: srmService.vim.VsanHostDecommissionMode;
         }
         interface ServiceConsoleReservationInfo extends srmService.vim.DynamicData {
            serviceConsoleReservedCfg: number;
            serviceConsoleReserved: number;
            unreserved: number;
         }
         enum VirtualMachineMemoryAllocationPolicy {
            "swapNone",
            "swapSome",
            "swapMost",
         }
         interface VirtualMachineMemoryReservationInfo extends srmService.vim.DynamicData {
            virtualMachineMin: number;
            virtualMachineMax: number;
            virtualMachineReserved: number;
            allocationPolicy: string;
         }
         interface VirtualMachineMemoryReservationSpec extends srmService.vim.DynamicData {
            virtualMachineReserved?: number;
            allocationPolicy?: string;
         }
         interface HostMemorySpec extends srmService.vim.DynamicData {
            serviceConsoleReservation?: number;
         }
         enum HostMountMode {
            "readWrite",
            "readOnly",
         }
         enum HostMountInfoInaccessibleReason {
            "AllPathsDown_Start",
            "AllPathsDown_Timeout",
            "PermanentDeviceLoss",
         }
         interface HostMountInfo extends srmService.vim.DynamicData {
            path?: string;
            accessMode: string;
            mounted?: boolean;
            accessible?: boolean;
            inaccessibleReason?: string;
         }
         enum MultipathState {
            "standby",
            "active",
            "disabled",
            "dead",
            "unknown",
         }
         interface HostMultipathInfoLogicalUnitPolicy extends srmService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoLogicalUnitStorageArrayTypePolicy extends srmService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoFixedLogicalUnitPolicy extends srmService.vim.HostMultipathInfoLogicalUnitPolicy {
            prefer: string;
         }
         interface HostMultipathInfoLogicalUnit extends srmService.vim.DynamicData {
            key: string;
            id: string;
            lun: string;
            path: Array<srmService.vim.HostMultipathInfoPath>;
            policy: srmService.vim.HostMultipathInfoLogicalUnitPolicy;
            storageArrayTypePolicy?: srmService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         }
         interface ArrayOfHostMultipathInfoLogicalUnit {
            hostMultipathInfoLogicalUnit?: Array<srmService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathInfoPath extends srmService.vim.DynamicData {
            key: string;
            name: string;
            pathState: string;
            state?: string;
            isWorkingPath?: boolean;
            adapter: string;
            lun: string;
            transport?: srmService.vim.HostTargetTransport;
         }
         interface ArrayOfHostMultipathInfoPath {
            hostMultipathInfoPath?: Array<srmService.vim.HostMultipathInfoPath>;
         }
         interface HostMultipathInfo extends srmService.vim.DynamicData {
            lun?: Array<srmService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathStateInfoPath extends srmService.vim.DynamicData {
            name: string;
            pathState: string;
         }
         interface ArrayOfHostMultipathStateInfoPath {
            hostMultipathStateInfoPath?: Array<srmService.vim.HostMultipathStateInfoPath>;
         }
         interface HostMultipathStateInfo extends srmService.vim.DynamicData {
            path?: Array<srmService.vim.HostMultipathStateInfoPath>;
         }
         interface HostNatServicePortForwardSpec extends srmService.vim.DynamicData {
            type: string;
            name: string;
            hostPort: number;
            guestPort: number;
            guestIpAddress: string;
         }
         interface ArrayOfHostNatServicePortForwardSpec {
            hostNatServicePortForwardSpec?: Array<srmService.vim.HostNatServicePortForwardSpec>;
         }
         interface HostNatServiceNameServiceSpec extends srmService.vim.DynamicData {
            dnsAutoDetect: boolean;
            dnsPolicy: string;
            dnsRetries: number;
            dnsTimeout: number;
            dnsNameServer?: Array<string>;
            nbdsTimeout: number;
            nbnsRetries: number;
            nbnsTimeout: number;
         }
         interface HostNatServiceSpec extends srmService.vim.DynamicData {
            virtualSwitch: string;
            activeFtp: boolean;
            allowAnyOui: boolean;
            configPort: boolean;
            ipGatewayAddress: string;
            udpTimeout: number;
            portForward?: Array<srmService.vim.HostNatServicePortForwardSpec>;
            nameService?: srmService.vim.HostNatServiceNameServiceSpec;
         }
         interface HostNatServiceConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: srmService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatServiceConfig {
            hostNatServiceConfig?: Array<srmService.vim.HostNatServiceConfig>;
         }
         interface HostNatService extends srmService.vim.DynamicData {
            key: string;
            spec: srmService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatService {
            hostNatService?: Array<srmService.vim.HostNatService>;
         }
         interface HostNetCapabilities extends srmService.vim.DynamicData {
            canSetPhysicalNicLinkSpeed: boolean;
            supportsNicTeaming: boolean;
            nicTeamingPolicy?: Array<string>;
            supportsVlan: boolean;
            usesServiceConsoleNic: boolean;
            supportsNetworkHints: boolean;
            maxPortGroupsPerVswitch?: number;
            vswitchConfigSupported: boolean;
            vnicConfigSupported: boolean;
            ipRouteConfigSupported: boolean;
            dnsConfigSupported: boolean;
            dhcpOnVnicSupported: boolean;
            ipV6Supported?: boolean;
         }
         interface HostNetOffloadCapabilities extends srmService.vim.DynamicData {
            csumOffload?: boolean;
            tcpSegmentation?: boolean;
            zeroCopyXmit?: boolean;
         }
         enum HostNetStackInstanceSystemStackKey {
            "defaultTcpipStack",
         }
         enum HostNetStackInstanceCongestionControlAlgorithmType {
            "newreno",
            "cubic",
         }
         interface HostNetStackInstance extends srmService.vim.DynamicData {
            key?: string;
            name?: string;
            dnsConfig?: srmService.vim.HostDnsConfig;
            ipRouteConfig?: srmService.vim.HostIpRouteConfig;
            requestedMaxNumberOfConnections?: number;
            congestionControlAlgorithm?: string;
            ipV6Enabled?: boolean;
            routeTableConfig?: srmService.vim.HostIpRouteTableConfig;
         }
         interface ArrayOfHostNetStackInstance {
            hostNetStackInstance?: Array<srmService.vim.HostNetStackInstance>;
         }
         interface HostNetworkConfigResult extends srmService.vim.DynamicData {
            vnicDevice?: Array<string>;
            consoleVnicDevice?: Array<string>;
         }
         interface HostNetworkConfigNetStackSpec extends srmService.vim.DynamicData {
            netStackInstance: srmService.vim.HostNetStackInstance;
            operation?: string;
         }
         interface ArrayOfHostNetworkConfigNetStackSpec {
            hostNetworkConfigNetStackSpec?: Array<srmService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkConfig extends srmService.vim.DynamicData {
            vswitch?: Array<srmService.vim.HostVirtualSwitchConfig>;
            proxySwitch?: Array<srmService.vim.HostProxySwitchConfig>;
            portgroup?: Array<srmService.vim.HostPortGroupConfig>;
            pnic?: Array<srmService.vim.PhysicalNicConfig>;
            vnic?: Array<srmService.vim.HostVirtualNicConfig>;
            consoleVnic?: Array<srmService.vim.HostVirtualNicConfig>;
            dnsConfig?: srmService.vim.HostDnsConfig;
            ipRouteConfig?: srmService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: srmService.vim.HostIpRouteConfig;
            routeTableConfig?: srmService.vim.HostIpRouteTableConfig;
            dhcp?: Array<srmService.vim.HostDhcpServiceConfig>;
            nat?: Array<srmService.vim.HostNatServiceConfig>;
            ipV6Enabled?: boolean;
            netStackSpec?: Array<srmService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkInfo extends srmService.vim.DynamicData {
            vswitch?: Array<srmService.vim.HostVirtualSwitch>;
            proxySwitch?: Array<srmService.vim.HostProxySwitch>;
            portgroup?: Array<srmService.vim.HostPortGroup>;
            pnic?: Array<srmService.vim.PhysicalNic>;
            vnic?: Array<srmService.vim.HostVirtualNic>;
            consoleVnic?: Array<srmService.vim.HostVirtualNic>;
            dnsConfig?: srmService.vim.HostDnsConfig;
            ipRouteConfig?: srmService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: srmService.vim.HostIpRouteConfig;
            routeTableInfo?: srmService.vim.HostIpRouteTableInfo;
            dhcp?: Array<srmService.vim.HostDhcpService>;
            nat?: Array<srmService.vim.HostNatService>;
            ipV6Enabled?: boolean;
            atBootIpV6Enabled?: boolean;
            netStackInstance?: Array<srmService.vim.HostNetStackInstance>;
            opaqueSwitch?: Array<srmService.vim.HostOpaqueSwitch>;
            opaqueNetwork?: Array<srmService.vim.HostOpaqueNetworkInfo>;
         }
         interface HostNetworkSecurityPolicy extends srmService.vim.DynamicData {
            allowPromiscuous?: boolean;
            macChanges?: boolean;
            forgedTransmits?: boolean;
         }
         interface HostNetworkTrafficShapingPolicy extends srmService.vim.DynamicData {
            enabled?: boolean;
            averageBandwidth?: number;
            peakBandwidth?: number;
            burstSize?: number;
         }
         interface HostNicFailureCriteria extends srmService.vim.DynamicData {
            checkSpeed?: string;
            speed?: number;
            checkDuplex?: boolean;
            fullDuplex?: boolean;
            checkErrorPercent?: boolean;
            percentage?: number;
            checkBeacon?: boolean;
         }
         interface HostNicOrderPolicy extends srmService.vim.DynamicData {
            activeNic?: Array<string>;
            standbyNic?: Array<string>;
         }
         interface HostNicTeamingPolicy extends srmService.vim.DynamicData {
            policy?: string;
            reversePolicy?: boolean;
            notifySwitches?: boolean;
            rollingOrder?: boolean;
            failureCriteria?: srmService.vim.HostNicFailureCriteria;
            nicOrder?: srmService.vim.HostNicOrderPolicy;
         }
         interface HostNetworkPolicy extends srmService.vim.DynamicData {
            security?: srmService.vim.HostNetworkSecurityPolicy;
            nicTeaming?: srmService.vim.HostNicTeamingPolicy;
            offloadPolicy?: srmService.vim.HostNetOffloadCapabilities;
            shapingPolicy?: srmService.vim.HostNetworkTrafficShapingPolicy;
         }
         interface HostNtpConfig extends srmService.vim.DynamicData {
            server?: Array<string>;
         }
         enum HostNumericSensorHealthState {
            "unknown",
            "green",
            "yellow",
            "red",
         }
         enum HostNumericSensorType {
            "fan",
            "power",
            "temperature",
            "voltage",
            "other",
         }
         interface HostNumericSensorInfo extends srmService.vim.DynamicData {
            name: string;
            healthState?: srmService.vim.ElementDescription;
            currentReading: number;
            unitModifier: number;
            baseUnits: string;
            rateUnits?: string;
            sensorType: string;
         }
         interface ArrayOfHostNumericSensorInfo {
            hostNumericSensorInfo?: Array<srmService.vim.HostNumericSensorInfo>;
         }
         interface HostOpaqueNetworkInfo extends srmService.vim.DynamicData {
            opaqueNetworkId: string;
            opaqueNetworkName: string;
            opaqueNetworkType: string;
         }
         interface ArrayOfHostOpaqueNetworkInfo {
            hostOpaqueNetworkInfo?: Array<srmService.vim.HostOpaqueNetworkInfo>;
         }
         interface HostOpaqueSwitch extends srmService.vim.DynamicData {
            key: string;
            name?: string;
            pnic?: Array<string>;
         }
         interface ArrayOfHostOpaqueSwitch {
            hostOpaqueSwitch?: Array<srmService.vim.HostOpaqueSwitch>;
         }
         interface HostPatchManagerResult extends srmService.vim.DynamicData {
            version: string;
            status?: Array<srmService.vim.HostPatchManagerStatus>;
            xmlResult?: string;
         }
         enum HostPatchManagerReason {
            "obsoleted",
            "missingPatch",
            "missingLib",
            "hasDependentPatch",
            "conflictPatch",
            "conflictLib",
         }
         enum HostPatchManagerIntegrityStatus {
            "validated",
            "keyNotFound",
            "keyRevoked",
            "keyExpired",
            "digestMismatch",
            "notEnoughSignatures",
            "validationError",
         }
         enum HostPatchManagerInstallState {
            "hostRestarted",
            "imageActive",
         }
         interface HostPatchManagerStatusPrerequisitePatch extends srmService.vim.DynamicData {
            id: string;
            installState?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatusPrerequisitePatch {
            hostPatchManagerStatusPrerequisitePatch?: Array<srmService.vim.HostPatchManagerStatusPrerequisitePatch>;
         }
         interface HostPatchManagerStatus extends srmService.vim.DynamicData {
            id: string;
            applicable: boolean;
            reason?: Array<string>;
            integrity?: string;
            installed: boolean;
            installState?: Array<string>;
            prerequisitePatch?: Array<srmService.vim.HostPatchManagerStatusPrerequisitePatch>;
            restartRequired: boolean;
            reconnectRequired: boolean;
            vmOffRequired: boolean;
            supersededPatchIds?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatus {
            hostPatchManagerStatus?: Array<srmService.vim.HostPatchManagerStatus>;
         }
         interface HostPatchManagerLocator extends srmService.vim.DynamicData {
            url: string;
            proxy?: string;
         }
         interface HostPatchManagerPatchManagerOperationSpec extends srmService.vim.DynamicData {
            proxy?: string;
            port?: number;
            userName?: string;
            password?: string;
            cmdOption?: string;
         }
         interface HostPathSelectionPolicyOption extends srmService.vim.DynamicData {
            policy: srmService.vim.ElementDescription;
         }
         interface ArrayOfHostPathSelectionPolicyOption {
            hostPathSelectionPolicyOption?: Array<srmService.vim.HostPathSelectionPolicyOption>;
         }
         interface HostPciDevice extends srmService.vim.DynamicData {
            id: string;
            classId: number;
            bus: number;
            slot: number;
            function: number;
            vendorId: number;
            subVendorId: number;
            vendorName: string;
            deviceId: number;
            subDeviceId: number;
            parentBridge?: string;
            deviceName: string;
         }
         interface ArrayOfHostPciDevice {
            hostPciDevice?: Array<srmService.vim.HostPciDevice>;
         }
         interface HostPciPassthruConfig extends srmService.vim.DynamicData {
            id: string;
            passthruEnabled: boolean;
         }
         interface ArrayOfHostPciPassthruConfig {
            hostPciPassthruConfig?: Array<srmService.vim.HostPciPassthruConfig>;
         }
         interface HostPciPassthruInfo extends srmService.vim.DynamicData {
            id: string;
            dependentDevice: string;
            passthruEnabled: boolean;
            passthruCapable: boolean;
            passthruActive: boolean;
         }
         interface ArrayOfHostPciPassthruInfo {
            hostPciPassthruInfo?: Array<srmService.vim.HostPciPassthruInfo>;
         }
         interface PhysicalNicSpec extends srmService.vim.DynamicData {
            ip?: srmService.vim.HostIpConfig;
            linkSpeed?: srmService.vim.PhysicalNicLinkInfo;
         }
         interface PhysicalNicConfig extends srmService.vim.DynamicData {
            device: string;
            spec: srmService.vim.PhysicalNicSpec;
         }
         interface ArrayOfPhysicalNicConfig {
            physicalNicConfig?: Array<srmService.vim.PhysicalNicConfig>;
         }
         interface PhysicalNicLinkInfo extends srmService.vim.DynamicData {
            speedMb: number;
            duplex: boolean;
         }
         interface ArrayOfPhysicalNicLinkInfo {
            physicalNicLinkInfo?: Array<srmService.vim.PhysicalNicLinkInfo>;
         }
         interface PhysicalNicHint extends srmService.vim.DynamicData {
            vlanId?: number;
         }
         interface PhysicalNicIpHint extends srmService.vim.PhysicalNicHint {
            ipSubnet: string;
         }
         interface ArrayOfPhysicalNicIpHint {
            physicalNicIpHint?: Array<srmService.vim.PhysicalNicIpHint>;
         }
         interface PhysicalNicNameHint extends srmService.vim.PhysicalNicHint {
            network: string;
         }
         interface ArrayOfPhysicalNicNameHint {
            physicalNicNameHint?: Array<srmService.vim.PhysicalNicNameHint>;
         }
         interface PhysicalNicHintInfo extends srmService.vim.DynamicData {
            device: string;
            subnet?: Array<srmService.vim.PhysicalNicIpHint>;
            network?: Array<srmService.vim.PhysicalNicNameHint>;
            connectedSwitchPort?: srmService.vim.PhysicalNicCdpInfo;
            lldpInfo?: srmService.vim.LinkLayerDiscoveryProtocolInfo;
         }
         interface ArrayOfPhysicalNicHintInfo {
            physicalNicHintInfo?: Array<srmService.vim.PhysicalNicHintInfo>;
         }
         interface PhysicalNicCdpDeviceCapability extends srmService.vim.DynamicData {
            router: boolean;
            transparentBridge: boolean;
            sourceRouteBridge: boolean;
            networkSwitch: boolean;
            host: boolean;
            igmpEnabled: boolean;
            repeater: boolean;
         }
         interface PhysicalNicCdpInfo extends srmService.vim.DynamicData {
            cdpVersion?: number;
            timeout?: number;
            ttl?: number;
            samples?: number;
            devId?: string;
            address?: string;
            portId?: string;
            deviceCapability?: srmService.vim.PhysicalNicCdpDeviceCapability;
            softwareVersion?: string;
            hardwarePlatform?: string;
            ipPrefix?: string;
            ipPrefixLen?: number;
            vlan?: number;
            fullDuplex?: boolean;
            mtu?: number;
            systemName?: string;
            systemOID?: string;
            mgmtAddr?: string;
            location?: string;
         }
         interface LinkLayerDiscoveryProtocolInfo extends srmService.vim.DynamicData {
            chassisId: string;
            portId: string;
            timeToLive: number;
            parameter?: Array<srmService.vim.KeyAnyValue>;
         }
         enum PhysicalNicVmDirectPathGen2SupportedMode {
            "upt",
         }
         enum PhysicalNicResourcePoolSchedulerDisallowedReason {
            "userOptOut",
            "hardwareUnsupported",
         }
         interface PhysicalNic extends srmService.vim.DynamicData {
            key?: string;
            device: string;
            pci: string;
            driver?: string;
            linkSpeed?: srmService.vim.PhysicalNicLinkInfo;
            validLinkSpecification?: Array<srmService.vim.PhysicalNicLinkInfo>;
            spec: srmService.vim.PhysicalNicSpec;
            wakeOnLanSupported: boolean;
            mac: string;
            fcoeConfiguration?: srmService.vim.FcoeConfig;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2SupportedMode?: string;
            resourcePoolSchedulerAllowed?: boolean;
            resourcePoolSchedulerDisallowedReason?: Array<string>;
            autoNegotiateSupported?: boolean;
         }
         interface ArrayOfPhysicalNic {
            physicalNic?: Array<srmService.vim.PhysicalNic>;
         }
         interface HostPlugStoreTopologyAdapter extends srmService.vim.DynamicData {
            key: string;
            adapter: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyAdapter {
            hostPlugStoreTopologyAdapter?: Array<srmService.vim.HostPlugStoreTopologyAdapter>;
         }
         interface HostPlugStoreTopologyPath extends srmService.vim.DynamicData {
            key: string;
            name: string;
            channelNumber?: number;
            targetNumber?: number;
            lunNumber?: number;
            adapter?: string;
            target?: string;
            device?: string;
         }
         interface ArrayOfHostPlugStoreTopologyPath {
            hostPlugStoreTopologyPath?: Array<srmService.vim.HostPlugStoreTopologyPath>;
         }
         interface HostPlugStoreTopologyDevice extends srmService.vim.DynamicData {
            key: string;
            lun: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyDevice {
            hostPlugStoreTopologyDevice?: Array<srmService.vim.HostPlugStoreTopologyDevice>;
         }
         interface HostPlugStoreTopologyPlugin extends srmService.vim.DynamicData {
            key: string;
            name: string;
            device?: Array<string>;
            claimedPath?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyPlugin {
            hostPlugStoreTopologyPlugin?: Array<srmService.vim.HostPlugStoreTopologyPlugin>;
         }
         interface HostPlugStoreTopologyTarget extends srmService.vim.DynamicData {
            key: string;
            transport?: srmService.vim.HostTargetTransport;
         }
         interface ArrayOfHostPlugStoreTopologyTarget {
            hostPlugStoreTopologyTarget?: Array<srmService.vim.HostPlugStoreTopologyTarget>;
         }
         interface HostPlugStoreTopology extends srmService.vim.DynamicData {
            adapter?: Array<srmService.vim.HostPlugStoreTopologyAdapter>;
            path?: Array<srmService.vim.HostPlugStoreTopologyPath>;
            target?: Array<srmService.vim.HostPlugStoreTopologyTarget>;
            device?: Array<srmService.vim.HostPlugStoreTopologyDevice>;
            plugin?: Array<srmService.vim.HostPlugStoreTopologyPlugin>;
         }
         enum PortGroupConnecteeType {
            "virtualMachine",
            "systemManagement",
            "host",
            "unknown",
         }
         interface HostPortGroupSpec extends srmService.vim.DynamicData {
            name: string;
            vlanId: number;
            vswitchName: string;
            policy: srmService.vim.HostNetworkPolicy;
         }
         interface HostPortGroupConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            spec?: srmService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroupConfig {
            hostPortGroupConfig?: Array<srmService.vim.HostPortGroupConfig>;
         }
         interface HostPortGroupPort extends srmService.vim.DynamicData {
            key?: string;
            mac?: Array<string>;
            type: string;
         }
         interface ArrayOfHostPortGroupPort {
            hostPortGroupPort?: Array<srmService.vim.HostPortGroupPort>;
         }
         interface HostPortGroup extends srmService.vim.DynamicData {
            key?: string;
            port?: Array<srmService.vim.HostPortGroupPort>;
            vswitch?: string;
            computedPolicy: srmService.vim.HostNetworkPolicy;
            spec: srmService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroup {
            hostPortGroup?: Array<srmService.vim.HostPortGroup>;
         }
         interface HostPowerPolicy extends srmService.vim.DynamicData {
            key: number;
            name: string;
            shortName: string;
            description: string;
         }
         interface ArrayOfHostPowerPolicy {
            hostPowerPolicy?: Array<srmService.vim.HostPowerPolicy>;
         }
         interface PowerSystemCapability extends srmService.vim.DynamicData {
            availablePolicy: Array<srmService.vim.HostPowerPolicy>;
         }
         interface PowerSystemInfo extends srmService.vim.DynamicData {
            currentPolicy: srmService.vim.HostPowerPolicy;
         }
         interface HostResignatureRescanResult extends srmService.vim.DynamicData {
            rescan?: Array<srmService.vim.HostVmfsRescanResult>;
            result: srmService.vim.ManagedObjectReference;
         }
         interface HostFirewallRulesetIpNetwork extends srmService.vim.DynamicData {
            network: string;
            prefixLength: number;
         }
         interface ArrayOfHostFirewallRulesetIpNetwork {
            hostFirewallRulesetIpNetwork?: Array<srmService.vim.HostFirewallRulesetIpNetwork>;
         }
         interface HostFirewallRulesetIpList extends srmService.vim.DynamicData {
            ipAddress?: Array<string>;
            ipNetwork?: Array<srmService.vim.HostFirewallRulesetIpNetwork>;
            allIp: boolean;
         }
         interface HostFirewallRulesetRulesetSpec extends srmService.vim.DynamicData {
            allowedHosts: srmService.vim.HostFirewallRulesetIpList;
         }
         enum HostFirewallRuleDirection {
            "inbound",
            "outbound",
         }
         enum HostFirewallRulePortType {
            "src",
            "dst",
         }
         enum HostFirewallRuleProtocol {
            "tcp",
            "udp",
         }
         interface HostFirewallRule extends srmService.vim.DynamicData {
            port: number;
            endPort?: number;
            direction: srmService.vim.HostFirewallRuleDirection;
            portType?: srmService.vim.HostFirewallRulePortType;
            protocol: string;
         }
         interface ArrayOfHostFirewallRule {
            hostFirewallRule?: Array<srmService.vim.HostFirewallRule>;
         }
         interface HostFirewallRuleset extends srmService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            rule: Array<srmService.vim.HostFirewallRule>;
            service?: string;
            enabled: boolean;
            allowedHosts?: srmService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallRuleset {
            hostFirewallRuleset?: Array<srmService.vim.HostFirewallRuleset>;
         }
         enum HostRuntimeInfoNetStackInstanceRuntimeInfoState {
            "inactive",
            "active",
            "deactivating",
            "activating",
         }
         interface HostRuntimeInfoNetStackInstanceRuntimeInfo extends srmService.vim.DynamicData {
            netStackInstanceKey: string;
            state?: string;
            vmknicKeys?: Array<string>;
            maxNumberOfConnections?: number;
            currentIpV6Enabled?: boolean;
         }
         interface ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo {
            hostRuntimeInfoNetStackInstanceRuntimeInfo?: Array<srmService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
         }
         interface HostRuntimeInfoNetworkRuntimeInfo extends srmService.vim.DynamicData {
            netStackInstanceRuntimeInfo?: Array<srmService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
         }
         interface HostRuntimeInfo extends srmService.vim.DynamicData {
            connectionState: srmService.vim.HostSystemConnectionState;
            powerState: srmService.vim.HostSystemPowerState;
            standbyMode?: string;
            inMaintenanceMode: boolean;
            bootTime?: Date;
            healthSystemRuntime?: srmService.vim.HealthSystemRuntime;
            dasHostState?: srmService.vim.ClusterDasFdmHostState;
            tpmPcrValues?: Array<srmService.vim.HostTpmDigestInfo>;
            vsanRuntimeInfo?: srmService.vim.VsanHostRuntimeInfo;
            networkRuntimeInfo?: srmService.vim.HostRuntimeInfoNetworkRuntimeInfo;
            vFlashResourceRuntimeInfo?: srmService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
            hostMaxVirtualDiskCapacity?: number;
         }
         interface HostScsiDiskPartition extends srmService.vim.DynamicData {
            diskName: string;
            partition: number;
         }
         interface ArrayOfHostScsiDiskPartition {
            hostScsiDiskPartition?: Array<srmService.vim.HostScsiDiskPartition>;
         }
         interface HostScsiDisk extends srmService.vim.ScsiLun {
            capacity: srmService.vim.HostDiskDimensionsLba;
            devicePath: string;
            ssd?: boolean;
         }
         interface ArrayOfHostScsiDisk {
            hostScsiDisk?: Array<srmService.vim.HostScsiDisk>;
         }
         enum ScsiLunType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "opticalDevice",
            "mediaChanger",
            "communications",
            "storageArrayController",
            "enclosure",
            "unknown",
         }
         interface ScsiLunCapabilities extends srmService.vim.DynamicData {
            updateDisplayNameSupported: boolean;
         }
         interface ScsiLunDurableName extends srmService.vim.DynamicData {
            namespace: string;
            namespaceId: number;
            data?: Array<number>;
         }
         interface ArrayOfScsiLunDurableName {
            scsiLunDurableName?: Array<srmService.vim.ScsiLunDurableName>;
         }
         enum ScsiLunState {
            "unknownState",
            "ok",
            "error",
            "off",
            "quiesced",
            "degraded",
            "lostCommunication",
            "timeout",
         }
         enum ScsiLunDescriptorQuality {
            "highQuality",
            "mediumQuality",
            "lowQuality",
            "unknownQuality",
         }
         interface ScsiLunDescriptor extends srmService.vim.DynamicData {
            quality: string;
            id: string;
         }
         interface ArrayOfScsiLunDescriptor {
            scsiLunDescriptor?: Array<srmService.vim.ScsiLunDescriptor>;
         }
         enum ScsiLunVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface ScsiLun extends srmService.vim.HostDevice {
            key?: string;
            uuid: string;
            descriptor?: Array<srmService.vim.ScsiLunDescriptor>;
            canonicalName?: string;
            displayName?: string;
            lunType: string;
            vendor?: string;
            model?: string;
            revision?: string;
            scsiLevel?: number;
            serialNumber?: string;
            durableName?: srmService.vim.ScsiLunDurableName;
            alternateName?: Array<srmService.vim.ScsiLunDurableName>;
            standardInquiry?: Array<number>;
            queueDepth?: number;
            operationalState: Array<string>;
            capabilities?: srmService.vim.ScsiLunCapabilities;
            vStorageSupport?: string;
         }
         interface ArrayOfScsiLun {
            scsiLun?: Array<srmService.vim.ScsiLun>;
         }
         interface HostScsiTopologyInterface extends srmService.vim.DynamicData {
            key: string;
            adapter: string;
            target?: Array<srmService.vim.HostScsiTopologyTarget>;
         }
         interface ArrayOfHostScsiTopologyInterface {
            hostScsiTopologyInterface?: Array<srmService.vim.HostScsiTopologyInterface>;
         }
         interface HostScsiTopologyTarget extends srmService.vim.DynamicData {
            key: string;
            target: number;
            lun?: Array<srmService.vim.HostScsiTopologyLun>;
            transport?: srmService.vim.HostTargetTransport;
         }
         interface ArrayOfHostScsiTopologyTarget {
            hostScsiTopologyTarget?: Array<srmService.vim.HostScsiTopologyTarget>;
         }
         interface HostScsiTopologyLun extends srmService.vim.DynamicData {
            key: string;
            lun: number;
            scsiLun: string;
         }
         interface ArrayOfHostScsiTopologyLun {
            hostScsiTopologyLun?: Array<srmService.vim.HostScsiTopologyLun>;
         }
         interface HostScsiTopology extends srmService.vim.DynamicData {
            adapter?: Array<srmService.vim.HostScsiTopologyInterface>;
         }
         interface HostSecuritySpec extends srmService.vim.DynamicData {
            adminPassword?: string;
            removePermission?: Array<srmService.vim.Permission>;
            addPermission?: Array<srmService.vim.Permission>;
         }
         enum HostServicePolicy {
            "on",
            "automatic",
            "off",
         }
         interface HostServiceSourcePackage extends srmService.vim.DynamicData {
            sourcePackageName: string;
            description: string;
         }
         interface HostService extends srmService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            uninstallable: boolean;
            running: boolean;
            ruleset?: Array<string>;
            policy: string;
            sourcePackage?: srmService.vim.HostServiceSourcePackage;
         }
         interface ArrayOfHostService {
            hostService?: Array<srmService.vim.HostService>;
         }
         interface HostServiceConfig extends srmService.vim.DynamicData {
            serviceId: string;
            startupPolicy: string;
         }
         interface ArrayOfHostServiceConfig {
            hostServiceConfig?: Array<srmService.vim.HostServiceConfig>;
         }
         interface HostServiceInfo extends srmService.vim.DynamicData {
            service?: Array<srmService.vim.HostService>;
         }
         interface HostSnmpDestination extends srmService.vim.DynamicData {
            hostName: string;
            port: number;
            community: string;
         }
         interface ArrayOfHostSnmpDestination {
            hostSnmpDestination?: Array<srmService.vim.HostSnmpDestination>;
         }
         interface HostSnmpConfigSpec extends srmService.vim.DynamicData {
            enabled?: boolean;
            port?: number;
            readOnlyCommunities?: Array<string>;
            trapTargets?: Array<srmService.vim.HostSnmpDestination>;
            option?: Array<srmService.vim.KeyValue>;
         }
         enum HostSnmpAgentCapability {
            "COMPLETE",
            "DIAGNOSTICS",
            "CONFIGURATION",
         }
         interface HostSnmpSystemAgentLimits extends srmService.vim.DynamicData {
            maxReadOnlyCommunities: number;
            maxTrapDestinations: number;
            maxCommunityLength: number;
            maxBufferSize: number;
            capability?: srmService.vim.HostSnmpAgentCapability;
         }
         interface HostSriovConfig extends srmService.vim.HostPciPassthruConfig {
            sriovEnabled: boolean;
            numVirtualFunction: number;
         }
         interface HostSriovInfo extends srmService.vim.HostPciPassthruInfo {
            sriovEnabled: boolean;
            sriovCapable: boolean;
            sriovActive: boolean;
            numVirtualFunctionRequested: number;
            numVirtualFunction: number;
            maxVirtualFunctionSupported: number;
         }
         interface HostSslThumbprintInfo extends srmService.vim.DynamicData {
            principal: string;
            ownerTag?: string;
            sslThumbprints?: Array<string>;
         }
         interface ArrayOfHostSslThumbprintInfo {
            hostSslThumbprintInfo?: Array<srmService.vim.HostSslThumbprintInfo>;
         }
         interface HostStorageArrayTypePolicyOption extends srmService.vim.DynamicData {
            policy: srmService.vim.ElementDescription;
         }
         interface ArrayOfHostStorageArrayTypePolicyOption {
            hostStorageArrayTypePolicyOption?: Array<srmService.vim.HostStorageArrayTypePolicyOption>;
         }
         interface HostStorageDeviceInfo extends srmService.vim.DynamicData {
            hostBusAdapter?: Array<srmService.vim.HostHostBusAdapter>;
            scsiLun?: Array<srmService.vim.ScsiLun>;
            scsiTopology?: srmService.vim.HostScsiTopology;
            multipathInfo?: srmService.vim.HostMultipathInfo;
            plugStoreTopology?: srmService.vim.HostPlugStoreTopology;
            softwareInternetScsiEnabled: boolean;
         }
         interface HostHardwareSummary extends srmService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<srmService.vim.HostSystemIdentificationInfo>;
            memorySize: number;
            cpuModel: string;
            cpuMhz: number;
            numCpuPkgs: number;
            numCpuCores: number;
            numCpuThreads: number;
            numNics: number;
            numHBAs: number;
         }
         interface HostListSummaryQuickStats extends srmService.vim.DynamicData {
            overallCpuUsage?: number;
            overallMemoryUsage?: number;
            distributedCpuFairness?: number;
            distributedMemoryFairness?: number;
            uptime?: number;
         }
         interface HostConfigSummary extends srmService.vim.DynamicData {
            name: string;
            port: number;
            sslThumbprint?: string;
            product?: srmService.vim.AboutInfo;
            vmotionEnabled: boolean;
            faultToleranceEnabled?: boolean;
            featureVersion?: Array<srmService.vim.HostFeatureVersionInfo>;
            agentVmDatastore?: srmService.vim.ManagedObjectReference;
            agentVmNetwork?: srmService.vim.ManagedObjectReference;
         }
         interface HostListSummary extends srmService.vim.DynamicData {
            host?: srmService.vim.ManagedObjectReference;
            hardware?: srmService.vim.HostHardwareSummary;
            runtime?: srmService.vim.HostRuntimeInfo;
            config: srmService.vim.HostConfigSummary;
            quickStats: srmService.vim.HostListSummaryQuickStats;
            overallStatus: srmService.vim.ManagedEntityStatus;
            rebootRequired: boolean;
            customValue?: Array<srmService.vim.CustomFieldValue>;
            managementServerIp?: string;
            maxEVCModeKey?: string;
            currentEVCModeKey?: string;
         }
         interface HostSystemHealthInfo extends srmService.vim.DynamicData {
            numericSensorInfo?: Array<srmService.vim.HostNumericSensorInfo>;
         }
         enum HostSystemIdentificationInfoIdentifier {
            "AssetTag",
            "ServiceTag",
            "OemSpecificString",
         }
         interface HostSystemIdentificationInfo extends srmService.vim.DynamicData {
            identifierValue: string;
            identifierType: srmService.vim.ElementDescription;
         }
         interface ArrayOfHostSystemIdentificationInfo {
            hostSystemIdentificationInfo?: Array<srmService.vim.HostSystemIdentificationInfo>;
         }
         interface HostSystemResourceInfo extends srmService.vim.DynamicData {
            key: string;
            config?: srmService.vim.ResourceConfigSpec;
            child?: Array<srmService.vim.HostSystemResourceInfo>;
         }
         interface ArrayOfHostSystemResourceInfo {
            hostSystemResourceInfo?: Array<srmService.vim.HostSystemResourceInfo>;
         }
         interface HostSystemSwapConfigurationSystemSwapOption extends srmService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfHostSystemSwapConfigurationSystemSwapOption {
            hostSystemSwapConfigurationSystemSwapOption?: Array<srmService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostSystemSwapConfigurationDisabledOption extends srmService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostCacheOption extends srmService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostLocalSwapOption extends srmService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationDatastoreOption extends srmService.vim.HostSystemSwapConfigurationSystemSwapOption {
            datastore: string;
         }
         interface HostSystemSwapConfiguration extends srmService.vim.DynamicData {
            option?: Array<srmService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostTargetTransport extends srmService.vim.DynamicData {
         }
         interface HostParallelScsiTargetTransport extends srmService.vim.HostTargetTransport {
         }
         interface HostBlockAdapterTargetTransport extends srmService.vim.HostTargetTransport {
         }
         interface HostFibreChannelTargetTransport extends srmService.vim.HostTargetTransport {
            portWorldWideName: number;
            nodeWorldWideName: number;
         }
         interface HostInternetScsiTargetTransport extends srmService.vim.HostTargetTransport {
            iScsiName: string;
            iScsiAlias: string;
            address?: Array<string>;
         }
         interface HostFibreChannelOverEthernetTargetTransport extends srmService.vim.HostFibreChannelTargetTransport {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostTpmAttestationReport extends srmService.vim.DynamicData {
            tpmPcrValues: Array<srmService.vim.HostTpmDigestInfo>;
            tpmEvents: Array<srmService.vim.HostTpmEventLogEntry>;
            tpmLogReliable: boolean;
         }
         interface HostTpmBootSecurityOptionEventDetails extends srmService.vim.HostTpmEventDetails {
            bootSecurityOption: string;
         }
         interface HostTpmCommandEventDetails extends srmService.vim.HostTpmEventDetails {
            commandLine: string;
         }
         enum HostDigestInfoDigestMethodType {
            "SHA1",
            "MD5",
         }
         interface HostDigestInfo extends srmService.vim.DynamicData {
            digestMethod: string;
            digestValue: Array<number>;
            objectName?: string;
         }
         interface HostTpmDigestInfo extends srmService.vim.HostDigestInfo {
            pcrNumber: number;
         }
         interface ArrayOfHostTpmDigestInfo {
            hostTpmDigestInfo?: Array<srmService.vim.HostTpmDigestInfo>;
         }
         interface HostTpmEventDetails extends srmService.vim.DynamicData {
            dataHash: Array<number>;
         }
         interface HostTpmEventLogEntry extends srmService.vim.DynamicData {
            pcrIndex: number;
            eventDetails: srmService.vim.HostTpmEventDetails;
         }
         interface ArrayOfHostTpmEventLogEntry {
            hostTpmEventLogEntry?: Array<srmService.vim.HostTpmEventLogEntry>;
         }
         interface HostTpmOptionEventDetails extends srmService.vim.HostTpmEventDetails {
            optionsFileName: string;
            bootOptions?: Array<number>;
         }
         interface HostTpmSoftwareComponentEventDetails extends srmService.vim.HostTpmEventDetails {
            componentName: string;
            vibName: string;
            vibVersion: string;
            vibVendor: string;
         }
         enum HostUnresolvedVmfsExtentUnresolvedReason {
            "diskIdMismatch",
            "uuidConflict",
         }
         interface HostUnresolvedVmfsExtent extends srmService.vim.DynamicData {
            device: srmService.vim.HostScsiDiskPartition;
            devicePath: string;
            vmfsUuid: string;
            isHeadExtent: boolean;
            ordinal: number;
            startBlock: number;
            endBlock: number;
            reason: string;
         }
         interface ArrayOfHostUnresolvedVmfsExtent {
            hostUnresolvedVmfsExtent?: Array<srmService.vim.HostUnresolvedVmfsExtent>;
         }
         interface HostUnresolvedVmfsResignatureSpec extends srmService.vim.DynamicData {
            extentDevicePath: Array<string>;
         }
         interface HostUnresolvedVmfsResolutionResult extends srmService.vim.DynamicData {
            spec: srmService.vim.HostUnresolvedVmfsResolutionSpec;
            vmfs?: srmService.vim.HostVmfsVolume;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionResult {
            hostUnresolvedVmfsResolutionResult?: Array<srmService.vim.HostUnresolvedVmfsResolutionResult>;
         }
         enum HostUnresolvedVmfsResolutionSpecVmfsUuidResolution {
            "resignature",
            "forceMount",
         }
         interface HostUnresolvedVmfsResolutionSpec extends srmService.vim.DynamicData {
            extentDevicePath: Array<string>;
            uuidResolution: string;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionSpec {
            hostUnresolvedVmfsResolutionSpec?: Array<srmService.vim.HostUnresolvedVmfsResolutionSpec>;
         }
         interface HostUnresolvedVmfsVolumeResolveStatus extends srmService.vim.DynamicData {
            resolvable: boolean;
            incompleteExtents?: boolean;
            multipleCopies?: boolean;
         }
         interface HostUnresolvedVmfsVolume extends srmService.vim.DynamicData {
            extent: Array<srmService.vim.HostUnresolvedVmfsExtent>;
            vmfsLabel: string;
            vmfsUuid: string;
            totalBlocks: number;
            resolveStatus: srmService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         }
         interface ArrayOfHostUnresolvedVmfsVolume {
            hostUnresolvedVmfsVolume?: Array<srmService.vim.HostUnresolvedVmfsVolume>;
         }
         interface HostVFlashManagerVFlashResourceConfigSpec extends srmService.vim.DynamicData {
            vffsUuid: string;
         }
         interface HostVFlashManagerVFlashResourceConfigInfo extends srmService.vim.DynamicData {
            vffs?: srmService.vim.HostVffsVolume;
            capacity: number;
         }
         interface HostVFlashManagerVFlashResourceRunTimeInfo extends srmService.vim.DynamicData {
            usage: number;
            capacity: number;
            accessible: boolean;
            capacityForVmCache: number;
            freeForVmCache: number;
         }
         interface HostVFlashManagerVFlashCacheConfigSpec extends srmService.vim.DynamicData {
            defaultVFlashModule: string;
            swapCacheReservationInGB: number;
         }
         interface HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption extends srmService.vim.DynamicData {
            vFlashModule: string;
            vFlashModuleVersion: string;
            minSupportedModuleVersion: string;
            cacheConsistencyType: srmService.vim.ChoiceOption;
            cacheMode: srmService.vim.ChoiceOption;
            blockSizeInKBOption: srmService.vim.LongOption;
            reservationInMBOption: srmService.vim.LongOption;
            maxDiskSizeInKB: number;
         }
         interface ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption {
            hostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption?: Array<srmService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
         }
         interface HostVFlashManagerVFlashCacheConfigInfo extends srmService.vim.DynamicData {
            vFlashModuleConfigOption?: Array<srmService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
            defaultVFlashModule?: string;
            swapCacheReservationInGB?: number;
         }
         interface HostVFlashManagerVFlashConfigInfo extends srmService.vim.DynamicData {
            vFlashResourceConfigInfo?: srmService.vim.HostVFlashManagerVFlashResourceConfigInfo;
            vFlashCacheConfigInfo?: srmService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         }
         interface HostVFlashResourceConfigurationResult extends srmService.vim.DynamicData {
            devicePath?: Array<string>;
            vffs?: srmService.vim.HostVffsVolume;
            diskConfigurationResult?: Array<srmService.vim.HostDiskConfigurationResult>;
         }
         interface HostVMotionConfig extends srmService.vim.DynamicData {
            vmotionNicKey?: string;
            enabled: boolean;
         }
         interface HostVMotionInfo extends srmService.vim.DynamicData {
            netConfig?: srmService.vim.HostVMotionNetConfig;
            ipConfig?: srmService.vim.HostIpConfig;
         }
         interface HostVMotionNetConfig extends srmService.vim.DynamicData {
            candidateVnic?: Array<srmService.vim.HostVirtualNic>;
            selectedVnic?: string;
         }
         interface HostVffsSpec extends srmService.vim.DynamicData {
            devicePath: string;
            partition?: srmService.vim.HostDiskPartitionSpec;
            majorVersion: number;
            volumeName: string;
         }
         interface HostVffsVolume extends srmService.vim.HostFileSystemVolume {
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<srmService.vim.HostScsiDiskPartition>;
         }
         interface HostVirtualNicSpec extends srmService.vim.DynamicData {
            ip?: srmService.vim.HostIpConfig;
            mac?: string;
            distributedVirtualPort?: srmService.vim.DistributedVirtualSwitchPortConnection;
            portgroup?: string;
            mtu?: number;
            tsoEnabled?: boolean;
            netStackInstanceKey?: string;
         }
         interface HostVirtualNicConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            device?: string;
            portgroup: string;
            spec?: srmService.vim.HostVirtualNicSpec;
         }
         interface ArrayOfHostVirtualNicConfig {
            hostVirtualNicConfig?: Array<srmService.vim.HostVirtualNicConfig>;
         }
         interface HostVirtualNic extends srmService.vim.DynamicData {
            device: string;
            key: string;
            portgroup: string;
            spec: srmService.vim.HostVirtualNicSpec;
            port?: string;
         }
         interface ArrayOfHostVirtualNic {
            hostVirtualNic?: Array<srmService.vim.HostVirtualNic>;
         }
         interface HostVirtualNicConnection extends srmService.vim.DynamicData {
            portgroup?: string;
            dvPort?: srmService.vim.DistributedVirtualSwitchPortConnection;
         }
         enum HostVirtualNicManagerNicType {
            "vmotion",
            "faultToleranceLogging",
            "vSphereReplication",
            "management",
            "vsan",
         }
         interface HostVirtualNicManagerNicTypeSelection extends srmService.vim.DynamicData {
            vnic: srmService.vim.HostVirtualNicConnection;
            nicType?: Array<string>;
         }
         interface ArrayOfHostVirtualNicManagerNicTypeSelection {
            hostVirtualNicManagerNicTypeSelection?: Array<srmService.vim.HostVirtualNicManagerNicTypeSelection>;
         }
         interface VirtualNicManagerNetConfig extends srmService.vim.DynamicData {
            nicType: string;
            multiSelectAllowed: boolean;
            candidateVnic?: Array<srmService.vim.HostVirtualNic>;
            selectedVnic?: Array<string>;
         }
         interface ArrayOfVirtualNicManagerNetConfig {
            virtualNicManagerNetConfig?: Array<srmService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualNicManagerInfo extends srmService.vim.DynamicData {
            netConfig?: Array<srmService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualSwitchBridge extends srmService.vim.DynamicData {
         }
         interface HostVirtualSwitchAutoBridge extends srmService.vim.HostVirtualSwitchBridge {
            excludedNicDevice?: Array<string>;
         }
         interface HostVirtualSwitchSimpleBridge extends srmService.vim.HostVirtualSwitchBridge {
            nicDevice: string;
         }
         interface HostVirtualSwitchBondBridge extends srmService.vim.HostVirtualSwitchBridge {
            nicDevice: Array<string>;
            beacon?: srmService.vim.HostVirtualSwitchBeaconConfig;
            linkDiscoveryProtocolConfig?: srmService.vim.LinkDiscoveryProtocolConfig;
         }
         interface HostVirtualSwitchBeaconConfig extends srmService.vim.DynamicData {
            interval: number;
         }
         interface HostVirtualSwitchSpec extends srmService.vim.DynamicData {
            numPorts: number;
            bridge?: srmService.vim.HostVirtualSwitchBridge;
            policy?: srmService.vim.HostNetworkPolicy;
            mtu?: number;
         }
         interface HostVirtualSwitchConfig extends srmService.vim.DynamicData {
            changeOperation?: string;
            name: string;
            spec?: srmService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitchConfig {
            hostVirtualSwitchConfig?: Array<srmService.vim.HostVirtualSwitchConfig>;
         }
         interface HostVirtualSwitch extends srmService.vim.DynamicData {
            name: string;
            key: string;
            numPorts: number;
            numPortsAvailable: number;
            mtu?: number;
            portgroup?: Array<string>;
            pnic?: Array<string>;
            spec: srmService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitch {
            hostVirtualSwitch?: Array<srmService.vim.HostVirtualSwitch>;
         }
         enum HostVmciAccessManagerMode {
            "grant",
            "replace",
            "revoke",
         }
         interface HostVmciAccessManagerAccessSpec extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            services?: Array<string>;
            mode: string;
         }
         interface ArrayOfHostVmciAccessManagerAccessSpec {
            hostVmciAccessManagerAccessSpec?: Array<srmService.vim.HostVmciAccessManagerAccessSpec>;
         }
         interface HostVmfsRescanResult extends srmService.vim.DynamicData {
            host: srmService.vim.ManagedObjectReference;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostVmfsRescanResult {
            hostVmfsRescanResult?: Array<srmService.vim.HostVmfsRescanResult>;
         }
         interface HostVmfsSpec extends srmService.vim.DynamicData {
            extent: srmService.vim.HostScsiDiskPartition;
            blockSizeMb?: number;
            majorVersion: number;
            volumeName: string;
         }
         interface HostVmfsVolume extends srmService.vim.HostFileSystemVolume {
            blockSizeMb: number;
            maxBlocks: number;
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<srmService.vim.HostScsiDiskPartition>;
            vmfsUpgradable: boolean;
            forceMountedInfo?: srmService.vim.HostForceMountedInfo;
            ssd?: boolean;
            local?: boolean;
         }
         interface HostVsanInternalSystemCmmdsQuery extends srmService.vim.DynamicData {
            type?: string;
            uuid?: string;
            owner?: string;
         }
         interface ArrayOfHostVsanInternalSystemCmmdsQuery {
            hostVsanInternalSystemCmmdsQuery?: Array<srmService.vim.HostVsanInternalSystemCmmdsQuery>;
         }
         interface NetDhcpConfigInfoDhcpOptions extends srmService.vim.DynamicData {
            enable: boolean;
            config?: Array<srmService.vim.KeyValue>;
         }
         interface NetDhcpConfigInfo extends srmService.vim.DynamicData {
            ipv6?: srmService.vim.NetDhcpConfigInfoDhcpOptions;
            ipv4?: srmService.vim.NetDhcpConfigInfoDhcpOptions;
         }
         interface NetDhcpConfigSpecDhcpOptionsSpec extends srmService.vim.DynamicData {
            enable?: boolean;
            config: Array<srmService.vim.KeyValue>;
            operation: string;
         }
         interface NetDhcpConfigSpec extends srmService.vim.DynamicData {
            ipv6?: srmService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
            ipv4?: srmService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         }
         interface NetDnsConfigInfo extends srmService.vim.DynamicData {
            dhcp: boolean;
            hostName: string;
            domainName: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface NetDnsConfigSpec extends srmService.vim.DynamicData {
            dhcp?: boolean;
            hostName?: string;
            domainName?: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         enum NetIpConfigInfoIpAddressOrigin {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum NetIpConfigInfoIpAddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface NetIpConfigInfoIpAddress extends srmService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            state?: string;
            lifetime?: Date;
         }
         interface ArrayOfNetIpConfigInfoIpAddress {
            netIpConfigInfoIpAddress?: Array<srmService.vim.NetIpConfigInfoIpAddress>;
         }
         interface NetIpConfigInfo extends srmService.vim.DynamicData {
            ipAddress?: Array<srmService.vim.NetIpConfigInfoIpAddress>;
            dhcp?: srmService.vim.NetDhcpConfigInfo;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpConfigSpecIpAddressSpec extends srmService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            operation: string;
         }
         interface ArrayOfNetIpConfigSpecIpAddressSpec {
            netIpConfigSpecIpAddressSpec?: Array<srmService.vim.NetIpConfigSpecIpAddressSpec>;
         }
         interface NetIpConfigSpec extends srmService.vim.DynamicData {
            ipAddress?: Array<srmService.vim.NetIpConfigSpecIpAddressSpec>;
            dhcp?: srmService.vim.NetDhcpConfigSpec;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpRouteConfigInfoGateway extends srmService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigInfoIpRoute extends srmService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: srmService.vim.NetIpRouteConfigInfoGateway;
         }
         interface ArrayOfNetIpRouteConfigInfoIpRoute {
            netIpRouteConfigInfoIpRoute?: Array<srmService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigInfo extends srmService.vim.DynamicData {
            ipRoute?: Array<srmService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigSpecGatewaySpec extends srmService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigSpecIpRouteSpec extends srmService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: srmService.vim.NetIpRouteConfigSpecGatewaySpec;
            operation: string;
         }
         interface ArrayOfNetIpRouteConfigSpecIpRouteSpec {
            netIpRouteConfigSpecIpRouteSpec?: Array<srmService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         interface NetIpRouteConfigSpec extends srmService.vim.DynamicData {
            ipRoute?: Array<srmService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         enum NetIpStackInfoEntryType {
            "other",
            "invalid",
            "dynamic",
            "manual",
         }
         enum NetIpStackInfoPreference {
            "reserved",
            "low",
            "medium",
            "high",
         }
         interface NetIpStackInfoNetToMedia extends srmService.vim.DynamicData {
            ipAddress: string;
            physicalAddress: string;
            device: string;
            type: string;
         }
         interface ArrayOfNetIpStackInfoNetToMedia {
            netIpStackInfoNetToMedia?: Array<srmService.vim.NetIpStackInfoNetToMedia>;
         }
         interface NetIpStackInfoDefaultRouter extends srmService.vim.DynamicData {
            ipAddress: string;
            device: string;
            lifetime: Date;
            preference: string;
         }
         interface ArrayOfNetIpStackInfoDefaultRouter {
            netIpStackInfoDefaultRouter?: Array<srmService.vim.NetIpStackInfoDefaultRouter>;
         }
         interface NetIpStackInfo extends srmService.vim.DynamicData {
            neighbor?: Array<srmService.vim.NetIpStackInfoNetToMedia>;
            defaultRouter?: Array<srmService.vim.NetIpStackInfoDefaultRouter>;
         }
         enum NetBIOSConfigInfoMode {
            "unknown",
            "enabled",
            "disabled",
            "enabledViaDHCP",
         }
         interface NetBIOSConfigInfo extends srmService.vim.DynamicData {
            mode: string;
         }
         interface WinNetBIOSConfigInfo extends srmService.vim.NetBIOSConfigInfo {
            primaryWINS: string;
            secondaryWINS?: string;
         }
         enum ArrayUpdateOperation {
            "add",
            "remove",
            "edit",
         }
         interface ArrayUpdateSpec extends srmService.vim.DynamicData {
            operation: srmService.vim.ArrayUpdateOperation;
            removeKey?: any;
         }
         interface BoolOption extends srmService.vim.OptionType {
            supported: boolean;
            defaultValue: boolean;
         }
         interface ChoiceOption extends srmService.vim.OptionType {
            choiceInfo: Array<srmService.vim.ElementDescription>;
            defaultIndex?: number;
         }
         interface FloatOption extends srmService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface IntOption extends srmService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface LongOption extends srmService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface OptionDef extends srmService.vim.ElementDescription {
            optionType: srmService.vim.OptionType;
         }
         interface ArrayOfOptionDef {
            optionDef?: Array<srmService.vim.OptionDef>;
         }
         interface OptionType extends srmService.vim.DynamicData {
            valueIsReadonly?: boolean;
         }
         interface OptionValue extends srmService.vim.DynamicData {
            key: string;
            value?: any;
         }
         interface ArrayOfOptionValue {
            optionValue?: Array<srmService.vim.OptionValue>;
         }
         interface StringOption extends srmService.vim.OptionType {
            defaultValue: string;
            validCharacters?: string;
         }
         interface ApplyProfile extends srmService.vim.DynamicData {
            enabled: boolean;
            policy?: Array<srmService.vim.ProfilePolicy>;
            profileTypeName?: string;
            profileVersion?: string;
            property?: Array<srmService.vim.ProfileApplyProfileProperty>;
         }
         interface ArrayOfApplyProfile {
            applyProfile?: Array<srmService.vim.ApplyProfile>;
         }
         interface ProfileApplyProfileElement extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ProfileApplyProfileProperty extends srmService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            profile?: Array<srmService.vim.ApplyProfile>;
         }
         interface ArrayOfProfileApplyProfileProperty {
            profileApplyProfileProperty?: Array<srmService.vim.ProfileApplyProfileProperty>;
         }
         interface ComplianceLocator extends srmService.vim.DynamicData {
            expressionName: string;
            applyPath: srmService.vim.ProfilePropertyPath;
         }
         interface ArrayOfComplianceLocator {
            complianceLocator?: Array<srmService.vim.ComplianceLocator>;
         }
         interface ComplianceProfile extends srmService.vim.DynamicData {
            expression: Array<srmService.vim.ProfileExpression>;
            rootExpression: string;
         }
         enum ComplianceResultStatus {
            "compliant",
            "nonCompliant",
            "unknown",
         }
         interface ComplianceFailure extends srmService.vim.DynamicData {
            failureType: string;
            message: srmService.vim.LocalizableMessage;
            expressionName?: string;
         }
         interface ArrayOfComplianceFailure {
            complianceFailure?: Array<srmService.vim.ComplianceFailure>;
         }
         interface ComplianceResult extends srmService.vim.DynamicData {
            profile?: srmService.vim.ManagedObjectReference;
            complianceStatus: string;
            entity?: srmService.vim.ManagedObjectReference;
            checkTime?: Date;
            failure?: Array<srmService.vim.ComplianceFailure>;
         }
         interface ArrayOfComplianceResult {
            complianceResult?: Array<srmService.vim.ComplianceResult>;
         }
         interface ProfileDeferredPolicyOptionParameter extends srmService.vim.DynamicData {
            inputPath: srmService.vim.ProfilePropertyPath;
            parameter?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ArrayOfProfileDeferredPolicyOptionParameter {
            profileDeferredPolicyOptionParameter?: Array<srmService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface ProfileExpression extends srmService.vim.DynamicData {
            id: string;
            displayName: string;
            negated: boolean;
         }
         interface ArrayOfProfileExpression {
            profileExpression?: Array<srmService.vim.ProfileExpression>;
         }
         interface ProfileSimpleExpression extends srmService.vim.ProfileExpression {
            expressionType: string;
            parameter?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ProfileCompositeExpression extends srmService.vim.ProfileExpression {
            operator: string;
            expressionName: Array<string>;
         }
         interface ProfileExpressionMetadata extends srmService.vim.DynamicData {
            expressionId: srmService.vim.ExtendedElementDescription;
            parameter?: Array<srmService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfileExpressionMetadata {
            profileExpressionMetadata?: Array<srmService.vim.ProfileExpressionMetadata>;
         }
         enum ProfileNumericComparator {
            "lessThan",
            "lessThanEqual",
            "equal",
            "notEqual",
            "greaterThanEqual",
            "greaterThan",
         }
         interface ProfileParameterMetadata extends srmService.vim.DynamicData {
            id: srmService.vim.ExtendedElementDescription;
            type: string;
            optional: boolean;
            defaultValue?: any;
         }
         interface ArrayOfProfileParameterMetadata {
            profileParameterMetadata?: Array<srmService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicy extends srmService.vim.DynamicData {
            id: string;
            policyOption: srmService.vim.PolicyOption;
         }
         interface ArrayOfProfilePolicy {
            profilePolicy?: Array<srmService.vim.ProfilePolicy>;
         }
         interface ProfilePolicyOptionMetadata extends srmService.vim.DynamicData {
            id: srmService.vim.ExtendedElementDescription;
            parameter?: Array<srmService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfilePolicyOptionMetadata {
            profilePolicyOptionMetadata?: Array<srmService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ProfileCompositePolicyOptionMetadata extends srmService.vim.ProfilePolicyOptionMetadata {
            option: Array<string>;
         }
         interface UserInputRequiredParameterMetadata extends srmService.vim.ProfilePolicyOptionMetadata {
            userInputParameter?: Array<srmService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicyMetadata extends srmService.vim.DynamicData {
            id: srmService.vim.ExtendedElementDescription;
            possibleOption: Array<srmService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ArrayOfProfilePolicyMetadata {
            profilePolicyMetadata?: Array<srmService.vim.ProfilePolicyMetadata>;
         }
         interface PolicyOption extends srmService.vim.DynamicData {
            id: string;
            parameter?: Array<srmService.vim.KeyAnyValue>;
         }
         interface ArrayOfPolicyOption {
            policyOption?: Array<srmService.vim.PolicyOption>;
         }
         interface CompositePolicyOption extends srmService.vim.PolicyOption {
            option?: Array<srmService.vim.PolicyOption>;
         }
         interface ProfileCreateSpec extends srmService.vim.DynamicData {
            name?: string;
            annotation?: string;
            enabled?: boolean;
         }
         interface ProfileSerializedCreateSpec extends srmService.vim.ProfileCreateSpec {
            profileConfigString: string;
         }
         interface ProfileConfigInfo extends srmService.vim.DynamicData {
            name: string;
            annotation?: string;
            enabled: boolean;
         }
         interface ProfileDescriptionSection extends srmService.vim.DynamicData {
            description: srmService.vim.ExtendedElementDescription;
            message?: Array<srmService.vim.LocalizableMessage>;
         }
         interface ArrayOfProfileDescriptionSection {
            profileDescriptionSection?: Array<srmService.vim.ProfileDescriptionSection>;
         }
         interface ProfileDescription extends srmService.vim.DynamicData {
            section: Array<srmService.vim.ProfileDescriptionSection>;
         }
         interface ProfileMetadataProfileSortSpec extends srmService.vim.DynamicData {
            policyId: string;
            parameter: string;
         }
         interface ArrayOfProfileMetadataProfileSortSpec {
            profileMetadataProfileSortSpec?: Array<srmService.vim.ProfileMetadataProfileSortSpec>;
         }
         interface ProfileMetadata extends srmService.vim.DynamicData {
            key: string;
            profileTypeName?: string;
            description?: srmService.vim.ExtendedDescription;
            sortSpec?: Array<srmService.vim.ProfileMetadataProfileSortSpec>;
            profileCategory?: string;
            profileComponent?: string;
         }
         interface ArrayOfProfileMetadata {
            profileMetadata?: Array<srmService.vim.ProfileMetadata>;
         }
         interface ProfilePropertyPath extends srmService.vim.DynamicData {
            profilePath: string;
            policyId?: string;
            parameterId?: string;
         }
         interface ArrayOfProfilePropertyPath {
            profilePropertyPath?: Array<srmService.vim.ProfilePropertyPath>;
         }
         interface ProfileProfileStructure extends srmService.vim.DynamicData {
            profileTypeName: string;
            child?: Array<srmService.vim.ProfileProfileStructureProperty>;
         }
         interface ProfileProfileStructureProperty extends srmService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            element: srmService.vim.ProfileProfileStructure;
         }
         interface ArrayOfProfileProfileStructureProperty {
            profileProfileStructureProperty?: Array<srmService.vim.ProfileProfileStructureProperty>;
         }
         interface ClusterProfileConfigInfo extends srmService.vim.ProfileConfigInfo {
            complyProfile?: srmService.vim.ComplianceProfile;
         }
         interface ClusterProfileCreateSpec extends srmService.vim.ProfileCreateSpec {
         }
         interface ClusterProfileConfigSpec extends srmService.vim.ClusterProfileCreateSpec {
         }
         interface ClusterProfileCompleteConfigSpec extends srmService.vim.ClusterProfileConfigSpec {
            complyProfile?: srmService.vim.ComplianceProfile;
         }
         enum ClusterProfileServiceType {
            "DRS",
            "HA",
            "DPM",
            "FT",
         }
         interface ClusterProfileConfigServiceCreateSpec extends srmService.vim.ClusterProfileConfigSpec {
            serviceType?: Array<string>;
         }
         interface AnswerFile extends srmService.vim.DynamicData {
            userInput?: Array<srmService.vim.ProfileDeferredPolicyOptionParameter>;
            createdTime: Date;
            modifiedTime: Date;
         }
         interface AnswerFileStatusError extends srmService.vim.DynamicData {
            userInputPath: srmService.vim.ProfilePropertyPath;
            errMsg: srmService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileStatusError {
            answerFileStatusError?: Array<srmService.vim.AnswerFileStatusError>;
         }
         interface AnswerFileStatusResult extends srmService.vim.DynamicData {
            checkedTime: Date;
            host: srmService.vim.ManagedObjectReference;
            status: string;
            error?: Array<srmService.vim.AnswerFileStatusError>;
         }
         interface ArrayOfAnswerFileStatusResult {
            answerFileStatusResult?: Array<srmService.vim.AnswerFileStatusResult>;
         }
         enum ProfileExecuteResultStatus {
            "success",
            "needInput",
            "error",
         }
         interface ProfileExecuteError extends srmService.vim.DynamicData {
            path?: srmService.vim.ProfilePropertyPath;
            message: srmService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileExecuteError {
            profileExecuteError?: Array<srmService.vim.ProfileExecuteError>;
         }
         interface ProfileExecuteResult extends srmService.vim.DynamicData {
            status: string;
            configSpec?: srmService.vim.HostConfigSpec;
            inapplicablePath?: Array<string>;
            requireInput?: Array<srmService.vim.ProfileDeferredPolicyOptionParameter>;
            error?: Array<srmService.vim.ProfileExecuteError>;
         }
         interface HostApplyProfile extends srmService.vim.ApplyProfile {
            memory?: srmService.vim.HostMemoryProfile;
            storage?: srmService.vim.StorageProfile;
            network?: srmService.vim.NetworkProfile;
            datetime?: srmService.vim.DateTimeProfile;
            firewall?: srmService.vim.FirewallProfile;
            security?: srmService.vim.SecurityProfile;
            service?: Array<srmService.vim.ServiceProfile>;
            option?: Array<srmService.vim.OptionProfile>;
            userAccount?: Array<srmService.vim.UserProfile>;
            usergroupAccount?: Array<srmService.vim.UserGroupProfile>;
            authentication?: srmService.vim.AuthenticationProfile;
         }
         interface PhysicalNicProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPhysicalNicProfile {
            physicalNicProfile?: Array<srmService.vim.PhysicalNicProfile>;
         }
         interface HostMemoryProfile extends srmService.vim.ApplyProfile {
         }
         interface UserProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserProfile {
            userProfile?: Array<srmService.vim.UserProfile>;
         }
         interface UserGroupProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserGroupProfile {
            userGroupProfile?: Array<srmService.vim.UserGroupProfile>;
         }
         interface SecurityProfile extends srmService.vim.ApplyProfile {
            permission?: Array<srmService.vim.PermissionProfile>;
         }
         interface OptionProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfOptionProfile {
            optionProfile?: Array<srmService.vim.OptionProfile>;
         }
         interface DateTimeProfile extends srmService.vim.ApplyProfile {
         }
         interface ServiceProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfServiceProfile {
            serviceProfile?: Array<srmService.vim.ServiceProfile>;
         }
         interface FirewallProfileRulesetProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfFirewallProfileRulesetProfile {
            firewallProfileRulesetProfile?: Array<srmService.vim.FirewallProfileRulesetProfile>;
         }
         interface FirewallProfile extends srmService.vim.ApplyProfile {
            ruleset?: Array<srmService.vim.FirewallProfileRulesetProfile>;
         }
         interface NasStorageProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfNasStorageProfile {
            nasStorageProfile?: Array<srmService.vim.NasStorageProfile>;
         }
         interface StorageProfile extends srmService.vim.ApplyProfile {
            nasStorage?: Array<srmService.vim.NasStorageProfile>;
         }
         interface NetworkProfileDnsConfigProfile extends srmService.vim.ApplyProfile {
         }
         interface NetworkProfile extends srmService.vim.ApplyProfile {
            vswitch?: Array<srmService.vim.VirtualSwitchProfile>;
            vmPortGroup?: Array<srmService.vim.VmPortGroupProfile>;
            hostPortGroup?: Array<srmService.vim.HostPortGroupProfile>;
            serviceConsolePortGroup?: Array<srmService.vim.ServiceConsolePortGroupProfile>;
            dnsConfig?: srmService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig?: srmService.vim.IpRouteProfile;
            consoleIpRouteConfig?: srmService.vim.IpRouteProfile;
            pnic?: Array<srmService.vim.PhysicalNicProfile>;
            dvswitch?: Array<srmService.vim.DvsProfile>;
            dvsServiceConsoleNic?: Array<srmService.vim.DvsServiceConsoleVNicProfile>;
            dvsHostNic?: Array<srmService.vim.DvsHostVNicProfile>;
            netStackInstance?: Array<srmService.vim.NetStackInstanceProfile>;
         }
         interface DvsVNicProfile extends srmService.vim.ApplyProfile {
            key: string;
            ipConfig: srmService.vim.IpAddressProfile;
         }
         interface DvsServiceConsoleVNicProfile extends srmService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsServiceConsoleVNicProfile {
            dvsServiceConsoleVNicProfile?: Array<srmService.vim.DvsServiceConsoleVNicProfile>;
         }
         interface DvsHostVNicProfile extends srmService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsHostVNicProfile {
            dvsHostVNicProfile?: Array<srmService.vim.DvsHostVNicProfile>;
         }
         interface DvsProfile extends srmService.vim.ApplyProfile {
            key: string;
            name: string;
            uplink?: Array<srmService.vim.PnicUplinkProfile>;
         }
         interface ArrayOfDvsProfile {
            dvsProfile?: Array<srmService.vim.DvsProfile>;
         }
         interface PnicUplinkProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPnicUplinkProfile {
            pnicUplinkProfile?: Array<srmService.vim.PnicUplinkProfile>;
         }
         interface IpRouteProfile extends srmService.vim.ApplyProfile {
            staticRoute?: Array<srmService.vim.StaticRouteProfile>;
         }
         interface StaticRouteProfile extends srmService.vim.ApplyProfile {
            key?: string;
         }
         interface ArrayOfStaticRouteProfile {
            staticRouteProfile?: Array<srmService.vim.StaticRouteProfile>;
         }
         interface LinkProfile extends srmService.vim.ApplyProfile {
         }
         interface NumPortsProfile extends srmService.vim.ApplyProfile {
         }
         interface VirtualSwitchProfile extends srmService.vim.ApplyProfile {
            key: string;
            name: string;
            link: srmService.vim.LinkProfile;
            numPorts: srmService.vim.NumPortsProfile;
            networkPolicy: srmService.vim.NetworkPolicyProfile;
         }
         interface ArrayOfVirtualSwitchProfile {
            virtualSwitchProfile?: Array<srmService.vim.VirtualSwitchProfile>;
         }
         interface NetStackInstanceProfile extends srmService.vim.ApplyProfile {
            key: string;
            dnsConfig: srmService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig: srmService.vim.IpRouteProfile;
         }
         interface ArrayOfNetStackInstanceProfile {
            netStackInstanceProfile?: Array<srmService.vim.NetStackInstanceProfile>;
         }
         interface VlanProfile extends srmService.vim.ApplyProfile {
         }
         interface VirtualSwitchSelectionProfile extends srmService.vim.ApplyProfile {
         }
         interface PortGroupProfile extends srmService.vim.ApplyProfile {
            key: string;
            name: string;
            vlan: srmService.vim.VlanProfile;
            vswitch: srmService.vim.VirtualSwitchSelectionProfile;
            networkPolicy: srmService.vim.NetworkPolicyProfile;
         }
         interface VmPortGroupProfile extends srmService.vim.PortGroupProfile {
         }
         interface ArrayOfVmPortGroupProfile {
            vmPortGroupProfile?: Array<srmService.vim.VmPortGroupProfile>;
         }
         interface HostPortGroupProfile extends srmService.vim.PortGroupProfile {
            ipConfig: srmService.vim.IpAddressProfile;
         }
         interface ArrayOfHostPortGroupProfile {
            hostPortGroupProfile?: Array<srmService.vim.HostPortGroupProfile>;
         }
         interface ServiceConsolePortGroupProfile extends srmService.vim.PortGroupProfile {
            ipConfig: srmService.vim.IpAddressProfile;
         }
         interface ArrayOfServiceConsolePortGroupProfile {
            serviceConsolePortGroupProfile?: Array<srmService.vim.ServiceConsolePortGroupProfile>;
         }
         interface NetworkPolicyProfile extends srmService.vim.ApplyProfile {
         }
         interface IpAddressProfile extends srmService.vim.ApplyProfile {
         }
         interface AuthenticationProfile extends srmService.vim.ApplyProfile {
            activeDirectory?: srmService.vim.ActiveDirectoryProfile;
         }
         interface ActiveDirectoryProfile extends srmService.vim.ApplyProfile {
         }
         interface PermissionProfile extends srmService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPermissionProfile {
            permissionProfile?: Array<srmService.vim.PermissionProfile>;
         }
         interface HostProfileConfigInfo extends srmService.vim.ProfileConfigInfo {
            applyProfile?: srmService.vim.HostApplyProfile;
            defaultComplyProfile?: srmService.vim.ComplianceProfile;
            defaultComplyLocator?: Array<srmService.vim.ComplianceLocator>;
            customComplyProfile?: srmService.vim.ComplianceProfile;
            disabledExpressionList?: Array<string>;
         }
         interface HostProfileConfigSpec extends srmService.vim.ProfileCreateSpec {
         }
         interface HostProfileSerializedHostProfileSpec extends srmService.vim.ProfileSerializedCreateSpec {
            validatorHost?: srmService.vim.ManagedObjectReference;
         }
         interface HostProfileCompleteConfigSpec extends srmService.vim.HostProfileConfigSpec {
            applyProfile?: srmService.vim.HostApplyProfile;
            customComplyProfile?: srmService.vim.ComplianceProfile;
            disabledExpressionListChanged: boolean;
            disabledExpressionList?: Array<string>;
            validatorHost?: srmService.vim.ManagedObjectReference;
         }
         interface HostProfileHostBasedConfigSpec extends srmService.vim.HostProfileConfigSpec {
            host: srmService.vim.ManagedObjectReference;
            useHostProfileEngine?: boolean;
         }
         interface HostProfileManagerConfigTaskList extends srmService.vim.DynamicData {
            configSpec?: srmService.vim.HostConfigSpec;
            taskDescription?: Array<srmService.vim.LocalizableMessage>;
         }
         interface AnswerFileCreateSpec extends srmService.vim.DynamicData {
         }
         interface AnswerFileOptionsCreateSpec extends srmService.vim.AnswerFileCreateSpec {
            userInput?: Array<srmService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface AnswerFileSerializedCreateSpec extends srmService.vim.AnswerFileCreateSpec {
            answerFileConfigString: string;
         }
         enum HostProfileManagerAnswerFileStatus {
            "valid",
            "invalid",
            "unknown",
         }
         interface ScheduledTaskDetail extends srmService.vim.TypeDescription {
            frequency: string;
         }
         interface ArrayOfScheduledTaskDetail {
            scheduledTaskDetail?: Array<srmService.vim.ScheduledTaskDetail>;
         }
         interface ScheduledTaskDescription extends srmService.vim.DynamicData {
            action: Array<srmService.vim.TypeDescription>;
            schedulerInfo: Array<srmService.vim.ScheduledTaskDetail>;
            state: Array<srmService.vim.ElementDescription>;
            dayOfWeek: Array<srmService.vim.ElementDescription>;
            weekOfMonth: Array<srmService.vim.ElementDescription>;
         }
         interface ScheduledTaskInfo extends srmService.vim.ScheduledTaskSpec {
            scheduledTask: srmService.vim.ManagedObjectReference;
            entity: srmService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            nextRunTime?: Date;
            prevRunTime?: Date;
            state: srmService.vim.TaskInfoState;
            error?: srmService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            activeTask?: srmService.vim.ManagedObjectReference;
            taskObject?: srmService.vim.ManagedObjectReference;
         }
         interface TaskScheduler extends srmService.vim.DynamicData {
            activeTime?: Date;
            expireTime?: Date;
         }
         interface AfterStartupTaskScheduler extends srmService.vim.TaskScheduler {
            minute: number;
         }
         interface OnceTaskScheduler extends srmService.vim.TaskScheduler {
            runAt?: Date;
         }
         interface RecurrentTaskScheduler extends srmService.vim.TaskScheduler {
            interval: number;
         }
         interface HourlyTaskScheduler extends srmService.vim.RecurrentTaskScheduler {
            minute: number;
         }
         interface DailyTaskScheduler extends srmService.vim.HourlyTaskScheduler {
            hour: number;
         }
         interface WeeklyTaskScheduler extends srmService.vim.DailyTaskScheduler {
            sunday: boolean;
            monday: boolean;
            tuesday: boolean;
            wednesday: boolean;
            thursday: boolean;
            friday: boolean;
            saturday: boolean;
         }
         interface MonthlyTaskScheduler extends srmService.vim.DailyTaskScheduler {
         }
         interface MonthlyByDayTaskScheduler extends srmService.vim.MonthlyTaskScheduler {
            day: number;
         }
         enum DayOfWeek {
            "sunday",
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday",
            "saturday",
         }
         enum WeekOfMonth {
            "first",
            "second",
            "third",
            "fourth",
            "last",
         }
         interface MonthlyByWeekdayTaskScheduler extends srmService.vim.MonthlyTaskScheduler {
            offset: srmService.vim.WeekOfMonth;
            weekday: srmService.vim.DayOfWeek;
         }
         interface ScheduledTaskSpec extends srmService.vim.DynamicData {
            name: string;
            description: string;
            enabled: boolean;
            scheduler: srmService.vim.TaskScheduler;
            action: srmService.vim.Action;
            notification?: string;
         }
         interface ApplyStorageRecommendationResult extends srmService.vim.DynamicData {
            vm?: srmService.vim.ManagedObjectReference;
         }
         interface StorageDrsConfigInfo extends srmService.vim.DynamicData {
            podConfig: srmService.vim.StorageDrsPodConfigInfo;
            vmConfig?: Array<srmService.vim.StorageDrsVmConfigInfo>;
         }
         interface StorageDrsConfigSpec extends srmService.vim.DynamicData {
            podConfigSpec?: srmService.vim.StorageDrsPodConfigSpec;
            vmConfigSpec?: Array<srmService.vim.StorageDrsVmConfigSpec>;
         }
         interface StorageDrsVmConfigSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.StorageDrsVmConfigInfo;
         }
         interface ArrayOfStorageDrsVmConfigSpec {
            storageDrsVmConfigSpec?: Array<srmService.vim.StorageDrsVmConfigSpec>;
         }
         enum StorageDrsPodConfigInfoBehavior {
            "manual",
            "automated",
         }
         interface StorageDrsPodConfigInfo extends srmService.vim.DynamicData {
            enabled: boolean;
            ioLoadBalanceEnabled: boolean;
            defaultVmBehavior: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: srmService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: srmService.vim.StorageDrsIoLoadBalanceConfig;
            rule?: Array<srmService.vim.ClusterRuleInfo>;
            option?: Array<srmService.vim.OptionValue>;
         }
         interface StorageDrsSpaceLoadBalanceConfig extends srmService.vim.DynamicData {
            spaceUtilizationThreshold?: number;
            minSpaceUtilizationDifference?: number;
         }
         interface StorageDrsIoLoadBalanceConfig extends srmService.vim.DynamicData {
            ioLatencyThreshold?: number;
            ioLoadImbalanceThreshold?: number;
         }
         interface StorageDrsPodConfigSpec extends srmService.vim.DynamicData {
            enabled?: boolean;
            ioLoadBalanceEnabled?: boolean;
            defaultVmBehavior?: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: srmService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: srmService.vim.StorageDrsIoLoadBalanceConfig;
            rule?: Array<srmService.vim.ClusterRuleSpec>;
            option?: Array<srmService.vim.StorageDrsOptionSpec>;
         }
         interface StorageDrsOptionSpec extends srmService.vim.ArrayUpdateSpec {
            option?: srmService.vim.OptionValue;
         }
         interface ArrayOfStorageDrsOptionSpec {
            storageDrsOptionSpec?: Array<srmService.vim.StorageDrsOptionSpec>;
         }
         interface VmPodConfigForPlacement extends srmService.vim.DynamicData {
            storagePod: srmService.vim.ManagedObjectReference;
            disk?: Array<srmService.vim.PodDiskLocator>;
            vmConfig?: srmService.vim.StorageDrsVmConfigInfo;
            interVmRule?: Array<srmService.vim.ClusterRuleInfo>;
         }
         interface ArrayOfVmPodConfigForPlacement {
            vmPodConfigForPlacement?: Array<srmService.vim.VmPodConfigForPlacement>;
         }
         interface PodDiskLocator extends srmService.vim.DynamicData {
            diskId: number;
            diskMoveType?: string;
            diskBackingInfo?: srmService.vim.VirtualDeviceBackingInfo;
            profile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfPodDiskLocator {
            podDiskLocator?: Array<srmService.vim.PodDiskLocator>;
         }
         interface StorageDrsPodSelectionSpec extends srmService.vim.DynamicData {
            initialVmConfig?: Array<srmService.vim.VmPodConfigForPlacement>;
            storagePod?: srmService.vim.ManagedObjectReference;
         }
         interface StorageMigrationAction extends srmService.vim.ClusterAction {
            vm: srmService.vim.ManagedObjectReference;
            relocateSpec: srmService.vim.VirtualMachineRelocateSpec;
            source: srmService.vim.ManagedObjectReference;
            destination: srmService.vim.ManagedObjectReference;
            sizeTransferred: number;
            spaceUtilSrcBefore?: number;
            spaceUtilDstBefore?: number;
            spaceUtilSrcAfter?: number;
            spaceUtilDstAfter?: number;
            ioLatencySrcBefore?: number;
            ioLatencyDstBefore?: number;
         }
         interface StoragePlacementAction extends srmService.vim.ClusterAction {
            vm?: srmService.vim.ManagedObjectReference;
            relocateSpec: srmService.vim.VirtualMachineRelocateSpec;
            destination: srmService.vim.ManagedObjectReference;
            spaceUtilBefore?: number;
            spaceUtilAfter?: number;
            ioLatencyBefore?: number;
         }
         interface StoragePlacementResult extends srmService.vim.DynamicData {
            recommendations?: Array<srmService.vim.ClusterRecommendation>;
            drsFault?: srmService.vim.ClusterDrsFaults;
            task?: srmService.vim.ManagedObjectReference;
         }
         enum StoragePlacementSpecPlacementType {
            "create",
            "reconfigure",
            "relocate",
            "clone",
         }
         interface StoragePlacementSpec extends srmService.vim.DynamicData {
            type: string;
            priority?: srmService.vim.VirtualMachineMovePriority;
            vm?: srmService.vim.ManagedObjectReference;
            podSelectionSpec: srmService.vim.StorageDrsPodSelectionSpec;
            cloneSpec?: srmService.vim.VirtualMachineCloneSpec;
            cloneName?: string;
            configSpec?: srmService.vim.VirtualMachineConfigSpec;
            relocateSpec?: srmService.vim.VirtualMachineRelocateSpec;
            resourcePool?: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
            folder?: srmService.vim.ManagedObjectReference;
            disallowPrerequisiteMoves?: boolean;
            resourceLeaseDurationSec?: number;
         }
         interface VirtualDiskAntiAffinityRuleSpec extends srmService.vim.ClusterRuleInfo {
            diskId: Array<number>;
         }
         interface StorageDrsVmConfigInfo extends srmService.vim.DynamicData {
            vm?: srmService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: string;
            intraVmAffinity?: boolean;
            intraVmAntiAffinity?: srmService.vim.VirtualDiskAntiAffinityRuleSpec;
         }
         interface ArrayOfStorageDrsVmConfigInfo {
            storageDrsVmConfigInfo?: Array<srmService.vim.StorageDrsVmConfigInfo>;
         }
         interface VAppCloneSpecNetworkMappingPair extends srmService.vim.DynamicData {
            source: srmService.vim.ManagedObjectReference;
            destination: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecNetworkMappingPair {
            vAppCloneSpecNetworkMappingPair?: Array<srmService.vim.VAppCloneSpecNetworkMappingPair>;
         }
         interface VAppCloneSpecResourceMap extends srmService.vim.DynamicData {
            source: srmService.vim.ManagedObjectReference;
            parent?: srmService.vim.ManagedObjectReference;
            resourceSpec?: srmService.vim.ResourceConfigSpec;
            location?: srmService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecResourceMap {
            vAppCloneSpecResourceMap?: Array<srmService.vim.VAppCloneSpecResourceMap>;
         }
         enum VAppCloneSpecProvisioningType {
            "sameAsSource",
            "thin",
            "thick",
         }
         interface VAppCloneSpec extends srmService.vim.DynamicData {
            location: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
            resourceSpec?: srmService.vim.ResourceConfigSpec;
            vmFolder?: srmService.vim.ManagedObjectReference;
            networkMapping?: Array<srmService.vim.VAppCloneSpecNetworkMappingPair>;
            property?: Array<srmService.vim.KeyValue>;
            resourceMapping?: Array<srmService.vim.VAppCloneSpecResourceMap>;
            provisioning?: string;
         }
         enum VAppAutoStartAction {
            "none",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface VAppEntityConfigInfo extends srmService.vim.DynamicData {
            key?: srmService.vim.ManagedObjectReference;
            tag?: string;
            startOrder?: number;
            startDelay?: number;
            waitingForGuest?: boolean;
            startAction?: string;
            stopDelay?: number;
            stopAction?: string;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVAppEntityConfigInfo {
            vAppEntityConfigInfo?: Array<srmService.vim.VAppEntityConfigInfo>;
         }
         enum VAppIPAssignmentInfoIpAllocationPolicy {
            "dhcpPolicy",
            "transientPolicy",
            "fixedPolicy",
            "fixedAllocatedPolicy",
         }
         enum VAppIPAssignmentInfoAllocationSchemes {
            "dhcp",
            "ovfenv",
         }
         enum VAppIPAssignmentInfoProtocols {
            "IPv4",
            "IPv6",
         }
         interface VAppIPAssignmentInfo extends srmService.vim.DynamicData {
            supportedAllocationScheme?: Array<string>;
            ipAllocationPolicy?: string;
            supportedIpProtocol?: Array<string>;
            ipProtocol?: string;
         }
         interface IpPoolIpPoolConfigInfo extends srmService.vim.DynamicData {
            subnetAddress?: string;
            netmask?: string;
            gateway?: string;
            range?: string;
            dns?: Array<string>;
            dhcpServerAvailable?: boolean;
            ipPoolEnabled?: boolean;
         }
         interface IpPoolAssociation extends srmService.vim.DynamicData {
            network?: srmService.vim.ManagedObjectReference;
            networkName: string;
         }
         interface ArrayOfIpPoolAssociation {
            ipPoolAssociation?: Array<srmService.vim.IpPoolAssociation>;
         }
         interface IpPool extends srmService.vim.DynamicData {
            id?: number;
            name?: string;
            ipv4Config?: srmService.vim.IpPoolIpPoolConfigInfo;
            ipv6Config?: srmService.vim.IpPoolIpPoolConfigInfo;
            dnsDomain?: string;
            dnsSearchPath?: string;
            hostPrefix?: string;
            httpProxy?: string;
            networkAssociation?: Array<srmService.vim.IpPoolAssociation>;
            availableIpv4Addresses?: number;
            availableIpv6Addresses?: number;
            allocatedIpv4Addresses?: number;
            allocatedIpv6Addresses?: number;
         }
         interface ArrayOfIpPool {
            ipPool?: Array<srmService.vim.IpPool>;
         }
         interface VAppOvfSectionInfo extends srmService.vim.DynamicData {
            key?: number;
            namespace?: string;
            type?: string;
            atEnvelopeLevel?: boolean;
            contents?: string;
         }
         interface ArrayOfVAppOvfSectionInfo {
            vAppOvfSectionInfo?: Array<srmService.vim.VAppOvfSectionInfo>;
         }
         interface VAppProductInfo extends srmService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            name?: string;
            vendor?: string;
            version?: string;
            fullVersion?: string;
            vendorUrl?: string;
            productUrl?: string;
            appUrl?: string;
         }
         interface ArrayOfVAppProductInfo {
            vAppProductInfo?: Array<srmService.vim.VAppProductInfo>;
         }
         interface VAppPropertyInfo extends srmService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            id?: string;
            category?: string;
            label?: string;
            type?: string;
            typeReference?: string;
            userConfigurable?: boolean;
            defaultValue?: string;
            value?: string;
            description?: string;
         }
         interface ArrayOfVAppPropertyInfo {
            vAppPropertyInfo?: Array<srmService.vim.VAppPropertyInfo>;
         }
         interface VAppConfigInfo extends srmService.vim.VmConfigInfo {
            entityConfig?: Array<srmService.vim.VAppEntityConfigInfo>;
            annotation: string;
            instanceUuid?: string;
            managedBy?: srmService.vim.ManagedByInfo;
         }
         interface VAppConfigSpec extends srmService.vim.VmConfigSpec {
            entityConfig?: Array<srmService.vim.VAppEntityConfigInfo>;
            annotation?: string;
            instanceUuid?: string;
            managedBy?: srmService.vim.ManagedByInfo;
         }
         interface VirtualAppImportSpec extends srmService.vim.ImportSpec {
            name: string;
            vAppConfigSpec: srmService.vim.VAppConfigSpec;
            resourcePoolSpec: srmService.vim.ResourceConfigSpec;
            child?: Array<srmService.vim.ImportSpec>;
         }
         interface VmConfigInfo extends srmService.vim.DynamicData {
            product?: Array<srmService.vim.VAppProductInfo>;
            property?: Array<srmService.vim.VAppPropertyInfo>;
            ipAssignment: srmService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<srmService.vim.VAppOvfSectionInfo>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired: boolean;
            installBootStopDelay: number;
         }
         interface VmConfigSpec extends srmService.vim.DynamicData {
            product?: Array<srmService.vim.VAppProductSpec>;
            property?: Array<srmService.vim.VAppPropertySpec>;
            ipAssignment?: srmService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<srmService.vim.VAppOvfSectionSpec>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired?: boolean;
            installBootStopDelay?: number;
         }
         interface VAppProductSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.VAppProductInfo;
         }
         interface ArrayOfVAppProductSpec {
            vAppProductSpec?: Array<srmService.vim.VAppProductSpec>;
         }
         interface VAppPropertySpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.VAppPropertyInfo;
         }
         interface ArrayOfVAppPropertySpec {
            vAppPropertySpec?: Array<srmService.vim.VAppPropertySpec>;
         }
         interface VAppOvfSectionSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.VAppOvfSectionInfo;
         }
         interface ArrayOfVAppOvfSectionSpec {
            vAppOvfSectionSpec?: Array<srmService.vim.VAppOvfSectionSpec>;
         }
         interface VirtualMachineAffinityInfo extends srmService.vim.DynamicData {
            affinitySet?: Array<number>;
         }
         interface VirtualMachineBootOptionsBootableDevice extends srmService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineBootOptionsBootableDevice {
            virtualMachineBootOptionsBootableDevice?: Array<srmService.vim.VirtualMachineBootOptionsBootableDevice>;
         }
         interface VirtualMachineBootOptionsBootableDiskDevice extends srmService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableEthernetDevice extends srmService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableFloppyDevice extends srmService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptionsBootableCdromDevice extends srmService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptions extends srmService.vim.DynamicData {
            bootDelay?: number;
            enterBIOSSetup?: boolean;
            bootRetryEnabled?: boolean;
            bootRetryDelay?: number;
            bootOrder?: Array<srmService.vim.VirtualMachineBootOptionsBootableDevice>;
         }
         interface VirtualMachineCapability extends srmService.vim.DynamicData {
            snapshotOperationsSupported: boolean;
            multipleSnapshotsSupported: boolean;
            snapshotConfigSupported: boolean;
            poweredOffSnapshotsSupported: boolean;
            memorySnapshotsSupported: boolean;
            revertToSnapshotSupported: boolean;
            quiescedSnapshotsSupported: boolean;
            disableSnapshotsSupported: boolean;
            lockSnapshotsSupported: boolean;
            consolePreferencesSupported: boolean;
            cpuFeatureMaskSupported: boolean;
            s1AcpiManagementSupported: boolean;
            settingScreenResolutionSupported: boolean;
            toolsAutoUpdateSupported: boolean;
            vmNpivWwnSupported: boolean;
            npivWwnOnNonRdmVmSupported: boolean;
            vmNpivWwnDisableSupported?: boolean;
            vmNpivWwnUpdateSupported?: boolean;
            swapPlacementSupported: boolean;
            toolsSyncTimeSupported: boolean;
            virtualMmuUsageSupported: boolean;
            diskSharesSupported: boolean;
            bootOptionsSupported: boolean;
            bootRetryOptionsSupported?: boolean;
            settingVideoRamSizeSupported: boolean;
            settingDisplayTopologySupported?: boolean;
            recordReplaySupported?: boolean;
            changeTrackingSupported?: boolean;
            multipleCoresPerSocketSupported?: boolean;
            hostBasedReplicationSupported?: boolean;
            guestAutoLockSupported?: boolean;
            memoryReservationLockSupported?: boolean;
            featureRequirementSupported?: boolean;
            poweredOnMonitorTypeChangeSupported?: boolean;
            seSparseDiskSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
         }
         interface VirtualMachineCdromInfo extends srmService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineCdromInfo {
            virtualMachineCdromInfo?: Array<srmService.vim.VirtualMachineCdromInfo>;
         }
         interface VirtualMachineCloneSpec extends srmService.vim.DynamicData {
            location: srmService.vim.VirtualMachineRelocateSpec;
            template: boolean;
            config?: srmService.vim.VirtualMachineConfigSpec;
            customization?: srmService.vim.CustomizationSpec;
            powerOn: boolean;
            snapshot?: srmService.vim.ManagedObjectReference;
            memory?: boolean;
         }
         enum VirtualMachineConfigInfoNpivWwnType {
            "vc",
            "host",
            "external",
         }
         enum VirtualMachineConfigInfoSwapPlacementType {
            "inherit",
            "vmDirectory",
            "hostLocal",
         }
         interface VirtualMachineConfigInfoDatastoreUrlPair extends srmService.vim.DynamicData {
            name: string;
            url: string;
         }
         interface ArrayOfVirtualMachineConfigInfoDatastoreUrlPair {
            virtualMachineConfigInfoDatastoreUrlPair?: Array<srmService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
         }
         interface VirtualMachineConfigInfoOverheadInfo extends srmService.vim.DynamicData {
            initialMemoryReservation?: number;
            initialSwapReservation?: number;
         }
         interface VirtualMachineConfigInfo extends srmService.vim.DynamicData {
            changeVersion: string;
            modified: Date;
            name: string;
            guestFullName: string;
            version: string;
            uuid: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            locationId?: string;
            template: boolean;
            guestId: string;
            alternateGuestName: string;
            annotation?: string;
            files: srmService.vim.VirtualMachineFileInfo;
            tools?: srmService.vim.ToolsConfigInfo;
            flags: srmService.vim.VirtualMachineFlagInfo;
            consolePreferences?: srmService.vim.VirtualMachineConsolePreferences;
            defaultPowerOps: srmService.vim.VirtualMachineDefaultPowerOpInfo;
            hardware: srmService.vim.VirtualHardware;
            cpuAllocation?: srmService.vim.ResourceAllocationInfo;
            memoryAllocation?: srmService.vim.ResourceAllocationInfo;
            latencySensitivity?: srmService.vim.LatencySensitivity;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            hotPlugMemoryLimit?: number;
            hotPlugMemoryIncrementSize?: number;
            cpuAffinity?: srmService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: srmService.vim.VirtualMachineAffinityInfo;
            networkShaper?: srmService.vim.VirtualMachineNetworkShaperInfo;
            extraConfig?: Array<srmService.vim.OptionValue>;
            cpuFeatureMask?: Array<srmService.vim.HostCpuIdInfo>;
            datastoreUrl?: Array<srmService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
            swapPlacement?: string;
            bootOptions?: srmService.vim.VirtualMachineBootOptions;
            ftInfo?: srmService.vim.FaultToleranceConfigInfo;
            vAppConfig?: srmService.vim.VmConfigInfo;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: srmService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            initialOverhead?: srmService.vim.VirtualMachineConfigInfoOverheadInfo;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: srmService.vim.ScheduledHardwareUpgradeInfo;
            vFlashCacheReservation?: number;
         }
         interface VirtualMachineConfigOption extends srmService.vim.DynamicData {
            version: string;
            description: string;
            guestOSDescriptor: Array<srmService.vim.GuestOsDescriptor>;
            guestOSDefaultIndex: number;
            hardwareOptions: srmService.vim.VirtualHardwareOption;
            capabilities: srmService.vim.VirtualMachineCapability;
            datastore: srmService.vim.DatastoreOption;
            defaultDevice?: Array<srmService.vim.VirtualDevice>;
            supportedMonitorType: Array<string>;
            supportedOvfEnvironmentTransport?: Array<string>;
            supportedOvfInstallTransport?: Array<string>;
         }
         interface VirtualMachineConfigOptionDescriptor extends srmService.vim.DynamicData {
            key: string;
            description?: string;
            host?: Array<srmService.vim.ManagedObjectReference>;
            createSupported?: boolean;
            defaultConfigOption?: boolean;
            runSupported?: boolean;
            upgradeSupported?: boolean;
         }
         interface ArrayOfVirtualMachineConfigOptionDescriptor {
            virtualMachineConfigOptionDescriptor?: Array<srmService.vim.VirtualMachineConfigOptionDescriptor>;
         }
         enum VirtualMachineConfigSpecNpivWwnOp {
            "generate",
            "set",
            "remove",
            "extend",
         }
         interface VirtualMachineCpuIdInfoSpec extends srmService.vim.ArrayUpdateSpec {
            info?: srmService.vim.HostCpuIdInfo;
         }
         interface ArrayOfVirtualMachineCpuIdInfoSpec {
            virtualMachineCpuIdInfoSpec?: Array<srmService.vim.VirtualMachineCpuIdInfoSpec>;
         }
         interface VirtualMachineConfigSpec extends srmService.vim.DynamicData {
            changeVersion?: string;
            name?: string;
            version?: string;
            uuid?: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            npivWorldWideNameOp?: string;
            locationId?: string;
            guestId?: string;
            alternateGuestName?: string;
            annotation?: string;
            files?: srmService.vim.VirtualMachineFileInfo;
            tools?: srmService.vim.ToolsConfigInfo;
            flags?: srmService.vim.VirtualMachineFlagInfo;
            consolePreferences?: srmService.vim.VirtualMachineConsolePreferences;
            powerOpInfo?: srmService.vim.VirtualMachineDefaultPowerOpInfo;
            numCPUs?: number;
            numCoresPerSocket?: number;
            memoryMB?: number;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            deviceChange?: Array<srmService.vim.VirtualDeviceConfigSpec>;
            cpuAllocation?: srmService.vim.ResourceAllocationInfo;
            memoryAllocation?: srmService.vim.ResourceAllocationInfo;
            latencySensitivity?: srmService.vim.LatencySensitivity;
            cpuAffinity?: srmService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: srmService.vim.VirtualMachineAffinityInfo;
            networkShaper?: srmService.vim.VirtualMachineNetworkShaperInfo;
            cpuFeatureMask?: Array<srmService.vim.VirtualMachineCpuIdInfoSpec>;
            extraConfig?: Array<srmService.vim.OptionValue>;
            swapPlacement?: string;
            bootOptions?: srmService.vim.VirtualMachineBootOptions;
            vAppConfig?: srmService.vim.VmConfigSpec;
            ftInfo?: srmService.vim.FaultToleranceConfigInfo;
            vAppConfigRemoved?: boolean;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: srmService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: srmService.vim.ScheduledHardwareUpgradeInfo;
            vmProfile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface ConfigTarget extends srmService.vim.DynamicData {
            numCpus: number;
            numCpuCores: number;
            numNumaNodes: number;
            smcPresent?: boolean;
            datastore?: Array<srmService.vim.VirtualMachineDatastoreInfo>;
            network?: Array<srmService.vim.VirtualMachineNetworkInfo>;
            opaqueNetwork?: Array<srmService.vim.OpaqueNetworkTargetInfo>;
            distributedVirtualPortgroup?: Array<srmService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<srmService.vim.DistributedVirtualSwitchInfo>;
            cdRom?: Array<srmService.vim.VirtualMachineCdromInfo>;
            serial?: Array<srmService.vim.VirtualMachineSerialInfo>;
            parallel?: Array<srmService.vim.VirtualMachineParallelInfo>;
            sound?: Array<srmService.vim.VirtualMachineSoundInfo>;
            usb?: Array<srmService.vim.VirtualMachineUsbInfo>;
            floppy?: Array<srmService.vim.VirtualMachineFloppyInfo>;
            legacyNetworkInfo?: Array<srmService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
            scsiPassthrough?: Array<srmService.vim.VirtualMachineScsiPassthroughInfo>;
            scsiDisk?: Array<srmService.vim.VirtualMachineScsiDiskDeviceInfo>;
            ideDisk?: Array<srmService.vim.VirtualMachineIdeDiskDeviceInfo>;
            maxMemMBOptimalPerf: number;
            resourcePool?: srmService.vim.ResourcePoolRuntimeInfo;
            autoVmotion?: boolean;
            pciPassthrough?: Array<srmService.vim.VirtualMachinePciPassthroughInfo>;
            sriov?: Array<srmService.vim.VirtualMachineSriovInfo>;
            vFlashModule?: Array<srmService.vim.VirtualMachineVFlashModuleInfo>;
         }
         interface VirtualMachineConsolePreferences extends srmService.vim.DynamicData {
            powerOnWhenOpened?: boolean;
            enterFullScreenOnPowerOn?: boolean;
            closeOnPowerOffOrSuspend?: boolean;
         }
         interface VirtualMachineDatastoreInfo extends srmService.vim.VirtualMachineTargetInfo {
            datastore: srmService.vim.DatastoreSummary;
            capability: srmService.vim.DatastoreCapability;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            mode: string;
            vStorageSupport?: string;
         }
         interface ArrayOfVirtualMachineDatastoreInfo {
            virtualMachineDatastoreInfo?: Array<srmService.vim.VirtualMachineDatastoreInfo>;
         }
         interface VirtualMachineDatastoreVolumeOption extends srmService.vim.DynamicData {
            fileSystemType: string;
            majorVersion?: number;
         }
         interface ArrayOfVirtualMachineDatastoreVolumeOption {
            virtualMachineDatastoreVolumeOption?: Array<srmService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         interface DatastoreOption extends srmService.vim.DynamicData {
            unsupportedVolumes?: Array<srmService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         enum VirtualMachinePowerOpType {
            "soft",
            "hard",
            "preset",
         }
         enum VirtualMachineStandbyActionType {
            "checkpoint",
            "powerOnSuspend",
         }
         interface VirtualMachineDefaultPowerOpInfo extends srmService.vim.DynamicData {
            powerOffType?: string;
            suspendType?: string;
            resetType?: string;
            defaultPowerOffType?: string;
            defaultSuspendType?: string;
            defaultResetType?: string;
            standbyAction?: string;
         }
         interface VirtualMachineDefinedProfileSpec extends srmService.vim.VirtualMachineProfileSpec {
            profileId: string;
            profileData?: srmService.vim.VirtualMachineProfileRawData;
         }
         interface VirtualMachineDeviceRuntimeInfoDeviceRuntimeState extends srmService.vim.DynamicData {
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm {
            "vmNptIncompatibleGuest",
            "vmNptIncompatibleGuestDriver",
            "vmNptIncompatibleAdapterType",
            "vmNptDisabledOrDisconnectedAdapter",
            "vmNptIncompatibleAdapterFeatures",
            "vmNptIncompatibleBackingType",
            "vmNptInsufficientMemoryReservation",
            "vmNptFaultToleranceOrRecordReplayConfigured",
            "vmNptConflictingIOChainConfigured",
            "vmNptMonitorBlocks",
            "vmNptConflictingOperationInProgress",
            "vmNptRuntimeError",
            "vmNptOutOfIntrVector",
            "vmNptVMCIActive",
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther {
            "vmNptIncompatibleHost",
            "vmNptIncompatibleNetwork",
         }
         interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState extends srmService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
            vmDirectPathGen2Active: boolean;
            vmDirectPathGen2InactiveReasonVm?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
            reservationStatus?: string;
         }
         interface VirtualMachineDeviceRuntimeInfo extends srmService.vim.DynamicData {
            runtimeState: srmService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
            key: number;
         }
         interface ArrayOfVirtualMachineDeviceRuntimeInfo {
            virtualMachineDeviceRuntimeInfo?: Array<srmService.vim.VirtualMachineDeviceRuntimeInfo>;
         }
         interface VirtualMachineDiskDeviceInfo extends srmService.vim.VirtualMachineTargetInfo {
            capacity?: number;
            vm?: Array<srmService.vim.ManagedObjectReference>;
         }
         interface VirtualMachineEmptyProfileSpec extends srmService.vim.VirtualMachineProfileSpec {
         }
         interface FaultToleranceConfigInfo extends srmService.vim.DynamicData {
            role: number;
            instanceUuids: Array<string>;
            configPaths: Array<string>;
         }
         interface FaultTolerancePrimaryConfigInfo extends srmService.vim.FaultToleranceConfigInfo {
            secondaries: Array<srmService.vim.ManagedObjectReference>;
         }
         interface FaultToleranceSecondaryConfigInfo extends srmService.vim.FaultToleranceConfigInfo {
            primaryVM: srmService.vim.ManagedObjectReference;
         }
         interface FaultToleranceSecondaryOpResult extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            powerOnAttempted: boolean;
            powerOnResult?: srmService.vim.ClusterPowerOnVmResult;
         }
         interface VirtualMachineFeatureRequirement extends srmService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfVirtualMachineFeatureRequirement {
            virtualMachineFeatureRequirement?: Array<srmService.vim.VirtualMachineFeatureRequirement>;
         }
         interface VirtualMachineFileInfo extends srmService.vim.DynamicData {
            vmPathName?: string;
            snapshotDirectory?: string;
            suspendDirectory?: string;
            logDirectory?: string;
         }
         interface VirtualMachineFileLayoutDiskLayout extends srmService.vim.DynamicData {
            key: number;
            diskFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutDiskLayout {
            virtualMachineFileLayoutDiskLayout?: Array<srmService.vim.VirtualMachineFileLayoutDiskLayout>;
         }
         interface VirtualMachineFileLayoutSnapshotLayout extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            snapshotFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutSnapshotLayout {
            virtualMachineFileLayoutSnapshotLayout?: Array<srmService.vim.VirtualMachineFileLayoutSnapshotLayout>;
         }
         interface VirtualMachineFileLayout extends srmService.vim.DynamicData {
            configFile?: Array<string>;
            logFile?: Array<string>;
            disk?: Array<srmService.vim.VirtualMachineFileLayoutDiskLayout>;
            snapshot?: Array<srmService.vim.VirtualMachineFileLayoutSnapshotLayout>;
            swapFile?: string;
         }
         enum VirtualMachineFileLayoutExFileType {
            "config",
            "extendedConfig",
            "diskDescriptor",
            "diskExtent",
            "digestDescriptor",
            "digestExtent",
            "diskReplicationState",
            "log",
            "stat",
            "namespaceData",
            "nvram",
            "snapshotData",
            "snapshotList",
            "snapshotManifestList",
            "suspend",
            "swap",
            "uwswap",
            "core",
            "screenshot",
         }
         interface VirtualMachineFileLayoutExFileInfo extends srmService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            size: number;
            uniqueSize?: number;
         }
         interface ArrayOfVirtualMachineFileLayoutExFileInfo {
            virtualMachineFileLayoutExFileInfo?: Array<srmService.vim.VirtualMachineFileLayoutExFileInfo>;
         }
         interface VirtualMachineFileLayoutExDiskUnit extends srmService.vim.DynamicData {
            fileKey: Array<number>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskUnit {
            virtualMachineFileLayoutExDiskUnit?: Array<srmService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface VirtualMachineFileLayoutExDiskLayout extends srmService.vim.DynamicData {
            key: number;
            chain?: Array<srmService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskLayout {
            virtualMachineFileLayoutExDiskLayout?: Array<srmService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface VirtualMachineFileLayoutExSnapshotLayout extends srmService.vim.DynamicData {
            key: srmService.vim.ManagedObjectReference;
            dataKey: number;
            disk?: Array<srmService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface ArrayOfVirtualMachineFileLayoutExSnapshotLayout {
            virtualMachineFileLayoutExSnapshotLayout?: Array<srmService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
         }
         interface VirtualMachineFileLayoutEx extends srmService.vim.DynamicData {
            file?: Array<srmService.vim.VirtualMachineFileLayoutExFileInfo>;
            disk?: Array<srmService.vim.VirtualMachineFileLayoutExDiskLayout>;
            snapshot?: Array<srmService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
            timestamp: Date;
         }
         enum VirtualMachineHtSharing {
            "any",
            "none",
            "internal",
         }
         enum VirtualMachinePowerOffBehavior {
            "powerOff",
            "revert",
            "prompt",
         }
         enum VirtualMachineFlagInfoMonitorType {
            "release",
            "debug",
            "stats",
         }
         enum VirtualMachineFlagInfoVirtualMmuUsage {
            "automatic",
            "on",
            "off",
         }
         enum VirtualMachineFlagInfoVirtualExecUsage {
            "hvAuto",
            "hvOn",
            "hvOff",
         }
         interface VirtualMachineFlagInfo extends srmService.vim.DynamicData {
            disableAcceleration?: boolean;
            enableLogging?: boolean;
            useToe?: boolean;
            runWithDebugInfo?: boolean;
            monitorType?: string;
            htSharing?: string;
            snapshotDisabled?: boolean;
            snapshotLocked?: boolean;
            diskUuidEnabled?: boolean;
            virtualMmuUsage?: string;
            virtualExecUsage?: string;
            snapshotPowerOffBehavior?: string;
            recordReplayEnabled?: boolean;
         }
         interface VirtualMachineFloppyInfo extends srmService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineFloppyInfo {
            virtualMachineFloppyInfo?: Array<srmService.vim.VirtualMachineFloppyInfo>;
         }
         enum VirtualMachineToolsStatus {
            "toolsNotInstalled",
            "toolsNotRunning",
            "toolsOld",
            "toolsOk",
         }
         enum VirtualMachineToolsVersionStatus {
            "guestToolsNotInstalled",
            "guestToolsNeedUpgrade",
            "guestToolsCurrent",
            "guestToolsUnmanaged",
            "guestToolsTooOld",
            "guestToolsSupportedOld",
            "guestToolsSupportedNew",
            "guestToolsTooNew",
            "guestToolsBlacklisted",
         }
         enum VirtualMachineToolsRunningStatus {
            "guestToolsNotRunning",
            "guestToolsRunning",
            "guestToolsExecutingScripts",
         }
         interface GuestDiskInfo extends srmService.vim.DynamicData {
            diskPath?: string;
            capacity?: number;
            freeSpace?: number;
         }
         interface ArrayOfGuestDiskInfo {
            guestDiskInfo?: Array<srmService.vim.GuestDiskInfo>;
         }
         interface GuestNicInfo extends srmService.vim.DynamicData {
            network?: string;
            ipAddress?: Array<string>;
            macAddress?: string;
            connected: boolean;
            deviceConfigId: number;
            dnsConfig?: srmService.vim.NetDnsConfigInfo;
            ipConfig?: srmService.vim.NetIpConfigInfo;
            netBIOSConfig?: srmService.vim.NetBIOSConfigInfo;
         }
         interface ArrayOfGuestNicInfo {
            guestNicInfo?: Array<srmService.vim.GuestNicInfo>;
         }
         interface GuestStackInfo extends srmService.vim.DynamicData {
            dnsConfig?: srmService.vim.NetDnsConfigInfo;
            ipRouteConfig?: srmService.vim.NetIpRouteConfigInfo;
            ipStackConfig?: Array<srmService.vim.KeyValue>;
            dhcpConfig?: srmService.vim.NetDhcpConfigInfo;
         }
         interface ArrayOfGuestStackInfo {
            guestStackInfo?: Array<srmService.vim.GuestStackInfo>;
         }
         interface GuestScreenInfo extends srmService.vim.DynamicData {
            width: number;
            height: number;
         }
         enum VirtualMachineGuestState {
            "running",
            "shuttingDown",
            "resetting",
            "standby",
            "notRunning",
            "unknown",
         }
         enum GuestInfoAppStateType {
            "none",
            "appStateOk",
            "appStateNeedReset",
         }
         interface GuestInfoNamespaceGenerationInfo extends srmService.vim.DynamicData {
            key: string;
            generationNo: number;
         }
         interface ArrayOfGuestInfoNamespaceGenerationInfo {
            guestInfoNamespaceGenerationInfo?: Array<srmService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         interface GuestInfo extends srmService.vim.DynamicData {
            toolsStatus?: srmService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            toolsVersion?: string;
            guestId?: string;
            guestFamily?: string;
            guestFullName?: string;
            hostName?: string;
            ipAddress?: string;
            net?: Array<srmService.vim.GuestNicInfo>;
            ipStack?: Array<srmService.vim.GuestStackInfo>;
            disk?: Array<srmService.vim.GuestDiskInfo>;
            screen?: srmService.vim.GuestScreenInfo;
            guestState: string;
            appHeartbeatStatus?: string;
            appState?: string;
            guestOperationsReady?: boolean;
            interactiveGuestOperationsReady?: boolean;
            generationInfo?: Array<srmService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         enum VirtualMachineGuestOsFamily {
            "windowsGuest",
            "linuxGuest",
            "netwareGuest",
            "solarisGuest",
            "darwinGuestFamily",
            "otherGuestFamily",
         }
         enum VirtualMachineGuestOsIdentifier {
            "dosGuest",
            "win31Guest",
            "win95Guest",
            "win98Guest",
            "winMeGuest",
            "winNTGuest",
            "win2000ProGuest",
            "win2000ServGuest",
            "win2000AdvServGuest",
            "winXPHomeGuest",
            "winXPProGuest",
            "winXPPro64Guest",
            "winNetWebGuest",
            "winNetStandardGuest",
            "winNetEnterpriseGuest",
            "winNetDatacenterGuest",
            "winNetBusinessGuest",
            "winNetStandard64Guest",
            "winNetEnterprise64Guest",
            "winLonghornGuest",
            "winLonghorn64Guest",
            "winNetDatacenter64Guest",
            "winVistaGuest",
            "winVista64Guest",
            "windows7Guest",
            "windows7_64Guest",
            "windows7Server64Guest",
            "windows8Guest",
            "windows8_64Guest",
            "windows8Server64Guest",
            "windowsHyperVGuest",
            "freebsdGuest",
            "freebsd64Guest",
            "redhatGuest",
            "rhel2Guest",
            "rhel3Guest",
            "rhel3_64Guest",
            "rhel4Guest",
            "rhel4_64Guest",
            "rhel5Guest",
            "rhel5_64Guest",
            "rhel6Guest",
            "rhel6_64Guest",
            "rhel7Guest",
            "rhel7_64Guest",
            "centosGuest",
            "centos64Guest",
            "oracleLinuxGuest",
            "oracleLinux64Guest",
            "suseGuest",
            "suse64Guest",
            "slesGuest",
            "sles64Guest",
            "sles10Guest",
            "sles10_64Guest",
            "sles11Guest",
            "sles11_64Guest",
            "sles12Guest",
            "sles12_64Guest",
            "nld9Guest",
            "oesGuest",
            "sjdsGuest",
            "mandrakeGuest",
            "mandrivaGuest",
            "mandriva64Guest",
            "turboLinuxGuest",
            "turboLinux64Guest",
            "ubuntuGuest",
            "ubuntu64Guest",
            "debian4Guest",
            "debian4_64Guest",
            "debian5Guest",
            "debian5_64Guest",
            "debian6Guest",
            "debian6_64Guest",
            "debian7Guest",
            "debian7_64Guest",
            "asianux3Guest",
            "asianux3_64Guest",
            "asianux4Guest",
            "asianux4_64Guest",
            "opensuseGuest",
            "opensuse64Guest",
            "fedoraGuest",
            "fedora64Guest",
            "other24xLinuxGuest",
            "other26xLinuxGuest",
            "otherLinuxGuest",
            "other3xLinuxGuest",
            "genericLinuxGuest",
            "other24xLinux64Guest",
            "other26xLinux64Guest",
            "other3xLinux64Guest",
            "otherLinux64Guest",
            "solaris6Guest",
            "solaris7Guest",
            "solaris8Guest",
            "solaris9Guest",
            "solaris10Guest",
            "solaris10_64Guest",
            "solaris11_64Guest",
            "os2Guest",
            "eComStationGuest",
            "eComStation2Guest",
            "netware4Guest",
            "netware5Guest",
            "netware6Guest",
            "openServer5Guest",
            "openServer6Guest",
            "unixWare7Guest",
            "darwinGuest",
            "darwin64Guest",
            "darwin10Guest",
            "darwin10_64Guest",
            "darwin11Guest",
            "darwin11_64Guest",
            "darwin12_64Guest",
            "darwin13_64Guest",
            "vmkernelGuest",
            "vmkernel5Guest",
            "otherGuest",
            "otherGuest64",
         }
         enum GuestOsDescriptorFirmwareType {
            "bios",
            "efi",
         }
         enum GuestOsDescriptorSupportLevel {
            "experimental",
            "legacy",
            "terminated",
            "supported",
            "unsupported",
            "deprecated",
            "techPreview",
         }
         interface GuestOsDescriptor extends srmService.vim.DynamicData {
            id: string;
            family: string;
            fullName: string;
            supportedMaxCPUs: number;
            numSupportedPhysicalSockets?: number;
            numSupportedCoresPerSocket?: number;
            supportedMinMemMB: number;
            supportedMaxMemMB: number;
            recommendedMemMB: number;
            recommendedColorDepth: number;
            supportedDiskControllerList: Array<string>;
            recommendedSCSIController?: string;
            recommendedDiskController: string;
            supportedNumDisks: number;
            recommendedDiskSizeMB: number;
            recommendedCdromController?: string;
            supportedEthernetCard: Array<string>;
            recommendedEthernetCard?: string;
            supportsSlaveDisk?: boolean;
            cpuFeatureMask?: Array<srmService.vim.HostCpuIdInfo>;
            smcRequired?: boolean;
            supportsWakeOnLan: boolean;
            supportsVMI?: boolean;
            supportsMemoryHotAdd?: boolean;
            supportsCpuHotAdd?: boolean;
            supportsCpuHotRemove?: boolean;
            supportedFirmware?: Array<string>;
            recommendedFirmware?: string;
            supportedUSBControllerList?: Array<string>;
            recommendedUSBController?: string;
            supports3D?: boolean;
            recommended3D?: boolean;
            smcRecommended?: boolean;
            ich7mRecommended?: boolean;
            usbRecommended?: boolean;
            supportLevel?: string;
            supportedForCreate?: boolean;
            vRAMSizeInKB?: srmService.vim.IntOption;
         }
         interface ArrayOfGuestOsDescriptor {
            guestOsDescriptor?: Array<srmService.vim.GuestOsDescriptor>;
         }
         interface VirtualMachineIdeDiskDevicePartitionInfo extends srmService.vim.DynamicData {
            id: number;
            capacity: number;
         }
         interface ArrayOfVirtualMachineIdeDiskDevicePartitionInfo {
            virtualMachineIdeDiskDevicePartitionInfo?: Array<srmService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface VirtualMachineIdeDiskDeviceInfo extends srmService.vim.VirtualMachineDiskDeviceInfo {
            partitionTable?: Array<srmService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface ArrayOfVirtualMachineIdeDiskDeviceInfo {
            virtualMachineIdeDiskDeviceInfo?: Array<srmService.vim.VirtualMachineIdeDiskDeviceInfo>;
         }
         interface VirtualMachineLegacyNetworkSwitchInfo extends srmService.vim.DynamicData {
            name: string;
         }
         interface ArrayOfVirtualMachineLegacyNetworkSwitchInfo {
            virtualMachineLegacyNetworkSwitchInfo?: Array<srmService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
         }
         interface VirtualMachineMessage extends srmService.vim.DynamicData {
            id: string;
            argument?: Array<any>;
            text?: string;
         }
         interface ArrayOfVirtualMachineMessage {
            virtualMachineMessage?: Array<srmService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineMetadataManagerVmMetadataOwnerOwner {
            "ComVmwareVsphereHA",
         }
         interface VirtualMachineMetadataManagerVmMetadataOwner extends srmService.vim.DynamicData {
            name: string;
         }
         enum VirtualMachineMetadataManagerVmMetadataOp {
            "Update",
            "Remove",
         }
         interface VirtualMachineMetadataManagerVmMetadata extends srmService.vim.DynamicData {
            vmId: string;
            metadata?: string;
         }
         interface VirtualMachineMetadataManagerVmMetadataInput extends srmService.vim.DynamicData {
            operation: string;
            vmMetadata: srmService.vim.VirtualMachineMetadataManagerVmMetadata;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataInput {
            virtualMachineMetadataManagerVmMetadataInput?: Array<srmService.vim.VirtualMachineMetadataManagerVmMetadataInput>;
         }
         interface VirtualMachineMetadataManagerVmMetadataResult extends srmService.vim.DynamicData {
            vmMetadata: srmService.vim.VirtualMachineMetadataManagerVmMetadata;
            error?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataResult {
            virtualMachineMetadataManagerVmMetadataResult?: Array<srmService.vim.VirtualMachineMetadataManagerVmMetadataResult>;
         }
         interface VirtualMachineNetworkInfo extends srmService.vim.VirtualMachineTargetInfo {
            network: srmService.vim.NetworkSummary;
         }
         interface ArrayOfVirtualMachineNetworkInfo {
            virtualMachineNetworkInfo?: Array<srmService.vim.VirtualMachineNetworkInfo>;
         }
         interface VirtualMachineNetworkShaperInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            peakBps?: number;
            averageBps?: number;
            burstSize?: number;
         }
         interface OpaqueNetworkTargetInfo extends srmService.vim.VirtualMachineTargetInfo {
            network: srmService.vim.OpaqueNetworkSummary;
         }
         interface ArrayOfOpaqueNetworkTargetInfo {
            opaqueNetworkTargetInfo?: Array<srmService.vim.OpaqueNetworkTargetInfo>;
         }
         interface VirtualMachineParallelInfo extends srmService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineParallelInfo {
            virtualMachineParallelInfo?: Array<srmService.vim.VirtualMachineParallelInfo>;
         }
         interface VirtualMachinePciPassthroughInfo extends srmService.vim.VirtualMachineTargetInfo {
            pciDevice: srmService.vim.HostPciDevice;
            systemId: string;
         }
         interface ArrayOfVirtualMachinePciPassthroughInfo {
            virtualMachinePciPassthroughInfo?: Array<srmService.vim.VirtualMachinePciPassthroughInfo>;
         }
         interface VirtualMachineProfileRawData extends srmService.vim.DynamicData {
            extensionKey: string;
            objectData?: string;
         }
         interface VirtualMachineProfileSpec extends srmService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineProfileSpec {
            virtualMachineProfileSpec?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface VirtualMachineQuestionInfo extends srmService.vim.DynamicData {
            id: string;
            text: string;
            choice: srmService.vim.ChoiceOption;
            message?: Array<srmService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineRelocateTransformation {
            "flat",
            "sparse",
         }
         interface VirtualMachineRelocateSpecDiskLocator extends srmService.vim.DynamicData {
            diskId: number;
            datastore: srmService.vim.ManagedObjectReference;
            diskMoveType?: string;
            diskBackingInfo?: srmService.vim.VirtualDeviceBackingInfo;
            profile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfVirtualMachineRelocateSpecDiskLocator {
            virtualMachineRelocateSpecDiskLocator?: Array<srmService.vim.VirtualMachineRelocateSpecDiskLocator>;
         }
         enum VirtualMachineRelocateDiskMoveOptions {
            "moveAllDiskBackingsAndAllowSharing",
            "moveAllDiskBackingsAndDisallowSharing",
            "moveChildMostDiskBacking",
            "createNewChildDiskBacking",
            "moveAllDiskBackingsAndConsolidate",
         }
         interface VirtualMachineRelocateSpec extends srmService.vim.DynamicData {
            datastore?: srmService.vim.ManagedObjectReference;
            diskMoveType?: string;
            pool?: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
            disk?: Array<srmService.vim.VirtualMachineRelocateSpecDiskLocator>;
            transform?: srmService.vim.VirtualMachineRelocateTransformation;
            deviceChange?: Array<srmService.vim.VirtualDeviceConfigSpec>;
            profile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface ReplicationInfoDiskSettings extends srmService.vim.DynamicData {
            key: number;
            diskReplicationId: string;
         }
         interface ArrayOfReplicationInfoDiskSettings {
            replicationInfoDiskSettings?: Array<srmService.vim.ReplicationInfoDiskSettings>;
         }
         interface VirtualMachineRuntimeInfoDasProtectionState extends srmService.vim.DynamicData {
            dasProtected: boolean;
         }
         interface VirtualMachineRuntimeInfo extends srmService.vim.DynamicData {
            device?: Array<srmService.vim.VirtualMachineDeviceRuntimeInfo>;
            host?: srmService.vim.ManagedObjectReference;
            connectionState: srmService.vim.VirtualMachineConnectionState;
            powerState: srmService.vim.VirtualMachinePowerState;
            faultToleranceState?: srmService.vim.VirtualMachineFaultToleranceState;
            dasVmProtection?: srmService.vim.VirtualMachineRuntimeInfoDasProtectionState;
            toolsInstallerMounted: boolean;
            suspendTime?: Date;
            bootTime?: Date;
            suspendInterval?: number;
            question?: srmService.vim.VirtualMachineQuestionInfo;
            memoryOverhead?: number;
            maxCpuUsage?: number;
            maxMemoryUsage?: number;
            numMksConnections: number;
            recordReplayState?: srmService.vim.VirtualMachineRecordReplayState;
            cleanPowerOff?: boolean;
            needSecondaryReason?: string;
            onlineStandby?: boolean;
            minRequiredEVCModeKey?: string;
            consolidationNeeded?: boolean;
            offlineFeatureRequirement?: Array<srmService.vim.VirtualMachineFeatureRequirement>;
            featureRequirement?: Array<srmService.vim.VirtualMachineFeatureRequirement>;
            featureMask?: Array<srmService.vim.HostFeatureMask>;
            vFlashCacheAllocation?: number;
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradePolicy {
            "never",
            "onSoftPowerOff",
            "always",
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradeStatus {
            "none",
            "pending",
            "success",
            "failed",
         }
         interface ScheduledHardwareUpgradeInfo extends srmService.vim.DynamicData {
            upgradePolicy?: string;
            versionKey?: string;
            scheduledHardwareUpgradeStatus?: string;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface VirtualMachineScsiDiskDeviceInfo extends srmService.vim.VirtualMachineDiskDeviceInfo {
            disk?: srmService.vim.HostScsiDisk;
            transportHint?: string;
            lunNumber?: number;
         }
         interface ArrayOfVirtualMachineScsiDiskDeviceInfo {
            virtualMachineScsiDiskDeviceInfo?: Array<srmService.vim.VirtualMachineScsiDiskDeviceInfo>;
         }
         enum VirtualMachineScsiPassthroughType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "optical",
            "media",
            "com",
            "raid",
            "unknown",
         }
         interface VirtualMachineScsiPassthroughInfo extends srmService.vim.VirtualMachineTargetInfo {
            scsiClass: string;
            vendor: string;
            physicalUnitNumber: number;
         }
         interface ArrayOfVirtualMachineScsiPassthroughInfo {
            virtualMachineScsiPassthroughInfo?: Array<srmService.vim.VirtualMachineScsiPassthroughInfo>;
         }
         interface VirtualMachineSerialInfo extends srmService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSerialInfo {
            virtualMachineSerialInfo?: Array<srmService.vim.VirtualMachineSerialInfo>;
         }
         interface VirtualMachineSnapshotInfo extends srmService.vim.DynamicData {
            currentSnapshot?: srmService.vim.ManagedObjectReference;
            rootSnapshotList: Array<srmService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSnapshotTree extends srmService.vim.DynamicData {
            snapshot: srmService.vim.ManagedObjectReference;
            vm: srmService.vim.ManagedObjectReference;
            name: string;
            description: string;
            id?: number;
            createTime: Date;
            state: srmService.vim.VirtualMachinePowerState;
            quiesced: boolean;
            backupManifest?: string;
            childSnapshotList?: Array<srmService.vim.VirtualMachineSnapshotTree>;
            replaySupported?: boolean;
         }
         interface ArrayOfVirtualMachineSnapshotTree {
            virtualMachineSnapshotTree?: Array<srmService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSoundInfo extends srmService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSoundInfo {
            virtualMachineSoundInfo?: Array<srmService.vim.VirtualMachineSoundInfo>;
         }
         interface VirtualMachineSriovInfo extends srmService.vim.VirtualMachinePciPassthroughInfo {
            virtualFunction: boolean;
            pnic?: string;
         }
         interface ArrayOfVirtualMachineSriovInfo {
            virtualMachineSriovInfo?: Array<srmService.vim.VirtualMachineSriovInfo>;
         }
         interface VirtualMachineUsageOnDatastore extends srmService.vim.DynamicData {
            datastore: srmService.vim.ManagedObjectReference;
            committed: number;
            uncommitted: number;
            unshared: number;
         }
         interface ArrayOfVirtualMachineUsageOnDatastore {
            virtualMachineUsageOnDatastore?: Array<srmService.vim.VirtualMachineUsageOnDatastore>;
         }
         interface VirtualMachineStorageInfo extends srmService.vim.DynamicData {
            perDatastoreUsage?: Array<srmService.vim.VirtualMachineUsageOnDatastore>;
            timestamp: Date;
         }
         interface VirtualMachineConfigSummary extends srmService.vim.DynamicData {
            name: string;
            template: boolean;
            vmPathName: string;
            memorySizeMB?: number;
            cpuReservation?: number;
            memoryReservation?: number;
            numCpu?: number;
            numEthernetCards?: number;
            numVirtualDisks?: number;
            uuid?: string;
            instanceUuid?: string;
            guestId?: string;
            guestFullName?: string;
            annotation?: string;
            product?: srmService.vim.VAppProductInfo;
            installBootRequired?: boolean;
            ftInfo?: srmService.vim.FaultToleranceConfigInfo;
            managedBy?: srmService.vim.ManagedByInfo;
         }
         interface VirtualMachineQuickStats extends srmService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            guestHeartbeatStatus: srmService.vim.ManagedEntityStatus;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            consumedOverheadMemory?: number;
            ftLogBandwidth?: number;
            ftSecondaryLatency?: number;
            ftLatencyStatus?: srmService.vim.ManagedEntityStatus;
            compressedMemory?: number;
            uptimeSeconds?: number;
            ssdSwappedMemory?: number;
         }
         interface VirtualMachineGuestSummary extends srmService.vim.DynamicData {
            guestId?: string;
            guestFullName?: string;
            toolsStatus?: srmService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            hostName?: string;
            ipAddress?: string;
         }
         interface VirtualMachineStorageSummary extends srmService.vim.DynamicData {
            committed: number;
            uncommitted: number;
            unshared: number;
            timestamp: Date;
         }
         interface VirtualMachineSummary extends srmService.vim.DynamicData {
            vm?: srmService.vim.ManagedObjectReference;
            runtime: srmService.vim.VirtualMachineRuntimeInfo;
            guest?: srmService.vim.VirtualMachineGuestSummary;
            config: srmService.vim.VirtualMachineConfigSummary;
            storage?: srmService.vim.VirtualMachineStorageSummary;
            quickStats: srmService.vim.VirtualMachineQuickStats;
            overallStatus: srmService.vim.ManagedEntityStatus;
            customValue?: Array<srmService.vim.CustomFieldValue>;
         }
         interface ArrayOfVirtualMachineSummary {
            virtualMachineSummary?: Array<srmService.vim.VirtualMachineSummary>;
         }
         enum VirtualMachineTargetInfoConfigurationTag {
            "compliant",
            "clusterWide",
         }
         interface VirtualMachineTargetInfo extends srmService.vim.DynamicData {
            name: string;
            configurationTag?: Array<string>;
         }
         enum UpgradePolicy {
            "manual",
            "upgradeAtPowerCycle",
         }
         interface ToolsConfigInfoToolsLastInstallInfo extends srmService.vim.DynamicData {
            counter: number;
            fault?: srmService.vim.LocalizedMethodFault;
         }
         interface ToolsConfigInfo extends srmService.vim.DynamicData {
            toolsVersion?: number;
            afterPowerOn?: boolean;
            afterResume?: boolean;
            beforeGuestStandby?: boolean;
            beforeGuestShutdown?: boolean;
            beforeGuestReboot?: boolean;
            toolsUpgradePolicy?: string;
            pendingCustomization?: string;
            syncTimeWithHost?: boolean;
            lastInstallInfo?: srmService.vim.ToolsConfigInfoToolsLastInstallInfo;
         }
         enum VirtualMachineUsbInfoSpeed {
            "low",
            "full",
            "high",
            "superSpeed",
            "unknownSpeed",
         }
         enum VirtualMachineUsbInfoFamily {
            "audio",
            "hid",
            "hid_bootable",
            "physical",
            "communication",
            "imaging",
            "printer",
            "storage",
            "hub",
            "smart_card",
            "security",
            "video",
            "wireless",
            "bluetooth",
            "wusb",
            "pda",
            "vendor_specific",
            "other",
            "unknownFamily",
         }
         interface VirtualMachineUsbInfo extends srmService.vim.VirtualMachineTargetInfo {
            description: string;
            vendor: number;
            product: number;
            physicalPath: string;
            family?: Array<string>;
            speed?: Array<string>;
            summary?: srmService.vim.VirtualMachineSummary;
         }
         interface ArrayOfVirtualMachineUsbInfo {
            virtualMachineUsbInfo?: Array<srmService.vim.VirtualMachineUsbInfo>;
         }
         interface VirtualMachineVFlashModuleInfo extends srmService.vim.VirtualMachineTargetInfo {
            vFlashModule: srmService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         }
         interface ArrayOfVirtualMachineVFlashModuleInfo {
            virtualMachineVFlashModuleInfo?: Array<srmService.vim.VirtualMachineVFlashModuleInfo>;
         }
         interface VirtualHardware extends srmService.vim.DynamicData {
            numCPU: number;
            numCoresPerSocket?: number;
            memoryMB: number;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            device?: Array<srmService.vim.VirtualDevice>;
         }
         interface VirtualHardwareOption extends srmService.vim.DynamicData {
            hwVersion: number;
            virtualDeviceOption: Array<srmService.vim.VirtualDeviceOption>;
            deviceListReadonly: boolean;
            numCPU: Array<number>;
            numCoresPerSocket?: srmService.vim.IntOption;
            numCpuReadonly: boolean;
            memoryMB: srmService.vim.LongOption;
            numPCIControllers: srmService.vim.IntOption;
            numIDEControllers: srmService.vim.IntOption;
            numUSBControllers: srmService.vim.IntOption;
            numUSBXHCIControllers?: srmService.vim.IntOption;
            numSIOControllers: srmService.vim.IntOption;
            numPS2Controllers: srmService.vim.IntOption;
            licensingLimit?: Array<string>;
            numSupportedWwnPorts?: srmService.vim.IntOption;
            numSupportedWwnNodes?: srmService.vim.IntOption;
            resourceConfigOption?: srmService.vim.ResourceConfigOption;
         }
         interface VirtualMachineImportSpec extends srmService.vim.ImportSpec {
            configSpec: srmService.vim.VirtualMachineConfigSpec;
            resPoolEntity?: srmService.vim.ManagedObjectReference;
         }
         interface CheckResult extends srmService.vim.DynamicData {
            vm?: srmService.vim.ManagedObjectReference;
            host?: srmService.vim.ManagedObjectReference;
            warning?: Array<srmService.vim.LocalizedMethodFault>;
            error?: Array<srmService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfCheckResult {
            checkResult?: Array<srmService.vim.CheckResult>;
         }
         enum CheckTestType {
            "sourceTests",
            "hostTests",
            "resourcePoolTests",
            "datastoreTests",
            "networkTests",
         }
         interface CustomizationIPSettingsIpV6AddressSpec extends srmService.vim.DynamicData {
            ip: Array<srmService.vim.CustomizationIpV6Generator>;
            gateway?: Array<string>;
         }
         enum CustomizationNetBIOSMode {
            "enableNetBIOSViaDhcp",
            "enableNetBIOS",
            "disableNetBIOS",
         }
         interface CustomizationIPSettings extends srmService.vim.DynamicData {
            ip: srmService.vim.CustomizationIpGenerator;
            subnetMask?: string;
            gateway?: Array<string>;
            ipV6Spec?: srmService.vim.CustomizationIPSettingsIpV6AddressSpec;
            dnsServerList?: Array<string>;
            dnsDomain?: string;
            primaryWINS?: string;
            secondaryWINS?: string;
            netBIOS?: srmService.vim.CustomizationNetBIOSMode;
         }
         interface CustomizationSpec extends srmService.vim.DynamicData {
            options?: srmService.vim.CustomizationOptions;
            identity: srmService.vim.CustomizationIdentitySettings;
            globalIPSettings: srmService.vim.CustomizationGlobalIPSettings;
            nicSettingMap?: Array<srmService.vim.CustomizationAdapterMapping>;
            encryptionKey?: Array<number>;
         }
         interface CustomizationName extends srmService.vim.DynamicData {
         }
         interface CustomizationFixedName extends srmService.vim.CustomizationName {
            name: string;
         }
         interface CustomizationPrefixName extends srmService.vim.CustomizationName {
            base: string;
         }
         interface CustomizationVirtualMachineName extends srmService.vim.CustomizationName {
         }
         interface CustomizationUnknownName extends srmService.vim.CustomizationName {
         }
         interface CustomizationCustomName extends srmService.vim.CustomizationName {
            argument?: string;
         }
         interface CustomizationPassword extends srmService.vim.DynamicData {
            value: string;
            plainText: boolean;
         }
         interface CustomizationOptions extends srmService.vim.DynamicData {
         }
         enum CustomizationSysprepRebootOption {
            "reboot",
            "noreboot",
            "shutdown",
         }
         interface CustomizationWinOptions extends srmService.vim.CustomizationOptions {
            changeSID: boolean;
            deleteAccounts: boolean;
            reboot?: srmService.vim.CustomizationSysprepRebootOption;
         }
         interface CustomizationLinuxOptions extends srmService.vim.CustomizationOptions {
         }
         interface CustomizationGuiUnattended extends srmService.vim.DynamicData {
            password?: srmService.vim.CustomizationPassword;
            timeZone: number;
            autoLogon: boolean;
            autoLogonCount: number;
         }
         interface CustomizationUserData extends srmService.vim.DynamicData {
            fullName: string;
            orgName: string;
            computerName: srmService.vim.CustomizationName;
            productId: string;
         }
         interface CustomizationGuiRunOnce extends srmService.vim.DynamicData {
            commandList: Array<string>;
         }
         interface CustomizationIdentification extends srmService.vim.DynamicData {
            joinWorkgroup?: string;
            joinDomain?: string;
            domainAdmin?: string;
            domainAdminPassword?: srmService.vim.CustomizationPassword;
         }
         enum CustomizationLicenseDataMode {
            "perServer",
            "perSeat",
         }
         interface CustomizationLicenseFilePrintData extends srmService.vim.DynamicData {
            autoMode: srmService.vim.CustomizationLicenseDataMode;
            autoUsers?: number;
         }
         interface CustomizationIdentitySettings extends srmService.vim.DynamicData {
         }
         interface CustomizationSysprepText extends srmService.vim.CustomizationIdentitySettings {
            value: string;
         }
         interface CustomizationSysprep extends srmService.vim.CustomizationIdentitySettings {
            guiUnattended: srmService.vim.CustomizationGuiUnattended;
            userData: srmService.vim.CustomizationUserData;
            guiRunOnce?: srmService.vim.CustomizationGuiRunOnce;
            identification: srmService.vim.CustomizationIdentification;
            licenseFilePrintData?: srmService.vim.CustomizationLicenseFilePrintData;
         }
         interface CustomizationLinuxPrep extends srmService.vim.CustomizationIdentitySettings {
            hostName: srmService.vim.CustomizationName;
            domain: string;
            timeZone?: string;
            hwClockUTC?: boolean;
         }
         interface CustomizationGlobalIPSettings extends srmService.vim.DynamicData {
            dnsSuffixList?: Array<string>;
            dnsServerList?: Array<string>;
         }
         interface CustomizationIpGenerator extends srmService.vim.DynamicData {
         }
         interface CustomizationDhcpIpGenerator extends srmService.vim.CustomizationIpGenerator {
         }
         interface CustomizationFixedIp extends srmService.vim.CustomizationIpGenerator {
            ipAddress: string;
         }
         interface CustomizationUnknownIpGenerator extends srmService.vim.CustomizationIpGenerator {
         }
         interface CustomizationCustomIpGenerator extends srmService.vim.CustomizationIpGenerator {
            argument?: string;
         }
         interface CustomizationIpV6Generator extends srmService.vim.DynamicData {
         }
         interface ArrayOfCustomizationIpV6Generator {
            customizationIpV6Generator?: Array<srmService.vim.CustomizationIpV6Generator>;
         }
         interface CustomizationDhcpIpV6Generator extends srmService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationStatelessIpV6Generator extends srmService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationFixedIpV6 extends srmService.vim.CustomizationIpV6Generator {
            ipAddress: string;
            subnetMask: number;
         }
         interface CustomizationAutoIpV6Generator extends srmService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationUnknownIpV6Generator extends srmService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationCustomIpV6Generator extends srmService.vim.CustomizationIpV6Generator {
            argument?: string;
         }
         interface CustomizationAdapterMapping extends srmService.vim.DynamicData {
            macAddress?: string;
            adapter: srmService.vim.CustomizationIPSettings;
         }
         interface ArrayOfCustomizationAdapterMapping {
            customizationAdapterMapping?: Array<srmService.vim.CustomizationAdapterMapping>;
         }
         interface HostDiskMappingPartitionInfo extends srmService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface HostDiskMappingInfo extends srmService.vim.DynamicData {
            physicalPartition?: srmService.vim.HostDiskMappingPartitionInfo;
            name: string;
            exclusive?: boolean;
         }
         interface HostDiskMappingPartitionOption extends srmService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface ArrayOfHostDiskMappingPartitionOption {
            hostDiskMappingPartitionOption?: Array<srmService.vim.HostDiskMappingPartitionOption>;
         }
         interface HostDiskMappingOption extends srmService.vim.DynamicData {
            physicalPartition?: Array<srmService.vim.HostDiskMappingPartitionOption>;
            name: string;
         }
         interface ParaVirtualSCSIController extends srmService.vim.VirtualSCSIController {
         }
         interface ParaVirtualSCSIControllerOption extends srmService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualAHCIController extends srmService.vim.VirtualSATAController {
         }
         interface VirtualAHCIControllerOption extends srmService.vim.VirtualSATAControllerOption {
         }
         interface VirtualBusLogicController extends srmService.vim.VirtualSCSIController {
         }
         interface VirtualBusLogicControllerOption extends srmService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualCdromIsoBackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualCdromPassthroughBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromRemotePassthroughBackingInfo extends srmService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromAtapiBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualCdromRemoteAtapiBackingInfo extends srmService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualCdrom extends srmService.vim.VirtualDevice {
         }
         interface VirtualCdromIsoBackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualCdromPassthroughBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
            exclusive: srmService.vim.BoolOption;
         }
         interface VirtualCdromRemotePassthroughBackingOption extends srmService.vim.VirtualDeviceRemoteDeviceBackingOption {
            exclusive: srmService.vim.BoolOption;
         }
         interface VirtualCdromAtapiBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromRemoteAtapiBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualController extends srmService.vim.VirtualDevice {
            busNumber: number;
            device?: Array<number>;
         }
         interface VirtualControllerOption extends srmService.vim.VirtualDeviceOption {
            devices: srmService.vim.IntOption;
            supportedDevice?: Array<string>;
         }
         interface VirtualDeviceBackingInfo extends srmService.vim.DynamicData {
         }
         interface VirtualDeviceFileBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            fileName: string;
            datastore?: srmService.vim.ManagedObjectReference;
            backingObjectId?: string;
         }
         interface VirtualDeviceDeviceBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDeviceRemoteDeviceBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDevicePipeBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            pipeName: string;
         }
         interface VirtualDeviceURIBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            serviceURI: string;
            direction: string;
            proxyURI?: string;
         }
         enum VirtualDeviceConnectInfoStatus {
            "ok",
            "recoverableError",
            "unrecoverableError",
            "untried",
         }
         interface VirtualDeviceConnectInfo extends srmService.vim.DynamicData {
            startConnected: boolean;
            allowGuestControl: boolean;
            connected: boolean;
            status?: string;
         }
         interface VirtualDeviceBusSlotInfo extends srmService.vim.DynamicData {
         }
         interface VirtualDevicePciBusSlotInfo extends srmService.vim.VirtualDeviceBusSlotInfo {
            pciSlotNumber: number;
         }
         interface VirtualDevice extends srmService.vim.DynamicData {
            key: number;
            deviceInfo?: srmService.vim.Description;
            backing?: srmService.vim.VirtualDeviceBackingInfo;
            connectable?: srmService.vim.VirtualDeviceConnectInfo;
            slotInfo?: srmService.vim.VirtualDeviceBusSlotInfo;
            controllerKey?: number;
            unitNumber?: number;
         }
         interface ArrayOfVirtualDevice {
            virtualDevice?: Array<srmService.vim.VirtualDevice>;
         }
         interface VirtualDeviceBackingOption extends srmService.vim.DynamicData {
            type: string;
         }
         interface ArrayOfVirtualDeviceBackingOption {
            virtualDeviceBackingOption?: Array<srmService.vim.VirtualDeviceBackingOption>;
         }
         enum VirtualDeviceFileExtension {
            "iso",
            "flp",
            "vmdk",
            "dsk",
            "rdm",
         }
         interface VirtualDeviceFileBackingOption extends srmService.vim.VirtualDeviceBackingOption {
            fileNameExtensions?: srmService.vim.ChoiceOption;
         }
         interface VirtualDeviceDeviceBackingOption extends srmService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: srmService.vim.BoolOption;
         }
         interface VirtualDeviceRemoteDeviceBackingOption extends srmService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: srmService.vim.BoolOption;
         }
         interface VirtualDevicePipeBackingOption extends srmService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualDeviceURIBackingOptionDirection {
            "server",
            "client",
         }
         interface VirtualDeviceURIBackingOption extends srmService.vim.VirtualDeviceBackingOption {
            directions: srmService.vim.ChoiceOption;
         }
         interface VirtualDeviceConnectOption extends srmService.vim.DynamicData {
            startConnected: srmService.vim.BoolOption;
            allowGuestControl: srmService.vim.BoolOption;
         }
         interface VirtualDeviceBusSlotOption extends srmService.vim.DynamicData {
            type: string;
         }
         interface VirtualDeviceOption extends srmService.vim.DynamicData {
            type: string;
            connectOption?: srmService.vim.VirtualDeviceConnectOption;
            busSlotOption?: srmService.vim.VirtualDeviceBusSlotOption;
            controllerType?: string;
            autoAssignController?: srmService.vim.BoolOption;
            backingOption?: Array<srmService.vim.VirtualDeviceBackingOption>;
            defaultBackingOptionIndex?: number;
            licensingLimit?: Array<string>;
            deprecated: boolean;
            plugAndPlay: boolean;
            hotRemoveSupported?: boolean;
         }
         interface ArrayOfVirtualDeviceOption {
            virtualDeviceOption?: Array<srmService.vim.VirtualDeviceOption>;
         }
         enum VirtualDeviceConfigSpecOperation {
            "add",
            "remove",
            "edit",
         }
         enum VirtualDeviceConfigSpecFileOperation {
            "create",
            "destroy",
            "replace",
         }
         interface VirtualDeviceConfigSpec extends srmService.vim.DynamicData {
            operation?: srmService.vim.VirtualDeviceConfigSpecOperation;
            fileOperation?: srmService.vim.VirtualDeviceConfigSpecFileOperation;
            device: srmService.vim.VirtualDevice;
            profile?: Array<srmService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfVirtualDeviceConfigSpec {
            virtualDeviceConfigSpec?: Array<srmService.vim.VirtualDeviceConfigSpec>;
         }
         enum VirtualDiskDeltaDiskFormat {
            "redoLogFormat",
            "nativeFormat",
            "seSparseFormat",
         }
         interface VirtualDiskSparseVer1BackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            contentId?: string;
            parent?: srmService.vim.VirtualDiskSparseVer1BackingInfo;
         }
         interface VirtualDiskSparseVer2BackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: srmService.vim.VirtualDiskSparseVer2BackingInfo;
         }
         interface VirtualDiskFlatVer1BackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            contentId?: string;
            parent?: srmService.vim.VirtualDiskFlatVer1BackingInfo;
         }
         interface VirtualDiskFlatVer2BackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            thinProvisioned?: boolean;
            eagerlyScrub?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: srmService.vim.VirtualDiskFlatVer2BackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            deltaGrainSize?: number;
         }
         interface VirtualDiskSeSparseBackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            writeThrough?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: srmService.vim.VirtualDiskSeSparseBackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            grainSize?: number;
         }
         interface VirtualDiskRawDiskVer2BackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            descriptorFileName: string;
            uuid?: string;
            changeId?: string;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingInfo extends srmService.vim.VirtualDiskRawDiskVer2BackingInfo {
            partition: Array<number>;
         }
         interface VirtualDiskRawDiskMappingVer1BackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
            lunUuid?: string;
            deviceName?: string;
            compatibilityMode?: string;
            diskMode?: string;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: srmService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheConsistencyType {
            "strong",
            "weak",
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheMode {
            "write_thru",
            "write_back",
         }
         interface VirtualDiskVFlashCacheConfigInfo extends srmService.vim.DynamicData {
            vFlashModule?: string;
            reservationInMB?: number;
            cacheConsistencyType?: string;
            cacheMode?: string;
            blockSizeInKB?: number;
         }
         interface VirtualDisk extends srmService.vim.VirtualDevice {
            capacityInKB: number;
            capacityInBytes?: number;
            shares?: srmService.vim.SharesInfo;
            storageIOAllocation?: srmService.vim.StorageIOAllocationInfo;
            diskObjectId?: string;
            vFlashCacheConfigInfo?: srmService.vim.VirtualDiskVFlashCacheConfigInfo;
         }
         interface ArrayOfVirtualDisk {
            virtualDisk?: Array<srmService.vim.VirtualDisk>;
         }
         interface VirtualDiskId extends srmService.vim.DynamicData {
            vm: srmService.vim.ManagedObjectReference;
            diskId: number;
         }
         enum VirtualDiskMode {
            "persistent",
            "nonpersistent",
            "undoable",
            "independent_persistent",
            "independent_nonpersistent",
            "append",
         }
         enum VirtualDiskCompatibilityMode {
            "virtualMode",
            "physicalMode",
         }
         interface VirtualDiskSparseVer1BackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
            diskModes: srmService.vim.ChoiceOption;
            split: srmService.vim.BoolOption;
            writeThrough: srmService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskSparseVer2BackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
            diskMode: srmService.vim.ChoiceOption;
            split: srmService.vim.BoolOption;
            writeThrough: srmService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
         }
         interface VirtualDiskFlatVer1BackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
            diskMode: srmService.vim.ChoiceOption;
            split: srmService.vim.BoolOption;
            writeThrough: srmService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskDeltaDiskFormatsSupported extends srmService.vim.DynamicData {
            datastoreType: string;
            deltaDiskFormat: srmService.vim.ChoiceOption;
         }
         interface ArrayOfVirtualDiskDeltaDiskFormatsSupported {
            virtualDiskDeltaDiskFormatsSupported?: Array<srmService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskFlatVer2BackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
            diskMode: srmService.vim.ChoiceOption;
            split: srmService.vim.BoolOption;
            writeThrough: srmService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            thinProvisioned?: srmService.vim.BoolOption;
            eagerlyScrub?: srmService.vim.BoolOption;
            deltaDiskFormat?: srmService.vim.ChoiceOption;
            deltaDiskFormatsSupported?: Array<srmService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskSeSparseBackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
            diskMode: srmService.vim.ChoiceOption;
            writeThrough: srmService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            deltaDiskFormatsSupported: Array<srmService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskRawDiskVer2BackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions: srmService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingOption extends srmService.vim.VirtualDiskRawDiskVer2BackingOption {
         }
         interface VirtualDiskRawDiskMappingVer1BackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions?: srmService.vim.ChoiceOption;
            compatibilityMode: srmService.vim.ChoiceOption;
            diskMode: srmService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskOptionVFlashCacheConfigOption extends srmService.vim.DynamicData {
            cacheConsistencyType: srmService.vim.ChoiceOption;
            cacheMode: srmService.vim.ChoiceOption;
            reservationInMB: srmService.vim.LongOption;
            blockSizeInKB: srmService.vim.LongOption;
         }
         interface VirtualDiskOption extends srmService.vim.VirtualDeviceOption {
            capacityInKB: srmService.vim.LongOption;
            ioAllocationOption?: srmService.vim.StorageIOAllocationOption;
            vFlashCacheConfigOption?: srmService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         }
         interface VirtualDiskConfigSpec extends srmService.vim.VirtualDeviceConfigSpec {
            migrateCache?: boolean;
         }
         interface VirtualE1000 extends srmService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000Option extends srmService.vim.VirtualEthernetCardOption {
         }
         interface VirtualE1000e extends srmService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000eOption extends srmService.vim.VirtualEthernetCardOption {
         }
         interface VirtualEnsoniq1371 extends srmService.vim.VirtualSoundCard {
         }
         interface VirtualEnsoniq1371Option extends srmService.vim.VirtualSoundCardOption {
         }
         interface VirtualEthernetCardNetworkBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            network?: srmService.vim.ManagedObjectReference;
            inPassthroughMode?: boolean;
         }
         interface VirtualEthernetCardLegacyNetworkBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualEthernetCardDistributedVirtualPortBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            port: srmService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface VirtualEthernetCardOpaqueNetworkBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface VirtualEthernetCard extends srmService.vim.VirtualDevice {
            addressType?: string;
            macAddress?: string;
            wakeOnLanEnabled?: boolean;
         }
         interface VirtualEthernetCardNetworkBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardOpaqueNetworkBackingOption extends srmService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardLegacyNetworkDeviceName {
            "bridged",
            "nat",
            "hostonly",
         }
         interface VirtualEthernetCardLegacyNetworkBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardDVPortBackingOption extends srmService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardMacType {
            "manual",
            "generated",
            "assigned",
         }
         interface VirtualEthernetCardOption extends srmService.vim.VirtualDeviceOption {
            supportedOUI: srmService.vim.ChoiceOption;
            macType: srmService.vim.ChoiceOption;
            wakeOnLanEnabled: srmService.vim.BoolOption;
            vmDirectPathGen2Supported?: boolean;
         }
         interface VirtualFloppyImageBackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualFloppyDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualFloppyRemoteDeviceBackingInfo extends srmService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualFloppy extends srmService.vim.VirtualDevice {
         }
         interface VirtualFloppyImageBackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualFloppyDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualFloppyRemoteDeviceBackingOption extends srmService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualFloppyOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualHdAudioCard extends srmService.vim.VirtualSoundCard {
         }
         interface VirtualHdAudioCardOption extends srmService.vim.VirtualSoundCardOption {
         }
         interface VirtualIDEController extends srmService.vim.VirtualController {
         }
         interface VirtualIDEControllerOption extends srmService.vim.VirtualControllerOption {
            numIDEDisks: srmService.vim.IntOption;
            numIDECdroms: srmService.vim.IntOption;
         }
         interface VirtualKeyboard extends srmService.vim.VirtualDevice {
         }
         interface VirtualKeyboardOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualLsiLogicController extends srmService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicControllerOption extends srmService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualLsiLogicSASController extends srmService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicSASControllerOption extends srmService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualPCIController extends srmService.vim.VirtualController {
         }
         interface VirtualPCIControllerOption extends srmService.vim.VirtualControllerOption {
            numSCSIControllers: srmService.vim.IntOption;
            numEthernetCards: srmService.vim.IntOption;
            numVideoCards: srmService.vim.IntOption;
            numSoundCards: srmService.vim.IntOption;
            numVmiRoms: srmService.vim.IntOption;
            numVmciDevices?: srmService.vim.IntOption;
            numPCIPassthroughDevices?: srmService.vim.IntOption;
            numSasSCSIControllers?: srmService.vim.IntOption;
            numVmxnet3EthernetCards?: srmService.vim.IntOption;
            numParaVirtualSCSIControllers?: srmService.vim.IntOption;
            numSATAControllers?: srmService.vim.IntOption;
         }
         interface VirtualPCIPassthroughDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            id: string;
            deviceId: string;
            systemId: string;
            vendorId: number;
         }
         interface VirtualPCIPassthrough extends srmService.vim.VirtualDevice {
         }
         interface VirtualPCIPassthroughDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualPCIPassthroughOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualPCNet32 extends srmService.vim.VirtualEthernetCard {
         }
         interface VirtualPCNet32Option extends srmService.vim.VirtualEthernetCardOption {
            supportsMorphing: boolean;
         }
         interface VirtualPS2Controller extends srmService.vim.VirtualController {
         }
         interface VirtualPS2ControllerOption extends srmService.vim.VirtualControllerOption {
            numKeyboards: srmService.vim.IntOption;
            numPointingDevices: srmService.vim.IntOption;
         }
         interface VirtualParallelPortFileBackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualParallelPortDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualParallelPort extends srmService.vim.VirtualDevice {
         }
         interface VirtualParallelPortFileBackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualParallelPortDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualParallelPortOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualPointingDeviceDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            hostPointingDevice: string;
         }
         interface VirtualPointingDevice extends srmService.vim.VirtualDevice {
         }
         enum VirtualPointingDeviceHostChoice {
            "autodetect",
            "intellimouseExplorer",
            "intellimousePs2",
            "logitechMouseman",
            "microsoft_serial",
            "mouseSystems",
            "mousemanSerial",
            "ps2",
         }
         interface VirtualPointingDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
            hostPointingDevice: srmService.vim.ChoiceOption;
         }
         interface VirtualPointingDeviceOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualSATAController extends srmService.vim.VirtualController {
         }
         interface VirtualSATAControllerOption extends srmService.vim.VirtualControllerOption {
            numSATADisks: srmService.vim.IntOption;
            numSATACdroms: srmService.vim.IntOption;
         }
         enum VirtualSCSISharing {
            "noSharing",
            "virtualSharing",
            "physicalSharing",
         }
         interface ArrayOfVirtualSCSISharing {
            virtualSCSISharing?: Array<srmService.vim.VirtualSCSISharing>;
         }
         interface VirtualSCSIController extends srmService.vim.VirtualController {
            hotAddRemove?: boolean;
            sharedBus: srmService.vim.VirtualSCSISharing;
            scsiCtlrUnitNumber?: number;
         }
         interface VirtualSCSIControllerOption extends srmService.vim.VirtualControllerOption {
            numSCSIDisks: srmService.vim.IntOption;
            numSCSICdroms: srmService.vim.IntOption;
            numSCSIPassthrough: srmService.vim.IntOption;
            sharing: Array<srmService.vim.VirtualSCSISharing>;
            defaultSharedIndex: number;
            hotAddRemove: srmService.vim.BoolOption;
            scsiCtlrUnitNumber: number;
         }
         interface VirtualSCSIPassthroughDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSCSIPassthrough extends srmService.vim.VirtualDevice {
         }
         interface VirtualSCSIPassthroughDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSCSIPassthroughOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualSIOController extends srmService.vim.VirtualController {
         }
         interface VirtualSIOControllerOption extends srmService.vim.VirtualControllerOption {
            numFloppyDrives: srmService.vim.IntOption;
            numSerialPorts: srmService.vim.IntOption;
            numParallelPorts: srmService.vim.IntOption;
         }
         interface VirtualSerialPortFileBackingInfo extends srmService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualSerialPortDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSerialPortPipeBackingInfo extends srmService.vim.VirtualDevicePipeBackingInfo {
            endpoint: string;
            noRxLoss?: boolean;
         }
         interface VirtualSerialPortURIBackingInfo extends srmService.vim.VirtualDeviceURIBackingInfo {
         }
         interface VirtualSerialPortThinPrintBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
         }
         interface VirtualSerialPort extends srmService.vim.VirtualDevice {
            yieldOnPoll: boolean;
         }
         enum VirtualSerialPortEndPoint {
            "client",
            "server",
         }
         interface VirtualSerialPortFileBackingOption extends srmService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualSerialPortDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSerialPortPipeBackingOption extends srmService.vim.VirtualDevicePipeBackingOption {
            endpoint: srmService.vim.ChoiceOption;
            noRxLoss: srmService.vim.BoolOption;
         }
         interface VirtualSerialPortURIBackingOption extends srmService.vim.VirtualDeviceURIBackingOption {
         }
         interface VirtualSerialPortThinPrintBackingOption extends srmService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSerialPortOption extends srmService.vim.VirtualDeviceOption {
            yieldOnPoll: srmService.vim.BoolOption;
         }
         interface VirtualSoundBlaster16 extends srmService.vim.VirtualSoundCard {
         }
         interface VirtualSoundBlaster16Option extends srmService.vim.VirtualSoundCardOption {
         }
         interface VirtualSoundCardDeviceBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSoundCard extends srmService.vim.VirtualDevice {
         }
         interface VirtualSoundCardDeviceBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSoundCardOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualSriovEthernetCardSriovBackingInfo extends srmService.vim.VirtualDeviceBackingInfo {
            physicalFunctionBacking?: srmService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionBacking?: srmService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionIndex?: number;
         }
         interface VirtualSriovEthernetCard extends srmService.vim.VirtualEthernetCard {
            allowGuestOSMtuChange?: boolean;
            sriovBacking?: srmService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         }
         interface VirtualSriovEthernetCardSriovBackingOption extends srmService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSriovEthernetCardOption extends srmService.vim.VirtualEthernetCardOption {
         }
         interface VirtualUSBUSBBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualUSBRemoteHostBackingInfo extends srmService.vim.VirtualDeviceDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSBRemoteClientBackingInfo extends srmService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSB extends srmService.vim.VirtualDevice {
            connected: boolean;
            vendor?: number;
            product?: number;
            family?: Array<string>;
            speed?: Array<string>;
         }
         interface VirtualUSBControllerPciBusSlotInfo extends srmService.vim.VirtualDevicePciBusSlotInfo {
            ehciPciSlotNumber?: number;
         }
         interface VirtualUSBController extends srmService.vim.VirtualController {
            autoConnectDevices?: boolean;
            ehciEnabled?: boolean;
         }
         interface VirtualUSBControllerOption extends srmService.vim.VirtualControllerOption {
            autoConnectDevices: srmService.vim.BoolOption;
            ehciSupported: srmService.vim.BoolOption;
            supportedSpeeds?: Array<string>;
         }
         interface VirtualUSBUSBBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteHostBackingOption extends srmService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteClientBackingOption extends srmService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualUSBOption extends srmService.vim.VirtualDeviceOption {
         }
         interface VirtualUSBXHCIController extends srmService.vim.VirtualController {
            autoConnectDevices?: boolean;
         }
         interface VirtualUSBXHCIControllerOption extends srmService.vim.VirtualControllerOption {
            autoConnectDevices: srmService.vim.BoolOption;
            supportedSpeeds: Array<string>;
         }
         interface VirtualMachineVMCIDevice extends srmService.vim.VirtualDevice {
            id?: number;
            allowUnrestrictedCommunication?: boolean;
         }
         interface VirtualMachineVMCIDeviceOption extends srmService.vim.VirtualDeviceOption {
            allowUnrestrictedCommunication: srmService.vim.BoolOption;
         }
         interface VirtualMachineVMIROM extends srmService.vim.VirtualDevice {
         }
         interface VirtualVMIROMOption extends srmService.vim.VirtualDeviceOption {
         }
         enum VirtualMachineVideoCardUse3dRenderer {
            "automatic",
            "software",
            "hardware",
         }
         interface VirtualMachineVideoCard extends srmService.vim.VirtualDevice {
            videoRamSizeInKB?: number;
            numDisplays?: number;
            useAutoDetect?: boolean;
            enable3DSupport?: boolean;
            use3dRenderer?: string;
         }
         interface VirtualVideoCardOption extends srmService.vim.VirtualDeviceOption {
            videoRamSizeInKB?: srmService.vim.LongOption;
            numDisplays?: srmService.vim.IntOption;
            useAutoDetect?: srmService.vim.BoolOption;
            support3D?: srmService.vim.BoolOption;
            use3dRendererSupported?: srmService.vim.BoolOption;
         }
         interface VirtualVmxnet extends srmService.vim.VirtualEthernetCard {
         }
         interface VirtualVmxnet2 extends srmService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet2Option extends srmService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnet3 extends srmService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet3Option extends srmService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnetOption extends srmService.vim.VirtualEthernetCardOption {
         }
         interface GuestFileAttributes extends srmService.vim.DynamicData {
            modificationTime?: Date;
            accessTime?: Date;
            symlinkTarget?: string;
         }
         interface GuestPosixFileAttributes extends srmService.vim.GuestFileAttributes {
            ownerId?: number;
            groupId?: number;
            permissions?: number;
         }
         interface GuestWindowsFileAttributes extends srmService.vim.GuestFileAttributes {
            hidden?: boolean;
            readOnly?: boolean;
            createTime?: Date;
         }
         enum GuestFileType {
            "file",
            "directory",
            "symlink",
         }
         interface GuestFileInfo extends srmService.vim.DynamicData {
            path: string;
            type: string;
            size: number;
            attributes: srmService.vim.GuestFileAttributes;
         }
         interface ArrayOfGuestFileInfo {
            guestFileInfo?: Array<srmService.vim.GuestFileInfo>;
         }
         interface GuestListFileInfo extends srmService.vim.DynamicData {
            files?: Array<srmService.vim.GuestFileInfo>;
            remaining: number;
         }
         interface FileTransferInformation extends srmService.vim.DynamicData {
            attributes: srmService.vim.GuestFileAttributes;
            size: number;
            url: string;
         }
         interface GuestAuthentication extends srmService.vim.DynamicData {
            interactiveSession: boolean;
         }
         interface NamePasswordAuthentication extends srmService.vim.GuestAuthentication {
            username: string;
            password: string;
         }
         interface GuestProgramSpec extends srmService.vim.DynamicData {
            programPath: string;
            arguments: string;
            workingDirectory?: string;
            envVariables?: Array<string>;
         }
         interface GuestWindowsProgramSpec extends srmService.vim.GuestProgramSpec {
            startMinimized: boolean;
         }
         interface GuestProcessInfo extends srmService.vim.DynamicData {
            name: string;
            pid: number;
            owner: string;
            cmdLine: string;
            startTime: Date;
            endTime?: Date;
            exitCode?: number;
         }
         interface ArrayOfGuestProcessInfo {
            guestProcessInfo?: Array<srmService.vim.GuestProcessInfo>;
         }
         interface SSPIAuthentication extends srmService.vim.GuestAuthentication {
            sspiToken: string;
         }
         interface TicketedSessionAuthentication extends srmService.vim.GuestAuthentication {
            ticket: string;
         }
         interface VsanClusterConfigInfoHostDefaultInfo extends srmService.vim.DynamicData {
            uuid?: string;
            autoClaimStorage?: boolean;
         }
         interface VsanClusterConfigInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            defaultConfig?: srmService.vim.VsanClusterConfigInfoHostDefaultInfo;
         }
         interface VsanHostClusterStatusStateCompletionEstimate extends srmService.vim.DynamicData {
            completeTime?: Date;
            percentComplete?: number;
         }
         interface VsanHostClusterStatusState extends srmService.vim.DynamicData {
            state: string;
            completion?: srmService.vim.VsanHostClusterStatusStateCompletionEstimate;
         }
         interface VsanHostClusterStatus extends srmService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
            health: string;
            nodeState: srmService.vim.VsanHostClusterStatusState;
            memberUuid?: Array<string>;
         }
         interface VsanHostConfigInfoStorageInfo extends srmService.vim.DynamicData {
            autoClaimStorage?: boolean;
            diskMapping?: Array<srmService.vim.VsanHostDiskMapping>;
         }
         interface VsanHostConfigInfoClusterInfo extends srmService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
         }
         interface VsanHostConfigInfoNetworkInfoPortConfig extends srmService.vim.DynamicData {
            ipConfig?: srmService.vim.VsanHostIpConfig;
            device: string;
         }
         interface ArrayOfVsanHostConfigInfoNetworkInfoPortConfig {
            vsanHostConfigInfoNetworkInfoPortConfig?: Array<srmService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostConfigInfoNetworkInfo extends srmService.vim.DynamicData {
            port?: Array<srmService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostConfigInfo extends srmService.vim.DynamicData {
            enabled?: boolean;
            hostSystem?: srmService.vim.ManagedObjectReference;
            clusterInfo?: srmService.vim.VsanHostConfigInfoClusterInfo;
            storageInfo?: srmService.vim.VsanHostConfigInfoStorageInfo;
            networkInfo?: srmService.vim.VsanHostConfigInfoNetworkInfo;
         }
         interface ArrayOfVsanHostConfigInfo {
            vsanHostConfigInfo?: Array<srmService.vim.VsanHostConfigInfo>;
         }
         enum VsanHostDecommissionModeObjectAction {
            "noAction",
            "ensureObjectAccessibility",
            "evacuateAllData",
         }
         interface VsanHostDecommissionMode extends srmService.vim.DynamicData {
            objectAction: string;
         }
         interface VsanHostDiskMapResult extends srmService.vim.DynamicData {
            mapping: srmService.vim.VsanHostDiskMapping;
            diskResult?: Array<srmService.vim.VsanHostDiskResult>;
            error?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVsanHostDiskMapResult {
            vsanHostDiskMapResult?: Array<srmService.vim.VsanHostDiskMapResult>;
         }
         interface VsanHostDiskMapping extends srmService.vim.DynamicData {
            ssd: srmService.vim.HostScsiDisk;
            nonSsd: Array<srmService.vim.HostScsiDisk>;
         }
         interface ArrayOfVsanHostDiskMapping {
            vsanHostDiskMapping?: Array<srmService.vim.VsanHostDiskMapping>;
         }
         enum VsanHostDiskResultState {
            "inUse",
            "eligible",
            "ineligible",
         }
         interface VsanHostDiskResult extends srmService.vim.DynamicData {
            disk: srmService.vim.HostScsiDisk;
            state: string;
            vsanUuid?: string;
            error?: srmService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVsanHostDiskResult {
            vsanHostDiskResult?: Array<srmService.vim.VsanHostDiskResult>;
         }
         enum VsanHostHealthState {
            "unknown",
            "healthy",
            "unhealthy",
         }
         interface VsanHostIpConfig extends srmService.vim.DynamicData {
            upstreamIpAddress: string;
            downstreamIpAddress: string;
         }
         interface VsanHostMembershipInfo extends srmService.vim.DynamicData {
            nodeUuid: string;
            hostname: string;
         }
         interface ArrayOfVsanHostMembershipInfo {
            vsanHostMembershipInfo?: Array<srmService.vim.VsanHostMembershipInfo>;
         }
         enum VsanHostNodeState {
            "error",
            "disabled",
            "agent",
            "master",
            "backup",
            "starting",
            "stopping",
            "enteringMaintenanceMode",
            "exitingMaintenanceMode",
            "decommissioning",
         }
         enum VsanDiskIssueType {
            "nonExist",
            "stampMismatch",
            "unknown",
         }
         interface VsanHostRuntimeInfoDiskIssue extends srmService.vim.DynamicData {
            diskId: string;
            issue: string;
         }
         interface ArrayOfVsanHostRuntimeInfoDiskIssue {
            vsanHostRuntimeInfoDiskIssue?: Array<srmService.vim.VsanHostRuntimeInfoDiskIssue>;
         }
         interface VsanHostRuntimeInfo extends srmService.vim.DynamicData {
            membershipList?: Array<srmService.vim.VsanHostMembershipInfo>;
            diskIssues?: Array<srmService.vim.VsanHostRuntimeInfoDiskIssue>;
            accessGenNo?: number;
         }
      }
   }
   function stsService(hostname: string, options?: {definition?: boolean; debug?: boolean; endpoint?: string, key?: string, port?: number, prefixes?: boolean;proxy?: boolean;proxyHeader?: string;}): Promise<vsphere.stsService>;
   interface stsService {
      addHandler(handler: Function): void;
      removeHandler(handler: Function): void;
      serializeObject(obj: Object, name: string): Node;
      deserializeObject(obj: Node): Object;
      xs: {
         AnyType: {
            (options?: stsService.xs.AnyType): stsService.xs.AnyType;
         };
         AnyURI: {
            (options?: stsService.xs.AnyURI): stsService.xs.AnyURI;
         };
         Base64Binary: {
            (options?: stsService.xs.Base64Binary): stsService.xs.Base64Binary;
         };
         Boolean: {
            (options?: stsService.xs.Boolean): stsService.xs.Boolean;
         };
         Byte: {
            (options?: stsService.xs.Byte): stsService.xs.Byte;
         };
         DateTime: {
            (options?: stsService.xs.DateTime): stsService.xs.DateTime;
         };
         Double: {
            (options?: stsService.xs.Double): stsService.xs.Double;
         };
         Float: {
            (options?: stsService.xs.Float): stsService.xs.Float;
         };
         ID: {
            (options?: stsService.xs.ID): stsService.xs.ID;
         };
         Int: {
            (options?: stsService.xs.Int): stsService.xs.Int;
         };
         Integer: {
            (options?: stsService.xs.Integer): stsService.xs.Integer;
         };
         Long: {
            (options?: stsService.xs.Long): stsService.xs.Long;
         };
         NCName: {
            (options?: stsService.xs.NCName): stsService.xs.NCName;
         };
         NegativeInteger: {
            (options?: stsService.xs.NegativeInteger): stsService.xs.NegativeInteger;
         };
         NonNegativeInteger: {
            (options?: stsService.xs.NonNegativeInteger): stsService.xs.NonNegativeInteger;
         };
         NonPositiveInteger: {
            (options?: stsService.xs.NonPositiveInteger): stsService.xs.NonPositiveInteger;
         };
         PositiveInteger: {
            (options?: stsService.xs.PositiveInteger): stsService.xs.PositiveInteger;
         };
         QName: {
            (options?: stsService.xs.QName): stsService.xs.QName;
         };
         Short: {
            (options?: stsService.xs.Short): stsService.xs.Short;
         };
         String: {
            (options?: stsService.xs.String): stsService.xs.String;
         };
         UnsignedLong: {
            (options?: stsService.xs.UnsignedLong): stsService.xs.UnsignedLong;
         };
      }
      stsPort: {
         challenge(requestSecurityTokenResponse: stsService.wst13.RequestSecurityTokenResponseType): Promise<stsService.wst13.RequestSecurityTokenResponseCollectionType>;
         issue(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseCollectionType>;
         renew(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseType>;
         validate(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseType>;
      }
      wsu: {
         TTimestampFault: {
            "wsu:MessageExpired": string;
         };
         AttributedDateTime: {
            (options?: stsService.wsu.AttributedDateTime): stsService.wsu.AttributedDateTime;
         };
         AttributedURI: {
            (options?: stsService.wsu.AttributedURI): stsService.wsu.AttributedURI;
         };
         TimestampType: {
            (options?: stsService.wsu.TimestampType): stsService.wsu.TimestampType;
         };
      }
      wsta: {
         AdviceSetType: {
            (options?: stsService.wsta.AdviceSetType): stsService.wsta.AdviceSetType;
         };
         AdviceType: {
            (options?: stsService.wsta.AdviceType): stsService.wsta.AdviceType;
         };
         AttributeType: {
            (options?: stsService.wsta.AttributeType): stsService.wsta.AttributeType;
         };
      }
      smlp: {
         NameIDFormats: {
            "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName": string;
            "http://schemas.xmlsoap.org/claims/UPN": string;
            "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent": string;
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress": string;
            "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified": string;
            "urn:oasis:names:tc:SAML:2.0:nameid-format:entity": string;
         };
         AttributeNameFormats: {
            "urn:oasis:names:tc:SAML:2.0:attrname-format:uri": string;
            "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified": string;
            "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified": string;
         };
         UUID: {
            (options?: stsService.smlp.UUID): stsService.smlp.UUID;
         };
         UTCTime: {
            (options?: stsService.smlp.UTCTime): stsService.smlp.UTCTime;
         };
         SubjectConfirmationMethods: {
            "urn:oasis:names:tc:SAML:2.0:cm:bearer": string;
            "urn:oasis:names:tc:SAML:2.0:cm:holder-of-key": string;
         };
         AuthnContextClassRefs: {
            "urn:oasis:names:tc:SAML:2.0:ac:classes:Kerberos": string;
            "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport": string;
            "urn:oasis:names:tc:SAML:2.0:ac:classes:XMLDSig": string;
            "urn:oasis:names:tc:SAML:2.0:ac:classes:PreviousSession": string;
            "urn:federation:authentication:windows": string;
         };
         AttributeNames: {
            "http://rsa.com/schemas/attr-names/2009/01/GroupIdentity": string;
            "http://vmware.com/schemas/attr-names/2011/07/isSolution": string;
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname": string;
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname": string;
         };
      }
      smle: {
         RSAAdviceType: {
            (options?: stsService.smle.RSAAdviceType): stsService.smle.RSAAdviceType;
         };
         RenewRestrictionType: {
            (options?: stsService.smle.RenewRestrictionType): stsService.smle.RenewRestrictionType;
         };
      }
      del: {
         DelegationRestrictionType: {
            (options?: stsService.del.DelegationRestrictionType): stsService.del.DelegationRestrictionType;
         };
         DelegateType: {
            (options?: stsService.del.DelegateType): stsService.del.DelegateType;
         };
      }
      wst14: {
         ActAsType: {
            (options?: stsService.wst14.ActAsType): stsService.wst14.ActAsType;
         };
      }
      wsa: {
         EndpointReferenceType: {
            (options?: stsService.wsa.EndpointReferenceType): stsService.wsa.EndpointReferenceType;
         };
         ReferenceParametersType: {
            (options?: stsService.wsa.ReferenceParametersType): stsService.wsa.ReferenceParametersType;
         };
         MetadataType: {
            (options?: stsService.wsa.MetadataType): stsService.wsa.MetadataType;
         };
         RelatesToType: {
            (options?: stsService.wsa.RelatesToType): stsService.wsa.RelatesToType;
         };
         RelationshipTypeOpenEnum: {
            (options?: stsService.wsa.RelationshipTypeOpenEnum): stsService.wsa.RelationshipTypeOpenEnum;
         };
         RelationshipType: {
            "http://www.w3.org/2005/08/addressing/reply": string;
         };
         AttributedURIType: {
            (options?: stsService.wsa.AttributedURIType): stsService.wsa.AttributedURIType;
         };
         FaultCodesOpenEnumType: {
            (options?: stsService.wsa.FaultCodesOpenEnumType): stsService.wsa.FaultCodesOpenEnumType;
         };
         FaultCodesType: {
            "tns:InvalidAddressingHeader": string;
            "tns:InvalidAddress": string;
            "tns:InvalidEPR": string;
            "tns:InvalidCardinality": string;
            "tns:MissingAddressInEPR": string;
            "tns:DuplicateMessageID": string;
            "tns:ActionMismatch": string;
            "tns:MessageAddressingHeaderRequired": string;
            "tns:DestinationUnreachable": string;
            "tns:ActionNotSupported": string;
            "tns:EndpointUnavailable": string;
         };
         AttributedUnsignedLongType: {
            (options?: stsService.wsa.AttributedUnsignedLongType): stsService.wsa.AttributedUnsignedLongType;
         };
         AttributedQNameType: {
            (options?: stsService.wsa.AttributedQNameType): stsService.wsa.AttributedQNameType;
         };
         ProblemActionType: {
            (options?: stsService.wsa.ProblemActionType): stsService.wsa.ProblemActionType;
         };
      }
      dsig: {
         CryptoBinary: {
            (options?: stsService.dsig.CryptoBinary): stsService.dsig.CryptoBinary;
         };
         SignatureType: {
            (options?: stsService.dsig.SignatureType): stsService.dsig.SignatureType;
         };
         SignatureValueType: {
            (options?: stsService.dsig.SignatureValueType): stsService.dsig.SignatureValueType;
         };
         SignedInfoType: {
            (options?: stsService.dsig.SignedInfoType): stsService.dsig.SignedInfoType;
         };
         CanonicalizationMethodType: {
            (options?: stsService.dsig.CanonicalizationMethodType): stsService.dsig.CanonicalizationMethodType;
         };
         SignatureMethodType: {
            (options?: stsService.dsig.SignatureMethodType): stsService.dsig.SignatureMethodType;
         };
         ReferenceType: {
            (options?: stsService.dsig.ReferenceType): stsService.dsig.ReferenceType;
         };
         TransformsType: {
            (options?: stsService.dsig.TransformsType): stsService.dsig.TransformsType;
         };
         TransformType: {
            (options?: stsService.dsig.TransformType): stsService.dsig.TransformType;
         };
         DigestMethodType: {
            (options?: stsService.dsig.DigestMethodType): stsService.dsig.DigestMethodType;
         };
         DigestValueType: {
            (options?: stsService.dsig.DigestValueType): stsService.dsig.DigestValueType;
         };
         KeyInfoType: {
            (options?: stsService.dsig.KeyInfoType): stsService.dsig.KeyInfoType;
         };
         KeyValueType: {
            (options?: stsService.dsig.KeyValueType): stsService.dsig.KeyValueType;
         };
         RetrievalMethodType: {
            (options?: stsService.dsig.RetrievalMethodType): stsService.dsig.RetrievalMethodType;
         };
         X509DataType: {
            (options?: stsService.dsig.X509DataType): stsService.dsig.X509DataType;
         };
         X509IssuerSerialType: {
            (options?: stsService.dsig.X509IssuerSerialType): stsService.dsig.X509IssuerSerialType;
         };
         PGPDataType: {
            (options?: stsService.dsig.PGPDataType): stsService.dsig.PGPDataType;
         };
         SPKIDataType: {
            (options?: stsService.dsig.SPKIDataType): stsService.dsig.SPKIDataType;
         };
         ObjectType: {
            (options?: stsService.dsig.ObjectType): stsService.dsig.ObjectType;
         };
         ManifestType: {
            (options?: stsService.dsig.ManifestType): stsService.dsig.ManifestType;
         };
         SignaturePropertiesType: {
            (options?: stsService.dsig.SignaturePropertiesType): stsService.dsig.SignaturePropertiesType;
         };
         SignaturePropertyType: {
            (options?: stsService.dsig.SignaturePropertyType): stsService.dsig.SignaturePropertyType;
         };
         HMACOutputLengthType: {
            (options?: stsService.dsig.HMACOutputLengthType): stsService.dsig.HMACOutputLengthType;
         };
         DSAKeyValueType: {
            (options?: stsService.dsig.DSAKeyValueType): stsService.dsig.DSAKeyValueType;
         };
         RSAKeyValueType: {
            (options?: stsService.dsig.RSAKeyValueType): stsService.dsig.RSAKeyValueType;
         };
      }
      saml: {
         NameIDType: {
            (options?: stsService.saml.NameIDType): stsService.saml.NameIDType;
         };
         AssertionType: {
            (options?: stsService.saml.AssertionType): stsService.saml.AssertionType;
         };
         SubjectType: {
            (options?: stsService.saml.SubjectType): stsService.saml.SubjectType;
         };
         SubjectConfirmationType: {
            (options?: stsService.saml.SubjectConfirmationType): stsService.saml.SubjectConfirmationType;
         };
         SubjectConfirmationDataType: {
            (options?: stsService.saml.SubjectConfirmationDataType): stsService.saml.SubjectConfirmationDataType;
         };
         KeyInfoConfirmationDataType: {
            (options?: stsService.saml.KeyInfoConfirmationDataType): stsService.saml.KeyInfoConfirmationDataType;
         };
         ConditionsType: {
            (options?: stsService.saml.ConditionsType): stsService.saml.ConditionsType;
         };
         ConditionAbstractType: {
            (options?: stsService.saml.ConditionAbstractType): stsService.saml.ConditionAbstractType;
         };
         AudienceRestrictionType: {
            (options?: stsService.saml.AudienceRestrictionType): stsService.saml.AudienceRestrictionType;
         };
         OneTimeUseType: {
            (options?: stsService.saml.OneTimeUseType): stsService.saml.OneTimeUseType;
         };
         ProxyRestrictionType: {
            (options?: stsService.saml.ProxyRestrictionType): stsService.saml.ProxyRestrictionType;
         };
         AdviceType: {
            (options?: stsService.saml.AdviceType): stsService.saml.AdviceType;
         };
         StatementAbstractType: {
            (options?: stsService.saml.StatementAbstractType): stsService.saml.StatementAbstractType;
         };
         AuthnStatementType: {
            (options?: stsService.saml.AuthnStatementType): stsService.saml.AuthnStatementType;
         };
         AuthnContextType: {
            (options?: stsService.saml.AuthnContextType): stsService.saml.AuthnContextType;
         };
         AttributeStatementType: {
            (options?: stsService.saml.AttributeStatementType): stsService.saml.AttributeStatementType;
         };
         AttributeType: {
            (options?: stsService.saml.AttributeType): stsService.saml.AttributeType;
         };
      }
      wsse: {
         SecurityHeaderType: {
            (options?: stsService.wsse.SecurityHeaderType): stsService.wsse.SecurityHeaderType;
         };
         UsernameTokenType: {
            (options?: stsService.wsse.UsernameTokenType): stsService.wsse.UsernameTokenType;
         };
         AttributedString: {
            (options?: stsService.wsse.AttributedString): stsService.wsse.AttributedString;
         };
         PasswordString: {
            (options?: stsService.wsse.PasswordString): stsService.wsse.PasswordString;
         };
         BinarySecurityTokenType: {
            (options?: stsService.wsse.BinarySecurityTokenType): stsService.wsse.BinarySecurityTokenType;
         };
         EncodedString: {
            (options?: stsService.wsse.EncodedString): stsService.wsse.EncodedString;
         };
         KeyIdentifierType: {
            (options?: stsService.wsse.KeyIdentifierType): stsService.wsse.KeyIdentifierType;
         };
         ReferenceType: {
            (options?: stsService.wsse.ReferenceType): stsService.wsse.ReferenceType;
         };
         SecurityTokenReferenceType: {
            (options?: stsService.wsse.SecurityTokenReferenceType): stsService.wsse.SecurityTokenReferenceType;
         };
      }
      wst13: {
         RequestSecurityTokenType: {
            (options?: stsService.wst13.RequestSecurityTokenType): stsService.wst13.RequestSecurityTokenType;
         };
         RequestTypeOpenEnum: {
            (options?: stsService.wst13.RequestTypeOpenEnum): stsService.wst13.RequestTypeOpenEnum;
         };
         RequestTypeEnum: {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue": string;
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Renew": string;
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Cancel": string;
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Validate": string;
         };
         RequestSecurityTokenResponseType: {
            (options?: stsService.wst13.RequestSecurityTokenResponseType): stsService.wst13.RequestSecurityTokenResponseType;
         };
         RequestedSecurityTokenType: {
            (options?: stsService.wst13.RequestedSecurityTokenType): stsService.wst13.RequestedSecurityTokenType;
         };
         LifetimeType: {
            (options?: stsService.wst13.LifetimeType): stsService.wst13.LifetimeType;
         };
         RequestSecurityTokenResponseCollectionType: {
            (options?: stsService.wst13.RequestSecurityTokenResponseCollectionType): stsService.wst13.RequestSecurityTokenResponseCollectionType;
         };
         RenewTargetType: {
            (options?: stsService.wst13.RenewTargetType): stsService.wst13.RenewTargetType;
         };
         RenewingType: {
            (options?: stsService.wst13.RenewingType): stsService.wst13.RenewingType;
         };
         ValidateTargetType: {
            (options?: stsService.wst13.ValidateTargetType): stsService.wst13.ValidateTargetType;
         };
         StatusType: {
            (options?: stsService.wst13.StatusType): stsService.wst13.StatusType;
         };
         StatusCodeEnum: {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/status/valid": string;
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/status/invalid": string;
         };
         StatusCodeOpenEnum: {
            (options?: stsService.wst13.StatusCodeOpenEnum): stsService.wst13.StatusCodeOpenEnum;
         };
         BinaryExchangeType: {
            (options?: stsService.wst13.BinaryExchangeType): stsService.wst13.BinaryExchangeType;
         };
         KeyTypeEnum: {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey": string;
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer": string;
         };
         KeyTypeOpenEnum: {
            (options?: stsService.wst13.KeyTypeOpenEnum): stsService.wst13.KeyTypeOpenEnum;
         };
         UseKeyType: {
            (options?: stsService.wst13.UseKeyType): stsService.wst13.UseKeyType;
         };
         DelegateToType: {
            (options?: stsService.wst13.DelegateToType): stsService.wst13.DelegateToType;
         };
         ParticipantsType: {
            (options?: stsService.wst13.ParticipantsType): stsService.wst13.ParticipantsType;
         };
         ParticipantType: {
            (options?: stsService.wst13.ParticipantType): stsService.wst13.ParticipantType;
         };
      }
   }
   namespace stsService {
      interface xs {
      }
      namespace xs {
         interface AnyType {
            value: string;
         }
         interface AnyURI {
            value: string;
         }
         interface Base64Binary {
            value: string;
         }
         interface Boolean {
            value: string;
         }
         interface Byte {
            value: string;
         }
         interface DateTime {
            value: string;
         }
         interface Double {
            value: string;
         }
         interface Float {
            value: string;
         }
         interface ID {
            value: string;
         }
         interface Int {
            value: string;
         }
         interface Integer {
            value: string;
         }
         interface Long {
            value: string;
         }
         interface NCName {
            value: string;
         }
         interface NegativeInteger {
            value: string;
         }
         interface NonNegativeInteger {
            value: string;
         }
         interface NonPositiveInteger {
            value: string;
         }
         interface PositiveInteger {
            value: string;
         }
         interface QName {
            value: string;
         }
         interface Short {
            value: string;
         }
         interface String {
            value: string;
         }
         interface UnsignedLong {
            value: string;
         }
      }
      interface stsPort {
         challenge(requestSecurityTokenResponse: stsService.wst13.RequestSecurityTokenResponseType): Promise<stsService.wst13.RequestSecurityTokenResponseCollectionType>;
         issue(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseCollectionType>;
         renew(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseType>;
         validate(requestSecurityToken: stsService.wst13.RequestSecurityTokenType): Promise<stsService.wst13.RequestSecurityTokenResponseType>;
      }
      namespace stsPort {
      }
      interface wsu {
      }
      namespace wsu {
         enum TTimestampFault {
            "wsu:MessageExpired",
         }
         interface AttributedDateTime extends stsService.xs.String {
            id: string;
            value: string;
         }
         interface AttributedURI extends stsService.xs.AnyURI {
            id: string;
            value: string;
         }
         interface TimestampType {
            id: string;
            created: stsService.wsu.AttributedDateTime;
            expires: stsService.wsu.AttributedDateTime;
         }
      }
      interface wsta {
      }
      namespace wsta {
         interface AdviceSetType {
            advice: Array<stsService.wsta.AdviceType>;
         }
         interface AdviceType {
            adviceSource: string;
            attribute: Array<stsService.wsta.AttributeType>;
         }
         interface AttributeType {
            name: string;
            friendlyName: string;
            attributeValue?: Array<any>;
         }
      }
      interface smlp {
      }
      namespace smlp {
         enum NameIDFormats {
            "urn:oasis:names:tc:SAML:1.1:nameid-format:X509SubjectName",
            "http://schemas.xmlsoap.org/claims/UPN",
            "urn:oasis:names:tc:SAML:2.0:nameid-format:persistent",
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/emailaddress",
            "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified",
            "urn:oasis:names:tc:SAML:2.0:nameid-format:entity",
         }
         enum AttributeNameFormats {
            "urn:oasis:names:tc:SAML:2.0:attrname-format:uri",
            "urn:oasis:names:tc:SAML:1.1:nameid-format:unspecified",
            "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified",
         }
         interface UUID {
         }
         interface UTCTime {
         }
         enum SubjectConfirmationMethods {
            "urn:oasis:names:tc:SAML:2.0:cm:bearer",
            "urn:oasis:names:tc:SAML:2.0:cm:holder-of-key",
         }
         enum AuthnContextClassRefs {
            "urn:oasis:names:tc:SAML:2.0:ac:classes:Kerberos",
            "urn:oasis:names:tc:SAML:2.0:ac:classes:PasswordProtectedTransport",
            "urn:oasis:names:tc:SAML:2.0:ac:classes:XMLDSig",
            "urn:oasis:names:tc:SAML:2.0:ac:classes:PreviousSession",
            "urn:federation:authentication:windows",
         }
         enum AttributeNames {
            "http://rsa.com/schemas/attr-names/2009/01/GroupIdentity",
            "http://vmware.com/schemas/attr-names/2011/07/isSolution",
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/givenname",
            "http://schemas.xmlsoap.org/ws/2005/05/identity/claims/surname",
         }
      }
      interface smle {
      }
      namespace smle {
         interface RSAAdviceType {
            adviceSource: string;
            attribute: Array<stsService.saml.AttributeType>;
         }
         interface RenewRestrictionType extends stsService.saml.ConditionAbstractType {
            count: number;
            postdatable: boolean;
            renewExpired: boolean;
         }
      }
      interface del {
      }
      namespace del {
         interface DelegationRestrictionType extends stsService.saml.ConditionAbstractType {
            delegate: Array<stsService.del.DelegateType>;
         }
         interface DelegateType {
            delegationInstant: Date;
            nameID: stsService.saml.NameIDType;
         }
      }
      interface wst14 {
      }
      namespace wst14 {
         interface ActAsType {
            assertion: stsService.saml.AssertionType;
         }
      }
      interface wsa {
      }
      namespace wsa {
         interface EndpointReferenceType {
            address: stsService.wsa.AttributedURIType;
            referenceParameters?: stsService.wsa.ReferenceParametersType;
            metadata?: stsService.wsa.MetadataType;
         }
         interface ReferenceParametersType {
         }
         interface MetadataType {
         }
         interface RelatesToType extends stsService.xs.AnyURI {
            relationshipType: stsService.wsa.RelationshipTypeOpenEnum;
            value: string;
         }
         interface RelationshipTypeOpenEnum {
         }
         enum RelationshipType {
            "http://www.w3.org/2005/08/addressing/reply",
         }
         interface AttributedURIType extends stsService.xs.AnyURI {
            value: string;
         }
         interface FaultCodesOpenEnumType {
         }
         enum FaultCodesType {
            "tns:InvalidAddressingHeader",
            "tns:InvalidAddress",
            "tns:InvalidEPR",
            "tns:InvalidCardinality",
            "tns:MissingAddressInEPR",
            "tns:DuplicateMessageID",
            "tns:ActionMismatch",
            "tns:MessageAddressingHeaderRequired",
            "tns:DestinationUnreachable",
            "tns:ActionNotSupported",
            "tns:EndpointUnavailable",
         }
         interface AttributedUnsignedLongType extends stsService.xs.UnsignedLong {
            value: string;
         }
         interface AttributedQNameType extends stsService.xs.QName {
            value: string;
         }
         interface ProblemActionType {
            action?: stsService.wsa.AttributedURIType;
            soapAction?: string;
         }
      }
      interface dsig {
      }
      namespace dsig {
         interface CryptoBinary {
         }
         interface SignatureType {
            id: string;
            signedInfo: stsService.dsig.SignedInfoType;
            signatureValue: stsService.dsig.SignatureValueType;
            keyInfo?: stsService.dsig.KeyInfoType;
            object?: Array<stsService.dsig.ObjectType>;
         }
         interface SignatureValueType extends stsService.xs.Base64Binary {
            id: string;
            value: string;
         }
         interface SignedInfoType {
            id: string;
            canonicalizationMethod: stsService.dsig.CanonicalizationMethodType;
            signatureMethod: stsService.dsig.SignatureMethodType;
            reference: Array<stsService.dsig.ReferenceType>;
         }
         interface CanonicalizationMethodType {
            algorithm: string;
         }
         interface SignatureMethodType {
            algorithm: string;
            hMACOutputLength?: stsService.dsig.HMACOutputLengthType;
         }
         interface ReferenceType {
            id: string;
            uRI: string;
            type: string;
            transforms?: stsService.dsig.TransformsType;
            digestMethod: stsService.dsig.DigestMethodType;
            digestValue: stsService.dsig.DigestValueType;
         }
         interface TransformsType {
            transform: Array<stsService.dsig.TransformType>;
         }
         interface TransformType {
         }
         interface DigestMethodType {
            algorithm: string;
         }
         interface DigestValueType {
         }
         interface KeyInfoType {
         }
         interface KeyValueType {
            dSAKeyValue?: stsService.dsig.DSAKeyValueType;
            rSAKeyValue?: stsService.dsig.RSAKeyValueType;
         }
         interface RetrievalMethodType {
            uRI: string;
            type: string;
            transforms?: stsService.dsig.TransformsType;
         }
         interface X509DataType {
         }
         interface X509IssuerSerialType {
            x509IssuerName: string;
            x509SerialNumber: number;
         }
         interface PGPDataType {
            pGPKeyID: string;
            pGPKeyPacket: string;
         }
         interface SPKIDataType {
         }
         interface ObjectType {
         }
         interface ManifestType {
            id: string;
            reference: Array<stsService.dsig.ReferenceType>;
         }
         interface SignaturePropertiesType {
            id: string;
            signatureProperty: Array<stsService.dsig.SignaturePropertyType>;
         }
         interface SignaturePropertyType {
         }
         interface HMACOutputLengthType {
         }
         interface DSAKeyValueType {
            p: stsService.dsig.CryptoBinary;
            q: stsService.dsig.CryptoBinary;
            g?: stsService.dsig.CryptoBinary;
            y: stsService.dsig.CryptoBinary;
            j?: stsService.dsig.CryptoBinary;
            seed: stsService.dsig.CryptoBinary;
            pgenCounter: stsService.dsig.CryptoBinary;
         }
         interface RSAKeyValueType {
            modulus: stsService.dsig.CryptoBinary;
            exponent: stsService.dsig.CryptoBinary;
         }
      }
      interface saml {
      }
      namespace saml {
         interface NameIDType extends stsService.xs.String {
            nameQualifier: string;
            format: stsService.smlp.NameIDFormats;
            value: string;
         }
         interface AssertionType {
         }
         interface SubjectType {
            nameID: stsService.saml.NameIDType;
            subjectConfirmation: stsService.saml.SubjectConfirmationType;
         }
         interface SubjectConfirmationType {
            method: stsService.smlp.SubjectConfirmationMethods;
            nameID?: stsService.saml.NameIDType;
            subjectConfirmationData: stsService.saml.SubjectConfirmationDataType;
         }
         interface SubjectConfirmationDataType {
            notOnOrAfter: stsService.smlp.UTCTime;
            recipient: string;
            inResponseTo: string;
         }
         interface KeyInfoConfirmationDataType {
            keyInfo: Array<stsService.dsig.KeyInfoType>;
         }
         interface ConditionsType {
         }
         interface ConditionAbstractType {
         }
         interface AudienceRestrictionType extends stsService.saml.ConditionAbstractType {
            audience: Array<string>;
         }
         interface OneTimeUseType extends stsService.saml.ConditionAbstractType {
         }
         interface ProxyRestrictionType extends stsService.saml.ConditionAbstractType {
            count: number;
         }
         interface AdviceType {
         }
         interface StatementAbstractType {
         }
         interface AuthnStatementType extends stsService.saml.StatementAbstractType {
            authnInstant: stsService.smlp.UTCTime;
            sessionIndex: string;
            sessionNotOnOrAfter: Date;
            authnContext: stsService.saml.AuthnContextType;
         }
         interface AuthnContextType {
            authnContextClassRef: stsService.smlp.AuthnContextClassRefs;
         }
         interface AttributeStatementType extends stsService.saml.StatementAbstractType {
         }
         interface AttributeType {
            name: string;
            nameFormat: stsService.smlp.AttributeNameFormats;
            friendlyName: string;
            attributeValue?: Array<any>;
         }
      }
      interface wsse {
      }
      namespace wsse {
         interface SecurityHeaderType {
         }
         interface UsernameTokenType {
            id: string;
            username: stsService.wsse.AttributedString;
         }
         interface AttributedString extends stsService.xs.String {
            id: string;
            value: string;
         }
         interface PasswordString extends stsService.wsse.AttributedString {
            type: string;
         }
         interface BinarySecurityTokenType extends stsService.wsse.EncodedString {
            valueType: string;
         }
         interface EncodedString extends stsService.wsse.AttributedString {
            encodingType: string;
         }
         interface KeyIdentifierType extends stsService.wsse.EncodedString {
            valueType: string;
         }
         interface ReferenceType {
            uRI: string;
            valueType: string;
         }
         interface SecurityTokenReferenceType {
         }
      }
      interface wst13 {
      }
      namespace wst13 {
         interface RequestSecurityTokenType {
            context: string;
            tokenType?: string;
            requestType: stsService.wst13.RequestTypeOpenEnum;
            lifetime?: stsService.wst13.LifetimeType;
            validateTarget?: stsService.wst13.ValidateTargetType;
            renewTarget?: stsService.wst13.RenewTargetType;
            renewing?: stsService.wst13.RenewingType;
            delegateTo?: stsService.wst13.DelegateToType;
            delegatable?: boolean;
            actAs?: stsService.wst14.ActAsType;
            useKey?: stsService.wst13.UseKeyType;
            keyType?: stsService.wst13.KeyTypeOpenEnum;
            signatureAlgorithm?: string;
            binaryExchange?: stsService.wst13.BinaryExchangeType;
            participants?: stsService.wst13.ParticipantsType;
            adviceSet?: stsService.wsta.AdviceSetType;
         }
         interface RequestTypeOpenEnum {
         }
         enum RequestTypeEnum {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Issue",
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Renew",
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Cancel",
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Validate",
         }
         interface RequestSecurityTokenResponseType {
            context: string;
            requestedSecurityToken: stsService.wst13.RequestedSecurityTokenType;
            lifetime: stsService.wst13.LifetimeType;
            tokenType: string;
            status: stsService.wst13.StatusType;
            binaryExchange: stsService.wst13.BinaryExchangeType;
            renewing?: stsService.wst13.RenewingType;
            keyType?: stsService.wst13.KeyTypeOpenEnum;
            delegatable?: boolean;
            signatureAlgorithm?: string;
            adviceSet?: stsService.wsta.AdviceSetType;
         }
         interface RequestedSecurityTokenType {
            assertion: stsService.saml.AssertionType;
         }
         interface LifetimeType {
            created?: stsService.wsu.AttributedDateTime;
            expires?: stsService.wsu.AttributedDateTime;
         }
         interface RequestSecurityTokenResponseCollectionType {
            requestSecurityTokenResponse: stsService.wst13.RequestSecurityTokenResponseType;
         }
         interface RenewTargetType {
            assertion: stsService.saml.AssertionType;
         }
         interface RenewingType {
            allow: boolean;
            oK: boolean;
         }
         interface ValidateTargetType {
         }
         interface StatusType {
            code: stsService.wst13.StatusCodeOpenEnum;
            reason?: string;
         }
         enum StatusCodeEnum {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/status/valid",
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/status/invalid",
         }
         interface StatusCodeOpenEnum {
         }
         interface BinaryExchangeType extends stsService.xs.String {
            valueType: string;
            encodingType: string;
            value: string;
         }
         enum KeyTypeEnum {
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/PublicKey",
            "http://docs.oasis-open.org/ws-sx/ws-trust/200512/Bearer",
         }
         interface KeyTypeOpenEnum {
         }
         interface UseKeyType {
            sig: string;
         }
         interface DelegateToType {
            usernameToken: stsService.wsse.UsernameTokenType;
         }
         interface ParticipantsType {
            primary?: stsService.wst13.ParticipantType;
            participant?: Array<stsService.wst13.ParticipantType>;
         }
         interface ParticipantType {
            endpointReference: stsService.wsa.EndpointReferenceType;
         }
      }
   }
   function vimService(hostname: string, options?: {definition?: boolean; debug?: boolean; endpoint?: string, key?: string, port?: number, prefixes?: boolean;proxy?: boolean;proxyHeader?: string;}): Promise<vsphere.vimService>;
   interface vimService {
      addHandler(handler: Function): void;
      removeHandler(handler: Function): void;
      serializeObject(obj: Object, name: string): Node;
      deserializeObject(obj: Node): Object;
      serviceInstance: vimService.vim.ManagedObjectReference;
      serviceContent: vimService.vim.ServiceContent;
      xs: {
         AnyType: {
            (options?: vimService.xs.AnyType): vimService.xs.AnyType;
         };
         AnyURI: {
            (options?: vimService.xs.AnyURI): vimService.xs.AnyURI;
         };
         Base64Binary: {
            (options?: vimService.xs.Base64Binary): vimService.xs.Base64Binary;
         };
         Boolean: {
            (options?: vimService.xs.Boolean): vimService.xs.Boolean;
         };
         Byte: {
            (options?: vimService.xs.Byte): vimService.xs.Byte;
         };
         DateTime: {
            (options?: vimService.xs.DateTime): vimService.xs.DateTime;
         };
         Double: {
            (options?: vimService.xs.Double): vimService.xs.Double;
         };
         Float: {
            (options?: vimService.xs.Float): vimService.xs.Float;
         };
         ID: {
            (options?: vimService.xs.ID): vimService.xs.ID;
         };
         Int: {
            (options?: vimService.xs.Int): vimService.xs.Int;
         };
         Integer: {
            (options?: vimService.xs.Integer): vimService.xs.Integer;
         };
         Long: {
            (options?: vimService.xs.Long): vimService.xs.Long;
         };
         NCName: {
            (options?: vimService.xs.NCName): vimService.xs.NCName;
         };
         NegativeInteger: {
            (options?: vimService.xs.NegativeInteger): vimService.xs.NegativeInteger;
         };
         NonNegativeInteger: {
            (options?: vimService.xs.NonNegativeInteger): vimService.xs.NonNegativeInteger;
         };
         NonPositiveInteger: {
            (options?: vimService.xs.NonPositiveInteger): vimService.xs.NonPositiveInteger;
         };
         PositiveInteger: {
            (options?: vimService.xs.PositiveInteger): vimService.xs.PositiveInteger;
         };
         QName: {
            (options?: vimService.xs.QName): vimService.xs.QName;
         };
         Short: {
            (options?: vimService.xs.Short): vimService.xs.Short;
         };
         String: {
            (options?: vimService.xs.String): vimService.xs.String;
         };
         UnsignedLong: {
            (options?: vimService.xs.UnsignedLong): vimService.xs.UnsignedLong;
         };
      }
      vim: {
         DynamicArray: {
            (options?: vimService.vim.DynamicArray): vimService.vim.DynamicArray;
         };
         DynamicData: {
            (options?: vimService.vim.DynamicData): vimService.vim.DynamicData;
         };
         DynamicProperty: {
            (options?: vimService.vim.DynamicProperty): vimService.vim.DynamicProperty;
         };
         ArrayOfDynamicProperty: {
            (options?: vimService.vim.ArrayOfDynamicProperty): vimService.vim.ArrayOfDynamicProperty;
         };
         KeyAnyValue: {
            (options?: vimService.vim.KeyAnyValue): vimService.vim.KeyAnyValue;
         };
         ArrayOfKeyAnyValue: {
            (options?: vimService.vim.ArrayOfKeyAnyValue): vimService.vim.ArrayOfKeyAnyValue;
         };
         LocalizableMessage: {
            (options?: vimService.vim.LocalizableMessage): vimService.vim.LocalizableMessage;
         };
         ArrayOfLocalizableMessage: {
            (options?: vimService.vim.ArrayOfLocalizableMessage): vimService.vim.ArrayOfLocalizableMessage;
         };
         LocalizedMethodFault: {
            (options?: vimService.vim.LocalizedMethodFault): vimService.vim.LocalizedMethodFault;
         };
         MethodFault: {
            (options?: vimService.vim.MethodFault): vimService.vim.MethodFault;
         };
         ArrayOfMethodFault: {
            (options?: vimService.vim.ArrayOfMethodFault): vimService.vim.ArrayOfMethodFault;
         };
         RuntimeFault: {
            (options?: vimService.vim.RuntimeFault): vimService.vim.RuntimeFault;
         };
         HostCommunication: {
            (options?: vimService.vim.HostCommunication): vimService.vim.HostCommunication;
         };
         HostNotConnected: {
            (options?: vimService.vim.HostNotConnected): vimService.vim.HostNotConnected;
         };
         HostNotReachable: {
            (options?: vimService.vim.HostNotReachable): vimService.vim.HostNotReachable;
         };
         InvalidArgument: {
            (options?: vimService.vim.InvalidArgument): vimService.vim.InvalidArgument;
         };
         InvalidRequest: {
            (options?: vimService.vim.InvalidRequest): vimService.vim.InvalidRequest;
         };
         InvalidType: {
            (options?: vimService.vim.InvalidType): vimService.vim.InvalidType;
         };
         ManagedObjectNotFound: {
            (options?: vimService.vim.ManagedObjectNotFound): vimService.vim.ManagedObjectNotFound;
         };
         MethodNotFound: {
            (options?: vimService.vim.MethodNotFound): vimService.vim.MethodNotFound;
         };
         NotEnoughLicenses: {
            (options?: vimService.vim.NotEnoughLicenses): vimService.vim.NotEnoughLicenses;
         };
         NotImplemented: {
            (options?: vimService.vim.NotImplemented): vimService.vim.NotImplemented;
         };
         NotSupported: {
            (options?: vimService.vim.NotSupported): vimService.vim.NotSupported;
         };
         RequestCanceled: {
            (options?: vimService.vim.RequestCanceled): vimService.vim.RequestCanceled;
         };
         SecurityError: {
            (options?: vimService.vim.SecurityError): vimService.vim.SecurityError;
         };
         SystemError: {
            (options?: vimService.vim.SystemError): vimService.vim.SystemError;
         };
         UnexpectedFault: {
            (options?: vimService.vim.UnexpectedFault): vimService.vim.UnexpectedFault;
         };
         ManagedObjectReference: {
            (options?: vimService.vim.ManagedObjectReference): vimService.vim.ManagedObjectReference;
         };
         ArrayOfString: {
            (options?: vimService.vim.ArrayOfString): vimService.vim.ArrayOfString;
         };
         ArrayOfAnyType: {
            (options?: vimService.vim.ArrayOfAnyType): vimService.vim.ArrayOfAnyType;
         };
         ArrayOfAnyURI: {
            (options?: vimService.vim.ArrayOfAnyURI): vimService.vim.ArrayOfAnyURI;
         };
         ArrayOfManagedObjectReference: {
            (options?: vimService.vim.ArrayOfManagedObjectReference): vimService.vim.ArrayOfManagedObjectReference;
         };
         ArrayOfBoolean: {
            (options?: vimService.vim.ArrayOfBoolean): vimService.vim.ArrayOfBoolean;
         };
         ArrayOfByte: {
            (options?: vimService.vim.ArrayOfByte): vimService.vim.ArrayOfByte;
         };
         ArrayOfDouble: {
            (options?: vimService.vim.ArrayOfDouble): vimService.vim.ArrayOfDouble;
         };
         ArrayOfInt: {
            (options?: vimService.vim.ArrayOfInt): vimService.vim.ArrayOfInt;
         };
         ArrayOfLong: {
            (options?: vimService.vim.ArrayOfLong): vimService.vim.ArrayOfLong;
         };
         ArrayOfShort: {
            (options?: vimService.vim.ArrayOfShort): vimService.vim.ArrayOfShort;
         };
         InvalidCollectorVersion: {
            (options?: vimService.vim.InvalidCollectorVersion): vimService.vim.InvalidCollectorVersion;
         };
         InvalidProperty: {
            (options?: vimService.vim.InvalidProperty): vimService.vim.InvalidProperty;
         };
         PropertyFilterSpec: {
            (options?: vimService.vim.PropertyFilterSpec): vimService.vim.PropertyFilterSpec;
         };
         ArrayOfPropertyFilterSpec: {
            (options?: vimService.vim.ArrayOfPropertyFilterSpec): vimService.vim.ArrayOfPropertyFilterSpec;
         };
         PropertySpec: {
            (options?: vimService.vim.PropertySpec): vimService.vim.PropertySpec;
         };
         ArrayOfPropertySpec: {
            (options?: vimService.vim.ArrayOfPropertySpec): vimService.vim.ArrayOfPropertySpec;
         };
         ObjectSpec: {
            (options?: vimService.vim.ObjectSpec): vimService.vim.ObjectSpec;
         };
         ArrayOfObjectSpec: {
            (options?: vimService.vim.ArrayOfObjectSpec): vimService.vim.ArrayOfObjectSpec;
         };
         SelectionSpec: {
            (options?: vimService.vim.SelectionSpec): vimService.vim.SelectionSpec;
         };
         ArrayOfSelectionSpec: {
            (options?: vimService.vim.ArrayOfSelectionSpec): vimService.vim.ArrayOfSelectionSpec;
         };
         TraversalSpec: {
            (options?: vimService.vim.TraversalSpec): vimService.vim.TraversalSpec;
         };
         ObjectContent: {
            (options?: vimService.vim.ObjectContent): vimService.vim.ObjectContent;
         };
         ArrayOfObjectContent: {
            (options?: vimService.vim.ArrayOfObjectContent): vimService.vim.ArrayOfObjectContent;
         };
         UpdateSet: {
            (options?: vimService.vim.UpdateSet): vimService.vim.UpdateSet;
         };
         PropertyFilterUpdate: {
            (options?: vimService.vim.PropertyFilterUpdate): vimService.vim.PropertyFilterUpdate;
         };
         ArrayOfPropertyFilterUpdate: {
            (options?: vimService.vim.ArrayOfPropertyFilterUpdate): vimService.vim.ArrayOfPropertyFilterUpdate;
         };
         ObjectUpdateKind: {
            "modify": string;
            "enter": string;
            "leave": string;
         };
         ObjectUpdate: {
            (options?: vimService.vim.ObjectUpdate): vimService.vim.ObjectUpdate;
         };
         ArrayOfObjectUpdate: {
            (options?: vimService.vim.ArrayOfObjectUpdate): vimService.vim.ArrayOfObjectUpdate;
         };
         PropertyChangeOp: {
            "add": string;
            "remove": string;
            "assign": string;
            "indirectRemove": string;
         };
         PropertyChange: {
            (options?: vimService.vim.PropertyChange): vimService.vim.PropertyChange;
         };
         ArrayOfPropertyChange: {
            (options?: vimService.vim.ArrayOfPropertyChange): vimService.vim.ArrayOfPropertyChange;
         };
         MissingProperty: {
            (options?: vimService.vim.MissingProperty): vimService.vim.MissingProperty;
         };
         ArrayOfMissingProperty: {
            (options?: vimService.vim.ArrayOfMissingProperty): vimService.vim.ArrayOfMissingProperty;
         };
         MissingObject: {
            (options?: vimService.vim.MissingObject): vimService.vim.MissingObject;
         };
         ArrayOfMissingObject: {
            (options?: vimService.vim.ArrayOfMissingObject): vimService.vim.ArrayOfMissingObject;
         };
         WaitOptions: {
            (options?: vimService.vim.WaitOptions): vimService.vim.WaitOptions;
         };
         RetrieveOptions: {
            (options?: vimService.vim.RetrieveOptions): vimService.vim.RetrieveOptions;
         };
         RetrieveResult: {
            (options?: vimService.vim.RetrieveResult): vimService.vim.RetrieveResult;
         };
         AboutInfo: {
            (options?: vimService.vim.AboutInfo): vimService.vim.AboutInfo;
         };
         AuthorizationDescription: {
            (options?: vimService.vim.AuthorizationDescription): vimService.vim.AuthorizationDescription;
         };
         Permission: {
            (options?: vimService.vim.Permission): vimService.vim.Permission;
         };
         ArrayOfPermission: {
            (options?: vimService.vim.ArrayOfPermission): vimService.vim.ArrayOfPermission;
         };
         AuthorizationRole: {
            (options?: vimService.vim.AuthorizationRole): vimService.vim.AuthorizationRole;
         };
         ArrayOfAuthorizationRole: {
            (options?: vimService.vim.ArrayOfAuthorizationRole): vimService.vim.ArrayOfAuthorizationRole;
         };
         AuthorizationPrivilege: {
            (options?: vimService.vim.AuthorizationPrivilege): vimService.vim.AuthorizationPrivilege;
         };
         ArrayOfAuthorizationPrivilege: {
            (options?: vimService.vim.ArrayOfAuthorizationPrivilege): vimService.vim.ArrayOfAuthorizationPrivilege;
         };
         PrivilegeAvailability: {
            (options?: vimService.vim.PrivilegeAvailability): vimService.vim.PrivilegeAvailability;
         };
         ArrayOfPrivilegeAvailability: {
            (options?: vimService.vim.ArrayOfPrivilegeAvailability): vimService.vim.ArrayOfPrivilegeAvailability;
         };
         EntityPrivilege: {
            (options?: vimService.vim.EntityPrivilege): vimService.vim.EntityPrivilege;
         };
         ArrayOfEntityPrivilege: {
            (options?: vimService.vim.ArrayOfEntityPrivilege): vimService.vim.ArrayOfEntityPrivilege;
         };
         BatchResultResult: {
            "success": string;
            "fail": string;
         };
         BatchResult: {
            (options?: vimService.vim.BatchResult): vimService.vim.BatchResult;
         };
         BoolPolicy: {
            (options?: vimService.vim.BoolPolicy): vimService.vim.BoolPolicy;
         };
         Capability: {
            (options?: vimService.vim.Capability): vimService.vim.Capability;
         };
         ClusterComputeResourceSummary: {
            (options?: vimService.vim.ClusterComputeResourceSummary): vimService.vim.ClusterComputeResourceSummary;
         };
         ComputeResourceSummary: {
            (options?: vimService.vim.ComputeResourceSummary): vimService.vim.ComputeResourceSummary;
         };
         ComputeResourceConfigInfo: {
            (options?: vimService.vim.ComputeResourceConfigInfo): vimService.vim.ComputeResourceConfigInfo;
         };
         ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState: {
            "licensed": string;
            "unlicensed": string;
            "unknown": string;
         };
         ComputeResourceHostSPBMLicenseInfo: {
            (options?: vimService.vim.ComputeResourceHostSPBMLicenseInfo): vimService.vim.ComputeResourceHostSPBMLicenseInfo;
         };
         ArrayOfComputeResourceHostSPBMLicenseInfo: {
            (options?: vimService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo): vimService.vim.ArrayOfComputeResourceHostSPBMLicenseInfo;
         };
         ComputeResourceConfigSpec: {
            (options?: vimService.vim.ComputeResourceConfigSpec): vimService.vim.ComputeResourceConfigSpec;
         };
         ConfigSpecOperation: {
            "add": string;
            "edit": string;
            "remove": string;
         };
         CustomFieldDef: {
            (options?: vimService.vim.CustomFieldDef): vimService.vim.CustomFieldDef;
         };
         ArrayOfCustomFieldDef: {
            (options?: vimService.vim.ArrayOfCustomFieldDef): vimService.vim.ArrayOfCustomFieldDef;
         };
         CustomFieldValue: {
            (options?: vimService.vim.CustomFieldValue): vimService.vim.CustomFieldValue;
         };
         ArrayOfCustomFieldValue: {
            (options?: vimService.vim.ArrayOfCustomFieldValue): vimService.vim.ArrayOfCustomFieldValue;
         };
         CustomFieldStringValue: {
            (options?: vimService.vim.CustomFieldStringValue): vimService.vim.CustomFieldStringValue;
         };
         CustomizationSpecInfo: {
            (options?: vimService.vim.CustomizationSpecInfo): vimService.vim.CustomizationSpecInfo;
         };
         ArrayOfCustomizationSpecInfo: {
            (options?: vimService.vim.ArrayOfCustomizationSpecInfo): vimService.vim.ArrayOfCustomizationSpecInfo;
         };
         CustomizationSpecItem: {
            (options?: vimService.vim.CustomizationSpecItem): vimService.vim.CustomizationSpecItem;
         };
         DatacenterConfigInfo: {
            (options?: vimService.vim.DatacenterConfigInfo): vimService.vim.DatacenterConfigInfo;
         };
         DatacenterConfigSpec: {
            (options?: vimService.vim.DatacenterConfigSpec): vimService.vim.DatacenterConfigSpec;
         };
         DatastoreAccessible: {
            "True": string;
            "False": string;
         };
         DatastoreSummaryMaintenanceModeState: {
            "normal": string;
            "enteringMaintenance": string;
            "inMaintenance": string;
         };
         DatastoreSummary: {
            (options?: vimService.vim.DatastoreSummary): vimService.vim.DatastoreSummary;
         };
         DatastoreInfo: {
            (options?: vimService.vim.DatastoreInfo): vimService.vim.DatastoreInfo;
         };
         DatastoreCapability: {
            (options?: vimService.vim.DatastoreCapability): vimService.vim.DatastoreCapability;
         };
         DatastoreHostMount: {
            (options?: vimService.vim.DatastoreHostMount): vimService.vim.DatastoreHostMount;
         };
         ArrayOfDatastoreHostMount: {
            (options?: vimService.vim.ArrayOfDatastoreHostMount): vimService.vim.ArrayOfDatastoreHostMount;
         };
         DatastoreMountPathDatastorePair: {
            (options?: vimService.vim.DatastoreMountPathDatastorePair): vimService.vim.DatastoreMountPathDatastorePair;
         };
         ArrayOfDatastoreMountPathDatastorePair: {
            (options?: vimService.vim.ArrayOfDatastoreMountPathDatastorePair): vimService.vim.ArrayOfDatastoreMountPathDatastorePair;
         };
         Description: {
            (options?: vimService.vim.Description): vimService.vim.Description;
         };
         DiagnosticManagerLogCreator: {
            "vpxd": string;
            "vpxa": string;
            "hostd": string;
            "serverd": string;
            "install": string;
            "vpxClient": string;
            "recordLog": string;
         };
         DiagnosticManagerLogFormat: {
            "plain": string;
         };
         DiagnosticManagerLogDescriptor: {
            (options?: vimService.vim.DiagnosticManagerLogDescriptor): vimService.vim.DiagnosticManagerLogDescriptor;
         };
         ArrayOfDiagnosticManagerLogDescriptor: {
            (options?: vimService.vim.ArrayOfDiagnosticManagerLogDescriptor): vimService.vim.ArrayOfDiagnosticManagerLogDescriptor;
         };
         DiagnosticManagerLogHeader: {
            (options?: vimService.vim.DiagnosticManagerLogHeader): vimService.vim.DiagnosticManagerLogHeader;
         };
         DiagnosticManagerBundleInfo: {
            (options?: vimService.vim.DiagnosticManagerBundleInfo): vimService.vim.DiagnosticManagerBundleInfo;
         };
         ArrayOfDiagnosticManagerBundleInfo: {
            (options?: vimService.vim.ArrayOfDiagnosticManagerBundleInfo): vimService.vim.ArrayOfDiagnosticManagerBundleInfo;
         };
         DistributedVirtualSwitchProductSpecOperationType: {
            "preInstall": string;
            "upgrade": string;
            "notifyAvailableUpgrade": string;
            "proceedWithUpgrade": string;
            "updateBundleInfo": string;
         };
         DVSContactInfo: {
            (options?: vimService.vim.DVSContactInfo): vimService.vim.DVSContactInfo;
         };
         DistributedVirtualSwitchNicTeamingPolicyMode: {
            "loadbalance_ip": string;
            "loadbalance_srcmac": string;
            "loadbalance_srcid": string;
            "failover_explicit": string;
            "loadbalance_loadbased": string;
         };
         DVSNetworkResourceManagementCapability: {
            (options?: vimService.vim.DVSNetworkResourceManagementCapability): vimService.vim.DVSNetworkResourceManagementCapability;
         };
         DVSRollbackCapability: {
            (options?: vimService.vim.DVSRollbackCapability): vimService.vim.DVSRollbackCapability;
         };
         DVSBackupRestoreCapability: {
            (options?: vimService.vim.DVSBackupRestoreCapability): vimService.vim.DVSBackupRestoreCapability;
         };
         DVSFeatureCapability: {
            (options?: vimService.vim.DVSFeatureCapability): vimService.vim.DVSFeatureCapability;
         };
         DVSHealthCheckCapability: {
            (options?: vimService.vim.DVSHealthCheckCapability): vimService.vim.DVSHealthCheckCapability;
         };
         DVSCapability: {
            (options?: vimService.vim.DVSCapability): vimService.vim.DVSCapability;
         };
         DVSSummary: {
            (options?: vimService.vim.DVSSummary): vimService.vim.DVSSummary;
         };
         DVSPolicy: {
            (options?: vimService.vim.DVSPolicy): vimService.vim.DVSPolicy;
         };
         DVSUplinkPortPolicy: {
            (options?: vimService.vim.DVSUplinkPortPolicy): vimService.vim.DVSUplinkPortPolicy;
         };
         DVSNameArrayUplinkPortPolicy: {
            (options?: vimService.vim.DVSNameArrayUplinkPortPolicy): vimService.vim.DVSNameArrayUplinkPortPolicy;
         };
         DVSConfigSpec: {
            (options?: vimService.vim.DVSConfigSpec): vimService.vim.DVSConfigSpec;
         };
         DVSCreateSpec: {
            (options?: vimService.vim.DVSCreateSpec): vimService.vim.DVSCreateSpec;
         };
         DVSConfigInfo: {
            (options?: vimService.vim.DVSConfigInfo): vimService.vim.DVSConfigInfo;
         };
         DistributedVirtualSwitchNetworkResourceControlVersion: {
            "version2": string;
            "version3": string;
         };
         DistributedVirtualSwitchHostInfrastructureTrafficClass: {
            "management": string;
            "faultTolerance": string;
            "vmotion": string;
            "virtualMachine": string;
            "iSCSI": string;
            "nfs": string;
            "hbr": string;
            "vsan": string;
            "vdp": string;
         };
         DvsHostInfrastructureTrafficResourceAllocation: {
            (options?: vimService.vim.DvsHostInfrastructureTrafficResourceAllocation): vimService.vim.DvsHostInfrastructureTrafficResourceAllocation;
         };
         DvsHostInfrastructureTrafficResource: {
            (options?: vimService.vim.DvsHostInfrastructureTrafficResource): vimService.vim.DvsHostInfrastructureTrafficResource;
         };
         ArrayOfDvsHostInfrastructureTrafficResource: {
            (options?: vimService.vim.ArrayOfDvsHostInfrastructureTrafficResource): vimService.vim.ArrayOfDvsHostInfrastructureTrafficResource;
         };
         DVSHealthCheckConfig: {
            (options?: vimService.vim.DVSHealthCheckConfig): vimService.vim.DVSHealthCheckConfig;
         };
         ArrayOfDVSHealthCheckConfig: {
            (options?: vimService.vim.ArrayOfDVSHealthCheckConfig): vimService.vim.ArrayOfDVSHealthCheckConfig;
         };
         DvsResourceRuntimeInfo: {
            (options?: vimService.vim.DvsResourceRuntimeInfo): vimService.vim.DvsResourceRuntimeInfo;
         };
         DVSRuntimeInfo: {
            (options?: vimService.vim.DVSRuntimeInfo): vimService.vim.DVSRuntimeInfo;
         };
         DrsInjectorWorkloadCorrelationState: {
            "Correlated": string;
            "Uncorrelated": string;
         };
         EVCMode: {
            (options?: vimService.vim.EVCMode): vimService.vim.EVCMode;
         };
         ArrayOfEVCMode: {
            (options?: vimService.vim.ArrayOfEVCMode): vimService.vim.ArrayOfEVCMode;
         };
         ElementDescription: {
            (options?: vimService.vim.ElementDescription): vimService.vim.ElementDescription;
         };
         ArrayOfElementDescription: {
            (options?: vimService.vim.ArrayOfElementDescription): vimService.vim.ArrayOfElementDescription;
         };
         EnumDescription: {
            (options?: vimService.vim.EnumDescription): vimService.vim.EnumDescription;
         };
         ArrayOfEnumDescription: {
            (options?: vimService.vim.ArrayOfEnumDescription): vimService.vim.ArrayOfEnumDescription;
         };
         EnvironmentBrowserConfigOptionQuerySpec: {
            (options?: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): vimService.vim.EnvironmentBrowserConfigOptionQuerySpec;
         };
         ExtendedDescription: {
            (options?: vimService.vim.ExtendedDescription): vimService.vim.ExtendedDescription;
         };
         ExtendedElementDescription: {
            (options?: vimService.vim.ExtendedElementDescription): vimService.vim.ExtendedElementDescription;
         };
         ExtensionServerInfo: {
            (options?: vimService.vim.ExtensionServerInfo): vimService.vim.ExtensionServerInfo;
         };
         ArrayOfExtensionServerInfo: {
            (options?: vimService.vim.ArrayOfExtensionServerInfo): vimService.vim.ArrayOfExtensionServerInfo;
         };
         ExtensionClientInfo: {
            (options?: vimService.vim.ExtensionClientInfo): vimService.vim.ExtensionClientInfo;
         };
         ArrayOfExtensionClientInfo: {
            (options?: vimService.vim.ArrayOfExtensionClientInfo): vimService.vim.ArrayOfExtensionClientInfo;
         };
         ExtensionTaskTypeInfo: {
            (options?: vimService.vim.ExtensionTaskTypeInfo): vimService.vim.ExtensionTaskTypeInfo;
         };
         ArrayOfExtensionTaskTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionTaskTypeInfo): vimService.vim.ArrayOfExtensionTaskTypeInfo;
         };
         ExtensionEventTypeInfo: {
            (options?: vimService.vim.ExtensionEventTypeInfo): vimService.vim.ExtensionEventTypeInfo;
         };
         ArrayOfExtensionEventTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionEventTypeInfo): vimService.vim.ArrayOfExtensionEventTypeInfo;
         };
         ExtensionFaultTypeInfo: {
            (options?: vimService.vim.ExtensionFaultTypeInfo): vimService.vim.ExtensionFaultTypeInfo;
         };
         ArrayOfExtensionFaultTypeInfo: {
            (options?: vimService.vim.ArrayOfExtensionFaultTypeInfo): vimService.vim.ArrayOfExtensionFaultTypeInfo;
         };
         ExtensionPrivilegeInfo: {
            (options?: vimService.vim.ExtensionPrivilegeInfo): vimService.vim.ExtensionPrivilegeInfo;
         };
         ArrayOfExtensionPrivilegeInfo: {
            (options?: vimService.vim.ArrayOfExtensionPrivilegeInfo): vimService.vim.ArrayOfExtensionPrivilegeInfo;
         };
         ExtensionResourceInfo: {
            (options?: vimService.vim.ExtensionResourceInfo): vimService.vim.ExtensionResourceInfo;
         };
         ArrayOfExtensionResourceInfo: {
            (options?: vimService.vim.ArrayOfExtensionResourceInfo): vimService.vim.ArrayOfExtensionResourceInfo;
         };
         ExtensionHealthInfo: {
            (options?: vimService.vim.ExtensionHealthInfo): vimService.vim.ExtensionHealthInfo;
         };
         ExtensionOvfConsumerInfo: {
            (options?: vimService.vim.ExtensionOvfConsumerInfo): vimService.vim.ExtensionOvfConsumerInfo;
         };
         Extension: {
            (options?: vimService.vim.Extension): vimService.vim.Extension;
         };
         ArrayOfExtension: {
            (options?: vimService.vim.ArrayOfExtension): vimService.vim.ArrayOfExtension;
         };
         ExtensionManagerIpAllocationUsage: {
            (options?: vimService.vim.ExtensionManagerIpAllocationUsage): vimService.vim.ExtensionManagerIpAllocationUsage;
         };
         ArrayOfExtensionManagerIpAllocationUsage: {
            (options?: vimService.vim.ArrayOfExtensionManagerIpAllocationUsage): vimService.vim.ArrayOfExtensionManagerIpAllocationUsage;
         };
         ReplicationVmState: {
            "none": string;
            "paused": string;
            "syncing": string;
            "idle": string;
            "active": string;
            "error": string;
         };
         ReplicationVmProgressInfo: {
            (options?: vimService.vim.ReplicationVmProgressInfo): vimService.vim.ReplicationVmProgressInfo;
         };
         HbrManagerReplicationVmInfo: {
            (options?: vimService.vim.HbrManagerReplicationVmInfo): vimService.vim.HbrManagerReplicationVmInfo;
         };
         QuiesceMode: {
            "application": string;
            "filesystem": string;
            "none": string;
         };
         HbrManagerVmReplicationCapability: {
            (options?: vimService.vim.HbrManagerVmReplicationCapability): vimService.vim.HbrManagerVmReplicationCapability;
         };
         ArrayOfHbrManagerVmReplicationCapability: {
            (options?: vimService.vim.ArrayOfHbrManagerVmReplicationCapability): vimService.vim.ArrayOfHbrManagerVmReplicationCapability;
         };
         HostServiceTicket: {
            (options?: vimService.vim.HostServiceTicket): vimService.vim.HostServiceTicket;
         };
         HostSystemConnectionState: {
            "connected": string;
            "notResponding": string;
            "disconnected": string;
         };
         HostSystemPowerState: {
            "poweredOn": string;
            "poweredOff": string;
            "standBy": string;
            "unknown": string;
         };
         HostStandbyMode: {
            "entering": string;
            "exiting": string;
            "in": string;
            "none": string;
         };
         HostSystemReconnectSpec: {
            (options?: vimService.vim.HostSystemReconnectSpec): vimService.vim.HostSystemReconnectSpec;
         };
         HttpNfcLeaseState: {
            "initializing": string;
            "ready": string;
            "done": string;
            "error": string;
         };
         HttpNfcLeaseDatastoreLeaseInfo: {
            (options?: vimService.vim.HttpNfcLeaseDatastoreLeaseInfo): vimService.vim.HttpNfcLeaseDatastoreLeaseInfo;
         };
         ArrayOfHttpNfcLeaseDatastoreLeaseInfo: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo): vimService.vim.ArrayOfHttpNfcLeaseDatastoreLeaseInfo;
         };
         HttpNfcLeaseHostInfo: {
            (options?: vimService.vim.HttpNfcLeaseHostInfo): vimService.vim.HttpNfcLeaseHostInfo;
         };
         ArrayOfHttpNfcLeaseHostInfo: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseHostInfo): vimService.vim.ArrayOfHttpNfcLeaseHostInfo;
         };
         HttpNfcLeaseInfo: {
            (options?: vimService.vim.HttpNfcLeaseInfo): vimService.vim.HttpNfcLeaseInfo;
         };
         HttpNfcLeaseDeviceUrl: {
            (options?: vimService.vim.HttpNfcLeaseDeviceUrl): vimService.vim.HttpNfcLeaseDeviceUrl;
         };
         ArrayOfHttpNfcLeaseDeviceUrl: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseDeviceUrl): vimService.vim.ArrayOfHttpNfcLeaseDeviceUrl;
         };
         HttpNfcLeaseManifestEntry: {
            (options?: vimService.vim.HttpNfcLeaseManifestEntry): vimService.vim.HttpNfcLeaseManifestEntry;
         };
         ArrayOfHttpNfcLeaseManifestEntry: {
            (options?: vimService.vim.ArrayOfHttpNfcLeaseManifestEntry): vimService.vim.ArrayOfHttpNfcLeaseManifestEntry;
         };
         ImportSpec: {
            (options?: vimService.vim.ImportSpec): vimService.vim.ImportSpec;
         };
         ArrayOfImportSpec: {
            (options?: vimService.vim.ArrayOfImportSpec): vimService.vim.ArrayOfImportSpec;
         };
         InheritablePolicy: {
            (options?: vimService.vim.InheritablePolicy): vimService.vim.InheritablePolicy;
         };
         IntExpression: {
            (options?: vimService.vim.IntExpression): vimService.vim.IntExpression;
         };
         IntPolicy: {
            (options?: vimService.vim.IntPolicy): vimService.vim.IntPolicy;
         };
         IoFilterInfo: {
            (options?: vimService.vim.IoFilterInfo): vimService.vim.IoFilterInfo;
         };
         HostIoFilterInfo: {
            (options?: vimService.vim.HostIoFilterInfo): vimService.vim.HostIoFilterInfo;
         };
         ArrayOfHostIoFilterInfo: {
            (options?: vimService.vim.ArrayOfHostIoFilterInfo): vimService.vim.ArrayOfHostIoFilterInfo;
         };
         IoFilterOperation: {
            "install": string;
            "uninstall": string;
            "upgrade": string;
         };
         ClusterIoFilterInfo: {
            (options?: vimService.vim.ClusterIoFilterInfo): vimService.vim.ClusterIoFilterInfo;
         };
         ArrayOfClusterIoFilterInfo: {
            (options?: vimService.vim.ArrayOfClusterIoFilterInfo): vimService.vim.ArrayOfClusterIoFilterInfo;
         };
         IoFilterHostIssue: {
            (options?: vimService.vim.IoFilterHostIssue): vimService.vim.IoFilterHostIssue;
         };
         ArrayOfIoFilterHostIssue: {
            (options?: vimService.vim.ArrayOfIoFilterHostIssue): vimService.vim.ArrayOfIoFilterHostIssue;
         };
         IoFilterQueryIssueResult: {
            (options?: vimService.vim.IoFilterQueryIssueResult): vimService.vim.IoFilterQueryIssueResult;
         };
         IpAddress: {
            (options?: vimService.vim.IpAddress): vimService.vim.IpAddress;
         };
         IpPoolManagerIpAllocation: {
            (options?: vimService.vim.IpPoolManagerIpAllocation): vimService.vim.IpPoolManagerIpAllocation;
         };
         ArrayOfIpPoolManagerIpAllocation: {
            (options?: vimService.vim.ArrayOfIpPoolManagerIpAllocation): vimService.vim.ArrayOfIpPoolManagerIpAllocation;
         };
         IpRange: {
            (options?: vimService.vim.IpRange): vimService.vim.IpRange;
         };
         KeyValue: {
            (options?: vimService.vim.KeyValue): vimService.vim.KeyValue;
         };
         ArrayOfKeyValue: {
            (options?: vimService.vim.ArrayOfKeyValue): vimService.vim.ArrayOfKeyValue;
         };
         LatencySensitivitySensitivityLevel: {
            "low": string;
            "normal": string;
            "medium": string;
            "high": string;
            "custom": string;
         };
         LatencySensitivity: {
            (options?: vimService.vim.LatencySensitivity): vimService.vim.LatencySensitivity;
         };
         LicenseAssignmentManagerLicenseAssignment: {
            (options?: vimService.vim.LicenseAssignmentManagerLicenseAssignment): vimService.vim.LicenseAssignmentManagerLicenseAssignment;
         };
         ArrayOfLicenseAssignmentManagerLicenseAssignment: {
            (options?: vimService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment): vimService.vim.ArrayOfLicenseAssignmentManagerLicenseAssignment;
         };
         LicenseManagerState: {
            "initializing": string;
            "normal": string;
            "marginal": string;
            "fault": string;
         };
         LicenseManagerLicenseKey: {
            "esxFull": string;
            "esxVmtn": string;
            "esxExpress": string;
            "san": string;
            "iscsi": string;
            "nas": string;
            "vsmp": string;
            "backup": string;
            "vc": string;
            "vcExpress": string;
            "esxHost": string;
            "gsxHost": string;
            "serverHost": string;
            "drsPower": string;
            "vmotion": string;
            "drs": string;
            "das": string;
         };
         LicenseSource: {
            (options?: vimService.vim.LicenseSource): vimService.vim.LicenseSource;
         };
         LicenseServerSource: {
            (options?: vimService.vim.LicenseServerSource): vimService.vim.LicenseServerSource;
         };
         LocalLicenseSource: {
            (options?: vimService.vim.LocalLicenseSource): vimService.vim.LocalLicenseSource;
         };
         EvaluationLicenseSource: {
            (options?: vimService.vim.EvaluationLicenseSource): vimService.vim.EvaluationLicenseSource;
         };
         LicenseFeatureInfoUnit: {
            "host": string;
            "cpuCore": string;
            "cpuPackage": string;
            "server": string;
            "vm": string;
         };
         LicenseFeatureInfoState: {
            "enabled": string;
            "disabled": string;
            "optional": string;
         };
         LicenseFeatureInfoSourceRestriction: {
            "unrestricted": string;
            "served": string;
            "file": string;
         };
         LicenseFeatureInfo: {
            (options?: vimService.vim.LicenseFeatureInfo): vimService.vim.LicenseFeatureInfo;
         };
         ArrayOfLicenseFeatureInfo: {
            (options?: vimService.vim.ArrayOfLicenseFeatureInfo): vimService.vim.ArrayOfLicenseFeatureInfo;
         };
         LicenseReservationInfoState: {
            "notUsed": string;
            "noLicense": string;
            "unlicensedUse": string;
            "licensed": string;
         };
         LicenseReservationInfo: {
            (options?: vimService.vim.LicenseReservationInfo): vimService.vim.LicenseReservationInfo;
         };
         ArrayOfLicenseReservationInfo: {
            (options?: vimService.vim.ArrayOfLicenseReservationInfo): vimService.vim.ArrayOfLicenseReservationInfo;
         };
         LicenseAvailabilityInfo: {
            (options?: vimService.vim.LicenseAvailabilityInfo): vimService.vim.LicenseAvailabilityInfo;
         };
         ArrayOfLicenseAvailabilityInfo: {
            (options?: vimService.vim.ArrayOfLicenseAvailabilityInfo): vimService.vim.ArrayOfLicenseAvailabilityInfo;
         };
         LicenseDiagnostics: {
            (options?: vimService.vim.LicenseDiagnostics): vimService.vim.LicenseDiagnostics;
         };
         LicenseUsageInfo: {
            (options?: vimService.vim.LicenseUsageInfo): vimService.vim.LicenseUsageInfo;
         };
         LicenseManagerEvaluationInfo: {
            (options?: vimService.vim.LicenseManagerEvaluationInfo): vimService.vim.LicenseManagerEvaluationInfo;
         };
         HostLicensableResourceKey: {
            "numCpuPackages": string;
            "numCpuCores": string;
            "memorySize": string;
            "memoryForVms": string;
            "numVmsStarted": string;
            "numVmsStarting": string;
         };
         HostLicensableResourceInfo: {
            (options?: vimService.vim.HostLicensableResourceInfo): vimService.vim.HostLicensableResourceInfo;
         };
         LicenseManagerLicenseInfo: {
            (options?: vimService.vim.LicenseManagerLicenseInfo): vimService.vim.LicenseManagerLicenseInfo;
         };
         ArrayOfLicenseManagerLicenseInfo: {
            (options?: vimService.vim.ArrayOfLicenseManagerLicenseInfo): vimService.vim.ArrayOfLicenseManagerLicenseInfo;
         };
         LocalizationManagerMessageCatalog: {
            (options?: vimService.vim.LocalizationManagerMessageCatalog): vimService.vim.LocalizationManagerMessageCatalog;
         };
         ArrayOfLocalizationManagerMessageCatalog: {
            (options?: vimService.vim.ArrayOfLocalizationManagerMessageCatalog): vimService.vim.ArrayOfLocalizationManagerMessageCatalog;
         };
         LongPolicy: {
            (options?: vimService.vim.LongPolicy): vimService.vim.LongPolicy;
         };
         MacAddress: {
            (options?: vimService.vim.MacAddress): vimService.vim.MacAddress;
         };
         MacRange: {
            (options?: vimService.vim.MacRange): vimService.vim.MacRange;
         };
         ManagedEntityStatus: {
            "gray": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         MethodDescription: {
            (options?: vimService.vim.MethodDescription): vimService.vim.MethodDescription;
         };
         NegatableExpression: {
            (options?: vimService.vim.NegatableExpression): vimService.vim.NegatableExpression;
         };
         NetworkSummary: {
            (options?: vimService.vim.NetworkSummary): vimService.vim.NetworkSummary;
         };
         NumericRange: {
            (options?: vimService.vim.NumericRange): vimService.vim.NumericRange;
         };
         ArrayOfNumericRange: {
            (options?: vimService.vim.ArrayOfNumericRange): vimService.vim.ArrayOfNumericRange;
         };
         OpaqueNetworkSummary: {
            (options?: vimService.vim.OpaqueNetworkSummary): vimService.vim.OpaqueNetworkSummary;
         };
         OvfConsumerOvfSection: {
            (options?: vimService.vim.OvfConsumerOvfSection): vimService.vim.OvfConsumerOvfSection;
         };
         ArrayOfOvfConsumerOvfSection: {
            (options?: vimService.vim.ArrayOfOvfConsumerOvfSection): vimService.vim.ArrayOfOvfConsumerOvfSection;
         };
         OvfConsumerOstNodeType: {
            "envelope": string;
            "virtualSystem": string;
            "virtualSystemCollection": string;
         };
         OvfConsumerOstNode: {
            (options?: vimService.vim.OvfConsumerOstNode): vimService.vim.OvfConsumerOstNode;
         };
         ArrayOfOvfConsumerOstNode: {
            (options?: vimService.vim.ArrayOfOvfConsumerOstNode): vimService.vim.ArrayOfOvfConsumerOstNode;
         };
         OvfOptionInfo: {
            (options?: vimService.vim.OvfOptionInfo): vimService.vim.OvfOptionInfo;
         };
         ArrayOfOvfOptionInfo: {
            (options?: vimService.vim.ArrayOfOvfOptionInfo): vimService.vim.ArrayOfOvfOptionInfo;
         };
         OvfDeploymentOption: {
            (options?: vimService.vim.OvfDeploymentOption): vimService.vim.OvfDeploymentOption;
         };
         ArrayOfOvfDeploymentOption: {
            (options?: vimService.vim.ArrayOfOvfDeploymentOption): vimService.vim.ArrayOfOvfDeploymentOption;
         };
         OvfManagerCommonParams: {
            (options?: vimService.vim.OvfManagerCommonParams): vimService.vim.OvfManagerCommonParams;
         };
         OvfValidateHostParams: {
            (options?: vimService.vim.OvfValidateHostParams): vimService.vim.OvfValidateHostParams;
         };
         OvfValidateHostResult: {
            (options?: vimService.vim.OvfValidateHostResult): vimService.vim.OvfValidateHostResult;
         };
         OvfParseDescriptorParams: {
            (options?: vimService.vim.OvfParseDescriptorParams): vimService.vim.OvfParseDescriptorParams;
         };
         OvfParseDescriptorResult: {
            (options?: vimService.vim.OvfParseDescriptorResult): vimService.vim.OvfParseDescriptorResult;
         };
         OvfNetworkInfo: {
            (options?: vimService.vim.OvfNetworkInfo): vimService.vim.OvfNetworkInfo;
         };
         ArrayOfOvfNetworkInfo: {
            (options?: vimService.vim.ArrayOfOvfNetworkInfo): vimService.vim.ArrayOfOvfNetworkInfo;
         };
         OvfCreateImportSpecParamsDiskProvisioningType: {
            "monolithicSparse": string;
            "monolithicFlat": string;
            "twoGbMaxExtentSparse": string;
            "twoGbMaxExtentFlat": string;
            "thin": string;
            "thick": string;
            "seSparse": string;
            "eagerZeroedThick": string;
            "sparse": string;
            "flat": string;
         };
         OvfCreateImportSpecParams: {
            (options?: vimService.vim.OvfCreateImportSpecParams): vimService.vim.OvfCreateImportSpecParams;
         };
         OvfResourceMap: {
            (options?: vimService.vim.OvfResourceMap): vimService.vim.OvfResourceMap;
         };
         ArrayOfOvfResourceMap: {
            (options?: vimService.vim.ArrayOfOvfResourceMap): vimService.vim.ArrayOfOvfResourceMap;
         };
         OvfNetworkMapping: {
            (options?: vimService.vim.OvfNetworkMapping): vimService.vim.OvfNetworkMapping;
         };
         ArrayOfOvfNetworkMapping: {
            (options?: vimService.vim.ArrayOfOvfNetworkMapping): vimService.vim.ArrayOfOvfNetworkMapping;
         };
         OvfCreateImportSpecResult: {
            (options?: vimService.vim.OvfCreateImportSpecResult): vimService.vim.OvfCreateImportSpecResult;
         };
         OvfFileItem: {
            (options?: vimService.vim.OvfFileItem): vimService.vim.OvfFileItem;
         };
         ArrayOfOvfFileItem: {
            (options?: vimService.vim.ArrayOfOvfFileItem): vimService.vim.ArrayOfOvfFileItem;
         };
         OvfCreateDescriptorParams: {
            (options?: vimService.vim.OvfCreateDescriptorParams): vimService.vim.OvfCreateDescriptorParams;
         };
         OvfCreateDescriptorResult: {
            (options?: vimService.vim.OvfCreateDescriptorResult): vimService.vim.OvfCreateDescriptorResult;
         };
         OvfFile: {
            (options?: vimService.vim.OvfFile): vimService.vim.OvfFile;
         };
         ArrayOfOvfFile: {
            (options?: vimService.vim.ArrayOfOvfFile): vimService.vim.ArrayOfOvfFile;
         };
         PasswordField: {
            (options?: vimService.vim.PasswordField): vimService.vim.PasswordField;
         };
         PerformanceDescription: {
            (options?: vimService.vim.PerformanceDescription): vimService.vim.PerformanceDescription;
         };
         PerfFormat: {
            "normal": string;
            "csv": string;
         };
         PerfProviderSummary: {
            (options?: vimService.vim.PerfProviderSummary): vimService.vim.PerfProviderSummary;
         };
         PerfSummaryType: {
            "average": string;
            "maximum": string;
            "minimum": string;
            "latest": string;
            "summation": string;
            "none": string;
         };
         PerfStatsType: {
            "absolute": string;
            "delta": string;
            "rate": string;
         };
         PerformanceManagerUnit: {
            "percent": string;
            "kiloBytes": string;
            "megaBytes": string;
            "megaHertz": string;
            "number": string;
            "microsecond": string;
            "millisecond": string;
            "second": string;
            "kiloBytesPerSecond": string;
            "megaBytesPerSecond": string;
            "watt": string;
            "joule": string;
            "teraBytes": string;
         };
         PerfCounterInfo: {
            (options?: vimService.vim.PerfCounterInfo): vimService.vim.PerfCounterInfo;
         };
         ArrayOfPerfCounterInfo: {
            (options?: vimService.vim.ArrayOfPerfCounterInfo): vimService.vim.ArrayOfPerfCounterInfo;
         };
         PerfMetricId: {
            (options?: vimService.vim.PerfMetricId): vimService.vim.PerfMetricId;
         };
         ArrayOfPerfMetricId: {
            (options?: vimService.vim.ArrayOfPerfMetricId): vimService.vim.ArrayOfPerfMetricId;
         };
         PerfQuerySpec: {
            (options?: vimService.vim.PerfQuerySpec): vimService.vim.PerfQuerySpec;
         };
         ArrayOfPerfQuerySpec: {
            (options?: vimService.vim.ArrayOfPerfQuerySpec): vimService.vim.ArrayOfPerfQuerySpec;
         };
         PerfSampleInfo: {
            (options?: vimService.vim.PerfSampleInfo): vimService.vim.PerfSampleInfo;
         };
         ArrayOfPerfSampleInfo: {
            (options?: vimService.vim.ArrayOfPerfSampleInfo): vimService.vim.ArrayOfPerfSampleInfo;
         };
         PerfMetricSeries: {
            (options?: vimService.vim.PerfMetricSeries): vimService.vim.PerfMetricSeries;
         };
         ArrayOfPerfMetricSeries: {
            (options?: vimService.vim.ArrayOfPerfMetricSeries): vimService.vim.ArrayOfPerfMetricSeries;
         };
         PerfMetricIntSeries: {
            (options?: vimService.vim.PerfMetricIntSeries): vimService.vim.PerfMetricIntSeries;
         };
         PerfMetricSeriesCSV: {
            (options?: vimService.vim.PerfMetricSeriesCSV): vimService.vim.PerfMetricSeriesCSV;
         };
         ArrayOfPerfMetricSeriesCSV: {
            (options?: vimService.vim.ArrayOfPerfMetricSeriesCSV): vimService.vim.ArrayOfPerfMetricSeriesCSV;
         };
         PerfEntityMetricBase: {
            (options?: vimService.vim.PerfEntityMetricBase): vimService.vim.PerfEntityMetricBase;
         };
         ArrayOfPerfEntityMetricBase: {
            (options?: vimService.vim.ArrayOfPerfEntityMetricBase): vimService.vim.ArrayOfPerfEntityMetricBase;
         };
         PerfEntityMetric: {
            (options?: vimService.vim.PerfEntityMetric): vimService.vim.PerfEntityMetric;
         };
         PerfEntityMetricCSV: {
            (options?: vimService.vim.PerfEntityMetricCSV): vimService.vim.PerfEntityMetricCSV;
         };
         PerfCompositeMetric: {
            (options?: vimService.vim.PerfCompositeMetric): vimService.vim.PerfCompositeMetric;
         };
         PerformanceManagerCounterLevelMapping: {
            (options?: vimService.vim.PerformanceManagerCounterLevelMapping): vimService.vim.PerformanceManagerCounterLevelMapping;
         };
         ArrayOfPerformanceManagerCounterLevelMapping: {
            (options?: vimService.vim.ArrayOfPerformanceManagerCounterLevelMapping): vimService.vim.ArrayOfPerformanceManagerCounterLevelMapping;
         };
         PerfInterval: {
            (options?: vimService.vim.PerfInterval): vimService.vim.PerfInterval;
         };
         ArrayOfPerfInterval: {
            (options?: vimService.vim.ArrayOfPerfInterval): vimService.vim.ArrayOfPerfInterval;
         };
         PosixUserSearchResult: {
            (options?: vimService.vim.PosixUserSearchResult): vimService.vim.PosixUserSearchResult;
         };
         PrivilegePolicyDef: {
            (options?: vimService.vim.PrivilegePolicyDef): vimService.vim.PrivilegePolicyDef;
         };
         ResourceAllocationInfo: {
            (options?: vimService.vim.ResourceAllocationInfo): vimService.vim.ResourceAllocationInfo;
         };
         ResourceAllocationOption: {
            (options?: vimService.vim.ResourceAllocationOption): vimService.vim.ResourceAllocationOption;
         };
         ResourceConfigOption: {
            (options?: vimService.vim.ResourceConfigOption): vimService.vim.ResourceConfigOption;
         };
         ResourceConfigSpec: {
            (options?: vimService.vim.ResourceConfigSpec): vimService.vim.ResourceConfigSpec;
         };
         ArrayOfResourceConfigSpec: {
            (options?: vimService.vim.ArrayOfResourceConfigSpec): vimService.vim.ArrayOfResourceConfigSpec;
         };
         DatabaseSizeParam: {
            (options?: vimService.vim.DatabaseSizeParam): vimService.vim.DatabaseSizeParam;
         };
         InventoryDescription: {
            (options?: vimService.vim.InventoryDescription): vimService.vim.InventoryDescription;
         };
         PerformanceStatisticsDescription: {
            (options?: vimService.vim.PerformanceStatisticsDescription): vimService.vim.PerformanceStatisticsDescription;
         };
         DatabaseSizeEstimate: {
            (options?: vimService.vim.DatabaseSizeEstimate): vimService.vim.DatabaseSizeEstimate;
         };
         ResourcePoolResourceUsage: {
            (options?: vimService.vim.ResourcePoolResourceUsage): vimService.vim.ResourcePoolResourceUsage;
         };
         ResourcePoolRuntimeInfo: {
            (options?: vimService.vim.ResourcePoolRuntimeInfo): vimService.vim.ResourcePoolRuntimeInfo;
         };
         ResourcePoolQuickStats: {
            (options?: vimService.vim.ResourcePoolQuickStats): vimService.vim.ResourcePoolQuickStats;
         };
         ResourcePoolSummary: {
            (options?: vimService.vim.ResourcePoolSummary): vimService.vim.ResourcePoolSummary;
         };
         SelectionSet: {
            (options?: vimService.vim.SelectionSet): vimService.vim.SelectionSet;
         };
         ArrayOfSelectionSet: {
            (options?: vimService.vim.ArrayOfSelectionSet): vimService.vim.ArrayOfSelectionSet;
         };
         ValidateMigrationTestType: {
            "sourceTests": string;
            "compatibilityTests": string;
            "diskAccessibilityTests": string;
            "resourceTests": string;
         };
         VMotionCompatibilityType: {
            "cpu": string;
            "software": string;
         };
         HostVMotionCompatibility: {
            (options?: vimService.vim.HostVMotionCompatibility): vimService.vim.HostVMotionCompatibility;
         };
         ArrayOfHostVMotionCompatibility: {
            (options?: vimService.vim.ArrayOfHostVMotionCompatibility): vimService.vim.ArrayOfHostVMotionCompatibility;
         };
         ProductComponentInfo: {
            (options?: vimService.vim.ProductComponentInfo): vimService.vim.ProductComponentInfo;
         };
         ArrayOfProductComponentInfo: {
            (options?: vimService.vim.ArrayOfProductComponentInfo): vimService.vim.ArrayOfProductComponentInfo;
         };
         ServiceContent: {
            (options?: vimService.vim.ServiceContent): vimService.vim.ServiceContent;
         };
         ServiceLocatorCredential: {
            (options?: vimService.vim.ServiceLocatorCredential): vimService.vim.ServiceLocatorCredential;
         };
         ServiceLocatorNamePassword: {
            (options?: vimService.vim.ServiceLocatorNamePassword): vimService.vim.ServiceLocatorNamePassword;
         };
         ServiceLocatorSAMLCredential: {
            (options?: vimService.vim.ServiceLocatorSAMLCredential): vimService.vim.ServiceLocatorSAMLCredential;
         };
         ServiceLocator: {
            (options?: vimService.vim.ServiceLocator): vimService.vim.ServiceLocator;
         };
         ArrayOfServiceLocator: {
            (options?: vimService.vim.ArrayOfServiceLocator): vimService.vim.ArrayOfServiceLocator;
         };
         ServiceManagerServiceInfo: {
            (options?: vimService.vim.ServiceManagerServiceInfo): vimService.vim.ServiceManagerServiceInfo;
         };
         ArrayOfServiceManagerServiceInfo: {
            (options?: vimService.vim.ArrayOfServiceManagerServiceInfo): vimService.vim.ArrayOfServiceManagerServiceInfo;
         };
         SessionManagerLocalTicket: {
            (options?: vimService.vim.SessionManagerLocalTicket): vimService.vim.SessionManagerLocalTicket;
         };
         SessionManagerGenericServiceTicket: {
            (options?: vimService.vim.SessionManagerGenericServiceTicket): vimService.vim.SessionManagerGenericServiceTicket;
         };
         SessionManagerServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerServiceRequestSpec): vimService.vim.SessionManagerServiceRequestSpec;
         };
         SessionManagerVmomiServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerVmomiServiceRequestSpec): vimService.vim.SessionManagerVmomiServiceRequestSpec;
         };
         SessionManagerHttpServiceRequestSpecMethod: {
            "httpOptions": string;
            "httpGet": string;
            "httpHead": string;
            "httpPost": string;
            "httpPut": string;
            "httpDelete": string;
            "httpTrace": string;
            "httpConnect": string;
         };
         SessionManagerHttpServiceRequestSpec: {
            (options?: vimService.vim.SessionManagerHttpServiceRequestSpec): vimService.vim.SessionManagerHttpServiceRequestSpec;
         };
         SharesLevel: {
            "low": string;
            "normal": string;
            "high": string;
            "custom": string;
         };
         SharesInfo: {
            (options?: vimService.vim.SharesInfo): vimService.vim.SharesInfo;
         };
         SharesOption: {
            (options?: vimService.vim.SharesOption): vimService.vim.SharesOption;
         };
         SimpleCommandEncoding: {
            "CSV": string;
            "HEX": string;
            "STRING": string;
         };
         SingleIp: {
            (options?: vimService.vim.SingleIp): vimService.vim.SingleIp;
         };
         SingleMac: {
            (options?: vimService.vim.SingleMac): vimService.vim.SingleMac;
         };
         StoragePodSummary: {
            (options?: vimService.vim.StoragePodSummary): vimService.vim.StoragePodSummary;
         };
         StorageIOAllocationInfo: {
            (options?: vimService.vim.StorageIOAllocationInfo): vimService.vim.StorageIOAllocationInfo;
         };
         StorageIOAllocationOption: {
            (options?: vimService.vim.StorageIOAllocationOption): vimService.vim.StorageIOAllocationOption;
         };
         StorageIORMThresholdMode: {
            "automatic": string;
            "manual": string;
         };
         StorageIORMInfo: {
            (options?: vimService.vim.StorageIORMInfo): vimService.vim.StorageIORMInfo;
         };
         StorageIORMConfigSpec: {
            (options?: vimService.vim.StorageIORMConfigSpec): vimService.vim.StorageIORMConfigSpec;
         };
         StorageIORMConfigOption: {
            (options?: vimService.vim.StorageIORMConfigOption): vimService.vim.StorageIORMConfigOption;
         };
         StoragePerformanceSummary: {
            (options?: vimService.vim.StoragePerformanceSummary): vimService.vim.StoragePerformanceSummary;
         };
         ArrayOfStoragePerformanceSummary: {
            (options?: vimService.vim.ArrayOfStoragePerformanceSummary): vimService.vim.ArrayOfStoragePerformanceSummary;
         };
         PodStorageDrsEntry: {
            (options?: vimService.vim.PodStorageDrsEntry): vimService.vim.PodStorageDrsEntry;
         };
         StorageResourceManagerStorageProfileStatistics: {
            (options?: vimService.vim.StorageResourceManagerStorageProfileStatistics): vimService.vim.StorageResourceManagerStorageProfileStatistics;
         };
         StringExpression: {
            (options?: vimService.vim.StringExpression): vimService.vim.StringExpression;
         };
         StringPolicy: {
            (options?: vimService.vim.StringPolicy): vimService.vim.StringPolicy;
         };
         Tag: {
            (options?: vimService.vim.Tag): vimService.vim.Tag;
         };
         ArrayOfTag: {
            (options?: vimService.vim.ArrayOfTag): vimService.vim.ArrayOfTag;
         };
         TaskDescription: {
            (options?: vimService.vim.TaskDescription): vimService.vim.TaskDescription;
         };
         TaskFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         TaskFilterSpecTimeOption: {
            "queuedTime": string;
            "startedTime": string;
            "completedTime": string;
         };
         TaskFilterSpecByEntity: {
            (options?: vimService.vim.TaskFilterSpecByEntity): vimService.vim.TaskFilterSpecByEntity;
         };
         TaskFilterSpecByTime: {
            (options?: vimService.vim.TaskFilterSpecByTime): vimService.vim.TaskFilterSpecByTime;
         };
         TaskFilterSpecByUsername: {
            (options?: vimService.vim.TaskFilterSpecByUsername): vimService.vim.TaskFilterSpecByUsername;
         };
         TaskFilterSpec: {
            (options?: vimService.vim.TaskFilterSpec): vimService.vim.TaskFilterSpec;
         };
         TaskInfoState: {
            "queued": string;
            "running": string;
            "success": string;
            "error": string;
         };
         ArrayOfTaskInfoState: {
            (options?: vimService.vim.ArrayOfTaskInfoState): vimService.vim.ArrayOfTaskInfoState;
         };
         TaskInfo: {
            (options?: vimService.vim.TaskInfo): vimService.vim.TaskInfo;
         };
         ArrayOfTaskInfo: {
            (options?: vimService.vim.ArrayOfTaskInfo): vimService.vim.ArrayOfTaskInfo;
         };
         TaskReason: {
            (options?: vimService.vim.TaskReason): vimService.vim.TaskReason;
         };
         TaskReasonSystem: {
            (options?: vimService.vim.TaskReasonSystem): vimService.vim.TaskReasonSystem;
         };
         TaskReasonUser: {
            (options?: vimService.vim.TaskReasonUser): vimService.vim.TaskReasonUser;
         };
         TaskReasonAlarm: {
            (options?: vimService.vim.TaskReasonAlarm): vimService.vim.TaskReasonAlarm;
         };
         TaskReasonSchedule: {
            (options?: vimService.vim.TaskReasonSchedule): vimService.vim.TaskReasonSchedule;
         };
         TypeDescription: {
            (options?: vimService.vim.TypeDescription): vimService.vim.TypeDescription;
         };
         ArrayOfTypeDescription: {
            (options?: vimService.vim.ArrayOfTypeDescription): vimService.vim.ArrayOfTypeDescription;
         };
         UpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo): vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo: {
            (options?: vimService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo): vimService.vim.ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo;
         };
         UpdateVirtualMachineFilesResult: {
            (options?: vimService.vim.UpdateVirtualMachineFilesResult): vimService.vim.UpdateVirtualMachineFilesResult;
         };
         UserSearchResult: {
            (options?: vimService.vim.UserSearchResult): vimService.vim.UserSearchResult;
         };
         ArrayOfUserSearchResult: {
            (options?: vimService.vim.ArrayOfUserSearchResult): vimService.vim.ArrayOfUserSearchResult;
         };
         UserSession: {
            (options?: vimService.vim.UserSession): vimService.vim.UserSession;
         };
         ArrayOfUserSession: {
            (options?: vimService.vim.ArrayOfUserSession): vimService.vim.ArrayOfUserSession;
         };
         VASAStorageArray: {
            (options?: vimService.vim.VASAStorageArray): vimService.vim.VASAStorageArray;
         };
         ArrayOfVASAStorageArray: {
            (options?: vimService.vim.ArrayOfVASAStorageArray): vimService.vim.ArrayOfVASAStorageArray;
         };
         VasaProviderContainerSpec: {
            (options?: vimService.vim.VasaProviderContainerSpec): vimService.vim.VasaProviderContainerSpec;
         };
         VimVasaProviderStatePerArray: {
            (options?: vimService.vim.VimVasaProviderStatePerArray): vimService.vim.VimVasaProviderStatePerArray;
         };
         ArrayOfVimVasaProviderStatePerArray: {
            (options?: vimService.vim.ArrayOfVimVasaProviderStatePerArray): vimService.vim.ArrayOfVimVasaProviderStatePerArray;
         };
         VimVasaProvider: {
            (options?: vimService.vim.VimVasaProvider): vimService.vim.VimVasaProvider;
         };
         VimVasaProviderInfo: {
            (options?: vimService.vim.VimVasaProviderInfo): vimService.vim.VimVasaProviderInfo;
         };
         ArrayOfVimVasaProviderInfo: {
            (options?: vimService.vim.ArrayOfVimVasaProviderInfo): vimService.vim.ArrayOfVimVasaProviderInfo;
         };
         VirtualAppVAppState: {
            "started": string;
            "stopped": string;
            "starting": string;
            "stopping": string;
         };
         VirtualAppSummary: {
            (options?: vimService.vim.VirtualAppSummary): vimService.vim.VirtualAppSummary;
         };
         VirtualAppLinkInfo: {
            (options?: vimService.vim.VirtualAppLinkInfo): vimService.vim.VirtualAppLinkInfo;
         };
         ArrayOfVirtualAppLinkInfo: {
            (options?: vimService.vim.ArrayOfVirtualAppLinkInfo): vimService.vim.ArrayOfVirtualAppLinkInfo;
         };
         VirtualDiskType: {
            "preallocated": string;
            "thin": string;
            "seSparse": string;
            "rdm": string;
            "rdmp": string;
            "raw": string;
            "delta": string;
            "sparse2Gb": string;
            "thick2Gb": string;
            "eagerZeroedThick": string;
            "sparseMonolithic": string;
            "flatMonolithic": string;
            "thick": string;
         };
         VirtualDiskAdapterType: {
            "ide": string;
            "busLogic": string;
            "lsiLogic": string;
         };
         VirtualDiskSpec: {
            (options?: vimService.vim.VirtualDiskSpec): vimService.vim.VirtualDiskSpec;
         };
         FileBackedVirtualDiskSpec: {
            (options?: vimService.vim.FileBackedVirtualDiskSpec): vimService.vim.FileBackedVirtualDiskSpec;
         };
         SeSparseVirtualDiskSpec: {
            (options?: vimService.vim.SeSparseVirtualDiskSpec): vimService.vim.SeSparseVirtualDiskSpec;
         };
         DeviceBackedVirtualDiskSpec: {
            (options?: vimService.vim.DeviceBackedVirtualDiskSpec): vimService.vim.DeviceBackedVirtualDiskSpec;
         };
         StorageRequirement: {
            (options?: vimService.vim.StorageRequirement): vimService.vim.StorageRequirement;
         };
         ArrayOfStorageRequirement: {
            (options?: vimService.vim.ArrayOfStorageRequirement): vimService.vim.ArrayOfStorageRequirement;
         };
         VirtualMachinePowerState: {
            "poweredOff": string;
            "poweredOn": string;
            "suspended": string;
         };
         VirtualMachineAppHeartbeatStatusType: {
            "appStatusGray": string;
            "appStatusGreen": string;
            "appStatusRed": string;
         };
         VirtualMachineConnectionState: {
            "connected": string;
            "disconnected": string;
            "orphaned": string;
            "inaccessible": string;
            "invalid": string;
         };
         VirtualMachineMovePriority: {
            "lowPriority": string;
            "highPriority": string;
            "defaultPriority": string;
         };
         VirtualMachineTicket: {
            (options?: vimService.vim.VirtualMachineTicket): vimService.vim.VirtualMachineTicket;
         };
         VirtualMachineMksTicket: {
            (options?: vimService.vim.VirtualMachineMksTicket): vimService.vim.VirtualMachineMksTicket;
         };
         VirtualMachineFaultToleranceState: {
            "notConfigured": string;
            "disabled": string;
            "enabled": string;
            "needSecondary": string;
            "starting": string;
            "running": string;
         };
         VirtualMachineRecordReplayState: {
            "recording": string;
            "replaying": string;
            "inactive": string;
         };
         VirtualMachineNeedSecondaryReason: {
            "initializing": string;
            "divergence": string;
            "lostConnection": string;
            "partialHardwareFailure": string;
            "userAction": string;
            "checkpointError": string;
            "other": string;
         };
         VirtualMachineFaultToleranceType: {
            "unset": string;
            "recordReplay": string;
            "checkpointing": string;
         };
         VirtualMachineTicketType: {
            "mks": string;
            "device": string;
            "guestControl": string;
            "webmks": string;
         };
         VirtualMachineDisplayTopology: {
            (options?: vimService.vim.VirtualMachineDisplayTopology): vimService.vim.VirtualMachineDisplayTopology;
         };
         ArrayOfVirtualMachineDisplayTopology: {
            (options?: vimService.vim.ArrayOfVirtualMachineDisplayTopology): vimService.vim.ArrayOfVirtualMachineDisplayTopology;
         };
         DiskChangeExtent: {
            (options?: vimService.vim.DiskChangeExtent): vimService.vim.DiskChangeExtent;
         };
         ArrayOfDiskChangeExtent: {
            (options?: vimService.vim.ArrayOfDiskChangeExtent): vimService.vim.ArrayOfDiskChangeExtent;
         };
         DiskChangeInfo: {
            (options?: vimService.vim.DiskChangeInfo): vimService.vim.DiskChangeInfo;
         };
         VirtualMachineWipeResult: {
            (options?: vimService.vim.VirtualMachineWipeResult): vimService.vim.VirtualMachineWipeResult;
         };
         VsanUpgradeSystemPreflightCheckIssue: {
            (options?: vimService.vim.VsanUpgradeSystemPreflightCheckIssue): vimService.vim.VsanUpgradeSystemPreflightCheckIssue;
         };
         ArrayOfVsanUpgradeSystemPreflightCheckIssue: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemPreflightCheckIssue): vimService.vim.ArrayOfVsanUpgradeSystemPreflightCheckIssue;
         };
         VsanUpgradeSystemHostsDisconnectedIssue: {
            (options?: vimService.vim.VsanUpgradeSystemHostsDisconnectedIssue): vimService.vim.VsanUpgradeSystemHostsDisconnectedIssue;
         };
         VsanUpgradeSystemMissingHostsInClusterIssue: {
            (options?: vimService.vim.VsanUpgradeSystemMissingHostsInClusterIssue): vimService.vim.VsanUpgradeSystemMissingHostsInClusterIssue;
         };
         VsanUpgradeSystemRogueHostsInClusterIssue: {
            (options?: vimService.vim.VsanUpgradeSystemRogueHostsInClusterIssue): vimService.vim.VsanUpgradeSystemRogueHostsInClusterIssue;
         };
         VsanUpgradeSystemWrongEsxVersionIssue: {
            (options?: vimService.vim.VsanUpgradeSystemWrongEsxVersionIssue): vimService.vim.VsanUpgradeSystemWrongEsxVersionIssue;
         };
         VsanUpgradeSystemAutoClaimEnabledOnHostsIssue: {
            (options?: vimService.vim.VsanUpgradeSystemAutoClaimEnabledOnHostsIssue): vimService.vim.VsanUpgradeSystemAutoClaimEnabledOnHostsIssue;
         };
         VsanUpgradeSystemAPIBrokenIssue: {
            (options?: vimService.vim.VsanUpgradeSystemAPIBrokenIssue): vimService.vim.VsanUpgradeSystemAPIBrokenIssue;
         };
         VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue: {
            (options?: vimService.vim.VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue): vimService.vim.VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue;
         };
         VsanUpgradeSystemNotEnoughFreeCapacityIssue: {
            (options?: vimService.vim.VsanUpgradeSystemNotEnoughFreeCapacityIssue): vimService.vim.VsanUpgradeSystemNotEnoughFreeCapacityIssue;
         };
         VsanUpgradeSystemNetworkPartitionInfo: {
            (options?: vimService.vim.VsanUpgradeSystemNetworkPartitionInfo): vimService.vim.VsanUpgradeSystemNetworkPartitionInfo;
         };
         ArrayOfVsanUpgradeSystemNetworkPartitionInfo: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemNetworkPartitionInfo): vimService.vim.ArrayOfVsanUpgradeSystemNetworkPartitionInfo;
         };
         VsanUpgradeSystemNetworkPartitionIssue: {
            (options?: vimService.vim.VsanUpgradeSystemNetworkPartitionIssue): vimService.vim.VsanUpgradeSystemNetworkPartitionIssue;
         };
         VsanUpgradeSystemPreflightCheckResult: {
            (options?: vimService.vim.VsanUpgradeSystemPreflightCheckResult): vimService.vim.VsanUpgradeSystemPreflightCheckResult;
         };
         VsanUpgradeSystemUpgradeHistoryItem: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryItem): vimService.vim.VsanUpgradeSystemUpgradeHistoryItem;
         };
         ArrayOfVsanUpgradeSystemUpgradeHistoryItem: {
            (options?: vimService.vim.ArrayOfVsanUpgradeSystemUpgradeHistoryItem): vimService.vim.ArrayOfVsanUpgradeSystemUpgradeHistoryItem;
         };
         VsanUpgradeSystemUpgradeHistoryDiskGroupOpType: {
            "add": string;
            "remove": string;
         };
         VsanUpgradeSystemUpgradeHistoryDiskGroupOp: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryDiskGroupOp): vimService.vim.VsanUpgradeSystemUpgradeHistoryDiskGroupOp;
         };
         VsanUpgradeSystemUpgradeHistoryPreflightFail: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeHistoryPreflightFail): vimService.vim.VsanUpgradeSystemUpgradeHistoryPreflightFail;
         };
         VsanUpgradeSystemUpgradeStatus: {
            (options?: vimService.vim.VsanUpgradeSystemUpgradeStatus): vimService.vim.VsanUpgradeSystemUpgradeStatus;
         };
         ActionParameter: {
            "targetName": string;
            "alarmName": string;
            "oldStatus": string;
            "newStatus": string;
            "triggeringSummary": string;
            "declaringSummary": string;
            "eventDescription": string;
            "target": string;
            "alarm": string;
         };
         Action: {
            (options?: vimService.vim.Action): vimService.vim.Action;
         };
         MethodActionArgument: {
            (options?: vimService.vim.MethodActionArgument): vimService.vim.MethodActionArgument;
         };
         ArrayOfMethodActionArgument: {
            (options?: vimService.vim.ArrayOfMethodActionArgument): vimService.vim.ArrayOfMethodActionArgument;
         };
         MethodAction: {
            (options?: vimService.vim.MethodAction): vimService.vim.MethodAction;
         };
         SendEmailAction: {
            (options?: vimService.vim.SendEmailAction): vimService.vim.SendEmailAction;
         };
         SendSNMPAction: {
            (options?: vimService.vim.SendSNMPAction): vimService.vim.SendSNMPAction;
         };
         RunScriptAction: {
            (options?: vimService.vim.RunScriptAction): vimService.vim.RunScriptAction;
         };
         CreateTaskAction: {
            (options?: vimService.vim.CreateTaskAction): vimService.vim.CreateTaskAction;
         };
         AlarmAction: {
            (options?: vimService.vim.AlarmAction): vimService.vim.AlarmAction;
         };
         ArrayOfAlarmAction: {
            (options?: vimService.vim.ArrayOfAlarmAction): vimService.vim.ArrayOfAlarmAction;
         };
         AlarmTriggeringActionTransitionSpec: {
            (options?: vimService.vim.AlarmTriggeringActionTransitionSpec): vimService.vim.AlarmTriggeringActionTransitionSpec;
         };
         ArrayOfAlarmTriggeringActionTransitionSpec: {
            (options?: vimService.vim.ArrayOfAlarmTriggeringActionTransitionSpec): vimService.vim.ArrayOfAlarmTriggeringActionTransitionSpec;
         };
         AlarmTriggeringAction: {
            (options?: vimService.vim.AlarmTriggeringAction): vimService.vim.AlarmTriggeringAction;
         };
         GroupAlarmAction: {
            (options?: vimService.vim.GroupAlarmAction): vimService.vim.GroupAlarmAction;
         };
         AlarmDescription: {
            (options?: vimService.vim.AlarmDescription): vimService.vim.AlarmDescription;
         };
         AlarmExpression: {
            (options?: vimService.vim.AlarmExpression): vimService.vim.AlarmExpression;
         };
         ArrayOfAlarmExpression: {
            (options?: vimService.vim.ArrayOfAlarmExpression): vimService.vim.ArrayOfAlarmExpression;
         };
         AndAlarmExpression: {
            (options?: vimService.vim.AndAlarmExpression): vimService.vim.AndAlarmExpression;
         };
         OrAlarmExpression: {
            (options?: vimService.vim.OrAlarmExpression): vimService.vim.OrAlarmExpression;
         };
         StateAlarmOperator: {
            "isEqual": string;
            "isUnequal": string;
         };
         StateAlarmExpression: {
            (options?: vimService.vim.StateAlarmExpression): vimService.vim.StateAlarmExpression;
         };
         EventAlarmExpressionComparisonOperator: {
            "equals": string;
            "notEqualTo": string;
            "startsWith": string;
            "doesNotStartWith": string;
            "endsWith": string;
            "doesNotEndWith": string;
         };
         EventAlarmExpressionComparison: {
            (options?: vimService.vim.EventAlarmExpressionComparison): vimService.vim.EventAlarmExpressionComparison;
         };
         ArrayOfEventAlarmExpressionComparison: {
            (options?: vimService.vim.ArrayOfEventAlarmExpressionComparison): vimService.vim.ArrayOfEventAlarmExpressionComparison;
         };
         EventAlarmExpression: {
            (options?: vimService.vim.EventAlarmExpression): vimService.vim.EventAlarmExpression;
         };
         MetricAlarmOperator: {
            "isAbove": string;
            "isBelow": string;
         };
         MetricAlarmExpression: {
            (options?: vimService.vim.MetricAlarmExpression): vimService.vim.MetricAlarmExpression;
         };
         AlarmInfo: {
            (options?: vimService.vim.AlarmInfo): vimService.vim.AlarmInfo;
         };
         AlarmSetting: {
            (options?: vimService.vim.AlarmSetting): vimService.vim.AlarmSetting;
         };
         AlarmSpec: {
            (options?: vimService.vim.AlarmSpec): vimService.vim.AlarmSpec;
         };
         AlarmState: {
            (options?: vimService.vim.AlarmState): vimService.vim.AlarmState;
         };
         ArrayOfAlarmState: {
            (options?: vimService.vim.ArrayOfAlarmState): vimService.vim.ArrayOfAlarmState;
         };
         ActionType: {
            "MigrationV1": string;
            "VmPowerV1": string;
            "HostPowerV1": string;
            "HostMaintenanceV1": string;
            "StorageMigrationV1": string;
            "StoragePlacementV1": string;
            "PlacementV1": string;
         };
         ClusterAction: {
            (options?: vimService.vim.ClusterAction): vimService.vim.ClusterAction;
         };
         ArrayOfClusterAction: {
            (options?: vimService.vim.ArrayOfClusterAction): vimService.vim.ArrayOfClusterAction;
         };
         ClusterActionHistory: {
            (options?: vimService.vim.ClusterActionHistory): vimService.vim.ClusterActionHistory;
         };
         ArrayOfClusterActionHistory: {
            (options?: vimService.vim.ArrayOfClusterActionHistory): vimService.vim.ArrayOfClusterActionHistory;
         };
         ClusterAffinityRuleSpec: {
            (options?: vimService.vim.ClusterAffinityRuleSpec): vimService.vim.ClusterAffinityRuleSpec;
         };
         ClusterAntiAffinityRuleSpec: {
            (options?: vimService.vim.ClusterAntiAffinityRuleSpec): vimService.vim.ClusterAntiAffinityRuleSpec;
         };
         ClusterAttemptedVmInfo: {
            (options?: vimService.vim.ClusterAttemptedVmInfo): vimService.vim.ClusterAttemptedVmInfo;
         };
         ArrayOfClusterAttemptedVmInfo: {
            (options?: vimService.vim.ArrayOfClusterAttemptedVmInfo): vimService.vim.ArrayOfClusterAttemptedVmInfo;
         };
         ClusterConfigInfo: {
            (options?: vimService.vim.ClusterConfigInfo): vimService.vim.ClusterConfigInfo;
         };
         DrsBehavior: {
            "manual": string;
            "partiallyAutomated": string;
            "fullyAutomated": string;
         };
         ClusterDrsConfigInfo: {
            (options?: vimService.vim.ClusterDrsConfigInfo): vimService.vim.ClusterDrsConfigInfo;
         };
         ClusterDrsVmConfigInfo: {
            (options?: vimService.vim.ClusterDrsVmConfigInfo): vimService.vim.ClusterDrsVmConfigInfo;
         };
         ArrayOfClusterDrsVmConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDrsVmConfigInfo): vimService.vim.ArrayOfClusterDrsVmConfigInfo;
         };
         ClusterConfigInfoEx: {
            (options?: vimService.vim.ClusterConfigInfoEx): vimService.vim.ClusterConfigInfoEx;
         };
         DpmBehavior: {
            "manual": string;
            "automated": string;
         };
         ClusterDpmConfigInfo: {
            (options?: vimService.vim.ClusterDpmConfigInfo): vimService.vim.ClusterDpmConfigInfo;
         };
         ClusterDpmHostConfigInfo: {
            (options?: vimService.vim.ClusterDpmHostConfigInfo): vimService.vim.ClusterDpmHostConfigInfo;
         };
         ArrayOfClusterDpmHostConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDpmHostConfigInfo): vimService.vim.ArrayOfClusterDpmHostConfigInfo;
         };
         ClusterConfigSpec: {
            (options?: vimService.vim.ClusterConfigSpec): vimService.vim.ClusterConfigSpec;
         };
         ClusterDasVmConfigSpec: {
            (options?: vimService.vim.ClusterDasVmConfigSpec): vimService.vim.ClusterDasVmConfigSpec;
         };
         ArrayOfClusterDasVmConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDasVmConfigSpec): vimService.vim.ArrayOfClusterDasVmConfigSpec;
         };
         ClusterDrsVmConfigSpec: {
            (options?: vimService.vim.ClusterDrsVmConfigSpec): vimService.vim.ClusterDrsVmConfigSpec;
         };
         ArrayOfClusterDrsVmConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDrsVmConfigSpec): vimService.vim.ArrayOfClusterDrsVmConfigSpec;
         };
         ClusterConfigSpecEx: {
            (options?: vimService.vim.ClusterConfigSpecEx): vimService.vim.ClusterConfigSpecEx;
         };
         ClusterDpmHostConfigSpec: {
            (options?: vimService.vim.ClusterDpmHostConfigSpec): vimService.vim.ClusterDpmHostConfigSpec;
         };
         ArrayOfClusterDpmHostConfigSpec: {
            (options?: vimService.vim.ArrayOfClusterDpmHostConfigSpec): vimService.vim.ArrayOfClusterDpmHostConfigSpec;
         };
         ClusterGroupSpec: {
            (options?: vimService.vim.ClusterGroupSpec): vimService.vim.ClusterGroupSpec;
         };
         ArrayOfClusterGroupSpec: {
            (options?: vimService.vim.ArrayOfClusterGroupSpec): vimService.vim.ArrayOfClusterGroupSpec;
         };
         ClusterDasAamHostInfo: {
            (options?: vimService.vim.ClusterDasAamHostInfo): vimService.vim.ClusterDasAamHostInfo;
         };
         ClusterDasAamNodeStateDasState: {
            "uninitialized": string;
            "initialized": string;
            "configuring": string;
            "unconfiguring": string;
            "running": string;
            "error": string;
            "agentShutdown": string;
            "nodeFailed": string;
         };
         ClusterDasAamNodeState: {
            (options?: vimService.vim.ClusterDasAamNodeState): vimService.vim.ClusterDasAamNodeState;
         };
         ArrayOfClusterDasAamNodeState: {
            (options?: vimService.vim.ArrayOfClusterDasAamNodeState): vimService.vim.ArrayOfClusterDasAamNodeState;
         };
         ClusterDasAdmissionControlInfo: {
            (options?: vimService.vim.ClusterDasAdmissionControlInfo): vimService.vim.ClusterDasAdmissionControlInfo;
         };
         ClusterDasAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterDasAdmissionControlPolicy): vimService.vim.ClusterDasAdmissionControlPolicy;
         };
         ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo: {
            (options?: vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo): vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
         };
         DasHeartbeatDatastoreInfo: {
            (options?: vimService.vim.DasHeartbeatDatastoreInfo): vimService.vim.DasHeartbeatDatastoreInfo;
         };
         ArrayOfDasHeartbeatDatastoreInfo: {
            (options?: vimService.vim.ArrayOfDasHeartbeatDatastoreInfo): vimService.vim.ArrayOfDasHeartbeatDatastoreInfo;
         };
         ClusterDasAdvancedRuntimeInfo: {
            (options?: vimService.vim.ClusterDasAdvancedRuntimeInfo): vimService.vim.ClusterDasAdvancedRuntimeInfo;
         };
         ClusterDasConfigInfoServiceState: {
            "disabled": string;
            "enabled": string;
         };
         ClusterDasConfigInfoVmMonitoringState: {
            "vmMonitoringDisabled": string;
            "vmMonitoringOnly": string;
            "vmAndAppMonitoring": string;
         };
         ClusterDasConfigInfoHBDatastoreCandidate: {
            "userSelectedDs": string;
            "allFeasibleDs": string;
            "allFeasibleDsWithUserPreference": string;
         };
         ClusterDasConfigInfo: {
            (options?: vimService.vim.ClusterDasConfigInfo): vimService.vim.ClusterDasConfigInfo;
         };
         ClusterDasData: {
            (options?: vimService.vim.ClusterDasData): vimService.vim.ClusterDasData;
         };
         ClusterDasDataSummary: {
            (options?: vimService.vim.ClusterDasDataSummary): vimService.vim.ClusterDasDataSummary;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots: {
            (options?: vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots): vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots: {
            (options?: vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots): vimService.vim.ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots;
         };
         ClusterDasFailoverLevelAdvancedRuntimeInfo: {
            (options?: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo): vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfo;
         };
         ClusterDasFdmAvailabilityState: {
            "uninitialized": string;
            "election": string;
            "master": string;
            "connectedToMaster": string;
            "networkPartitionedFromMaster": string;
            "networkIsolated": string;
            "hostDown": string;
            "initializationError": string;
            "uninitializationError": string;
            "fdmUnreachable": string;
         };
         ClusterDasFdmHostState: {
            (options?: vimService.vim.ClusterDasFdmHostState): vimService.vim.ClusterDasFdmHostState;
         };
         ClusterDasHostInfo: {
            (options?: vimService.vim.ClusterDasHostInfo): vimService.vim.ClusterDasHostInfo;
         };
         ClusterDasHostRecommendation: {
            (options?: vimService.vim.ClusterDasHostRecommendation): vimService.vim.ClusterDasHostRecommendation;
         };
         ClusterDasMetroHASettings: {
            (options?: vimService.vim.ClusterDasMetroHASettings): vimService.vim.ClusterDasMetroHASettings;
         };
         DasVmPriority: {
            "disabled": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         ClusterDasVmConfigInfo: {
            (options?: vimService.vim.ClusterDasVmConfigInfo): vimService.vim.ClusterDasVmConfigInfo;
         };
         ArrayOfClusterDasVmConfigInfo: {
            (options?: vimService.vim.ArrayOfClusterDasVmConfigInfo): vimService.vim.ArrayOfClusterDasVmConfigInfo;
         };
         ClusterDasVmSettingsRestartPriority: {
            "disabled": string;
            "low": string;
            "medium": string;
            "high": string;
            "clusterRestartPriority": string;
         };
         ClusterDasVmSettingsIsolationResponse: {
            "none": string;
            "powerOff": string;
            "shutdown": string;
            "clusterIsolationResponse": string;
         };
         ClusterDasVmSettings: {
            (options?: vimService.vim.ClusterDasVmSettings): vimService.vim.ClusterDasVmSettings;
         };
         ClusterDrsFaultsFaultsByVm: {
            (options?: vimService.vim.ClusterDrsFaultsFaultsByVm): vimService.vim.ClusterDrsFaultsFaultsByVm;
         };
         ArrayOfClusterDrsFaultsFaultsByVm: {
            (options?: vimService.vim.ArrayOfClusterDrsFaultsFaultsByVm): vimService.vim.ArrayOfClusterDrsFaultsFaultsByVm;
         };
         ClusterDrsFaultsFaultsByVirtualDisk: {
            (options?: vimService.vim.ClusterDrsFaultsFaultsByVirtualDisk): vimService.vim.ClusterDrsFaultsFaultsByVirtualDisk;
         };
         ClusterDrsFaults: {
            (options?: vimService.vim.ClusterDrsFaults): vimService.vim.ClusterDrsFaults;
         };
         ArrayOfClusterDrsFaults: {
            (options?: vimService.vim.ArrayOfClusterDrsFaults): vimService.vim.ArrayOfClusterDrsFaults;
         };
         ClusterDrsMigration: {
            (options?: vimService.vim.ClusterDrsMigration): vimService.vim.ClusterDrsMigration;
         };
         ArrayOfClusterDrsMigration: {
            (options?: vimService.vim.ArrayOfClusterDrsMigration): vimService.vim.ArrayOfClusterDrsMigration;
         };
         DrsRecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
         };
         ClusterDrsRecommendation: {
            (options?: vimService.vim.ClusterDrsRecommendation): vimService.vim.ClusterDrsRecommendation;
         };
         ArrayOfClusterDrsRecommendation: {
            (options?: vimService.vim.ArrayOfClusterDrsRecommendation): vimService.vim.ArrayOfClusterDrsRecommendation;
         };
         ClusterEVCManagerEVCState: {
            (options?: vimService.vim.ClusterEVCManagerEVCState): vimService.vim.ClusterEVCManagerEVCState;
         };
         ClusterEVCManagerCheckResult: {
            (options?: vimService.vim.ClusterEVCManagerCheckResult): vimService.vim.ClusterEVCManagerCheckResult;
         };
         ArrayOfClusterEVCManagerCheckResult: {
            (options?: vimService.vim.ArrayOfClusterEVCManagerCheckResult): vimService.vim.ArrayOfClusterEVCManagerCheckResult;
         };
         ClusterEnterMaintenanceResult: {
            (options?: vimService.vim.ClusterEnterMaintenanceResult): vimService.vim.ClusterEnterMaintenanceResult;
         };
         ClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus): vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus: {
            (options?: vimService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus): vimService.vim.ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus;
         };
         ClusterFailoverHostAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlInfo): vimService.vim.ClusterFailoverHostAdmissionControlInfo;
         };
         ClusterFailoverHostAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverHostAdmissionControlPolicy): vimService.vim.ClusterFailoverHostAdmissionControlPolicy;
         };
         ClusterFailoverLevelAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverLevelAdmissionControlInfo): vimService.vim.ClusterFailoverLevelAdmissionControlInfo;
         };
         ClusterFailoverLevelAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverLevelAdmissionControlPolicy): vimService.vim.ClusterFailoverLevelAdmissionControlPolicy;
         };
         ClusterFailoverResourcesAdmissionControlInfo: {
            (options?: vimService.vim.ClusterFailoverResourcesAdmissionControlInfo): vimService.vim.ClusterFailoverResourcesAdmissionControlInfo;
         };
         ClusterFailoverResourcesAdmissionControlPolicy: {
            (options?: vimService.vim.ClusterFailoverResourcesAdmissionControlPolicy): vimService.vim.ClusterFailoverResourcesAdmissionControlPolicy;
         };
         ClusterGroupInfo: {
            (options?: vimService.vim.ClusterGroupInfo): vimService.vim.ClusterGroupInfo;
         };
         ArrayOfClusterGroupInfo: {
            (options?: vimService.vim.ArrayOfClusterGroupInfo): vimService.vim.ArrayOfClusterGroupInfo;
         };
         ClusterHostGroup: {
            (options?: vimService.vim.ClusterHostGroup): vimService.vim.ClusterHostGroup;
         };
         HostPowerOperationType: {
            "powerOn": string;
            "powerOff": string;
         };
         ClusterHostPowerAction: {
            (options?: vimService.vim.ClusterHostPowerAction): vimService.vim.ClusterHostPowerAction;
         };
         ClusterHostRecommendation: {
            (options?: vimService.vim.ClusterHostRecommendation): vimService.vim.ClusterHostRecommendation;
         };
         ArrayOfClusterHostRecommendation: {
            (options?: vimService.vim.ArrayOfClusterHostRecommendation): vimService.vim.ArrayOfClusterHostRecommendation;
         };
         ClusterInitialPlacementAction: {
            (options?: vimService.vim.ClusterInitialPlacementAction): vimService.vim.ClusterInitialPlacementAction;
         };
         ClusterMigrationAction: {
            (options?: vimService.vim.ClusterMigrationAction): vimService.vim.ClusterMigrationAction;
         };
         ClusterNotAttemptedVmInfo: {
            (options?: vimService.vim.ClusterNotAttemptedVmInfo): vimService.vim.ClusterNotAttemptedVmInfo;
         };
         ArrayOfClusterNotAttemptedVmInfo: {
            (options?: vimService.vim.ArrayOfClusterNotAttemptedVmInfo): vimService.vim.ArrayOfClusterNotAttemptedVmInfo;
         };
         PlacementAction: {
            (options?: vimService.vim.PlacementAction): vimService.vim.PlacementAction;
         };
         PlacementResult: {
            (options?: vimService.vim.PlacementResult): vimService.vim.PlacementResult;
         };
         PlacementSpecPlacementType: {
            "create": string;
            "reconfigure": string;
            "relocate": string;
            "clone": string;
         };
         PlacementSpec: {
            (options?: vimService.vim.PlacementSpec): vimService.vim.PlacementSpec;
         };
         ArrayOfPlacementSpec: {
            (options?: vimService.vim.ArrayOfPlacementSpec): vimService.vim.ArrayOfPlacementSpec;
         };
         ClusterPowerOnVmOption: {
            "OverrideAutomationLevel": string;
            "ReserveResources": string;
         };
         ClusterPowerOnVmResult: {
            (options?: vimService.vim.ClusterPowerOnVmResult): vimService.vim.ClusterPowerOnVmResult;
         };
         RecommendationType: {
            "V1": string;
         };
         RecommendationReasonCode: {
            "fairnessCpuAvg": string;
            "fairnessMemAvg": string;
            "jointAffin": string;
            "antiAffin": string;
            "hostMaint": string;
            "enterStandby": string;
            "reservationCpu": string;
            "reservationMem": string;
            "powerOnVm": string;
            "powerSaving": string;
            "increaseCapacity": string;
            "checkResource": string;
            "unreservedCapacity": string;
            "vmHostHardAffinity": string;
            "vmHostSoftAffinity": string;
            "balanceDatastoreSpaceUsage": string;
            "balanceDatastoreIOLoad": string;
            "balanceDatastoreIOPSReservation": string;
            "datastoreMaint": string;
            "virtualDiskJointAffin": string;
            "virtualDiskAntiAffin": string;
            "datastoreSpaceOutage": string;
            "storagePlacement": string;
            "iolbDisabledInternal": string;
            "xvmotionPlacement": string;
            "networkBandwidthReservation": string;
         };
         ClusterRecommendation: {
            (options?: vimService.vim.ClusterRecommendation): vimService.vim.ClusterRecommendation;
         };
         ArrayOfClusterRecommendation: {
            (options?: vimService.vim.ArrayOfClusterRecommendation): vimService.vim.ArrayOfClusterRecommendation;
         };
         ClusterResourceUsageSummary: {
            (options?: vimService.vim.ClusterResourceUsageSummary): vimService.vim.ClusterResourceUsageSummary;
         };
         ClusterRuleInfo: {
            (options?: vimService.vim.ClusterRuleInfo): vimService.vim.ClusterRuleInfo;
         };
         ArrayOfClusterRuleInfo: {
            (options?: vimService.vim.ArrayOfClusterRuleInfo): vimService.vim.ArrayOfClusterRuleInfo;
         };
         ClusterRuleSpec: {
            (options?: vimService.vim.ClusterRuleSpec): vimService.vim.ClusterRuleSpec;
         };
         ArrayOfClusterRuleSpec: {
            (options?: vimService.vim.ArrayOfClusterRuleSpec): vimService.vim.ArrayOfClusterRuleSpec;
         };
         ClusterSlotPolicy: {
            (options?: vimService.vim.ClusterSlotPolicy): vimService.vim.ClusterSlotPolicy;
         };
         ClusterFixedSizeSlotPolicy: {
            (options?: vimService.vim.ClusterFixedSizeSlotPolicy): vimService.vim.ClusterFixedSizeSlotPolicy;
         };
         ClusterUsageSummary: {
            (options?: vimService.vim.ClusterUsageSummary): vimService.vim.ClusterUsageSummary;
         };
         ClusterVmComponentProtectionSettingsStorageVmReaction: {
            "disabled": string;
            "warning": string;
            "restartConservative": string;
            "restartAggressive": string;
            "clusterDefault": string;
         };
         ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared: {
            "none": string;
            "reset": string;
            "useClusterDefault": string;
         };
         ClusterVmComponentProtectionSettings: {
            (options?: vimService.vim.ClusterVmComponentProtectionSettings): vimService.vim.ClusterVmComponentProtectionSettings;
         };
         ClusterVmGroup: {
            (options?: vimService.vim.ClusterVmGroup): vimService.vim.ClusterVmGroup;
         };
         ClusterVmHostRuleInfo: {
            (options?: vimService.vim.ClusterVmHostRuleInfo): vimService.vim.ClusterVmHostRuleInfo;
         };
         ClusterVmToolsMonitoringSettings: {
            (options?: vimService.vim.ClusterVmToolsMonitoringSettings): vimService.vim.ClusterVmToolsMonitoringSettings;
         };
         DVPortConfigSpec: {
            (options?: vimService.vim.DVPortConfigSpec): vimService.vim.DVPortConfigSpec;
         };
         ArrayOfDVPortConfigSpec: {
            (options?: vimService.vim.ArrayOfDVPortConfigSpec): vimService.vim.ArrayOfDVPortConfigSpec;
         };
         DVPortConfigInfo: {
            (options?: vimService.vim.DVPortConfigInfo): vimService.vim.DVPortConfigInfo;
         };
         DVSTrafficShapingPolicy: {
            (options?: vimService.vim.DVSTrafficShapingPolicy): vimService.vim.DVSTrafficShapingPolicy;
         };
         DVSHostLocalPortInfo: {
            (options?: vimService.vim.DVSHostLocalPortInfo): vimService.vim.DVSHostLocalPortInfo;
         };
         DVSVendorSpecificConfig: {
            (options?: vimService.vim.DVSVendorSpecificConfig): vimService.vim.DVSVendorSpecificConfig;
         };
         DVSIPEntry: {
            (options?: vimService.vim.DVSIPEntry): vimService.vim.DVSIPEntry;
         };
         ArrayOfDVSIPEntry: {
            (options?: vimService.vim.ArrayOfDVSIPEntry): vimService.vim.ArrayOfDVSIPEntry;
         };
         DVSStaticIPArray: {
            (options?: vimService.vim.DVSStaticIPArray): vimService.vim.DVSStaticIPArray;
         };
         DVSPortDbEntry: {
            (options?: vimService.vim.DVSPortDbEntry): vimService.vim.DVSPortDbEntry;
         };
         ArrayOfDVSPortDbEntry: {
            (options?: vimService.vim.ArrayOfDVSPortDbEntry): vimService.vim.ArrayOfDVSPortDbEntry;
         };
         DVSPortDbQueryResults: {
            (options?: vimService.vim.DVSPortDbQueryResults): vimService.vim.DVSPortDbQueryResults;
         };
         DVSPortDbClearSpec: {
            (options?: vimService.vim.DVSPortDbClearSpec): vimService.vim.DVSPortDbClearSpec;
         };
         DvsFilterParameter: {
            (options?: vimService.vim.DvsFilterParameter): vimService.vim.DvsFilterParameter;
         };
         DvsFilterOnFailure: {
            "failOpen": string;
            "failClosed": string;
         };
         DvsFilterConfig: {
            (options?: vimService.vim.DvsFilterConfig): vimService.vim.DvsFilterConfig;
         };
         ArrayOfDvsFilterConfig: {
            (options?: vimService.vim.ArrayOfDvsFilterConfig): vimService.vim.ArrayOfDvsFilterConfig;
         };
         DvsTrafficFilterConfig: {
            (options?: vimService.vim.DvsTrafficFilterConfig): vimService.vim.DvsTrafficFilterConfig;
         };
         DvsFilterConfigSpec: {
            (options?: vimService.vim.DvsFilterConfigSpec): vimService.vim.DvsFilterConfigSpec;
         };
         DvsTrafficFilterConfigSpec: {
            (options?: vimService.vim.DvsTrafficFilterConfigSpec): vimService.vim.DvsTrafficFilterConfigSpec;
         };
         DvsFilterPolicy: {
            (options?: vimService.vim.DvsFilterPolicy): vimService.vim.DvsFilterPolicy;
         };
         DVPortSetting: {
            (options?: vimService.vim.DVPortSetting): vimService.vim.DVPortSetting;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonNetwork: {
            "portNptIncompatibleDvs": string;
            "portNptNoCompatibleNics": string;
            "portNptNoVirtualFunctionsAvailable": string;
            "portNptDisabledForPort": string;
         };
         DVPortStatusVmDirectPathGen2InactiveReasonOther: {
            "portNptIncompatibleHost": string;
            "portNptIncompatibleConnectee": string;
         };
         DVPortStatus: {
            (options?: vimService.vim.DVPortStatus): vimService.vim.DVPortStatus;
         };
         DVPortState: {
            (options?: vimService.vim.DVPortState): vimService.vim.DVPortState;
         };
         DistributedVirtualPort: {
            (options?: vimService.vim.DistributedVirtualPort): vimService.vim.DistributedVirtualPort;
         };
         ArrayOfDistributedVirtualPort: {
            (options?: vimService.vim.ArrayOfDistributedVirtualPort): vimService.vim.ArrayOfDistributedVirtualPort;
         };
         DistributedVirtualPortgroupPortgroupType: {
            "earlyBinding": string;
            "lateBinding": string;
            "ephemeral": string;
         };
         DVPortgroupPolicy: {
            (options?: vimService.vim.DVPortgroupPolicy): vimService.vim.DVPortgroupPolicy;
         };
         DistributedVirtualPortgroupMetaTagName: {
            "dvsName": string;
            "portgroupName": string;
            "portIndex": string;
         };
         DVPortgroupConfigSpec: {
            (options?: vimService.vim.DVPortgroupConfigSpec): vimService.vim.DVPortgroupConfigSpec;
         };
         ArrayOfDVPortgroupConfigSpec: {
            (options?: vimService.vim.ArrayOfDVPortgroupConfigSpec): vimService.vim.ArrayOfDVPortgroupConfigSpec;
         };
         DVPortgroupConfigInfo: {
            (options?: vimService.vim.DVPortgroupConfigInfo): vimService.vim.DVPortgroupConfigInfo;
         };
         DistributedVirtualPortgroupInfo: {
            (options?: vimService.vim.DistributedVirtualPortgroupInfo): vimService.vim.DistributedVirtualPortgroupInfo;
         };
         ArrayOfDistributedVirtualPortgroupInfo: {
            (options?: vimService.vim.ArrayOfDistributedVirtualPortgroupInfo): vimService.vim.ArrayOfDistributedVirtualPortgroupInfo;
         };
         DVPortgroupSelection: {
            (options?: vimService.vim.DVPortgroupSelection): vimService.vim.DVPortgroupSelection;
         };
         DistributedVirtualSwitchInfo: {
            (options?: vimService.vim.DistributedVirtualSwitchInfo): vimService.vim.DistributedVirtualSwitchInfo;
         };
         ArrayOfDistributedVirtualSwitchInfo: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchInfo): vimService.vim.ArrayOfDistributedVirtualSwitchInfo;
         };
         DVSManagerDvsConfigTarget: {
            (options?: vimService.vim.DVSManagerDvsConfigTarget): vimService.vim.DVSManagerDvsConfigTarget;
         };
         DistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult): vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult;
         };
         ArrayOfDistributedVirtualSwitchManagerCompatibilityResult: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult): vimService.vim.ArrayOfDistributedVirtualSwitchManagerCompatibilityResult;
         };
         DistributedVirtualSwitchManagerHostContainer: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostContainer): vimService.vim.DistributedVirtualSwitchManagerHostContainer;
         };
         DistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec): vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec): vimService.vim.ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec;
         };
         DistributedVirtualSwitchManagerHostArrayFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostArrayFilter): vimService.vim.DistributedVirtualSwitchManagerHostArrayFilter;
         };
         DistributedVirtualSwitchManagerHostContainerFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostContainerFilter): vimService.vim.DistributedVirtualSwitchManagerHostContainerFilter;
         };
         DistributedVirtualSwitchManagerHostDvsMembershipFilter: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter): vimService.vim.DistributedVirtualSwitchManagerHostDvsMembershipFilter;
         };
         DistributedVirtualSwitchManagerDvsProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec): vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec;
         };
         DistributedVirtualSwitchManagerImportResult: {
            (options?: vimService.vim.DistributedVirtualSwitchManagerImportResult): vimService.vim.DistributedVirtualSwitchManagerImportResult;
         };
         DVSSelection: {
            (options?: vimService.vim.DVSSelection): vimService.vim.DVSSelection;
         };
         EntityBackupConfig: {
            (options?: vimService.vim.EntityBackupConfig): vimService.vim.EntityBackupConfig;
         };
         ArrayOfEntityBackupConfig: {
            (options?: vimService.vim.ArrayOfEntityBackupConfig): vimService.vim.ArrayOfEntityBackupConfig;
         };
         EntityType: {
            "distributedVirtualSwitch": string;
            "distributedVirtualPortgroup": string;
         };
         EntityImportType: {
            "createEntityWithNewIdentifier": string;
            "createEntityWithOriginalIdentifier": string;
            "applyToEntitySpecified": string;
         };
         EntityBackup: {
            (options?: vimService.vim.EntityBackup): vimService.vim.EntityBackup;
         };
         DistributedVirtualSwitchHostMemberHostComponentState: {
            "up": string;
            "pending": string;
            "outOfSync": string;
            "warning": string;
            "disconnected": string;
            "down": string;
         };
         DistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec): vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberConfigSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberConfigSpec;
         };
         DistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec): vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec;
         };
         ArrayOfDistributedVirtualSwitchHostMemberPnicSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostMemberPnicSpec;
         };
         DistributedVirtualSwitchHostMemberBacking: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberBacking): vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         };
         DistributedVirtualSwitchHostMemberPnicBacking: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberPnicBacking): vimService.vim.DistributedVirtualSwitchHostMemberPnicBacking;
         };
         DistributedVirtualSwitchHostMemberRuntimeState: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState): vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
         };
         DistributedVirtualSwitchHostMemberConfigInfo: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo): vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
         };
         HostMemberRuntimeInfo: {
            (options?: vimService.vim.HostMemberRuntimeInfo): vimService.vim.HostMemberRuntimeInfo;
         };
         ArrayOfHostMemberRuntimeInfo: {
            (options?: vimService.vim.ArrayOfHostMemberRuntimeInfo): vimService.vim.ArrayOfHostMemberRuntimeInfo;
         };
         HostMemberHealthCheckResult: {
            (options?: vimService.vim.HostMemberHealthCheckResult): vimService.vim.HostMemberHealthCheckResult;
         };
         ArrayOfHostMemberHealthCheckResult: {
            (options?: vimService.vim.ArrayOfHostMemberHealthCheckResult): vimService.vim.ArrayOfHostMemberHealthCheckResult;
         };
         HostMemberUplinkHealthCheckResult: {
            (options?: vimService.vim.HostMemberUplinkHealthCheckResult): vimService.vim.HostMemberUplinkHealthCheckResult;
         };
         DistributedVirtualSwitchHostMember: {
            (options?: vimService.vim.DistributedVirtualSwitchHostMember): vimService.vim.DistributedVirtualSwitchHostMember;
         };
         ArrayOfDistributedVirtualSwitchHostMember: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostMember): vimService.vim.ArrayOfDistributedVirtualSwitchHostMember;
         };
         DistributedVirtualSwitchHostProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchHostProductSpec): vimService.vim.DistributedVirtualSwitchHostProductSpec;
         };
         ArrayOfDistributedVirtualSwitchHostProductSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec): vimService.vim.ArrayOfDistributedVirtualSwitchHostProductSpec;
         };
         DistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob): vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob;
         };
         ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob): vimService.vim.ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob;
         };
         DVSNetworkResourcePoolAllocationInfo: {
            (options?: vimService.vim.DVSNetworkResourcePoolAllocationInfo): vimService.vim.DVSNetworkResourcePoolAllocationInfo;
         };
         DVSNetworkResourcePoolConfigSpec: {
            (options?: vimService.vim.DVSNetworkResourcePoolConfigSpec): vimService.vim.DVSNetworkResourcePoolConfigSpec;
         };
         ArrayOfDVSNetworkResourcePoolConfigSpec: {
            (options?: vimService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec): vimService.vim.ArrayOfDVSNetworkResourcePoolConfigSpec;
         };
         DVSNetworkResourcePool: {
            (options?: vimService.vim.DVSNetworkResourcePool): vimService.vim.DVSNetworkResourcePool;
         };
         ArrayOfDVSNetworkResourcePool: {
            (options?: vimService.vim.ArrayOfDVSNetworkResourcePool): vimService.vim.ArrayOfDVSNetworkResourcePool;
         };
         DistributedVirtualSwitchPortConnecteeConnecteeType: {
            "pnic": string;
            "vmVnic": string;
            "hostConsoleVnic": string;
            "hostVmkVnic": string;
         };
         DistributedVirtualSwitchPortConnectee: {
            (options?: vimService.vim.DistributedVirtualSwitchPortConnectee): vimService.vim.DistributedVirtualSwitchPortConnectee;
         };
         DistributedVirtualSwitchPortConnection: {
            (options?: vimService.vim.DistributedVirtualSwitchPortConnection): vimService.vim.DistributedVirtualSwitchPortConnection;
         };
         DistributedVirtualSwitchPortCriteria: {
            (options?: vimService.vim.DistributedVirtualSwitchPortCriteria): vimService.vim.DistributedVirtualSwitchPortCriteria;
         };
         DistributedVirtualSwitchPortStatistics: {
            (options?: vimService.vim.DistributedVirtualSwitchPortStatistics): vimService.vim.DistributedVirtualSwitchPortStatistics;
         };
         DistributedVirtualSwitchProductSpec: {
            (options?: vimService.vim.DistributedVirtualSwitchProductSpec): vimService.vim.DistributedVirtualSwitchProductSpec;
         };
         ArrayOfDistributedVirtualSwitchProductSpec: {
            (options?: vimService.vim.ArrayOfDistributedVirtualSwitchProductSpec): vimService.vim.ArrayOfDistributedVirtualSwitchProductSpec;
         };
         DvsNetworkRuleQualifier: {
            (options?: vimService.vim.DvsNetworkRuleQualifier): vimService.vim.DvsNetworkRuleQualifier;
         };
         ArrayOfDvsNetworkRuleQualifier: {
            (options?: vimService.vim.ArrayOfDvsNetworkRuleQualifier): vimService.vim.ArrayOfDvsNetworkRuleQualifier;
         };
         DvsNetworkRuleAction: {
            (options?: vimService.vim.DvsNetworkRuleAction): vimService.vim.DvsNetworkRuleAction;
         };
         DvsNetworkRuleDirectionType: {
            "incomingPackets": string;
            "outgoingPackets": string;
            "both": string;
         };
         DvsIpNetworkRuleQualifier: {
            (options?: vimService.vim.DvsIpNetworkRuleQualifier): vimService.vim.DvsIpNetworkRuleQualifier;
         };
         DvsIpPort: {
            (options?: vimService.vim.DvsIpPort): vimService.vim.DvsIpPort;
         };
         DvsSingleIpPort: {
            (options?: vimService.vim.DvsSingleIpPort): vimService.vim.DvsSingleIpPort;
         };
         DvsIpPortRange: {
            (options?: vimService.vim.DvsIpPortRange): vimService.vim.DvsIpPortRange;
         };
         DvsMacNetworkRuleQualifier: {
            (options?: vimService.vim.DvsMacNetworkRuleQualifier): vimService.vim.DvsMacNetworkRuleQualifier;
         };
         DvsSystemTrafficNetworkRuleQualifier: {
            (options?: vimService.vim.DvsSystemTrafficNetworkRuleQualifier): vimService.vim.DvsSystemTrafficNetworkRuleQualifier;
         };
         DvsDropNetworkRuleAction: {
            (options?: vimService.vim.DvsDropNetworkRuleAction): vimService.vim.DvsDropNetworkRuleAction;
         };
         DvsAcceptNetworkRuleAction: {
            (options?: vimService.vim.DvsAcceptNetworkRuleAction): vimService.vim.DvsAcceptNetworkRuleAction;
         };
         DvsUpdateTagNetworkRuleAction: {
            (options?: vimService.vim.DvsUpdateTagNetworkRuleAction): vimService.vim.DvsUpdateTagNetworkRuleAction;
         };
         DvsRateLimitNetworkRuleAction: {
            (options?: vimService.vim.DvsRateLimitNetworkRuleAction): vimService.vim.DvsRateLimitNetworkRuleAction;
         };
         DvsLogNetworkRuleAction: {
            (options?: vimService.vim.DvsLogNetworkRuleAction): vimService.vim.DvsLogNetworkRuleAction;
         };
         DvsGreEncapNetworkRuleAction: {
            (options?: vimService.vim.DvsGreEncapNetworkRuleAction): vimService.vim.DvsGreEncapNetworkRuleAction;
         };
         DvsMacRewriteNetworkRuleAction: {
            (options?: vimService.vim.DvsMacRewriteNetworkRuleAction): vimService.vim.DvsMacRewriteNetworkRuleAction;
         };
         DvsPuntNetworkRuleAction: {
            (options?: vimService.vim.DvsPuntNetworkRuleAction): vimService.vim.DvsPuntNetworkRuleAction;
         };
         DvsCopyNetworkRuleAction: {
            (options?: vimService.vim.DvsCopyNetworkRuleAction): vimService.vim.DvsCopyNetworkRuleAction;
         };
         DvsTrafficRule: {
            (options?: vimService.vim.DvsTrafficRule): vimService.vim.DvsTrafficRule;
         };
         ArrayOfDvsTrafficRule: {
            (options?: vimService.vim.ArrayOfDvsTrafficRule): vimService.vim.ArrayOfDvsTrafficRule;
         };
         DvsTrafficRuleset: {
            (options?: vimService.vim.DvsTrafficRuleset): vimService.vim.DvsTrafficRuleset;
         };
         DvsVmVnicResourceAllocation: {
            (options?: vimService.vim.DvsVmVnicResourceAllocation): vimService.vim.DvsVmVnicResourceAllocation;
         };
         DvsVmVnicResourcePoolConfigSpec: {
            (options?: vimService.vim.DvsVmVnicResourcePoolConfigSpec): vimService.vim.DvsVmVnicResourcePoolConfigSpec;
         };
         ArrayOfDvsVmVnicResourcePoolConfigSpec: {
            (options?: vimService.vim.ArrayOfDvsVmVnicResourcePoolConfigSpec): vimService.vim.ArrayOfDvsVmVnicResourcePoolConfigSpec;
         };
         DvsVnicAllocatedResource: {
            (options?: vimService.vim.DvsVnicAllocatedResource): vimService.vim.DvsVnicAllocatedResource;
         };
         ArrayOfDvsVnicAllocatedResource: {
            (options?: vimService.vim.ArrayOfDvsVnicAllocatedResource): vimService.vim.ArrayOfDvsVnicAllocatedResource;
         };
         DvsVmVnicNetworkResourcePoolRuntimeInfo: {
            (options?: vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo): vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo;
         };
         ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo: {
            (options?: vimService.vim.ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo): vimService.vim.ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo;
         };
         DVSVmVnicNetworkResourcePool: {
            (options?: vimService.vim.DVSVmVnicNetworkResourcePool): vimService.vim.DVSVmVnicNetworkResourcePool;
         };
         ArrayOfDVSVmVnicNetworkResourcePool: {
            (options?: vimService.vim.ArrayOfDVSVmVnicNetworkResourcePool): vimService.vim.ArrayOfDVSVmVnicNetworkResourcePool;
         };
         VMwareDVSFeatureCapability: {
            (options?: vimService.vim.VMwareDVSFeatureCapability): vimService.vim.VMwareDVSFeatureCapability;
         };
         VMwareDvsIpfixCapability: {
            (options?: vimService.vim.VMwareDvsIpfixCapability): vimService.vim.VMwareDvsIpfixCapability;
         };
         VMwareDvsLacpCapability: {
            (options?: vimService.vim.VMwareDvsLacpCapability): vimService.vim.VMwareDvsLacpCapability;
         };
         VMwareDVSHealthCheckCapability: {
            (options?: vimService.vim.VMwareDVSHealthCheckCapability): vimService.vim.VMwareDVSHealthCheckCapability;
         };
         VMwareDVSVspanCapability: {
            (options?: vimService.vim.VMwareDVSVspanCapability): vimService.vim.VMwareDVSVspanCapability;
         };
         VMwareVspanPort: {
            (options?: vimService.vim.VMwareVspanPort): vimService.vim.VMwareVspanPort;
         };
         VMwareVspanSession: {
            (options?: vimService.vim.VMwareVspanSession): vimService.vim.VMwareVspanSession;
         };
         ArrayOfVMwareVspanSession: {
            (options?: vimService.vim.ArrayOfVMwareVspanSession): vimService.vim.ArrayOfVMwareVspanSession;
         };
         VMwareIpfixConfig: {
            (options?: vimService.vim.VMwareIpfixConfig): vimService.vim.VMwareIpfixConfig;
         };
         VMwareDVSConfigInfo: {
            (options?: vimService.vim.VMwareDVSConfigInfo): vimService.vim.VMwareDVSConfigInfo;
         };
         VMwareDVSConfigSpec: {
            (options?: vimService.vim.VMwareDVSConfigSpec): vimService.vim.VMwareDVSConfigSpec;
         };
         VMwareUplinkPortOrderPolicy: {
            (options?: vimService.vim.VMwareUplinkPortOrderPolicy): vimService.vim.VMwareUplinkPortOrderPolicy;
         };
         DVSFailureCriteria: {
            (options?: vimService.vim.DVSFailureCriteria): vimService.vim.DVSFailureCriteria;
         };
         VmwareUplinkPortTeamingPolicy: {
            (options?: vimService.vim.VmwareUplinkPortTeamingPolicy): vimService.vim.VmwareUplinkPortTeamingPolicy;
         };
         VmwareDistributedVirtualSwitchVlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchVlanSpec): vimService.vim.VmwareDistributedVirtualSwitchVlanSpec;
         };
         VmwareDistributedVirtualSwitchPvlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchPvlanSpec): vimService.vim.VmwareDistributedVirtualSwitchPvlanSpec;
         };
         VmwareDistributedVirtualSwitchVlanIdSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchVlanIdSpec): vimService.vim.VmwareDistributedVirtualSwitchVlanIdSpec;
         };
         VmwareDistributedVirtualSwitchTrunkVlanSpec: {
            (options?: vimService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec): vimService.vim.VmwareDistributedVirtualSwitchTrunkVlanSpec;
         };
         DVSSecurityPolicy: {
            (options?: vimService.vim.DVSSecurityPolicy): vimService.vim.DVSSecurityPolicy;
         };
         VMwareDVSPortSetting: {
            (options?: vimService.vim.VMwareDVSPortSetting): vimService.vim.VMwareDVSPortSetting;
         };
         VMwareDVSPortgroupPolicy: {
            (options?: vimService.vim.VMwareDVSPortgroupPolicy): vimService.vim.VMwareDVSPortgroupPolicy;
         };
         VmwareDistributedVirtualSwitchPvlanPortType: {
            "promiscuous": string;
            "isolated": string;
            "community": string;
         };
         VMwareDVSPvlanConfigSpec: {
            (options?: vimService.vim.VMwareDVSPvlanConfigSpec): vimService.vim.VMwareDVSPvlanConfigSpec;
         };
         ArrayOfVMwareDVSPvlanConfigSpec: {
            (options?: vimService.vim.ArrayOfVMwareDVSPvlanConfigSpec): vimService.vim.ArrayOfVMwareDVSPvlanConfigSpec;
         };
         VMwareDVSPvlanMapEntry: {
            (options?: vimService.vim.VMwareDVSPvlanMapEntry): vimService.vim.VMwareDVSPvlanMapEntry;
         };
         ArrayOfVMwareDVSPvlanMapEntry: {
            (options?: vimService.vim.ArrayOfVMwareDVSPvlanMapEntry): vimService.vim.ArrayOfVMwareDVSPvlanMapEntry;
         };
         VMwareDVSVspanConfigSpec: {
            (options?: vimService.vim.VMwareDVSVspanConfigSpec): vimService.vim.VMwareDVSVspanConfigSpec;
         };
         ArrayOfVMwareDVSVspanConfigSpec: {
            (options?: vimService.vim.ArrayOfVMwareDVSVspanConfigSpec): vimService.vim.ArrayOfVMwareDVSVspanConfigSpec;
         };
         VMwareDVSVspanSessionType: {
            "mixedDestMirror": string;
            "dvPortMirror": string;
            "remoteMirrorSource": string;
            "remoteMirrorDest": string;
            "encapsulatedRemoteMirrorSource": string;
         };
         VMwareDVSHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSHealthCheckConfig): vimService.vim.VMwareDVSHealthCheckConfig;
         };
         VMwareDVSVlanMtuHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSVlanMtuHealthCheckConfig): vimService.vim.VMwareDVSVlanMtuHealthCheckConfig;
         };
         VMwareDVSTeamingHealthCheckConfig: {
            (options?: vimService.vim.VMwareDVSTeamingHealthCheckConfig): vimService.vim.VMwareDVSTeamingHealthCheckConfig;
         };
         VMwareDVSVlanHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSVlanHealthCheckResult): vimService.vim.VMwareDVSVlanHealthCheckResult;
         };
         VMwareDVSMtuHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSMtuHealthCheckResult): vimService.vim.VMwareDVSMtuHealthCheckResult;
         };
         VMwareDVSTeamingMatchStatus: {
            "iphashMatch": string;
            "nonIphashMatch": string;
            "iphashMismatch": string;
            "nonIphashMismatch": string;
         };
         VMwareDVSTeamingHealthCheckResult: {
            (options?: vimService.vim.VMwareDVSTeamingHealthCheckResult): vimService.vim.VMwareDVSTeamingHealthCheckResult;
         };
         VMwareUplinkLacpPolicy: {
            (options?: vimService.vim.VMwareUplinkLacpPolicy): vimService.vim.VMwareUplinkLacpPolicy;
         };
         VMwareDvsLacpGroupConfig: {
            (options?: vimService.vim.VMwareDvsLacpGroupConfig): vimService.vim.VMwareDvsLacpGroupConfig;
         };
         ArrayOfVMwareDvsLacpGroupConfig: {
            (options?: vimService.vim.ArrayOfVMwareDvsLacpGroupConfig): vimService.vim.ArrayOfVMwareDvsLacpGroupConfig;
         };
         VMwareDvsLagVlanConfig: {
            (options?: vimService.vim.VMwareDvsLagVlanConfig): vimService.vim.VMwareDvsLagVlanConfig;
         };
         VMwareDvsLagIpfixConfig: {
            (options?: vimService.vim.VMwareDvsLagIpfixConfig): vimService.vim.VMwareDvsLagIpfixConfig;
         };
         VMwareUplinkLacpMode: {
            "active": string;
            "passive": string;
         };
         VMwareDvsLacpGroupSpec: {
            (options?: vimService.vim.VMwareDvsLacpGroupSpec): vimService.vim.VMwareDvsLacpGroupSpec;
         };
         ArrayOfVMwareDvsLacpGroupSpec: {
            (options?: vimService.vim.ArrayOfVMwareDvsLacpGroupSpec): vimService.vim.ArrayOfVMwareDvsLacpGroupSpec;
         };
         VMwareDvsLacpLoadBalanceAlgorithm: {
            "srcMac": string;
            "destMac": string;
            "srcDestMac": string;
            "destIpVlan": string;
            "srcIpVlan": string;
            "srcDestIpVlan": string;
            "destTcpUdpPort": string;
            "srcTcpUdpPort": string;
            "srcDestTcpUdpPort": string;
            "destIpTcpUdpPort": string;
            "srcIpTcpUdpPort": string;
            "srcDestIpTcpUdpPort": string;
            "destIpTcpUdpPortVlan": string;
            "srcIpTcpUdpPortVlan": string;
            "srcDestIpTcpUdpPortVlan": string;
            "destIp": string;
            "srcIp": string;
            "srcDestIp": string;
            "vlan": string;
            "srcPortId": string;
         };
         VMwareDvsLacpApiVersion: {
            "singleLag": string;
            "multipleLag": string;
         };
         VMwareDvsMulticastFilteringMode: {
            "legacyFiltering": string;
            "snooping": string;
         };
         EventEventSeverity: {
            "error": string;
            "warning": string;
            "info": string;
            "user": string;
         };
         Event: {
            (options?: vimService.vim.Event): vimService.vim.Event;
         };
         ArrayOfEvent: {
            (options?: vimService.vim.ArrayOfEvent): vimService.vim.ArrayOfEvent;
         };
         GeneralEvent: {
            (options?: vimService.vim.GeneralEvent): vimService.vim.GeneralEvent;
         };
         GeneralHostInfoEvent: {
            (options?: vimService.vim.GeneralHostInfoEvent): vimService.vim.GeneralHostInfoEvent;
         };
         GeneralHostWarningEvent: {
            (options?: vimService.vim.GeneralHostWarningEvent): vimService.vim.GeneralHostWarningEvent;
         };
         GeneralHostErrorEvent: {
            (options?: vimService.vim.GeneralHostErrorEvent): vimService.vim.GeneralHostErrorEvent;
         };
         GeneralVmInfoEvent: {
            (options?: vimService.vim.GeneralVmInfoEvent): vimService.vim.GeneralVmInfoEvent;
         };
         GeneralVmWarningEvent: {
            (options?: vimService.vim.GeneralVmWarningEvent): vimService.vim.GeneralVmWarningEvent;
         };
         GeneralVmErrorEvent: {
            (options?: vimService.vim.GeneralVmErrorEvent): vimService.vim.GeneralVmErrorEvent;
         };
         GeneralUserEvent: {
            (options?: vimService.vim.GeneralUserEvent): vimService.vim.GeneralUserEvent;
         };
         ExtendedEventPair: {
            (options?: vimService.vim.ExtendedEventPair): vimService.vim.ExtendedEventPair;
         };
         ArrayOfExtendedEventPair: {
            (options?: vimService.vim.ArrayOfExtendedEventPair): vimService.vim.ArrayOfExtendedEventPair;
         };
         ExtendedEvent: {
            (options?: vimService.vim.ExtendedEvent): vimService.vim.ExtendedEvent;
         };
         HealthStatusChangedEvent: {
            (options?: vimService.vim.HealthStatusChangedEvent): vimService.vim.HealthStatusChangedEvent;
         };
         HostInventoryUnreadableEvent: {
            (options?: vimService.vim.HostInventoryUnreadableEvent): vimService.vim.HostInventoryUnreadableEvent;
         };
         DatacenterEvent: {
            (options?: vimService.vim.DatacenterEvent): vimService.vim.DatacenterEvent;
         };
         DatacenterCreatedEvent: {
            (options?: vimService.vim.DatacenterCreatedEvent): vimService.vim.DatacenterCreatedEvent;
         };
         DatacenterRenamedEvent: {
            (options?: vimService.vim.DatacenterRenamedEvent): vimService.vim.DatacenterRenamedEvent;
         };
         SessionEvent: {
            (options?: vimService.vim.SessionEvent): vimService.vim.SessionEvent;
         };
         ServerStartedSessionEvent: {
            (options?: vimService.vim.ServerStartedSessionEvent): vimService.vim.ServerStartedSessionEvent;
         };
         UserLoginSessionEvent: {
            (options?: vimService.vim.UserLoginSessionEvent): vimService.vim.UserLoginSessionEvent;
         };
         UserLogoutSessionEvent: {
            (options?: vimService.vim.UserLogoutSessionEvent): vimService.vim.UserLogoutSessionEvent;
         };
         BadUsernameSessionEvent: {
            (options?: vimService.vim.BadUsernameSessionEvent): vimService.vim.BadUsernameSessionEvent;
         };
         AlreadyAuthenticatedSessionEvent: {
            (options?: vimService.vim.AlreadyAuthenticatedSessionEvent): vimService.vim.AlreadyAuthenticatedSessionEvent;
         };
         NoAccessUserEvent: {
            (options?: vimService.vim.NoAccessUserEvent): vimService.vim.NoAccessUserEvent;
         };
         SessionTerminatedEvent: {
            (options?: vimService.vim.SessionTerminatedEvent): vimService.vim.SessionTerminatedEvent;
         };
         GlobalMessageChangedEvent: {
            (options?: vimService.vim.GlobalMessageChangedEvent): vimService.vim.GlobalMessageChangedEvent;
         };
         UpgradeEvent: {
            (options?: vimService.vim.UpgradeEvent): vimService.vim.UpgradeEvent;
         };
         InfoUpgradeEvent: {
            (options?: vimService.vim.InfoUpgradeEvent): vimService.vim.InfoUpgradeEvent;
         };
         WarningUpgradeEvent: {
            (options?: vimService.vim.WarningUpgradeEvent): vimService.vim.WarningUpgradeEvent;
         };
         ErrorUpgradeEvent: {
            (options?: vimService.vim.ErrorUpgradeEvent): vimService.vim.ErrorUpgradeEvent;
         };
         UserUpgradeEvent: {
            (options?: vimService.vim.UserUpgradeEvent): vimService.vim.UserUpgradeEvent;
         };
         HostEvent: {
            (options?: vimService.vim.HostEvent): vimService.vim.HostEvent;
         };
         HostDasEvent: {
            (options?: vimService.vim.HostDasEvent): vimService.vim.HostDasEvent;
         };
         HostConnectedEvent: {
            (options?: vimService.vim.HostConnectedEvent): vimService.vim.HostConnectedEvent;
         };
         HostDisconnectedEventReasonCode: {
            "sslThumbprintVerifyFailed": string;
            "licenseExpired": string;
            "agentUpgrade": string;
            "userRequest": string;
            "insufficientLicenses": string;
            "agentOutOfDate": string;
            "passwordDecryptFailure": string;
            "unknown": string;
            "vcVRAMCapacityExceeded": string;
         };
         HostDisconnectedEvent: {
            (options?: vimService.vim.HostDisconnectedEvent): vimService.vim.HostDisconnectedEvent;
         };
         HostSyncFailedEvent: {
            (options?: vimService.vim.HostSyncFailedEvent): vimService.vim.HostSyncFailedEvent;
         };
         HostConnectionLostEvent: {
            (options?: vimService.vim.HostConnectionLostEvent): vimService.vim.HostConnectionLostEvent;
         };
         HostReconnectionFailedEvent: {
            (options?: vimService.vim.HostReconnectionFailedEvent): vimService.vim.HostReconnectionFailedEvent;
         };
         HostCnxFailedNoConnectionEvent: {
            (options?: vimService.vim.HostCnxFailedNoConnectionEvent): vimService.vim.HostCnxFailedNoConnectionEvent;
         };
         HostCnxFailedBadUsernameEvent: {
            (options?: vimService.vim.HostCnxFailedBadUsernameEvent): vimService.vim.HostCnxFailedBadUsernameEvent;
         };
         HostCnxFailedBadVersionEvent: {
            (options?: vimService.vim.HostCnxFailedBadVersionEvent): vimService.vim.HostCnxFailedBadVersionEvent;
         };
         HostCnxFailedAlreadyManagedEvent: {
            (options?: vimService.vim.HostCnxFailedAlreadyManagedEvent): vimService.vim.HostCnxFailedAlreadyManagedEvent;
         };
         HostCnxFailedNoLicenseEvent: {
            (options?: vimService.vim.HostCnxFailedNoLicenseEvent): vimService.vim.HostCnxFailedNoLicenseEvent;
         };
         HostCnxFailedNetworkErrorEvent: {
            (options?: vimService.vim.HostCnxFailedNetworkErrorEvent): vimService.vim.HostCnxFailedNetworkErrorEvent;
         };
         HostRemovedEvent: {
            (options?: vimService.vim.HostRemovedEvent): vimService.vim.HostRemovedEvent;
         };
         HostCnxFailedCcagentUpgradeEvent: {
            (options?: vimService.vim.HostCnxFailedCcagentUpgradeEvent): vimService.vim.HostCnxFailedCcagentUpgradeEvent;
         };
         HostCnxFailedBadCcagentEvent: {
            (options?: vimService.vim.HostCnxFailedBadCcagentEvent): vimService.vim.HostCnxFailedBadCcagentEvent;
         };
         HostCnxFailedEvent: {
            (options?: vimService.vim.HostCnxFailedEvent): vimService.vim.HostCnxFailedEvent;
         };
         HostCnxFailedAccountFailedEvent: {
            (options?: vimService.vim.HostCnxFailedAccountFailedEvent): vimService.vim.HostCnxFailedAccountFailedEvent;
         };
         HostCnxFailedNoAccessEvent: {
            (options?: vimService.vim.HostCnxFailedNoAccessEvent): vimService.vim.HostCnxFailedNoAccessEvent;
         };
         HostShutdownEvent: {
            (options?: vimService.vim.HostShutdownEvent): vimService.vim.HostShutdownEvent;
         };
         HostCnxFailedNotFoundEvent: {
            (options?: vimService.vim.HostCnxFailedNotFoundEvent): vimService.vim.HostCnxFailedNotFoundEvent;
         };
         HostCnxFailedTimeoutEvent: {
            (options?: vimService.vim.HostCnxFailedTimeoutEvent): vimService.vim.HostCnxFailedTimeoutEvent;
         };
         HostUpgradeFailedEvent: {
            (options?: vimService.vim.HostUpgradeFailedEvent): vimService.vim.HostUpgradeFailedEvent;
         };
         EnteringMaintenanceModeEvent: {
            (options?: vimService.vim.EnteringMaintenanceModeEvent): vimService.vim.EnteringMaintenanceModeEvent;
         };
         EnteredMaintenanceModeEvent: {
            (options?: vimService.vim.EnteredMaintenanceModeEvent): vimService.vim.EnteredMaintenanceModeEvent;
         };
         ExitMaintenanceModeEvent: {
            (options?: vimService.vim.ExitMaintenanceModeEvent): vimService.vim.ExitMaintenanceModeEvent;
         };
         CanceledHostOperationEvent: {
            (options?: vimService.vim.CanceledHostOperationEvent): vimService.vim.CanceledHostOperationEvent;
         };
         TimedOutHostOperationEvent: {
            (options?: vimService.vim.TimedOutHostOperationEvent): vimService.vim.TimedOutHostOperationEvent;
         };
         HostDasEnabledEvent: {
            (options?: vimService.vim.HostDasEnabledEvent): vimService.vim.HostDasEnabledEvent;
         };
         HostDasDisabledEvent: {
            (options?: vimService.vim.HostDasDisabledEvent): vimService.vim.HostDasDisabledEvent;
         };
         HostDasEnablingEvent: {
            (options?: vimService.vim.HostDasEnablingEvent): vimService.vim.HostDasEnablingEvent;
         };
         HostDasDisablingEvent: {
            (options?: vimService.vim.HostDasDisablingEvent): vimService.vim.HostDasDisablingEvent;
         };
         HostDasErrorEventHostDasErrorReason: {
            "configFailed": string;
            "timeout": string;
            "communicationInitFailed": string;
            "healthCheckScriptFailed": string;
            "agentFailed": string;
            "agentShutdown": string;
            "isolationAddressUnpingable": string;
            "other": string;
         };
         HostDasErrorEvent: {
            (options?: vimService.vim.HostDasErrorEvent): vimService.vim.HostDasErrorEvent;
         };
         HostDasOkEvent: {
            (options?: vimService.vim.HostDasOkEvent): vimService.vim.HostDasOkEvent;
         };
         VcAgentUpgradedEvent: {
            (options?: vimService.vim.VcAgentUpgradedEvent): vimService.vim.VcAgentUpgradedEvent;
         };
         VcAgentUninstalledEvent: {
            (options?: vimService.vim.VcAgentUninstalledEvent): vimService.vim.VcAgentUninstalledEvent;
         };
         VcAgentUpgradeFailedEvent: {
            (options?: vimService.vim.VcAgentUpgradeFailedEvent): vimService.vim.VcAgentUpgradeFailedEvent;
         };
         VcAgentUninstallFailedEvent: {
            (options?: vimService.vim.VcAgentUninstallFailedEvent): vimService.vim.VcAgentUninstallFailedEvent;
         };
         HostAddedEvent: {
            (options?: vimService.vim.HostAddedEvent): vimService.vim.HostAddedEvent;
         };
         HostAddFailedEvent: {
            (options?: vimService.vim.HostAddFailedEvent): vimService.vim.HostAddFailedEvent;
         };
         HostIpChangedEvent: {
            (options?: vimService.vim.HostIpChangedEvent): vimService.vim.HostIpChangedEvent;
         };
         EnteringStandbyModeEvent: {
            (options?: vimService.vim.EnteringStandbyModeEvent): vimService.vim.EnteringStandbyModeEvent;
         };
         DrsEnteringStandbyModeEvent: {
            (options?: vimService.vim.DrsEnteringStandbyModeEvent): vimService.vim.DrsEnteringStandbyModeEvent;
         };
         EnteredStandbyModeEvent: {
            (options?: vimService.vim.EnteredStandbyModeEvent): vimService.vim.EnteredStandbyModeEvent;
         };
         DrsEnteredStandbyModeEvent: {
            (options?: vimService.vim.DrsEnteredStandbyModeEvent): vimService.vim.DrsEnteredStandbyModeEvent;
         };
         ExitingStandbyModeEvent: {
            (options?: vimService.vim.ExitingStandbyModeEvent): vimService.vim.ExitingStandbyModeEvent;
         };
         DrsExitingStandbyModeEvent: {
            (options?: vimService.vim.DrsExitingStandbyModeEvent): vimService.vim.DrsExitingStandbyModeEvent;
         };
         ExitedStandbyModeEvent: {
            (options?: vimService.vim.ExitedStandbyModeEvent): vimService.vim.ExitedStandbyModeEvent;
         };
         DrsExitedStandbyModeEvent: {
            (options?: vimService.vim.DrsExitedStandbyModeEvent): vimService.vim.DrsExitedStandbyModeEvent;
         };
         ExitStandbyModeFailedEvent: {
            (options?: vimService.vim.ExitStandbyModeFailedEvent): vimService.vim.ExitStandbyModeFailedEvent;
         };
         DrsExitStandbyModeFailedEvent: {
            (options?: vimService.vim.DrsExitStandbyModeFailedEvent): vimService.vim.DrsExitStandbyModeFailedEvent;
         };
         UpdatedAgentBeingRestartedEvent: {
            (options?: vimService.vim.UpdatedAgentBeingRestartedEvent): vimService.vim.UpdatedAgentBeingRestartedEvent;
         };
         AccountCreatedEvent: {
            (options?: vimService.vim.AccountCreatedEvent): vimService.vim.AccountCreatedEvent;
         };
         AccountRemovedEvent: {
            (options?: vimService.vim.AccountRemovedEvent): vimService.vim.AccountRemovedEvent;
         };
         UserPasswordChanged: {
            (options?: vimService.vim.UserPasswordChanged): vimService.vim.UserPasswordChanged;
         };
         AccountUpdatedEvent: {
            (options?: vimService.vim.AccountUpdatedEvent): vimService.vim.AccountUpdatedEvent;
         };
         UserAssignedToGroup: {
            (options?: vimService.vim.UserAssignedToGroup): vimService.vim.UserAssignedToGroup;
         };
         UserUnassignedFromGroup: {
            (options?: vimService.vim.UserUnassignedFromGroup): vimService.vim.UserUnassignedFromGroup;
         };
         DatastorePrincipalConfigured: {
            (options?: vimService.vim.DatastorePrincipalConfigured): vimService.vim.DatastorePrincipalConfigured;
         };
         VMFSDatastoreCreatedEvent: {
            (options?: vimService.vim.VMFSDatastoreCreatedEvent): vimService.vim.VMFSDatastoreCreatedEvent;
         };
         NASDatastoreCreatedEvent: {
            (options?: vimService.vim.NASDatastoreCreatedEvent): vimService.vim.NASDatastoreCreatedEvent;
         };
         LocalDatastoreCreatedEvent: {
            (options?: vimService.vim.LocalDatastoreCreatedEvent): vimService.vim.LocalDatastoreCreatedEvent;
         };
         VMFSDatastoreExtendedEvent: {
            (options?: vimService.vim.VMFSDatastoreExtendedEvent): vimService.vim.VMFSDatastoreExtendedEvent;
         };
         VMFSDatastoreExpandedEvent: {
            (options?: vimService.vim.VMFSDatastoreExpandedEvent): vimService.vim.VMFSDatastoreExpandedEvent;
         };
         DatastoreRemovedOnHostEvent: {
            (options?: vimService.vim.DatastoreRemovedOnHostEvent): vimService.vim.DatastoreRemovedOnHostEvent;
         };
         DatastoreRenamedOnHostEvent: {
            (options?: vimService.vim.DatastoreRenamedOnHostEvent): vimService.vim.DatastoreRenamedOnHostEvent;
         };
         DuplicateIpDetectedEvent: {
            (options?: vimService.vim.DuplicateIpDetectedEvent): vimService.vim.DuplicateIpDetectedEvent;
         };
         DatastoreDiscoveredEvent: {
            (options?: vimService.vim.DatastoreDiscoveredEvent): vimService.vim.DatastoreDiscoveredEvent;
         };
         DrsResourceConfigureFailedEvent: {
            (options?: vimService.vim.DrsResourceConfigureFailedEvent): vimService.vim.DrsResourceConfigureFailedEvent;
         };
         DrsResourceConfigureSyncedEvent: {
            (options?: vimService.vim.DrsResourceConfigureSyncedEvent): vimService.vim.DrsResourceConfigureSyncedEvent;
         };
         HostGetShortNameFailedEvent: {
            (options?: vimService.vim.HostGetShortNameFailedEvent): vimService.vim.HostGetShortNameFailedEvent;
         };
         HostShortNameToIpFailedEvent: {
            (options?: vimService.vim.HostShortNameToIpFailedEvent): vimService.vim.HostShortNameToIpFailedEvent;
         };
         HostIpToShortNameFailedEvent: {
            (options?: vimService.vim.HostIpToShortNameFailedEvent): vimService.vim.HostIpToShortNameFailedEvent;
         };
         HostPrimaryAgentNotShortNameEvent: {
            (options?: vimService.vim.HostPrimaryAgentNotShortNameEvent): vimService.vim.HostPrimaryAgentNotShortNameEvent;
         };
         HostNotInClusterEvent: {
            (options?: vimService.vim.HostNotInClusterEvent): vimService.vim.HostNotInClusterEvent;
         };
         HostIsolationIpPingFailedEvent: {
            (options?: vimService.vim.HostIsolationIpPingFailedEvent): vimService.vim.HostIsolationIpPingFailedEvent;
         };
         HostIpInconsistentEvent: {
            (options?: vimService.vim.HostIpInconsistentEvent): vimService.vim.HostIpInconsistentEvent;
         };
         HostUserWorldSwapNotEnabledEvent: {
            (options?: vimService.vim.HostUserWorldSwapNotEnabledEvent): vimService.vim.HostUserWorldSwapNotEnabledEvent;
         };
         HostNonCompliantEvent: {
            (options?: vimService.vim.HostNonCompliantEvent): vimService.vim.HostNonCompliantEvent;
         };
         HostCompliantEvent: {
            (options?: vimService.vim.HostCompliantEvent): vimService.vim.HostCompliantEvent;
         };
         HostComplianceCheckedEvent: {
            (options?: vimService.vim.HostComplianceCheckedEvent): vimService.vim.HostComplianceCheckedEvent;
         };
         ClusterComplianceCheckedEvent: {
            (options?: vimService.vim.ClusterComplianceCheckedEvent): vimService.vim.ClusterComplianceCheckedEvent;
         };
         ProfileEvent: {
            (options?: vimService.vim.ProfileEvent): vimService.vim.ProfileEvent;
         };
         ProfileCreatedEvent: {
            (options?: vimService.vim.ProfileCreatedEvent): vimService.vim.ProfileCreatedEvent;
         };
         ProfileRemovedEvent: {
            (options?: vimService.vim.ProfileRemovedEvent): vimService.vim.ProfileRemovedEvent;
         };
         ProfileAssociatedEvent: {
            (options?: vimService.vim.ProfileAssociatedEvent): vimService.vim.ProfileAssociatedEvent;
         };
         ProfileDissociatedEvent: {
            (options?: vimService.vim.ProfileDissociatedEvent): vimService.vim.ProfileDissociatedEvent;
         };
         HostConfigAppliedEvent: {
            (options?: vimService.vim.HostConfigAppliedEvent): vimService.vim.HostConfigAppliedEvent;
         };
         ProfileReferenceHostChangedEvent: {
            (options?: vimService.vim.ProfileReferenceHostChangedEvent): vimService.vim.ProfileReferenceHostChangedEvent;
         };
         ProfileChangedEvent: {
            (options?: vimService.vim.ProfileChangedEvent): vimService.vim.ProfileChangedEvent;
         };
         HostProfileAppliedEvent: {
            (options?: vimService.vim.HostProfileAppliedEvent): vimService.vim.HostProfileAppliedEvent;
         };
         HostShortNameInconsistentEvent: {
            (options?: vimService.vim.HostShortNameInconsistentEvent): vimService.vim.HostShortNameInconsistentEvent;
         };
         HostNoRedundantManagementNetworkEvent: {
            (options?: vimService.vim.HostNoRedundantManagementNetworkEvent): vimService.vim.HostNoRedundantManagementNetworkEvent;
         };
         HostNoAvailableNetworksEvent: {
            (options?: vimService.vim.HostNoAvailableNetworksEvent): vimService.vim.HostNoAvailableNetworksEvent;
         };
         HostExtraNetworksEvent: {
            (options?: vimService.vim.HostExtraNetworksEvent): vimService.vim.HostExtraNetworksEvent;
         };
         HostNoHAEnabledPortGroupsEvent: {
            (options?: vimService.vim.HostNoHAEnabledPortGroupsEvent): vimService.vim.HostNoHAEnabledPortGroupsEvent;
         };
         HostMissingNetworksEvent: {
            (options?: vimService.vim.HostMissingNetworksEvent): vimService.vim.HostMissingNetworksEvent;
         };
         VnicPortArgument: {
            (options?: vimService.vim.VnicPortArgument): vimService.vim.VnicPortArgument;
         };
         ArrayOfVnicPortArgument: {
            (options?: vimService.vim.ArrayOfVnicPortArgument): vimService.vim.ArrayOfVnicPortArgument;
         };
         HostVnicConnectedToCustomizedDVPortEvent: {
            (options?: vimService.vim.HostVnicConnectedToCustomizedDVPortEvent): vimService.vim.HostVnicConnectedToCustomizedDVPortEvent;
         };
         GhostDvsProxySwitchDetectedEvent: {
            (options?: vimService.vim.GhostDvsProxySwitchDetectedEvent): vimService.vim.GhostDvsProxySwitchDetectedEvent;
         };
         GhostDvsProxySwitchRemovedEvent: {
            (options?: vimService.vim.GhostDvsProxySwitchRemovedEvent): vimService.vim.GhostDvsProxySwitchRemovedEvent;
         };
         VmEvent: {
            (options?: vimService.vim.VmEvent): vimService.vim.VmEvent;
         };
         VmPoweredOffEvent: {
            (options?: vimService.vim.VmPoweredOffEvent): vimService.vim.VmPoweredOffEvent;
         };
         VmPoweredOnEvent: {
            (options?: vimService.vim.VmPoweredOnEvent): vimService.vim.VmPoweredOnEvent;
         };
         VmSuspendedEvent: {
            (options?: vimService.vim.VmSuspendedEvent): vimService.vim.VmSuspendedEvent;
         };
         VmStartingEvent: {
            (options?: vimService.vim.VmStartingEvent): vimService.vim.VmStartingEvent;
         };
         VmStoppingEvent: {
            (options?: vimService.vim.VmStoppingEvent): vimService.vim.VmStoppingEvent;
         };
         VmSuspendingEvent: {
            (options?: vimService.vim.VmSuspendingEvent): vimService.vim.VmSuspendingEvent;
         };
         VmResumingEvent: {
            (options?: vimService.vim.VmResumingEvent): vimService.vim.VmResumingEvent;
         };
         VmDisconnectedEvent: {
            (options?: vimService.vim.VmDisconnectedEvent): vimService.vim.VmDisconnectedEvent;
         };
         VmRemoteConsoleConnectedEvent: {
            (options?: vimService.vim.VmRemoteConsoleConnectedEvent): vimService.vim.VmRemoteConsoleConnectedEvent;
         };
         VmRemoteConsoleDisconnectedEvent: {
            (options?: vimService.vim.VmRemoteConsoleDisconnectedEvent): vimService.vim.VmRemoteConsoleDisconnectedEvent;
         };
         VmDiscoveredEvent: {
            (options?: vimService.vim.VmDiscoveredEvent): vimService.vim.VmDiscoveredEvent;
         };
         VmOrphanedEvent: {
            (options?: vimService.vim.VmOrphanedEvent): vimService.vim.VmOrphanedEvent;
         };
         VmBeingCreatedEvent: {
            (options?: vimService.vim.VmBeingCreatedEvent): vimService.vim.VmBeingCreatedEvent;
         };
         VmCreatedEvent: {
            (options?: vimService.vim.VmCreatedEvent): vimService.vim.VmCreatedEvent;
         };
         VmStartRecordingEvent: {
            (options?: vimService.vim.VmStartRecordingEvent): vimService.vim.VmStartRecordingEvent;
         };
         VmEndRecordingEvent: {
            (options?: vimService.vim.VmEndRecordingEvent): vimService.vim.VmEndRecordingEvent;
         };
         VmStartReplayingEvent: {
            (options?: vimService.vim.VmStartReplayingEvent): vimService.vim.VmStartReplayingEvent;
         };
         VmEndReplayingEvent: {
            (options?: vimService.vim.VmEndReplayingEvent): vimService.vim.VmEndReplayingEvent;
         };
         VmRegisteredEvent: {
            (options?: vimService.vim.VmRegisteredEvent): vimService.vim.VmRegisteredEvent;
         };
         VmAutoRenameEvent: {
            (options?: vimService.vim.VmAutoRenameEvent): vimService.vim.VmAutoRenameEvent;
         };
         VmBeingHotMigratedEvent: {
            (options?: vimService.vim.VmBeingHotMigratedEvent): vimService.vim.VmBeingHotMigratedEvent;
         };
         VmResettingEvent: {
            (options?: vimService.vim.VmResettingEvent): vimService.vim.VmResettingEvent;
         };
         VmStaticMacConflictEvent: {
            (options?: vimService.vim.VmStaticMacConflictEvent): vimService.vim.VmStaticMacConflictEvent;
         };
         VmMacConflictEvent: {
            (options?: vimService.vim.VmMacConflictEvent): vimService.vim.VmMacConflictEvent;
         };
         VmBeingDeployedEvent: {
            (options?: vimService.vim.VmBeingDeployedEvent): vimService.vim.VmBeingDeployedEvent;
         };
         VmDeployFailedEvent: {
            (options?: vimService.vim.VmDeployFailedEvent): vimService.vim.VmDeployFailedEvent;
         };
         VmDeployedEvent: {
            (options?: vimService.vim.VmDeployedEvent): vimService.vim.VmDeployedEvent;
         };
         VmMacChangedEvent: {
            (options?: vimService.vim.VmMacChangedEvent): vimService.vim.VmMacChangedEvent;
         };
         VmMacAssignedEvent: {
            (options?: vimService.vim.VmMacAssignedEvent): vimService.vim.VmMacAssignedEvent;
         };
         VmUuidConflictEvent: {
            (options?: vimService.vim.VmUuidConflictEvent): vimService.vim.VmUuidConflictEvent;
         };
         VmInstanceUuidConflictEvent: {
            (options?: vimService.vim.VmInstanceUuidConflictEvent): vimService.vim.VmInstanceUuidConflictEvent;
         };
         VmBeingMigratedEvent: {
            (options?: vimService.vim.VmBeingMigratedEvent): vimService.vim.VmBeingMigratedEvent;
         };
         VmFailedMigrateEvent: {
            (options?: vimService.vim.VmFailedMigrateEvent): vimService.vim.VmFailedMigrateEvent;
         };
         VmMigratedEvent: {
            (options?: vimService.vim.VmMigratedEvent): vimService.vim.VmMigratedEvent;
         };
         VmUnsupportedStartingEvent: {
            (options?: vimService.vim.VmUnsupportedStartingEvent): vimService.vim.VmUnsupportedStartingEvent;
         };
         DrsVmMigratedEvent: {
            (options?: vimService.vim.DrsVmMigratedEvent): vimService.vim.DrsVmMigratedEvent;
         };
         DrsVmPoweredOnEvent: {
            (options?: vimService.vim.DrsVmPoweredOnEvent): vimService.vim.DrsVmPoweredOnEvent;
         };
         DrsRuleViolationEvent: {
            (options?: vimService.vim.DrsRuleViolationEvent): vimService.vim.DrsRuleViolationEvent;
         };
         DrsSoftRuleViolationEvent: {
            (options?: vimService.vim.DrsSoftRuleViolationEvent): vimService.vim.DrsSoftRuleViolationEvent;
         };
         DrsRuleComplianceEvent: {
            (options?: vimService.vim.DrsRuleComplianceEvent): vimService.vim.DrsRuleComplianceEvent;
         };
         VmRelocateSpecEvent: {
            (options?: vimService.vim.VmRelocateSpecEvent): vimService.vim.VmRelocateSpecEvent;
         };
         VmBeingRelocatedEvent: {
            (options?: vimService.vim.VmBeingRelocatedEvent): vimService.vim.VmBeingRelocatedEvent;
         };
         VmRelocatedEvent: {
            (options?: vimService.vim.VmRelocatedEvent): vimService.vim.VmRelocatedEvent;
         };
         VmRelocateFailedEvent: {
            (options?: vimService.vim.VmRelocateFailedEvent): vimService.vim.VmRelocateFailedEvent;
         };
         VmEmigratingEvent: {
            (options?: vimService.vim.VmEmigratingEvent): vimService.vim.VmEmigratingEvent;
         };
         VmCloneEvent: {
            (options?: vimService.vim.VmCloneEvent): vimService.vim.VmCloneEvent;
         };
         VmBeingClonedEvent: {
            (options?: vimService.vim.VmBeingClonedEvent): vimService.vim.VmBeingClonedEvent;
         };
         VmBeingClonedNoFolderEvent: {
            (options?: vimService.vim.VmBeingClonedNoFolderEvent): vimService.vim.VmBeingClonedNoFolderEvent;
         };
         VmCloneFailedEvent: {
            (options?: vimService.vim.VmCloneFailedEvent): vimService.vim.VmCloneFailedEvent;
         };
         VmClonedEvent: {
            (options?: vimService.vim.VmClonedEvent): vimService.vim.VmClonedEvent;
         };
         VmResourceReallocatedEvent: {
            (options?: vimService.vim.VmResourceReallocatedEvent): vimService.vim.VmResourceReallocatedEvent;
         };
         VmRenamedEvent: {
            (options?: vimService.vim.VmRenamedEvent): vimService.vim.VmRenamedEvent;
         };
         VmDateRolledBackEvent: {
            (options?: vimService.vim.VmDateRolledBackEvent): vimService.vim.VmDateRolledBackEvent;
         };
         VmNoNetworkAccessEvent: {
            (options?: vimService.vim.VmNoNetworkAccessEvent): vimService.vim.VmNoNetworkAccessEvent;
         };
         VmDiskFailedEvent: {
            (options?: vimService.vim.VmDiskFailedEvent): vimService.vim.VmDiskFailedEvent;
         };
         VmFailedToPowerOnEvent: {
            (options?: vimService.vim.VmFailedToPowerOnEvent): vimService.vim.VmFailedToPowerOnEvent;
         };
         VmFailedToPowerOffEvent: {
            (options?: vimService.vim.VmFailedToPowerOffEvent): vimService.vim.VmFailedToPowerOffEvent;
         };
         VmFailedToSuspendEvent: {
            (options?: vimService.vim.VmFailedToSuspendEvent): vimService.vim.VmFailedToSuspendEvent;
         };
         VmFailedToResetEvent: {
            (options?: vimService.vim.VmFailedToResetEvent): vimService.vim.VmFailedToResetEvent;
         };
         VmFailedToShutdownGuestEvent: {
            (options?: vimService.vim.VmFailedToShutdownGuestEvent): vimService.vim.VmFailedToShutdownGuestEvent;
         };
         VmFailedToRebootGuestEvent: {
            (options?: vimService.vim.VmFailedToRebootGuestEvent): vimService.vim.VmFailedToRebootGuestEvent;
         };
         VmFailedToStandbyGuestEvent: {
            (options?: vimService.vim.VmFailedToStandbyGuestEvent): vimService.vim.VmFailedToStandbyGuestEvent;
         };
         VmRemovedEvent: {
            (options?: vimService.vim.VmRemovedEvent): vimService.vim.VmRemovedEvent;
         };
         VmGuestShutdownEvent: {
            (options?: vimService.vim.VmGuestShutdownEvent): vimService.vim.VmGuestShutdownEvent;
         };
         VmGuestRebootEvent: {
            (options?: vimService.vim.VmGuestRebootEvent): vimService.vim.VmGuestRebootEvent;
         };
         VmGuestStandbyEvent: {
            (options?: vimService.vim.VmGuestStandbyEvent): vimService.vim.VmGuestStandbyEvent;
         };
         VmUpgradingEvent: {
            (options?: vimService.vim.VmUpgradingEvent): vimService.vim.VmUpgradingEvent;
         };
         VmUpgradeCompleteEvent: {
            (options?: vimService.vim.VmUpgradeCompleteEvent): vimService.vim.VmUpgradeCompleteEvent;
         };
         VmUpgradeFailedEvent: {
            (options?: vimService.vim.VmUpgradeFailedEvent): vimService.vim.VmUpgradeFailedEvent;
         };
         VmRestartedOnAlternateHostEvent: {
            (options?: vimService.vim.VmRestartedOnAlternateHostEvent): vimService.vim.VmRestartedOnAlternateHostEvent;
         };
         VmReconfiguredEvent: {
            (options?: vimService.vim.VmReconfiguredEvent): vimService.vim.VmReconfiguredEvent;
         };
         VmMessageEvent: {
            (options?: vimService.vim.VmMessageEvent): vimService.vim.VmMessageEvent;
         };
         VmMessageWarningEvent: {
            (options?: vimService.vim.VmMessageWarningEvent): vimService.vim.VmMessageWarningEvent;
         };
         VmMessageErrorEvent: {
            (options?: vimService.vim.VmMessageErrorEvent): vimService.vim.VmMessageErrorEvent;
         };
         VmConfigMissingEvent: {
            (options?: vimService.vim.VmConfigMissingEvent): vimService.vim.VmConfigMissingEvent;
         };
         VmPowerOffOnIsolationEvent: {
            (options?: vimService.vim.VmPowerOffOnIsolationEvent): vimService.vim.VmPowerOffOnIsolationEvent;
         };
         VmShutdownOnIsolationEventOperation: {
            "shutdown": string;
            "poweredOff": string;
         };
         VmShutdownOnIsolationEvent: {
            (options?: vimService.vim.VmShutdownOnIsolationEvent): vimService.vim.VmShutdownOnIsolationEvent;
         };
         VmFailoverFailed: {
            (options?: vimService.vim.VmFailoverFailed): vimService.vim.VmFailoverFailed;
         };
         VmDasBeingResetEventReasonCode: {
            "vmtoolsHeartbeatFailure": string;
            "appHeartbeatFailure": string;
            "appImmediateResetRequest": string;
            "vmcpResetApdCleared": string;
         };
         VmDasBeingResetEvent: {
            (options?: vimService.vim.VmDasBeingResetEvent): vimService.vim.VmDasBeingResetEvent;
         };
         VmDasResetFailedEvent: {
            (options?: vimService.vim.VmDasResetFailedEvent): vimService.vim.VmDasResetFailedEvent;
         };
         VmMaxRestartCountReached: {
            (options?: vimService.vim.VmMaxRestartCountReached): vimService.vim.VmMaxRestartCountReached;
         };
         VmMaxFTRestartCountReached: {
            (options?: vimService.vim.VmMaxFTRestartCountReached): vimService.vim.VmMaxFTRestartCountReached;
         };
         VmDasBeingResetWithScreenshotEvent: {
            (options?: vimService.vim.VmDasBeingResetWithScreenshotEvent): vimService.vim.VmDasBeingResetWithScreenshotEvent;
         };
         NotEnoughResourcesToStartVmEvent: {
            (options?: vimService.vim.NotEnoughResourcesToStartVmEvent): vimService.vim.NotEnoughResourcesToStartVmEvent;
         };
         VmUuidAssignedEvent: {
            (options?: vimService.vim.VmUuidAssignedEvent): vimService.vim.VmUuidAssignedEvent;
         };
         VmInstanceUuidAssignedEvent: {
            (options?: vimService.vim.VmInstanceUuidAssignedEvent): vimService.vim.VmInstanceUuidAssignedEvent;
         };
         VmUuidChangedEvent: {
            (options?: vimService.vim.VmUuidChangedEvent): vimService.vim.VmUuidChangedEvent;
         };
         VmInstanceUuidChangedEvent: {
            (options?: vimService.vim.VmInstanceUuidChangedEvent): vimService.vim.VmInstanceUuidChangedEvent;
         };
         VmWwnConflictEvent: {
            (options?: vimService.vim.VmWwnConflictEvent): vimService.vim.VmWwnConflictEvent;
         };
         VmAcquiredMksTicketEvent: {
            (options?: vimService.vim.VmAcquiredMksTicketEvent): vimService.vim.VmAcquiredMksTicketEvent;
         };
         VmAcquiredTicketEvent: {
            (options?: vimService.vim.VmAcquiredTicketEvent): vimService.vim.VmAcquiredTicketEvent;
         };
         VmGuestOSCrashedEvent: {
            (options?: vimService.vim.VmGuestOSCrashedEvent): vimService.vim.VmGuestOSCrashedEvent;
         };
         HostWwnConflictEvent: {
            (options?: vimService.vim.HostWwnConflictEvent): vimService.vim.HostWwnConflictEvent;
         };
         VmWwnAssignedEvent: {
            (options?: vimService.vim.VmWwnAssignedEvent): vimService.vim.VmWwnAssignedEvent;
         };
         VmWwnChangedEvent: {
            (options?: vimService.vim.VmWwnChangedEvent): vimService.vim.VmWwnChangedEvent;
         };
         VmSecondaryAddedEvent: {
            (options?: vimService.vim.VmSecondaryAddedEvent): vimService.vim.VmSecondaryAddedEvent;
         };
         VmFaultToleranceTurnedOffEvent: {
            (options?: vimService.vim.VmFaultToleranceTurnedOffEvent): vimService.vim.VmFaultToleranceTurnedOffEvent;
         };
         VmFaultToleranceStateChangedEvent: {
            (options?: vimService.vim.VmFaultToleranceStateChangedEvent): vimService.vim.VmFaultToleranceStateChangedEvent;
         };
         VmSecondaryDisabledEvent: {
            (options?: vimService.vim.VmSecondaryDisabledEvent): vimService.vim.VmSecondaryDisabledEvent;
         };
         VmSecondaryDisabledBySystemEvent: {
            (options?: vimService.vim.VmSecondaryDisabledBySystemEvent): vimService.vim.VmSecondaryDisabledBySystemEvent;
         };
         VmSecondaryEnabledEvent: {
            (options?: vimService.vim.VmSecondaryEnabledEvent): vimService.vim.VmSecondaryEnabledEvent;
         };
         VmStartingSecondaryEvent: {
            (options?: vimService.vim.VmStartingSecondaryEvent): vimService.vim.VmStartingSecondaryEvent;
         };
         VmSecondaryStartedEvent: {
            (options?: vimService.vim.VmSecondaryStartedEvent): vimService.vim.VmSecondaryStartedEvent;
         };
         VmFailedUpdatingSecondaryConfig: {
            (options?: vimService.vim.VmFailedUpdatingSecondaryConfig): vimService.vim.VmFailedUpdatingSecondaryConfig;
         };
         VmFailedStartingSecondaryEventFailureReason: {
            "incompatibleHost": string;
            "loginFailed": string;
            "registerVmFailed": string;
            "migrateFailed": string;
         };
         VmFailedStartingSecondaryEvent: {
            (options?: vimService.vim.VmFailedStartingSecondaryEvent): vimService.vim.VmFailedStartingSecondaryEvent;
         };
         VmTimedoutStartingSecondaryEvent: {
            (options?: vimService.vim.VmTimedoutStartingSecondaryEvent): vimService.vim.VmTimedoutStartingSecondaryEvent;
         };
         VmNoCompatibleHostForSecondaryEvent: {
            (options?: vimService.vim.VmNoCompatibleHostForSecondaryEvent): vimService.vim.VmNoCompatibleHostForSecondaryEvent;
         };
         VmPrimaryFailoverEvent: {
            (options?: vimService.vim.VmPrimaryFailoverEvent): vimService.vim.VmPrimaryFailoverEvent;
         };
         VmFaultToleranceVmTerminatedEvent: {
            (options?: vimService.vim.VmFaultToleranceVmTerminatedEvent): vimService.vim.VmFaultToleranceVmTerminatedEvent;
         };
         HostWwnChangedEvent: {
            (options?: vimService.vim.HostWwnChangedEvent): vimService.vim.HostWwnChangedEvent;
         };
         HostAdminDisableEvent: {
            (options?: vimService.vim.HostAdminDisableEvent): vimService.vim.HostAdminDisableEvent;
         };
         HostAdminEnableEvent: {
            (options?: vimService.vim.HostAdminEnableEvent): vimService.vim.HostAdminEnableEvent;
         };
         HostEnableAdminFailedEvent: {
            (options?: vimService.vim.HostEnableAdminFailedEvent): vimService.vim.HostEnableAdminFailedEvent;
         };
         VmFailedRelayoutOnVmfs2DatastoreEvent: {
            (options?: vimService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent): vimService.vim.VmFailedRelayoutOnVmfs2DatastoreEvent;
         };
         VmFailedRelayoutEvent: {
            (options?: vimService.vim.VmFailedRelayoutEvent): vimService.vim.VmFailedRelayoutEvent;
         };
         VmRelayoutSuccessfulEvent: {
            (options?: vimService.vim.VmRelayoutSuccessfulEvent): vimService.vim.VmRelayoutSuccessfulEvent;
         };
         VmRelayoutUpToDateEvent: {
            (options?: vimService.vim.VmRelayoutUpToDateEvent): vimService.vim.VmRelayoutUpToDateEvent;
         };
         VmConnectedEvent: {
            (options?: vimService.vim.VmConnectedEvent): vimService.vim.VmConnectedEvent;
         };
         VmPoweringOnWithCustomizedDVPortEvent: {
            (options?: vimService.vim.VmPoweringOnWithCustomizedDVPortEvent): vimService.vim.VmPoweringOnWithCustomizedDVPortEvent;
         };
         VmDasUpdateErrorEvent: {
            (options?: vimService.vim.VmDasUpdateErrorEvent): vimService.vim.VmDasUpdateErrorEvent;
         };
         NoMaintenanceModeDrsRecommendationForVM: {
            (options?: vimService.vim.NoMaintenanceModeDrsRecommendationForVM): vimService.vim.NoMaintenanceModeDrsRecommendationForVM;
         };
         VmDasUpdateOkEvent: {
            (options?: vimService.vim.VmDasUpdateOkEvent): vimService.vim.VmDasUpdateOkEvent;
         };
         ScheduledTaskEvent: {
            (options?: vimService.vim.ScheduledTaskEvent): vimService.vim.ScheduledTaskEvent;
         };
         ScheduledTaskCreatedEvent: {
            (options?: vimService.vim.ScheduledTaskCreatedEvent): vimService.vim.ScheduledTaskCreatedEvent;
         };
         ScheduledTaskStartedEvent: {
            (options?: vimService.vim.ScheduledTaskStartedEvent): vimService.vim.ScheduledTaskStartedEvent;
         };
         ScheduledTaskRemovedEvent: {
            (options?: vimService.vim.ScheduledTaskRemovedEvent): vimService.vim.ScheduledTaskRemovedEvent;
         };
         ScheduledTaskReconfiguredEvent: {
            (options?: vimService.vim.ScheduledTaskReconfiguredEvent): vimService.vim.ScheduledTaskReconfiguredEvent;
         };
         ScheduledTaskCompletedEvent: {
            (options?: vimService.vim.ScheduledTaskCompletedEvent): vimService.vim.ScheduledTaskCompletedEvent;
         };
         ScheduledTaskFailedEvent: {
            (options?: vimService.vim.ScheduledTaskFailedEvent): vimService.vim.ScheduledTaskFailedEvent;
         };
         ScheduledTaskEmailCompletedEvent: {
            (options?: vimService.vim.ScheduledTaskEmailCompletedEvent): vimService.vim.ScheduledTaskEmailCompletedEvent;
         };
         ScheduledTaskEmailFailedEvent: {
            (options?: vimService.vim.ScheduledTaskEmailFailedEvent): vimService.vim.ScheduledTaskEmailFailedEvent;
         };
         AlarmEvent: {
            (options?: vimService.vim.AlarmEvent): vimService.vim.AlarmEvent;
         };
         AlarmCreatedEvent: {
            (options?: vimService.vim.AlarmCreatedEvent): vimService.vim.AlarmCreatedEvent;
         };
         AlarmStatusChangedEvent: {
            (options?: vimService.vim.AlarmStatusChangedEvent): vimService.vim.AlarmStatusChangedEvent;
         };
         AlarmActionTriggeredEvent: {
            (options?: vimService.vim.AlarmActionTriggeredEvent): vimService.vim.AlarmActionTriggeredEvent;
         };
         AlarmEmailCompletedEvent: {
            (options?: vimService.vim.AlarmEmailCompletedEvent): vimService.vim.AlarmEmailCompletedEvent;
         };
         AlarmEmailFailedEvent: {
            (options?: vimService.vim.AlarmEmailFailedEvent): vimService.vim.AlarmEmailFailedEvent;
         };
         AlarmSnmpCompletedEvent: {
            (options?: vimService.vim.AlarmSnmpCompletedEvent): vimService.vim.AlarmSnmpCompletedEvent;
         };
         AlarmSnmpFailedEvent: {
            (options?: vimService.vim.AlarmSnmpFailedEvent): vimService.vim.AlarmSnmpFailedEvent;
         };
         AlarmScriptCompleteEvent: {
            (options?: vimService.vim.AlarmScriptCompleteEvent): vimService.vim.AlarmScriptCompleteEvent;
         };
         AlarmScriptFailedEvent: {
            (options?: vimService.vim.AlarmScriptFailedEvent): vimService.vim.AlarmScriptFailedEvent;
         };
         AlarmRemovedEvent: {
            (options?: vimService.vim.AlarmRemovedEvent): vimService.vim.AlarmRemovedEvent;
         };
         AlarmReconfiguredEvent: {
            (options?: vimService.vim.AlarmReconfiguredEvent): vimService.vim.AlarmReconfiguredEvent;
         };
         AlarmAcknowledgedEvent: {
            (options?: vimService.vim.AlarmAcknowledgedEvent): vimService.vim.AlarmAcknowledgedEvent;
         };
         AlarmClearedEvent: {
            (options?: vimService.vim.AlarmClearedEvent): vimService.vim.AlarmClearedEvent;
         };
         CustomFieldEvent: {
            (options?: vimService.vim.CustomFieldEvent): vimService.vim.CustomFieldEvent;
         };
         CustomFieldDefEvent: {
            (options?: vimService.vim.CustomFieldDefEvent): vimService.vim.CustomFieldDefEvent;
         };
         CustomFieldDefAddedEvent: {
            (options?: vimService.vim.CustomFieldDefAddedEvent): vimService.vim.CustomFieldDefAddedEvent;
         };
         CustomFieldDefRemovedEvent: {
            (options?: vimService.vim.CustomFieldDefRemovedEvent): vimService.vim.CustomFieldDefRemovedEvent;
         };
         CustomFieldDefRenamedEvent: {
            (options?: vimService.vim.CustomFieldDefRenamedEvent): vimService.vim.CustomFieldDefRenamedEvent;
         };
         CustomFieldValueChangedEvent: {
            (options?: vimService.vim.CustomFieldValueChangedEvent): vimService.vim.CustomFieldValueChangedEvent;
         };
         AuthorizationEvent: {
            (options?: vimService.vim.AuthorizationEvent): vimService.vim.AuthorizationEvent;
         };
         PermissionEvent: {
            (options?: vimService.vim.PermissionEvent): vimService.vim.PermissionEvent;
         };
         PermissionAddedEvent: {
            (options?: vimService.vim.PermissionAddedEvent): vimService.vim.PermissionAddedEvent;
         };
         PermissionUpdatedEvent: {
            (options?: vimService.vim.PermissionUpdatedEvent): vimService.vim.PermissionUpdatedEvent;
         };
         PermissionRemovedEvent: {
            (options?: vimService.vim.PermissionRemovedEvent): vimService.vim.PermissionRemovedEvent;
         };
         RoleEvent: {
            (options?: vimService.vim.RoleEvent): vimService.vim.RoleEvent;
         };
         RoleAddedEvent: {
            (options?: vimService.vim.RoleAddedEvent): vimService.vim.RoleAddedEvent;
         };
         RoleUpdatedEvent: {
            (options?: vimService.vim.RoleUpdatedEvent): vimService.vim.RoleUpdatedEvent;
         };
         RoleRemovedEvent: {
            (options?: vimService.vim.RoleRemovedEvent): vimService.vim.RoleRemovedEvent;
         };
         DatastoreEvent: {
            (options?: vimService.vim.DatastoreEvent): vimService.vim.DatastoreEvent;
         };
         DatastoreDestroyedEvent: {
            (options?: vimService.vim.DatastoreDestroyedEvent): vimService.vim.DatastoreDestroyedEvent;
         };
         DatastoreRenamedEvent: {
            (options?: vimService.vim.DatastoreRenamedEvent): vimService.vim.DatastoreRenamedEvent;
         };
         DatastoreCapacityIncreasedEvent: {
            (options?: vimService.vim.DatastoreCapacityIncreasedEvent): vimService.vim.DatastoreCapacityIncreasedEvent;
         };
         DatastoreDuplicatedEvent: {
            (options?: vimService.vim.DatastoreDuplicatedEvent): vimService.vim.DatastoreDuplicatedEvent;
         };
         DatastoreFileEvent: {
            (options?: vimService.vim.DatastoreFileEvent): vimService.vim.DatastoreFileEvent;
         };
         DatastoreFileCopiedEvent: {
            (options?: vimService.vim.DatastoreFileCopiedEvent): vimService.vim.DatastoreFileCopiedEvent;
         };
         DatastoreFileMovedEvent: {
            (options?: vimService.vim.DatastoreFileMovedEvent): vimService.vim.DatastoreFileMovedEvent;
         };
         DatastoreFileDeletedEvent: {
            (options?: vimService.vim.DatastoreFileDeletedEvent): vimService.vim.DatastoreFileDeletedEvent;
         };
         NonVIWorkloadDetectedOnDatastoreEvent: {
            (options?: vimService.vim.NonVIWorkloadDetectedOnDatastoreEvent): vimService.vim.NonVIWorkloadDetectedOnDatastoreEvent;
         };
         DatastoreIORMReconfiguredEvent: {
            (options?: vimService.vim.DatastoreIORMReconfiguredEvent): vimService.vim.DatastoreIORMReconfiguredEvent;
         };
         TaskEvent: {
            (options?: vimService.vim.TaskEvent): vimService.vim.TaskEvent;
         };
         TaskTimeoutEvent: {
            (options?: vimService.vim.TaskTimeoutEvent): vimService.vim.TaskTimeoutEvent;
         };
         LicenseEvent: {
            (options?: vimService.vim.LicenseEvent): vimService.vim.LicenseEvent;
         };
         ServerLicenseExpiredEvent: {
            (options?: vimService.vim.ServerLicenseExpiredEvent): vimService.vim.ServerLicenseExpiredEvent;
         };
         HostLicenseExpiredEvent: {
            (options?: vimService.vim.HostLicenseExpiredEvent): vimService.vim.HostLicenseExpiredEvent;
         };
         VMotionLicenseExpiredEvent: {
            (options?: vimService.vim.VMotionLicenseExpiredEvent): vimService.vim.VMotionLicenseExpiredEvent;
         };
         NoLicenseEvent: {
            (options?: vimService.vim.NoLicenseEvent): vimService.vim.NoLicenseEvent;
         };
         LicenseServerUnavailableEvent: {
            (options?: vimService.vim.LicenseServerUnavailableEvent): vimService.vim.LicenseServerUnavailableEvent;
         };
         LicenseServerAvailableEvent: {
            (options?: vimService.vim.LicenseServerAvailableEvent): vimService.vim.LicenseServerAvailableEvent;
         };
         LicenseExpiredEvent: {
            (options?: vimService.vim.LicenseExpiredEvent): vimService.vim.LicenseExpiredEvent;
         };
         InvalidEditionEvent: {
            (options?: vimService.vim.InvalidEditionEvent): vimService.vim.InvalidEditionEvent;
         };
         HostInventoryFullEvent: {
            (options?: vimService.vim.HostInventoryFullEvent): vimService.vim.HostInventoryFullEvent;
         };
         LicenseRestrictedEvent: {
            (options?: vimService.vim.LicenseRestrictedEvent): vimService.vim.LicenseRestrictedEvent;
         };
         IncorrectHostInformationEvent: {
            (options?: vimService.vim.IncorrectHostInformationEvent): vimService.vim.IncorrectHostInformationEvent;
         };
         UnlicensedVirtualMachinesEvent: {
            (options?: vimService.vim.UnlicensedVirtualMachinesEvent): vimService.vim.UnlicensedVirtualMachinesEvent;
         };
         UnlicensedVirtualMachinesFoundEvent: {
            (options?: vimService.vim.UnlicensedVirtualMachinesFoundEvent): vimService.vim.UnlicensedVirtualMachinesFoundEvent;
         };
         AllVirtualMachinesLicensedEvent: {
            (options?: vimService.vim.AllVirtualMachinesLicensedEvent): vimService.vim.AllVirtualMachinesLicensedEvent;
         };
         LicenseNonComplianceEvent: {
            (options?: vimService.vim.LicenseNonComplianceEvent): vimService.vim.LicenseNonComplianceEvent;
         };
         MigrationEvent: {
            (options?: vimService.vim.MigrationEvent): vimService.vim.MigrationEvent;
         };
         MigrationWarningEvent: {
            (options?: vimService.vim.MigrationWarningEvent): vimService.vim.MigrationWarningEvent;
         };
         MigrationErrorEvent: {
            (options?: vimService.vim.MigrationErrorEvent): vimService.vim.MigrationErrorEvent;
         };
         MigrationHostWarningEvent: {
            (options?: vimService.vim.MigrationHostWarningEvent): vimService.vim.MigrationHostWarningEvent;
         };
         MigrationHostErrorEvent: {
            (options?: vimService.vim.MigrationHostErrorEvent): vimService.vim.MigrationHostErrorEvent;
         };
         MigrationResourceWarningEvent: {
            (options?: vimService.vim.MigrationResourceWarningEvent): vimService.vim.MigrationResourceWarningEvent;
         };
         MigrationResourceErrorEvent: {
            (options?: vimService.vim.MigrationResourceErrorEvent): vimService.vim.MigrationResourceErrorEvent;
         };
         ClusterEvent: {
            (options?: vimService.vim.ClusterEvent): vimService.vim.ClusterEvent;
         };
         DasEnabledEvent: {
            (options?: vimService.vim.DasEnabledEvent): vimService.vim.DasEnabledEvent;
         };
         DasDisabledEvent: {
            (options?: vimService.vim.DasDisabledEvent): vimService.vim.DasDisabledEvent;
         };
         DasAdmissionControlDisabledEvent: {
            (options?: vimService.vim.DasAdmissionControlDisabledEvent): vimService.vim.DasAdmissionControlDisabledEvent;
         };
         DasAdmissionControlEnabledEvent: {
            (options?: vimService.vim.DasAdmissionControlEnabledEvent): vimService.vim.DasAdmissionControlEnabledEvent;
         };
         DasHostFailedEvent: {
            (options?: vimService.vim.DasHostFailedEvent): vimService.vim.DasHostFailedEvent;
         };
         DasHostIsolatedEvent: {
            (options?: vimService.vim.DasHostIsolatedEvent): vimService.vim.DasHostIsolatedEvent;
         };
         DasClusterIsolatedEvent: {
            (options?: vimService.vim.DasClusterIsolatedEvent): vimService.vim.DasClusterIsolatedEvent;
         };
         DasAgentUnavailableEvent: {
            (options?: vimService.vim.DasAgentUnavailableEvent): vimService.vim.DasAgentUnavailableEvent;
         };
         DasAgentFoundEvent: {
            (options?: vimService.vim.DasAgentFoundEvent): vimService.vim.DasAgentFoundEvent;
         };
         InsufficientFailoverResourcesEvent: {
            (options?: vimService.vim.InsufficientFailoverResourcesEvent): vimService.vim.InsufficientFailoverResourcesEvent;
         };
         FailoverLevelRestored: {
            (options?: vimService.vim.FailoverLevelRestored): vimService.vim.FailoverLevelRestored;
         };
         ClusterOvercommittedEvent: {
            (options?: vimService.vim.ClusterOvercommittedEvent): vimService.vim.ClusterOvercommittedEvent;
         };
         HostOvercommittedEvent: {
            (options?: vimService.vim.HostOvercommittedEvent): vimService.vim.HostOvercommittedEvent;
         };
         ClusterStatusChangedEvent: {
            (options?: vimService.vim.ClusterStatusChangedEvent): vimService.vim.ClusterStatusChangedEvent;
         };
         HostStatusChangedEvent: {
            (options?: vimService.vim.HostStatusChangedEvent): vimService.vim.HostStatusChangedEvent;
         };
         ClusterCreatedEvent: {
            (options?: vimService.vim.ClusterCreatedEvent): vimService.vim.ClusterCreatedEvent;
         };
         ClusterDestroyedEvent: {
            (options?: vimService.vim.ClusterDestroyedEvent): vimService.vim.ClusterDestroyedEvent;
         };
         DrsEnabledEvent: {
            (options?: vimService.vim.DrsEnabledEvent): vimService.vim.DrsEnabledEvent;
         };
         DrsDisabledEvent: {
            (options?: vimService.vim.DrsDisabledEvent): vimService.vim.DrsDisabledEvent;
         };
         ClusterReconfiguredEvent: {
            (options?: vimService.vim.ClusterReconfiguredEvent): vimService.vim.ClusterReconfiguredEvent;
         };
         HostMonitoringStateChangedEvent: {
            (options?: vimService.vim.HostMonitoringStateChangedEvent): vimService.vim.HostMonitoringStateChangedEvent;
         };
         VmHealthMonitoringStateChangedEvent: {
            (options?: vimService.vim.VmHealthMonitoringStateChangedEvent): vimService.vim.VmHealthMonitoringStateChangedEvent;
         };
         ResourcePoolEvent: {
            (options?: vimService.vim.ResourcePoolEvent): vimService.vim.ResourcePoolEvent;
         };
         ResourcePoolCreatedEvent: {
            (options?: vimService.vim.ResourcePoolCreatedEvent): vimService.vim.ResourcePoolCreatedEvent;
         };
         ResourcePoolDestroyedEvent: {
            (options?: vimService.vim.ResourcePoolDestroyedEvent): vimService.vim.ResourcePoolDestroyedEvent;
         };
         ResourcePoolMovedEvent: {
            (options?: vimService.vim.ResourcePoolMovedEvent): vimService.vim.ResourcePoolMovedEvent;
         };
         ResourcePoolReconfiguredEvent: {
            (options?: vimService.vim.ResourcePoolReconfiguredEvent): vimService.vim.ResourcePoolReconfiguredEvent;
         };
         ResourceViolatedEvent: {
            (options?: vimService.vim.ResourceViolatedEvent): vimService.vim.ResourceViolatedEvent;
         };
         VmResourcePoolMovedEvent: {
            (options?: vimService.vim.VmResourcePoolMovedEvent): vimService.vim.VmResourcePoolMovedEvent;
         };
         TemplateUpgradeEvent: {
            (options?: vimService.vim.TemplateUpgradeEvent): vimService.vim.TemplateUpgradeEvent;
         };
         TemplateBeingUpgradedEvent: {
            (options?: vimService.vim.TemplateBeingUpgradedEvent): vimService.vim.TemplateBeingUpgradedEvent;
         };
         TemplateUpgradeFailedEvent: {
            (options?: vimService.vim.TemplateUpgradeFailedEvent): vimService.vim.TemplateUpgradeFailedEvent;
         };
         TemplateUpgradedEvent: {
            (options?: vimService.vim.TemplateUpgradedEvent): vimService.vim.TemplateUpgradedEvent;
         };
         CustomizationEvent: {
            (options?: vimService.vim.CustomizationEvent): vimService.vim.CustomizationEvent;
         };
         CustomizationStartedEvent: {
            (options?: vimService.vim.CustomizationStartedEvent): vimService.vim.CustomizationStartedEvent;
         };
         CustomizationSucceeded: {
            (options?: vimService.vim.CustomizationSucceeded): vimService.vim.CustomizationSucceeded;
         };
         CustomizationFailed: {
            (options?: vimService.vim.CustomizationFailed): vimService.vim.CustomizationFailed;
         };
         CustomizationUnknownFailure: {
            (options?: vimService.vim.CustomizationUnknownFailure): vimService.vim.CustomizationUnknownFailure;
         };
         CustomizationSysprepFailed: {
            (options?: vimService.vim.CustomizationSysprepFailed): vimService.vim.CustomizationSysprepFailed;
         };
         CustomizationLinuxIdentityFailed: {
            (options?: vimService.vim.CustomizationLinuxIdentityFailed): vimService.vim.CustomizationLinuxIdentityFailed;
         };
         CustomizationNetworkSetupFailed: {
            (options?: vimService.vim.CustomizationNetworkSetupFailed): vimService.vim.CustomizationNetworkSetupFailed;
         };
         LockerMisconfiguredEvent: {
            (options?: vimService.vim.LockerMisconfiguredEvent): vimService.vim.LockerMisconfiguredEvent;
         };
         LockerReconfiguredEvent: {
            (options?: vimService.vim.LockerReconfiguredEvent): vimService.vim.LockerReconfiguredEvent;
         };
         NoDatastoresConfiguredEvent: {
            (options?: vimService.vim.NoDatastoresConfiguredEvent): vimService.vim.NoDatastoresConfiguredEvent;
         };
         AdminPasswordNotChangedEvent: {
            (options?: vimService.vim.AdminPasswordNotChangedEvent): vimService.vim.AdminPasswordNotChangedEvent;
         };
         HostInAuditModeEvent: {
            (options?: vimService.vim.HostInAuditModeEvent): vimService.vim.HostInAuditModeEvent;
         };
         LocalTSMEnabledEvent: {
            (options?: vimService.vim.LocalTSMEnabledEvent): vimService.vim.LocalTSMEnabledEvent;
         };
         RemoteTSMEnabledEvent: {
            (options?: vimService.vim.RemoteTSMEnabledEvent): vimService.vim.RemoteTSMEnabledEvent;
         };
         VimAccountPasswordChangedEvent: {
            (options?: vimService.vim.VimAccountPasswordChangedEvent): vimService.vim.VimAccountPasswordChangedEvent;
         };
         IScsiBootFailureEvent: {
            (options?: vimService.vim.IScsiBootFailureEvent): vimService.vim.IScsiBootFailureEvent;
         };
         DvsHealthStatusChangeEvent: {
            (options?: vimService.vim.DvsHealthStatusChangeEvent): vimService.vim.DvsHealthStatusChangeEvent;
         };
         NetworkRollbackEvent: {
            (options?: vimService.vim.NetworkRollbackEvent): vimService.vim.NetworkRollbackEvent;
         };
         UplinkPortVlanTrunkedEvent: {
            (options?: vimService.vim.UplinkPortVlanTrunkedEvent): vimService.vim.UplinkPortVlanTrunkedEvent;
         };
         UplinkPortVlanUntrunkedEvent: {
            (options?: vimService.vim.UplinkPortVlanUntrunkedEvent): vimService.vim.UplinkPortVlanUntrunkedEvent;
         };
         MtuMatchEvent: {
            (options?: vimService.vim.MtuMatchEvent): vimService.vim.MtuMatchEvent;
         };
         MtuMismatchEvent: {
            (options?: vimService.vim.MtuMismatchEvent): vimService.vim.MtuMismatchEvent;
         };
         UplinkPortMtuNotSupportEvent: {
            (options?: vimService.vim.UplinkPortMtuNotSupportEvent): vimService.vim.UplinkPortMtuNotSupportEvent;
         };
         UplinkPortMtuSupportEvent: {
            (options?: vimService.vim.UplinkPortMtuSupportEvent): vimService.vim.UplinkPortMtuSupportEvent;
         };
         TeamingMatchEvent: {
            (options?: vimService.vim.TeamingMatchEvent): vimService.vim.TeamingMatchEvent;
         };
         TeamingMisMatchEvent: {
            (options?: vimService.vim.TeamingMisMatchEvent): vimService.vim.TeamingMisMatchEvent;
         };
         DvsEvent: {
            (options?: vimService.vim.DvsEvent): vimService.vim.DvsEvent;
         };
         DvsCreatedEvent: {
            (options?: vimService.vim.DvsCreatedEvent): vimService.vim.DvsCreatedEvent;
         };
         DvsRenamedEvent: {
            (options?: vimService.vim.DvsRenamedEvent): vimService.vim.DvsRenamedEvent;
         };
         DvsReconfiguredEvent: {
            (options?: vimService.vim.DvsReconfiguredEvent): vimService.vim.DvsReconfiguredEvent;
         };
         DvsUpgradeAvailableEvent: {
            (options?: vimService.vim.DvsUpgradeAvailableEvent): vimService.vim.DvsUpgradeAvailableEvent;
         };
         DvsUpgradeInProgressEvent: {
            (options?: vimService.vim.DvsUpgradeInProgressEvent): vimService.vim.DvsUpgradeInProgressEvent;
         };
         DvsUpgradeRejectedEvent: {
            (options?: vimService.vim.DvsUpgradeRejectedEvent): vimService.vim.DvsUpgradeRejectedEvent;
         };
         DvsUpgradedEvent: {
            (options?: vimService.vim.DvsUpgradedEvent): vimService.vim.DvsUpgradedEvent;
         };
         DvsHostJoinedEvent: {
            (options?: vimService.vim.DvsHostJoinedEvent): vimService.vim.DvsHostJoinedEvent;
         };
         DvsHostLeftEvent: {
            (options?: vimService.vim.DvsHostLeftEvent): vimService.vim.DvsHostLeftEvent;
         };
         DvsOutOfSyncHostArgument: {
            (options?: vimService.vim.DvsOutOfSyncHostArgument): vimService.vim.DvsOutOfSyncHostArgument;
         };
         ArrayOfDvsOutOfSyncHostArgument: {
            (options?: vimService.vim.ArrayOfDvsOutOfSyncHostArgument): vimService.vim.ArrayOfDvsOutOfSyncHostArgument;
         };
         OutOfSyncDvsHost: {
            (options?: vimService.vim.OutOfSyncDvsHost): vimService.vim.OutOfSyncDvsHost;
         };
         DvsHostWentOutOfSyncEvent: {
            (options?: vimService.vim.DvsHostWentOutOfSyncEvent): vimService.vim.DvsHostWentOutOfSyncEvent;
         };
         DvsHostBackInSyncEvent: {
            (options?: vimService.vim.DvsHostBackInSyncEvent): vimService.vim.DvsHostBackInSyncEvent;
         };
         DvsHostStatusUpdated: {
            (options?: vimService.vim.DvsHostStatusUpdated): vimService.vim.DvsHostStatusUpdated;
         };
         DvsPortCreatedEvent: {
            (options?: vimService.vim.DvsPortCreatedEvent): vimService.vim.DvsPortCreatedEvent;
         };
         DvsPortReconfiguredEvent: {
            (options?: vimService.vim.DvsPortReconfiguredEvent): vimService.vim.DvsPortReconfiguredEvent;
         };
         DvsPortDeletedEvent: {
            (options?: vimService.vim.DvsPortDeletedEvent): vimService.vim.DvsPortDeletedEvent;
         };
         DvsPortConnectedEvent: {
            (options?: vimService.vim.DvsPortConnectedEvent): vimService.vim.DvsPortConnectedEvent;
         };
         DvsPortDisconnectedEvent: {
            (options?: vimService.vim.DvsPortDisconnectedEvent): vimService.vim.DvsPortDisconnectedEvent;
         };
         DvsPortVendorSpecificStateChangeEvent: {
            (options?: vimService.vim.DvsPortVendorSpecificStateChangeEvent): vimService.vim.DvsPortVendorSpecificStateChangeEvent;
         };
         DvsPortRuntimeChangeEvent: {
            (options?: vimService.vim.DvsPortRuntimeChangeEvent): vimService.vim.DvsPortRuntimeChangeEvent;
         };
         DvsPortLinkUpEvent: {
            (options?: vimService.vim.DvsPortLinkUpEvent): vimService.vim.DvsPortLinkUpEvent;
         };
         DvsPortLinkDownEvent: {
            (options?: vimService.vim.DvsPortLinkDownEvent): vimService.vim.DvsPortLinkDownEvent;
         };
         DvsPortJoinPortgroupEvent: {
            (options?: vimService.vim.DvsPortJoinPortgroupEvent): vimService.vim.DvsPortJoinPortgroupEvent;
         };
         DvsPortLeavePortgroupEvent: {
            (options?: vimService.vim.DvsPortLeavePortgroupEvent): vimService.vim.DvsPortLeavePortgroupEvent;
         };
         DvsPortBlockedEvent: {
            (options?: vimService.vim.DvsPortBlockedEvent): vimService.vim.DvsPortBlockedEvent;
         };
         DvsPortUnblockedEvent: {
            (options?: vimService.vim.DvsPortUnblockedEvent): vimService.vim.DvsPortUnblockedEvent;
         };
         DvsPortEnteredPassthruEvent: {
            (options?: vimService.vim.DvsPortEnteredPassthruEvent): vimService.vim.DvsPortEnteredPassthruEvent;
         };
         DvsPortExitedPassthruEvent: {
            (options?: vimService.vim.DvsPortExitedPassthruEvent): vimService.vim.DvsPortExitedPassthruEvent;
         };
         DvsDestroyedEvent: {
            (options?: vimService.vim.DvsDestroyedEvent): vimService.vim.DvsDestroyedEvent;
         };
         DvsMergedEvent: {
            (options?: vimService.vim.DvsMergedEvent): vimService.vim.DvsMergedEvent;
         };
         HostLocalPortCreatedEvent: {
            (options?: vimService.vim.HostLocalPortCreatedEvent): vimService.vim.HostLocalPortCreatedEvent;
         };
         RollbackEvent: {
            (options?: vimService.vim.RollbackEvent): vimService.vim.RollbackEvent;
         };
         RecoveryEvent: {
            (options?: vimService.vim.RecoveryEvent): vimService.vim.RecoveryEvent;
         };
         DvsImportEvent: {
            (options?: vimService.vim.DvsImportEvent): vimService.vim.DvsImportEvent;
         };
         DvsRestoreEvent: {
            (options?: vimService.vim.DvsRestoreEvent): vimService.vim.DvsRestoreEvent;
         };
         VmVnicPoolReservationViolationRaiseEvent: {
            (options?: vimService.vim.VmVnicPoolReservationViolationRaiseEvent): vimService.vim.VmVnicPoolReservationViolationRaiseEvent;
         };
         VmVnicPoolReservationViolationClearEvent: {
            (options?: vimService.vim.VmVnicPoolReservationViolationClearEvent): vimService.vim.VmVnicPoolReservationViolationClearEvent;
         };
         DVPortgroupEvent: {
            (options?: vimService.vim.DVPortgroupEvent): vimService.vim.DVPortgroupEvent;
         };
         DVPortgroupCreatedEvent: {
            (options?: vimService.vim.DVPortgroupCreatedEvent): vimService.vim.DVPortgroupCreatedEvent;
         };
         DVPortgroupRenamedEvent: {
            (options?: vimService.vim.DVPortgroupRenamedEvent): vimService.vim.DVPortgroupRenamedEvent;
         };
         DVPortgroupReconfiguredEvent: {
            (options?: vimService.vim.DVPortgroupReconfiguredEvent): vimService.vim.DVPortgroupReconfiguredEvent;
         };
         DVPortgroupDestroyedEvent: {
            (options?: vimService.vim.DVPortgroupDestroyedEvent): vimService.vim.DVPortgroupDestroyedEvent;
         };
         DvpgImportEvent: {
            (options?: vimService.vim.DvpgImportEvent): vimService.vim.DvpgImportEvent;
         };
         DvpgRestoreEvent: {
            (options?: vimService.vim.DvpgRestoreEvent): vimService.vim.DvpgRestoreEvent;
         };
         DrsInvocationFailedEvent: {
            (options?: vimService.vim.DrsInvocationFailedEvent): vimService.vim.DrsInvocationFailedEvent;
         };
         DrsRecoveredFromFailureEvent: {
            (options?: vimService.vim.DrsRecoveredFromFailureEvent): vimService.vim.DrsRecoveredFromFailureEvent;
         };
         VmReloadFromPathEvent: {
            (options?: vimService.vim.VmReloadFromPathEvent): vimService.vim.VmReloadFromPathEvent;
         };
         VmReloadFromPathFailedEvent: {
            (options?: vimService.vim.VmReloadFromPathFailedEvent): vimService.vim.VmReloadFromPathFailedEvent;
         };
         VmRequirementsExceedCurrentEVCModeEvent: {
            (options?: vimService.vim.VmRequirementsExceedCurrentEVCModeEvent): vimService.vim.VmRequirementsExceedCurrentEVCModeEvent;
         };
         EventArgument: {
            (options?: vimService.vim.EventArgument): vimService.vim.EventArgument;
         };
         RoleEventArgument: {
            (options?: vimService.vim.RoleEventArgument): vimService.vim.RoleEventArgument;
         };
         EntityEventArgument: {
            (options?: vimService.vim.EntityEventArgument): vimService.vim.EntityEventArgument;
         };
         ManagedEntityEventArgument: {
            (options?: vimService.vim.ManagedEntityEventArgument): vimService.vim.ManagedEntityEventArgument;
         };
         FolderEventArgument: {
            (options?: vimService.vim.FolderEventArgument): vimService.vim.FolderEventArgument;
         };
         DatacenterEventArgument: {
            (options?: vimService.vim.DatacenterEventArgument): vimService.vim.DatacenterEventArgument;
         };
         ComputeResourceEventArgument: {
            (options?: vimService.vim.ComputeResourceEventArgument): vimService.vim.ComputeResourceEventArgument;
         };
         ResourcePoolEventArgument: {
            (options?: vimService.vim.ResourcePoolEventArgument): vimService.vim.ResourcePoolEventArgument;
         };
         HostEventArgument: {
            (options?: vimService.vim.HostEventArgument): vimService.vim.HostEventArgument;
         };
         ArrayOfHostEventArgument: {
            (options?: vimService.vim.ArrayOfHostEventArgument): vimService.vim.ArrayOfHostEventArgument;
         };
         VmEventArgument: {
            (options?: vimService.vim.VmEventArgument): vimService.vim.VmEventArgument;
         };
         ArrayOfVmEventArgument: {
            (options?: vimService.vim.ArrayOfVmEventArgument): vimService.vim.ArrayOfVmEventArgument;
         };
         DatastoreEventArgument: {
            (options?: vimService.vim.DatastoreEventArgument): vimService.vim.DatastoreEventArgument;
         };
         NetworkEventArgument: {
            (options?: vimService.vim.NetworkEventArgument): vimService.vim.NetworkEventArgument;
         };
         AlarmEventArgument: {
            (options?: vimService.vim.AlarmEventArgument): vimService.vim.AlarmEventArgument;
         };
         ScheduledTaskEventArgument: {
            (options?: vimService.vim.ScheduledTaskEventArgument): vimService.vim.ScheduledTaskEventArgument;
         };
         ProfileEventArgument: {
            (options?: vimService.vim.ProfileEventArgument): vimService.vim.ProfileEventArgument;
         };
         DvsEventArgument: {
            (options?: vimService.vim.DvsEventArgument): vimService.vim.DvsEventArgument;
         };
         EventCategory: {
            "info": string;
            "warning": string;
            "error": string;
            "user": string;
         };
         EventArgDesc: {
            (options?: vimService.vim.EventArgDesc): vimService.vim.EventArgDesc;
         };
         ArrayOfEventArgDesc: {
            (options?: vimService.vim.ArrayOfEventArgDesc): vimService.vim.ArrayOfEventArgDesc;
         };
         EventDescriptionEventDetail: {
            (options?: vimService.vim.EventDescriptionEventDetail): vimService.vim.EventDescriptionEventDetail;
         };
         ArrayOfEventDescriptionEventDetail: {
            (options?: vimService.vim.ArrayOfEventDescriptionEventDetail): vimService.vim.ArrayOfEventDescriptionEventDetail;
         };
         EventDescription: {
            (options?: vimService.vim.EventDescription): vimService.vim.EventDescription;
         };
         EventEx: {
            (options?: vimService.vim.EventEx): vimService.vim.EventEx;
         };
         EventFilterSpecRecursionOption: {
            "self": string;
            "children": string;
            "all": string;
         };
         EventFilterSpecByEntity: {
            (options?: vimService.vim.EventFilterSpecByEntity): vimService.vim.EventFilterSpecByEntity;
         };
         EventFilterSpecByTime: {
            (options?: vimService.vim.EventFilterSpecByTime): vimService.vim.EventFilterSpecByTime;
         };
         EventFilterSpecByUsername: {
            (options?: vimService.vim.EventFilterSpecByUsername): vimService.vim.EventFilterSpecByUsername;
         };
         EventFilterSpec: {
            (options?: vimService.vim.EventFilterSpec): vimService.vim.EventFilterSpec;
         };
         ExtExtendedProductInfo: {
            (options?: vimService.vim.ExtExtendedProductInfo): vimService.vim.ExtExtendedProductInfo;
         };
         ManagedByInfo: {
            (options?: vimService.vim.ManagedByInfo): vimService.vim.ManagedByInfo;
         };
         ExtManagedEntityInfo: {
            (options?: vimService.vim.ExtManagedEntityInfo): vimService.vim.ExtManagedEntityInfo;
         };
         ArrayOfExtManagedEntityInfo: {
            (options?: vimService.vim.ArrayOfExtManagedEntityInfo): vimService.vim.ArrayOfExtManagedEntityInfo;
         };
         ExtSolutionManagerInfoTabInfo: {
            (options?: vimService.vim.ExtSolutionManagerInfoTabInfo): vimService.vim.ExtSolutionManagerInfoTabInfo;
         };
         ArrayOfExtSolutionManagerInfoTabInfo: {
            (options?: vimService.vim.ArrayOfExtSolutionManagerInfoTabInfo): vimService.vim.ArrayOfExtSolutionManagerInfoTabInfo;
         };
         ExtSolutionManagerInfo: {
            (options?: vimService.vim.ExtSolutionManagerInfo): vimService.vim.ExtSolutionManagerInfo;
         };
         ActiveDirectoryFault: {
            (options?: vimService.vim.ActiveDirectoryFault): vimService.vim.ActiveDirectoryFault;
         };
         ActiveVMsBlockingEVC: {
            (options?: vimService.vim.ActiveVMsBlockingEVC): vimService.vim.ActiveVMsBlockingEVC;
         };
         AdminDisabled: {
            (options?: vimService.vim.AdminDisabled): vimService.vim.AdminDisabled;
         };
         AdminNotDisabled: {
            (options?: vimService.vim.AdminNotDisabled): vimService.vim.AdminNotDisabled;
         };
         AffinityType: {
            "memory": string;
            "cpu": string;
         };
         AffinityConfigured: {
            (options?: vimService.vim.AffinityConfigured): vimService.vim.AffinityConfigured;
         };
         AgentInstallFailedReason: {
            "NotEnoughSpaceOnDevice": string;
            "PrepareToUpgradeFailed": string;
            "AgentNotRunning": string;
            "AgentNotReachable": string;
            "InstallTimedout": string;
            "SignatureVerificationFailed": string;
            "AgentUploadFailed": string;
            "AgentUploadTimedout": string;
            "UnknownInstallerError": string;
         };
         AgentInstallFailed: {
            (options?: vimService.vim.AgentInstallFailed): vimService.vim.AgentInstallFailed;
         };
         AlreadyBeingManaged: {
            (options?: vimService.vim.AlreadyBeingManaged): vimService.vim.AlreadyBeingManaged;
         };
         AlreadyConnected: {
            (options?: vimService.vim.AlreadyConnected): vimService.vim.AlreadyConnected;
         };
         AlreadyExists: {
            (options?: vimService.vim.AlreadyExists): vimService.vim.AlreadyExists;
         };
         AlreadyUpgraded: {
            (options?: vimService.vim.AlreadyUpgraded): vimService.vim.AlreadyUpgraded;
         };
         AnswerFileUpdateFailure: {
            (options?: vimService.vim.AnswerFileUpdateFailure): vimService.vim.AnswerFileUpdateFailure;
         };
         ArrayOfAnswerFileUpdateFailure: {
            (options?: vimService.vim.ArrayOfAnswerFileUpdateFailure): vimService.vim.ArrayOfAnswerFileUpdateFailure;
         };
         AnswerFileUpdateFailed: {
            (options?: vimService.vim.AnswerFileUpdateFailed): vimService.vim.AnswerFileUpdateFailed;
         };
         ApplicationQuiesceFault: {
            (options?: vimService.vim.ApplicationQuiesceFault): vimService.vim.ApplicationQuiesceFault;
         };
         AuthMinimumAdminPermission: {
            (options?: vimService.vim.AuthMinimumAdminPermission): vimService.vim.AuthMinimumAdminPermission;
         };
         BackupBlobReadFailure: {
            (options?: vimService.vim.BackupBlobReadFailure): vimService.vim.BackupBlobReadFailure;
         };
         BackupBlobWriteFailure: {
            (options?: vimService.vim.BackupBlobWriteFailure): vimService.vim.BackupBlobWriteFailure;
         };
         BlockedByFirewall: {
            (options?: vimService.vim.BlockedByFirewall): vimService.vim.BlockedByFirewall;
         };
         CAMServerRefusedConnection: {
            (options?: vimService.vim.CAMServerRefusedConnection): vimService.vim.CAMServerRefusedConnection;
         };
         CannotAccessFile: {
            (options?: vimService.vim.CannotAccessFile): vimService.vim.CannotAccessFile;
         };
         CannotAccessLocalSource: {
            (options?: vimService.vim.CannotAccessLocalSource): vimService.vim.CannotAccessLocalSource;
         };
         CannotAccessNetwork: {
            (options?: vimService.vim.CannotAccessNetwork): vimService.vim.CannotAccessNetwork;
         };
         CannotAccessVmComponent: {
            (options?: vimService.vim.CannotAccessVmComponent): vimService.vim.CannotAccessVmComponent;
         };
         CannotAccessVmConfig: {
            (options?: vimService.vim.CannotAccessVmConfig): vimService.vim.CannotAccessVmConfig;
         };
         CannotAccessVmDevice: {
            (options?: vimService.vim.CannotAccessVmDevice): vimService.vim.CannotAccessVmDevice;
         };
         CannotAccessVmDisk: {
            (options?: vimService.vim.CannotAccessVmDisk): vimService.vim.CannotAccessVmDisk;
         };
         CannotAddHostWithFTVmAsStandalone: {
            (options?: vimService.vim.CannotAddHostWithFTVmAsStandalone): vimService.vim.CannotAddHostWithFTVmAsStandalone;
         };
         CannotAddHostWithFTVmToDifferentCluster: {
            (options?: vimService.vim.CannotAddHostWithFTVmToDifferentCluster): vimService.vim.CannotAddHostWithFTVmToDifferentCluster;
         };
         CannotAddHostWithFTVmToNonHACluster: {
            (options?: vimService.vim.CannotAddHostWithFTVmToNonHACluster): vimService.vim.CannotAddHostWithFTVmToNonHACluster;
         };
         CannotChangeDrsBehaviorForFtSecondary: {
            (options?: vimService.vim.CannotChangeDrsBehaviorForFtSecondary): vimService.vim.CannotChangeDrsBehaviorForFtSecondary;
         };
         CannotChangeHaSettingsForFtSecondary: {
            (options?: vimService.vim.CannotChangeHaSettingsForFtSecondary): vimService.vim.CannotChangeHaSettingsForFtSecondary;
         };
         CannotChangeVsanClusterUuid: {
            (options?: vimService.vim.CannotChangeVsanClusterUuid): vimService.vim.CannotChangeVsanClusterUuid;
         };
         CannotChangeVsanNodeUuid: {
            (options?: vimService.vim.CannotChangeVsanNodeUuid): vimService.vim.CannotChangeVsanNodeUuid;
         };
         CannotComputeFTCompatibleHosts: {
            (options?: vimService.vim.CannotComputeFTCompatibleHosts): vimService.vim.CannotComputeFTCompatibleHosts;
         };
         CannotCreateFile: {
            (options?: vimService.vim.CannotCreateFile): vimService.vim.CannotCreateFile;
         };
         CannotDecryptPasswords: {
            (options?: vimService.vim.CannotDecryptPasswords): vimService.vim.CannotDecryptPasswords;
         };
         CannotDeleteFile: {
            (options?: vimService.vim.CannotDeleteFile): vimService.vim.CannotDeleteFile;
         };
         CannotDisableDrsOnClusterManagedByVDC: {
            (options?: vimService.vim.CannotDisableDrsOnClusterManagedByVDC): vimService.vim.CannotDisableDrsOnClusterManagedByVDC;
         };
         CannotDisableDrsOnClustersWithVApps: {
            (options?: vimService.vim.CannotDisableDrsOnClustersWithVApps): vimService.vim.CannotDisableDrsOnClustersWithVApps;
         };
         CannotDisableSnapshot: {
            (options?: vimService.vim.CannotDisableSnapshot): vimService.vim.CannotDisableSnapshot;
         };
         CannotDisconnectHostWithFaultToleranceVm: {
            (options?: vimService.vim.CannotDisconnectHostWithFaultToleranceVm): vimService.vim.CannotDisconnectHostWithFaultToleranceVm;
         };
         CannotEnableVmcpForClusterReason: {
            "APDTimeoutDisabled": string;
            "IncompatibleHostVersion": string;
         };
         CannotEnableVmcpForCluster: {
            (options?: vimService.vim.CannotEnableVmcpForCluster): vimService.vim.CannotEnableVmcpForCluster;
         };
         CannotModifyConfigCpuRequirements: {
            (options?: vimService.vim.CannotModifyConfigCpuRequirements): vimService.vim.CannotModifyConfigCpuRequirements;
         };
         CannotMoveFaultToleranceVmMoveType: {
            "resourcePool": string;
            "cluster": string;
         };
         CannotMoveFaultToleranceVm: {
            (options?: vimService.vim.CannotMoveFaultToleranceVm): vimService.vim.CannotMoveFaultToleranceVm;
         };
         CannotMoveHostWithFaultToleranceVm: {
            (options?: vimService.vim.CannotMoveHostWithFaultToleranceVm): vimService.vim.CannotMoveHostWithFaultToleranceVm;
         };
         CannotMoveVmWithDeltaDisk: {
            (options?: vimService.vim.CannotMoveVmWithDeltaDisk): vimService.vim.CannotMoveVmWithDeltaDisk;
         };
         CannotMoveVmWithNativeDeltaDisk: {
            (options?: vimService.vim.CannotMoveVmWithNativeDeltaDisk): vimService.vim.CannotMoveVmWithNativeDeltaDisk;
         };
         CannotMoveVsanEnabledHost: {
            (options?: vimService.vim.CannotMoveVsanEnabledHost): vimService.vim.CannotMoveVsanEnabledHost;
         };
         CannotPlaceWithoutPrerequisiteMoves: {
            (options?: vimService.vim.CannotPlaceWithoutPrerequisiteMoves): vimService.vim.CannotPlaceWithoutPrerequisiteMoves;
         };
         CannotPowerOffVmInClusterOperation: {
            "suspend": string;
            "powerOff": string;
            "guestShutdown": string;
            "guestSuspend": string;
         };
         CannotPowerOffVmInCluster: {
            (options?: vimService.vim.CannotPowerOffVmInCluster): vimService.vim.CannotPowerOffVmInCluster;
         };
         CannotReconfigureVsanWhenHaEnabled: {
            (options?: vimService.vim.CannotReconfigureVsanWhenHaEnabled): vimService.vim.CannotReconfigureVsanWhenHaEnabled;
         };
         CannotUseNetworkReason: {
            "NetworkReservationNotSupported": string;
            "MismatchedNetworkPolicies": string;
            "MismatchedDvsVersionOrVendor": string;
            "VMotionToUnsupportedNetworkType": string;
         };
         CannotUseNetwork: {
            (options?: vimService.vim.CannotUseNetwork): vimService.vim.CannotUseNetwork;
         };
         ClockSkew: {
            (options?: vimService.vim.ClockSkew): vimService.vim.ClockSkew;
         };
         CloneFromSnapshotNotSupported: {
            (options?: vimService.vim.CloneFromSnapshotNotSupported): vimService.vim.CloneFromSnapshotNotSupported;
         };
         CollectorAddressUnset: {
            (options?: vimService.vim.CollectorAddressUnset): vimService.vim.CollectorAddressUnset;
         };
         ConcurrentAccess: {
            (options?: vimService.vim.ConcurrentAccess): vimService.vim.ConcurrentAccess;
         };
         ConflictingConfigurationConfig: {
            (options?: vimService.vim.ConflictingConfigurationConfig): vimService.vim.ConflictingConfigurationConfig;
         };
         ArrayOfConflictingConfigurationConfig: {
            (options?: vimService.vim.ArrayOfConflictingConfigurationConfig): vimService.vim.ArrayOfConflictingConfigurationConfig;
         };
         ConflictingConfiguration: {
            (options?: vimService.vim.ConflictingConfiguration): vimService.vim.ConflictingConfiguration;
         };
         ConflictingDatastoreFound: {
            (options?: vimService.vim.ConflictingDatastoreFound): vimService.vim.ConflictingDatastoreFound;
         };
         ConnectedIso: {
            (options?: vimService.vim.ConnectedIso): vimService.vim.ConnectedIso;
         };
         CpuCompatibilityUnknown: {
            (options?: vimService.vim.CpuCompatibilityUnknown): vimService.vim.CpuCompatibilityUnknown;
         };
         CpuHotPlugNotSupported: {
            (options?: vimService.vim.CpuHotPlugNotSupported): vimService.vim.CpuHotPlugNotSupported;
         };
         CpuIncompatible: {
            (options?: vimService.vim.CpuIncompatible): vimService.vim.CpuIncompatible;
         };
         CpuIncompatible1ECX: {
            (options?: vimService.vim.CpuIncompatible1ECX): vimService.vim.CpuIncompatible1ECX;
         };
         CpuIncompatible81EDX: {
            (options?: vimService.vim.CpuIncompatible81EDX): vimService.vim.CpuIncompatible81EDX;
         };
         CustomizationFault: {
            (options?: vimService.vim.CustomizationFault): vimService.vim.CustomizationFault;
         };
         CustomizationPending: {
            (options?: vimService.vim.CustomizationPending): vimService.vim.CustomizationPending;
         };
         DVPortNotSupported: {
            (options?: vimService.vim.DVPortNotSupported): vimService.vim.DVPortNotSupported;
         };
         DasConfigFaultDasConfigFaultReason: {
            "HostNetworkMisconfiguration": string;
            "HostMisconfiguration": string;
            "InsufficientPrivileges": string;
            "NoPrimaryAgentAvailable": string;
            "Other": string;
            "NoDatastoresConfigured": string;
            "CreateConfigVvolFailed": string;
            "VSanNotSupportedOnHost": string;
            "DasNetworkMisconfiguration": string;
         };
         DasConfigFault: {
            (options?: vimService.vim.DasConfigFault): vimService.vim.DasConfigFault;
         };
         DatabaseError: {
            (options?: vimService.vim.DatabaseError): vimService.vim.DatabaseError;
         };
         DatacenterMismatchArgument: {
            (options?: vimService.vim.DatacenterMismatchArgument): vimService.vim.DatacenterMismatchArgument;
         };
         ArrayOfDatacenterMismatchArgument: {
            (options?: vimService.vim.ArrayOfDatacenterMismatchArgument): vimService.vim.ArrayOfDatacenterMismatchArgument;
         };
         DatacenterMismatch: {
            (options?: vimService.vim.DatacenterMismatch): vimService.vim.DatacenterMismatch;
         };
         DatastoreNotWritableOnHost: {
            (options?: vimService.vim.DatastoreNotWritableOnHost): vimService.vim.DatastoreNotWritableOnHost;
         };
         DeltaDiskFormatNotSupported: {
            (options?: vimService.vim.DeltaDiskFormatNotSupported): vimService.vim.DeltaDiskFormatNotSupported;
         };
         DestinationSwitchFull: {
            (options?: vimService.vim.DestinationSwitchFull): vimService.vim.DestinationSwitchFull;
         };
         DestinationVsanDisabled: {
            (options?: vimService.vim.DestinationVsanDisabled): vimService.vim.DestinationVsanDisabled;
         };
         DeviceBackingNotSupported: {
            (options?: vimService.vim.DeviceBackingNotSupported): vimService.vim.DeviceBackingNotSupported;
         };
         DeviceControllerNotSupported: {
            (options?: vimService.vim.DeviceControllerNotSupported): vimService.vim.DeviceControllerNotSupported;
         };
         DeviceHotPlugNotSupported: {
            (options?: vimService.vim.DeviceHotPlugNotSupported): vimService.vim.DeviceHotPlugNotSupported;
         };
         DeviceNotFound: {
            (options?: vimService.vim.DeviceNotFound): vimService.vim.DeviceNotFound;
         };
         DeviceNotSupportedReason: {
            "host": string;
            "guest": string;
         };
         DeviceNotSupported: {
            (options?: vimService.vim.DeviceNotSupported): vimService.vim.DeviceNotSupported;
         };
         DeviceUnsupportedForVmPlatform: {
            (options?: vimService.vim.DeviceUnsupportedForVmPlatform): vimService.vim.DeviceUnsupportedForVmPlatform;
         };
         DeviceUnsupportedForVmVersion: {
            (options?: vimService.vim.DeviceUnsupportedForVmVersion): vimService.vim.DeviceUnsupportedForVmVersion;
         };
         DigestNotSupported: {
            (options?: vimService.vim.DigestNotSupported): vimService.vim.DigestNotSupported;
         };
         DirectoryNotEmpty: {
            (options?: vimService.vim.DirectoryNotEmpty): vimService.vim.DirectoryNotEmpty;
         };
         DisableAdminNotSupported: {
            (options?: vimService.vim.DisableAdminNotSupported): vimService.vim.DisableAdminNotSupported;
         };
         DisallowedChangeByServiceDisallowedChange: {
            "hotExtendDisk": string;
         };
         DisallowedChangeByService: {
            (options?: vimService.vim.DisallowedChangeByService): vimService.vim.DisallowedChangeByService;
         };
         DisallowedDiskModeChange: {
            (options?: vimService.vim.DisallowedDiskModeChange): vimService.vim.DisallowedDiskModeChange;
         };
         DisallowedMigrationDeviceAttached: {
            (options?: vimService.vim.DisallowedMigrationDeviceAttached): vimService.vim.DisallowedMigrationDeviceAttached;
         };
         DisallowedOperationOnFailoverHost: {
            (options?: vimService.vim.DisallowedOperationOnFailoverHost): vimService.vim.DisallowedOperationOnFailoverHost;
         };
         DisconnectedHostsBlockingEVC: {
            (options?: vimService.vim.DisconnectedHostsBlockingEVC): vimService.vim.DisconnectedHostsBlockingEVC;
         };
         DiskHasPartitions: {
            (options?: vimService.vim.DiskHasPartitions): vimService.vim.DiskHasPartitions;
         };
         DiskIsLastRemainingNonSSD: {
            (options?: vimService.vim.DiskIsLastRemainingNonSSD): vimService.vim.DiskIsLastRemainingNonSSD;
         };
         DiskIsNonLocal: {
            (options?: vimService.vim.DiskIsNonLocal): vimService.vim.DiskIsNonLocal;
         };
         DiskIsUSB: {
            (options?: vimService.vim.DiskIsUSB): vimService.vim.DiskIsUSB;
         };
         DiskMoveTypeNotSupported: {
            (options?: vimService.vim.DiskMoveTypeNotSupported): vimService.vim.DiskMoveTypeNotSupported;
         };
         DiskNotSupported: {
            (options?: vimService.vim.DiskNotSupported): vimService.vim.DiskNotSupported;
         };
         DiskTooSmall: {
            (options?: vimService.vim.DiskTooSmall): vimService.vim.DiskTooSmall;
         };
         DomainNotFound: {
            (options?: vimService.vim.DomainNotFound): vimService.vim.DomainNotFound;
         };
         DrsDisabledOnVm: {
            (options?: vimService.vim.DrsDisabledOnVm): vimService.vim.DrsDisabledOnVm;
         };
         DrsVmotionIncompatibleFault: {
            (options?: vimService.vim.DrsVmotionIncompatibleFault): vimService.vim.DrsVmotionIncompatibleFault;
         };
         DuplicateDisks: {
            (options?: vimService.vim.DuplicateDisks): vimService.vim.DuplicateDisks;
         };
         DuplicateName: {
            (options?: vimService.vim.DuplicateName): vimService.vim.DuplicateName;
         };
         DuplicateVsanNetworkInterface: {
            (options?: vimService.vim.DuplicateVsanNetworkInterface): vimService.vim.DuplicateVsanNetworkInterface;
         };
         DvsApplyOperationFaultFaultOnObject: {
            (options?: vimService.vim.DvsApplyOperationFaultFaultOnObject): vimService.vim.DvsApplyOperationFaultFaultOnObject;
         };
         ArrayOfDvsApplyOperationFaultFaultOnObject: {
            (options?: vimService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject): vimService.vim.ArrayOfDvsApplyOperationFaultFaultOnObject;
         };
         DvsApplyOperationFault: {
            (options?: vimService.vim.DvsApplyOperationFault): vimService.vim.DvsApplyOperationFault;
         };
         DvsFault: {
            (options?: vimService.vim.DvsFault): vimService.vim.DvsFault;
         };
         DvsNotAuthorized: {
            (options?: vimService.vim.DvsNotAuthorized): vimService.vim.DvsNotAuthorized;
         };
         DvsOperationBulkFaultFaultOnHost: {
            (options?: vimService.vim.DvsOperationBulkFaultFaultOnHost): vimService.vim.DvsOperationBulkFaultFaultOnHost;
         };
         ArrayOfDvsOperationBulkFaultFaultOnHost: {
            (options?: vimService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost): vimService.vim.ArrayOfDvsOperationBulkFaultFaultOnHost;
         };
         DvsOperationBulkFault: {
            (options?: vimService.vim.DvsOperationBulkFault): vimService.vim.DvsOperationBulkFault;
         };
         DvsScopeViolated: {
            (options?: vimService.vim.DvsScopeViolated): vimService.vim.DvsScopeViolated;
         };
         EVCAdmissionFailed: {
            (options?: vimService.vim.EVCAdmissionFailed): vimService.vim.EVCAdmissionFailed;
         };
         EVCAdmissionFailedCPUFeaturesForMode: {
            (options?: vimService.vim.EVCAdmissionFailedCPUFeaturesForMode): vimService.vim.EVCAdmissionFailedCPUFeaturesForMode;
         };
         EVCAdmissionFailedCPUModel: {
            (options?: vimService.vim.EVCAdmissionFailedCPUModel): vimService.vim.EVCAdmissionFailedCPUModel;
         };
         EVCAdmissionFailedCPUModelForMode: {
            (options?: vimService.vim.EVCAdmissionFailedCPUModelForMode): vimService.vim.EVCAdmissionFailedCPUModelForMode;
         };
         EVCAdmissionFailedCPUVendor: {
            (options?: vimService.vim.EVCAdmissionFailedCPUVendor): vimService.vim.EVCAdmissionFailedCPUVendor;
         };
         EVCAdmissionFailedCPUVendorUnknown: {
            (options?: vimService.vim.EVCAdmissionFailedCPUVendorUnknown): vimService.vim.EVCAdmissionFailedCPUVendorUnknown;
         };
         EVCAdmissionFailedHostDisconnected: {
            (options?: vimService.vim.EVCAdmissionFailedHostDisconnected): vimService.vim.EVCAdmissionFailedHostDisconnected;
         };
         EVCAdmissionFailedHostSoftware: {
            (options?: vimService.vim.EVCAdmissionFailedHostSoftware): vimService.vim.EVCAdmissionFailedHostSoftware;
         };
         EVCAdmissionFailedHostSoftwareForMode: {
            (options?: vimService.vim.EVCAdmissionFailedHostSoftwareForMode): vimService.vim.EVCAdmissionFailedHostSoftwareForMode;
         };
         EVCAdmissionFailedVmActive: {
            (options?: vimService.vim.EVCAdmissionFailedVmActive): vimService.vim.EVCAdmissionFailedVmActive;
         };
         EVCConfigFault: {
            (options?: vimService.vim.EVCConfigFault): vimService.vim.EVCConfigFault;
         };
         EVCModeIllegalByVendor: {
            (options?: vimService.vim.EVCModeIllegalByVendor): vimService.vim.EVCModeIllegalByVendor;
         };
         EVCModeUnsupportedByHosts: {
            (options?: vimService.vim.EVCModeUnsupportedByHosts): vimService.vim.EVCModeUnsupportedByHosts;
         };
         EVCUnsupportedByHostHardware: {
            (options?: vimService.vim.EVCUnsupportedByHostHardware): vimService.vim.EVCUnsupportedByHostHardware;
         };
         EVCUnsupportedByHostSoftware: {
            (options?: vimService.vim.EVCUnsupportedByHostSoftware): vimService.vim.EVCUnsupportedByHostSoftware;
         };
         EightHostLimitViolated: {
            (options?: vimService.vim.EightHostLimitViolated): vimService.vim.EightHostLimitViolated;
         };
         ExpiredAddonLicense: {
            (options?: vimService.vim.ExpiredAddonLicense): vimService.vim.ExpiredAddonLicense;
         };
         ExpiredEditionLicense: {
            (options?: vimService.vim.ExpiredEditionLicense): vimService.vim.ExpiredEditionLicense;
         };
         ExpiredFeatureLicense: {
            (options?: vimService.vim.ExpiredFeatureLicense): vimService.vim.ExpiredFeatureLicense;
         };
         ExtendedFault: {
            (options?: vimService.vim.ExtendedFault): vimService.vim.ExtendedFault;
         };
         FailToEnableSPBM: {
            (options?: vimService.vim.FailToEnableSPBM): vimService.vim.FailToEnableSPBM;
         };
         FailToLockFaultToleranceVMs: {
            (options?: vimService.vim.FailToLockFaultToleranceVMs): vimService.vim.FailToLockFaultToleranceVMs;
         };
         FaultToleranceAntiAffinityViolated: {
            (options?: vimService.vim.FaultToleranceAntiAffinityViolated): vimService.vim.FaultToleranceAntiAffinityViolated;
         };
         FaultToleranceCannotEditMem: {
            (options?: vimService.vim.FaultToleranceCannotEditMem): vimService.vim.FaultToleranceCannotEditMem;
         };
         FaultToleranceCpuIncompatible: {
            (options?: vimService.vim.FaultToleranceCpuIncompatible): vimService.vim.FaultToleranceCpuIncompatible;
         };
         FaultToleranceNeedsThickDisk: {
            (options?: vimService.vim.FaultToleranceNeedsThickDisk): vimService.vim.FaultToleranceNeedsThickDisk;
         };
         FaultToleranceNotLicensed: {
            (options?: vimService.vim.FaultToleranceNotLicensed): vimService.vim.FaultToleranceNotLicensed;
         };
         FaultToleranceNotSameBuild: {
            (options?: vimService.vim.FaultToleranceNotSameBuild): vimService.vim.FaultToleranceNotSameBuild;
         };
         FaultTolerancePrimaryPowerOnNotAttempted: {
            (options?: vimService.vim.FaultTolerancePrimaryPowerOnNotAttempted): vimService.vim.FaultTolerancePrimaryPowerOnNotAttempted;
         };
         FaultToleranceVmNotDasProtected: {
            (options?: vimService.vim.FaultToleranceVmNotDasProtected): vimService.vim.FaultToleranceVmNotDasProtected;
         };
         FcoeFault: {
            (options?: vimService.vim.FcoeFault): vimService.vim.FcoeFault;
         };
         FcoeFaultPnicHasNoPortSet: {
            (options?: vimService.vim.FcoeFaultPnicHasNoPortSet): vimService.vim.FcoeFaultPnicHasNoPortSet;
         };
         FeatureRequirementsNotMet: {
            (options?: vimService.vim.FeatureRequirementsNotMet): vimService.vim.FeatureRequirementsNotMet;
         };
         FileAlreadyExists: {
            (options?: vimService.vim.FileAlreadyExists): vimService.vim.FileAlreadyExists;
         };
         FileBackedPortNotSupported: {
            (options?: vimService.vim.FileBackedPortNotSupported): vimService.vim.FileBackedPortNotSupported;
         };
         FileFault: {
            (options?: vimService.vim.FileFault): vimService.vim.FileFault;
         };
         FileLocked: {
            (options?: vimService.vim.FileLocked): vimService.vim.FileLocked;
         };
         FileNameTooLong: {
            (options?: vimService.vim.FileNameTooLong): vimService.vim.FileNameTooLong;
         };
         FileNotFound: {
            (options?: vimService.vim.FileNotFound): vimService.vim.FileNotFound;
         };
         FileNotWritable: {
            (options?: vimService.vim.FileNotWritable): vimService.vim.FileNotWritable;
         };
         FileTooLarge: {
            (options?: vimService.vim.FileTooLarge): vimService.vim.FileTooLarge;
         };
         FilesystemQuiesceFault: {
            (options?: vimService.vim.FilesystemQuiesceFault): vimService.vim.FilesystemQuiesceFault;
         };
         FilterInUse: {
            (options?: vimService.vim.FilterInUse): vimService.vim.FilterInUse;
         };
         FtIssuesOnHostHostSelectionType: {
            "user": string;
            "vc": string;
            "drs": string;
         };
         FtIssuesOnHost: {
            (options?: vimService.vim.FtIssuesOnHost): vimService.vim.FtIssuesOnHost;
         };
         FullStorageVMotionNotSupported: {
            (options?: vimService.vim.FullStorageVMotionNotSupported): vimService.vim.FullStorageVMotionNotSupported;
         };
         GatewayConnectFault: {
            (options?: vimService.vim.GatewayConnectFault): vimService.vim.GatewayConnectFault;
         };
         GatewayHostNotReachable: {
            (options?: vimService.vim.GatewayHostNotReachable): vimService.vim.GatewayHostNotReachable;
         };
         GatewayNotFound: {
            (options?: vimService.vim.GatewayNotFound): vimService.vim.GatewayNotFound;
         };
         GatewayNotReachable: {
            (options?: vimService.vim.GatewayNotReachable): vimService.vim.GatewayNotReachable;
         };
         GatewayOperationRefused: {
            (options?: vimService.vim.GatewayOperationRefused): vimService.vim.GatewayOperationRefused;
         };
         GatewayToHostAuthFault: {
            (options?: vimService.vim.GatewayToHostAuthFault): vimService.vim.GatewayToHostAuthFault;
         };
         GatewayToHostConnectFault: {
            (options?: vimService.vim.GatewayToHostConnectFault): vimService.vim.GatewayToHostConnectFault;
         };
         GatewayToHostTrustVerifyFault: {
            (options?: vimService.vim.GatewayToHostTrustVerifyFault): vimService.vim.GatewayToHostTrustVerifyFault;
         };
         GenericDrsFault: {
            (options?: vimService.vim.GenericDrsFault): vimService.vim.GenericDrsFault;
         };
         GenericVmConfigFault: {
            (options?: vimService.vim.GenericVmConfigFault): vimService.vim.GenericVmConfigFault;
         };
         GuestAuthenticationChallenge: {
            (options?: vimService.vim.GuestAuthenticationChallenge): vimService.vim.GuestAuthenticationChallenge;
         };
         GuestComponentsOutOfDate: {
            (options?: vimService.vim.GuestComponentsOutOfDate): vimService.vim.GuestComponentsOutOfDate;
         };
         GuestMultipleMappings: {
            (options?: vimService.vim.GuestMultipleMappings): vimService.vim.GuestMultipleMappings;
         };
         GuestOperationsFault: {
            (options?: vimService.vim.GuestOperationsFault): vimService.vim.GuestOperationsFault;
         };
         GuestOperationsUnavailable: {
            (options?: vimService.vim.GuestOperationsUnavailable): vimService.vim.GuestOperationsUnavailable;
         };
         GuestPermissionDenied: {
            (options?: vimService.vim.GuestPermissionDenied): vimService.vim.GuestPermissionDenied;
         };
         GuestProcessNotFound: {
            (options?: vimService.vim.GuestProcessNotFound): vimService.vim.GuestProcessNotFound;
         };
         GuestRegistryFault: {
            (options?: vimService.vim.GuestRegistryFault): vimService.vim.GuestRegistryFault;
         };
         GuestRegistryKeyAlreadyExists: {
            (options?: vimService.vim.GuestRegistryKeyAlreadyExists): vimService.vim.GuestRegistryKeyAlreadyExists;
         };
         GuestRegistryKeyFault: {
            (options?: vimService.vim.GuestRegistryKeyFault): vimService.vim.GuestRegistryKeyFault;
         };
         GuestRegistryKeyHasSubkeys: {
            (options?: vimService.vim.GuestRegistryKeyHasSubkeys): vimService.vim.GuestRegistryKeyHasSubkeys;
         };
         GuestRegistryKeyInvalid: {
            (options?: vimService.vim.GuestRegistryKeyInvalid): vimService.vim.GuestRegistryKeyInvalid;
         };
         GuestRegistryKeyParentVolatile: {
            (options?: vimService.vim.GuestRegistryKeyParentVolatile): vimService.vim.GuestRegistryKeyParentVolatile;
         };
         GuestRegistryValueFault: {
            (options?: vimService.vim.GuestRegistryValueFault): vimService.vim.GuestRegistryValueFault;
         };
         GuestRegistryValueNotFound: {
            (options?: vimService.vim.GuestRegistryValueNotFound): vimService.vim.GuestRegistryValueNotFound;
         };
         HAErrorsAtDest: {
            (options?: vimService.vim.HAErrorsAtDest): vimService.vim.HAErrorsAtDest;
         };
         HeterogenousHostsBlockingEVC: {
            (options?: vimService.vim.HeterogenousHostsBlockingEVC): vimService.vim.HeterogenousHostsBlockingEVC;
         };
         HostAccessRestrictedToManagementServer: {
            (options?: vimService.vim.HostAccessRestrictedToManagementServer): vimService.vim.HostAccessRestrictedToManagementServer;
         };
         HostConfigFailed: {
            (options?: vimService.vim.HostConfigFailed): vimService.vim.HostConfigFailed;
         };
         HostConfigFault: {
            (options?: vimService.vim.HostConfigFault): vimService.vim.HostConfigFault;
         };
         HostConnectFault: {
            (options?: vimService.vim.HostConnectFault): vimService.vim.HostConnectFault;
         };
         HostHasComponentFailureHostComponentType: {
            "Datastore": string;
         };
         HostHasComponentFailure: {
            (options?: vimService.vim.HostHasComponentFailure): vimService.vim.HostHasComponentFailure;
         };
         HostInDomain: {
            (options?: vimService.vim.HostInDomain): vimService.vim.HostInDomain;
         };
         HostIncompatibleForFaultToleranceReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForFaultTolerance: {
            (options?: vimService.vim.HostIncompatibleForFaultTolerance): vimService.vim.HostIncompatibleForFaultTolerance;
         };
         HostIncompatibleForRecordReplayReason: {
            "product": string;
            "processor": string;
         };
         HostIncompatibleForRecordReplay: {
            (options?: vimService.vim.HostIncompatibleForRecordReplay): vimService.vim.HostIncompatibleForRecordReplay;
         };
         HostInventoryFull: {
            (options?: vimService.vim.HostInventoryFull): vimService.vim.HostInventoryFull;
         };
         HostPowerOpFailed: {
            (options?: vimService.vim.HostPowerOpFailed): vimService.vim.HostPowerOpFailed;
         };
         HotSnapshotMoveNotSupported: {
            (options?: vimService.vim.HotSnapshotMoveNotSupported): vimService.vim.HotSnapshotMoveNotSupported;
         };
         IDEDiskNotSupported: {
            (options?: vimService.vim.IDEDiskNotSupported): vimService.vim.IDEDiskNotSupported;
         };
         IORMNotSupportedHostOnDatastore: {
            (options?: vimService.vim.IORMNotSupportedHostOnDatastore): vimService.vim.IORMNotSupportedHostOnDatastore;
         };
         ImportHostAddFailure: {
            (options?: vimService.vim.ImportHostAddFailure): vimService.vim.ImportHostAddFailure;
         };
         ImportOperationBulkFaultFaultOnImport: {
            (options?: vimService.vim.ImportOperationBulkFaultFaultOnImport): vimService.vim.ImportOperationBulkFaultFaultOnImport;
         };
         ArrayOfImportOperationBulkFaultFaultOnImport: {
            (options?: vimService.vim.ArrayOfImportOperationBulkFaultFaultOnImport): vimService.vim.ArrayOfImportOperationBulkFaultFaultOnImport;
         };
         ImportOperationBulkFault: {
            (options?: vimService.vim.ImportOperationBulkFault): vimService.vim.ImportOperationBulkFault;
         };
         InUseFeatureManipulationDisallowed: {
            (options?: vimService.vim.InUseFeatureManipulationDisallowed): vimService.vim.InUseFeatureManipulationDisallowed;
         };
         InaccessibleDatastore: {
            (options?: vimService.vim.InaccessibleDatastore): vimService.vim.InaccessibleDatastore;
         };
         InaccessibleFTMetadataDatastore: {
            (options?: vimService.vim.InaccessibleFTMetadataDatastore): vimService.vim.InaccessibleFTMetadataDatastore;
         };
         InaccessibleVFlashSource: {
            (options?: vimService.vim.InaccessibleVFlashSource): vimService.vim.InaccessibleVFlashSource;
         };
         IncompatibleDefaultDevice: {
            (options?: vimService.vim.IncompatibleDefaultDevice): vimService.vim.IncompatibleDefaultDevice;
         };
         IncompatibleHostForFtSecondary: {
            (options?: vimService.vim.IncompatibleHostForFtSecondary): vimService.vim.IncompatibleHostForFtSecondary;
         };
         IncompatibleHostForVmReplicationIncompatibleReason: {
            "rpo": string;
            "netCompression": string;
         };
         IncompatibleHostForVmReplication: {
            (options?: vimService.vim.IncompatibleHostForVmReplication): vimService.vim.IncompatibleHostForVmReplication;
         };
         IncompatibleSetting: {
            (options?: vimService.vim.IncompatibleSetting): vimService.vim.IncompatibleSetting;
         };
         IncorrectFileType: {
            (options?: vimService.vim.IncorrectFileType): vimService.vim.IncorrectFileType;
         };
         IncorrectHostInformation: {
            (options?: vimService.vim.IncorrectHostInformation): vimService.vim.IncorrectHostInformation;
         };
         IndependentDiskVMotionNotSupported: {
            (options?: vimService.vim.IndependentDiskVMotionNotSupported): vimService.vim.IndependentDiskVMotionNotSupported;
         };
         InsufficientAgentVmsDeployed: {
            (options?: vimService.vim.InsufficientAgentVmsDeployed): vimService.vim.InsufficientAgentVmsDeployed;
         };
         InsufficientCpuResourcesFault: {
            (options?: vimService.vim.InsufficientCpuResourcesFault): vimService.vim.InsufficientCpuResourcesFault;
         };
         InsufficientDisks: {
            (options?: vimService.vim.InsufficientDisks): vimService.vim.InsufficientDisks;
         };
         InsufficientFailoverResourcesFault: {
            (options?: vimService.vim.InsufficientFailoverResourcesFault): vimService.vim.InsufficientFailoverResourcesFault;
         };
         InsufficientGraphicsResourcesFault: {
            (options?: vimService.vim.InsufficientGraphicsResourcesFault): vimService.vim.InsufficientGraphicsResourcesFault;
         };
         InsufficientHostCapacityFault: {
            (options?: vimService.vim.InsufficientHostCapacityFault): vimService.vim.InsufficientHostCapacityFault;
         };
         InsufficientHostCpuCapacityFault: {
            (options?: vimService.vim.InsufficientHostCpuCapacityFault): vimService.vim.InsufficientHostCpuCapacityFault;
         };
         InsufficientHostMemoryCapacityFault: {
            (options?: vimService.vim.InsufficientHostMemoryCapacityFault): vimService.vim.InsufficientHostMemoryCapacityFault;
         };
         InsufficientMemoryResourcesFault: {
            (options?: vimService.vim.InsufficientMemoryResourcesFault): vimService.vim.InsufficientMemoryResourcesFault;
         };
         InsufficientNetworkCapacity: {
            (options?: vimService.vim.InsufficientNetworkCapacity): vimService.vim.InsufficientNetworkCapacity;
         };
         InsufficientNetworkResourcePoolCapacity: {
            (options?: vimService.vim.InsufficientNetworkResourcePoolCapacity): vimService.vim.InsufficientNetworkResourcePoolCapacity;
         };
         InsufficientPerCpuCapacity: {
            (options?: vimService.vim.InsufficientPerCpuCapacity): vimService.vim.InsufficientPerCpuCapacity;
         };
         InsufficientResourcesFault: {
            (options?: vimService.vim.InsufficientResourcesFault): vimService.vim.InsufficientResourcesFault;
         };
         InsufficientStandbyCpuResource: {
            (options?: vimService.vim.InsufficientStandbyCpuResource): vimService.vim.InsufficientStandbyCpuResource;
         };
         InsufficientStandbyMemoryResource: {
            (options?: vimService.vim.InsufficientStandbyMemoryResource): vimService.vim.InsufficientStandbyMemoryResource;
         };
         InsufficientStandbyResource: {
            (options?: vimService.vim.InsufficientStandbyResource): vimService.vim.InsufficientStandbyResource;
         };
         InsufficientStorageIops: {
            (options?: vimService.vim.InsufficientStorageIops): vimService.vim.InsufficientStorageIops;
         };
         InsufficientStorageSpace: {
            (options?: vimService.vim.InsufficientStorageSpace): vimService.vim.InsufficientStorageSpace;
         };
         InsufficientVFlashResourcesFault: {
            (options?: vimService.vim.InsufficientVFlashResourcesFault): vimService.vim.InsufficientVFlashResourcesFault;
         };
         InvalidAffinitySettingFault: {
            (options?: vimService.vim.InvalidAffinitySettingFault): vimService.vim.InvalidAffinitySettingFault;
         };
         InvalidBmcRole: {
            (options?: vimService.vim.InvalidBmcRole): vimService.vim.InvalidBmcRole;
         };
         InvalidBundle: {
            (options?: vimService.vim.InvalidBundle): vimService.vim.InvalidBundle;
         };
         InvalidCAMCertificate: {
            (options?: vimService.vim.InvalidCAMCertificate): vimService.vim.InvalidCAMCertificate;
         };
         InvalidCAMServer: {
            (options?: vimService.vim.InvalidCAMServer): vimService.vim.InvalidCAMServer;
         };
         InvalidClientCertificate: {
            (options?: vimService.vim.InvalidClientCertificate): vimService.vim.InvalidClientCertificate;
         };
         InvalidController: {
            (options?: vimService.vim.InvalidController): vimService.vim.InvalidController;
         };
         InvalidDasConfigArgumentEntryForInvalidArgument: {
            "admissionControl": string;
            "userHeartbeatDs": string;
            "vmConfig": string;
         };
         InvalidDasConfigArgument: {
            (options?: vimService.vim.InvalidDasConfigArgument): vimService.vim.InvalidDasConfigArgument;
         };
         InvalidDasRestartPriorityForFtVm: {
            (options?: vimService.vim.InvalidDasRestartPriorityForFtVm): vimService.vim.InvalidDasRestartPriorityForFtVm;
         };
         InvalidDatastore: {
            (options?: vimService.vim.InvalidDatastore): vimService.vim.InvalidDatastore;
         };
         InvalidDatastorePath: {
            (options?: vimService.vim.InvalidDatastorePath): vimService.vim.InvalidDatastorePath;
         };
         InvalidDatastoreState: {
            (options?: vimService.vim.InvalidDatastoreState): vimService.vim.InvalidDatastoreState;
         };
         InvalidDeviceBacking: {
            (options?: vimService.vim.InvalidDeviceBacking): vimService.vim.InvalidDeviceBacking;
         };
         InvalidDeviceOperation: {
            (options?: vimService.vim.InvalidDeviceOperation): vimService.vim.InvalidDeviceOperation;
         };
         InvalidDeviceSpec: {
            (options?: vimService.vim.InvalidDeviceSpec): vimService.vim.InvalidDeviceSpec;
         };
         InvalidDiskFormat: {
            (options?: vimService.vim.InvalidDiskFormat): vimService.vim.InvalidDiskFormat;
         };
         InvalidDrsBehaviorForFtVm: {
            (options?: vimService.vim.InvalidDrsBehaviorForFtVm): vimService.vim.InvalidDrsBehaviorForFtVm;
         };
         InvalidEditionLicense: {
            (options?: vimService.vim.InvalidEditionLicense): vimService.vim.InvalidEditionLicense;
         };
         InvalidEvent: {
            (options?: vimService.vim.InvalidEvent): vimService.vim.InvalidEvent;
         };
         InvalidFolder: {
            (options?: vimService.vim.InvalidFolder): vimService.vim.InvalidFolder;
         };
         InvalidFormat: {
            (options?: vimService.vim.InvalidFormat): vimService.vim.InvalidFormat;
         };
         InvalidGuestLogin: {
            (options?: vimService.vim.InvalidGuestLogin): vimService.vim.InvalidGuestLogin;
         };
         InvalidHostConnectionState: {
            (options?: vimService.vim.InvalidHostConnectionState): vimService.vim.InvalidHostConnectionState;
         };
         InvalidHostName: {
            (options?: vimService.vim.InvalidHostName): vimService.vim.InvalidHostName;
         };
         InvalidHostState: {
            (options?: vimService.vim.InvalidHostState): vimService.vim.InvalidHostState;
         };
         InvalidIndexArgument: {
            (options?: vimService.vim.InvalidIndexArgument): vimService.vim.InvalidIndexArgument;
         };
         InvalidIpfixConfig: {
            (options?: vimService.vim.InvalidIpfixConfig): vimService.vim.InvalidIpfixConfig;
         };
         InvalidIpmiLoginInfo: {
            (options?: vimService.vim.InvalidIpmiLoginInfo): vimService.vim.InvalidIpmiLoginInfo;
         };
         InvalidIpmiMacAddress: {
            (options?: vimService.vim.InvalidIpmiMacAddress): vimService.vim.InvalidIpmiMacAddress;
         };
         InvalidLicense: {
            (options?: vimService.vim.InvalidLicense): vimService.vim.InvalidLicense;
         };
         InvalidLocale: {
            (options?: vimService.vim.InvalidLocale): vimService.vim.InvalidLocale;
         };
         InvalidLogin: {
            (options?: vimService.vim.InvalidLogin): vimService.vim.InvalidLogin;
         };
         InvalidName: {
            (options?: vimService.vim.InvalidName): vimService.vim.InvalidName;
         };
         InvalidNasCredentials: {
            (options?: vimService.vim.InvalidNasCredentials): vimService.vim.InvalidNasCredentials;
         };
         InvalidNetworkInType: {
            (options?: vimService.vim.InvalidNetworkInType): vimService.vim.InvalidNetworkInType;
         };
         InvalidNetworkResource: {
            (options?: vimService.vim.InvalidNetworkResource): vimService.vim.InvalidNetworkResource;
         };
         InvalidOperationOnSecondaryVm: {
            (options?: vimService.vim.InvalidOperationOnSecondaryVm): vimService.vim.InvalidOperationOnSecondaryVm;
         };
         InvalidPowerState: {
            (options?: vimService.vim.InvalidPowerState): vimService.vim.InvalidPowerState;
         };
         InvalidPrivilege: {
            (options?: vimService.vim.InvalidPrivilege): vimService.vim.InvalidPrivilege;
         };
         InvalidProfileReferenceHostReason: {
            "incompatibleVersion": string;
            "missingReferenceHost": string;
         };
         InvalidProfileReferenceHost: {
            (options?: vimService.vim.InvalidProfileReferenceHost): vimService.vim.InvalidProfileReferenceHost;
         };
         InvalidPropertyType: {
            (options?: vimService.vim.InvalidPropertyType): vimService.vim.InvalidPropertyType;
         };
         InvalidPropertyValue: {
            (options?: vimService.vim.InvalidPropertyValue): vimService.vim.InvalidPropertyValue;
         };
         InvalidResourcePoolStructureFault: {
            (options?: vimService.vim.InvalidResourcePoolStructureFault): vimService.vim.InvalidResourcePoolStructureFault;
         };
         InvalidSnapshotFormat: {
            (options?: vimService.vim.InvalidSnapshotFormat): vimService.vim.InvalidSnapshotFormat;
         };
         InvalidState: {
            (options?: vimService.vim.InvalidState): vimService.vim.InvalidState;
         };
         InvalidVmConfig: {
            (options?: vimService.vim.InvalidVmConfig): vimService.vim.InvalidVmConfig;
         };
         InventoryHasStandardAloneHosts: {
            (options?: vimService.vim.InventoryHasStandardAloneHosts): vimService.vim.InventoryHasStandardAloneHosts;
         };
         IpHostnameGeneratorError: {
            (options?: vimService.vim.IpHostnameGeneratorError): vimService.vim.IpHostnameGeneratorError;
         };
         IscsiFault: {
            (options?: vimService.vim.IscsiFault): vimService.vim.IscsiFault;
         };
         IscsiFaultInvalidVnic: {
            (options?: vimService.vim.IscsiFaultInvalidVnic): vimService.vim.IscsiFaultInvalidVnic;
         };
         IscsiFaultPnicInUse: {
            (options?: vimService.vim.IscsiFaultPnicInUse): vimService.vim.IscsiFaultPnicInUse;
         };
         IscsiFaultVnicAlreadyBound: {
            (options?: vimService.vim.IscsiFaultVnicAlreadyBound): vimService.vim.IscsiFaultVnicAlreadyBound;
         };
         IscsiFaultVnicHasActivePaths: {
            (options?: vimService.vim.IscsiFaultVnicHasActivePaths): vimService.vim.IscsiFaultVnicHasActivePaths;
         };
         IscsiFaultVnicHasMultipleUplinks: {
            (options?: vimService.vim.IscsiFaultVnicHasMultipleUplinks): vimService.vim.IscsiFaultVnicHasMultipleUplinks;
         };
         IscsiFaultVnicHasNoUplinks: {
            (options?: vimService.vim.IscsiFaultVnicHasNoUplinks): vimService.vim.IscsiFaultVnicHasNoUplinks;
         };
         IscsiFaultVnicHasWrongUplink: {
            (options?: vimService.vim.IscsiFaultVnicHasWrongUplink): vimService.vim.IscsiFaultVnicHasWrongUplink;
         };
         IscsiFaultVnicInUse: {
            (options?: vimService.vim.IscsiFaultVnicInUse): vimService.vim.IscsiFaultVnicInUse;
         };
         IscsiFaultVnicIsLastPath: {
            (options?: vimService.vim.IscsiFaultVnicIsLastPath): vimService.vim.IscsiFaultVnicIsLastPath;
         };
         IscsiFaultVnicNotBound: {
            (options?: vimService.vim.IscsiFaultVnicNotBound): vimService.vim.IscsiFaultVnicNotBound;
         };
         IscsiFaultVnicNotFound: {
            (options?: vimService.vim.IscsiFaultVnicNotFound): vimService.vim.IscsiFaultVnicNotFound;
         };
         LargeRDMConversionNotSupported: {
            (options?: vimService.vim.LargeRDMConversionNotSupported): vimService.vim.LargeRDMConversionNotSupported;
         };
         LargeRDMNotSupportedOnDatastore: {
            (options?: vimService.vim.LargeRDMNotSupportedOnDatastore): vimService.vim.LargeRDMNotSupportedOnDatastore;
         };
         LegacyNetworkInterfaceInUse: {
            (options?: vimService.vim.LegacyNetworkInterfaceInUse): vimService.vim.LegacyNetworkInterfaceInUse;
         };
         LicenseAssignmentFailedReason: {
            "keyEntityMismatch": string;
            "downgradeDisallowed": string;
            "inventoryNotManageableByVirtualCenter": string;
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer": string;
         };
         LicenseAssignmentFailed: {
            (options?: vimService.vim.LicenseAssignmentFailed): vimService.vim.LicenseAssignmentFailed;
         };
         LicenseDowngradeDisallowed: {
            (options?: vimService.vim.LicenseDowngradeDisallowed): vimService.vim.LicenseDowngradeDisallowed;
         };
         LicenseEntityNotFound: {
            (options?: vimService.vim.LicenseEntityNotFound): vimService.vim.LicenseEntityNotFound;
         };
         LicenseExpired: {
            (options?: vimService.vim.LicenseExpired): vimService.vim.LicenseExpired;
         };
         LicenseKeyEntityMismatch: {
            (options?: vimService.vim.LicenseKeyEntityMismatch): vimService.vim.LicenseKeyEntityMismatch;
         };
         LicenseRestricted: {
            (options?: vimService.vim.LicenseRestricted): vimService.vim.LicenseRestricted;
         };
         LicenseServerUnavailable: {
            (options?: vimService.vim.LicenseServerUnavailable): vimService.vim.LicenseServerUnavailable;
         };
         LicenseSourceUnavailable: {
            (options?: vimService.vim.LicenseSourceUnavailable): vimService.vim.LicenseSourceUnavailable;
         };
         LimitExceeded: {
            (options?: vimService.vim.LimitExceeded): vimService.vim.LimitExceeded;
         };
         LinuxVolumeNotClean: {
            (options?: vimService.vim.LinuxVolumeNotClean): vimService.vim.LinuxVolumeNotClean;
         };
         LogBundlingFailed: {
            (options?: vimService.vim.LogBundlingFailed): vimService.vim.LogBundlingFailed;
         };
         MaintenanceModeFileMove: {
            (options?: vimService.vim.MaintenanceModeFileMove): vimService.vim.MaintenanceModeFileMove;
         };
         MemoryFileFormatNotSupportedByDatastore: {
            (options?: vimService.vim.MemoryFileFormatNotSupportedByDatastore): vimService.vim.MemoryFileFormatNotSupportedByDatastore;
         };
         MemoryHotPlugNotSupported: {
            (options?: vimService.vim.MemoryHotPlugNotSupported): vimService.vim.MemoryHotPlugNotSupported;
         };
         MemorySizeNotRecommended: {
            (options?: vimService.vim.MemorySizeNotRecommended): vimService.vim.MemorySizeNotRecommended;
         };
         MemorySizeNotSupported: {
            (options?: vimService.vim.MemorySizeNotSupported): vimService.vim.MemorySizeNotSupported;
         };
         MemorySizeNotSupportedByDatastore: {
            (options?: vimService.vim.MemorySizeNotSupportedByDatastore): vimService.vim.MemorySizeNotSupportedByDatastore;
         };
         MemorySnapshotOnIndependentDisk: {
            (options?: vimService.vim.MemorySnapshotOnIndependentDisk): vimService.vim.MemorySnapshotOnIndependentDisk;
         };
         MethodAlreadyDisabledFault: {
            (options?: vimService.vim.MethodAlreadyDisabledFault): vimService.vim.MethodAlreadyDisabledFault;
         };
         MethodDisabled: {
            (options?: vimService.vim.MethodDisabled): vimService.vim.MethodDisabled;
         };
         MigrationDisabled: {
            (options?: vimService.vim.MigrationDisabled): vimService.vim.MigrationDisabled;
         };
         MigrationFault: {
            (options?: vimService.vim.MigrationFault): vimService.vim.MigrationFault;
         };
         MigrationFeatureNotSupported: {
            (options?: vimService.vim.MigrationFeatureNotSupported): vimService.vim.MigrationFeatureNotSupported;
         };
         MigrationNotReady: {
            (options?: vimService.vim.MigrationNotReady): vimService.vim.MigrationNotReady;
         };
         MismatchedBundle: {
            (options?: vimService.vim.MismatchedBundle): vimService.vim.MismatchedBundle;
         };
         MismatchedNetworkPolicies: {
            (options?: vimService.vim.MismatchedNetworkPolicies): vimService.vim.MismatchedNetworkPolicies;
         };
         MismatchedVMotionNetworkNames: {
            (options?: vimService.vim.MismatchedVMotionNetworkNames): vimService.vim.MismatchedVMotionNetworkNames;
         };
         MissingBmcSupport: {
            (options?: vimService.vim.MissingBmcSupport): vimService.vim.MissingBmcSupport;
         };
         MissingController: {
            (options?: vimService.vim.MissingController): vimService.vim.MissingController;
         };
         MissingIpPool: {
            (options?: vimService.vim.MissingIpPool): vimService.vim.MissingIpPool;
         };
         MissingLinuxCustResources: {
            (options?: vimService.vim.MissingLinuxCustResources): vimService.vim.MissingLinuxCustResources;
         };
         MissingNetworkIpConfig: {
            (options?: vimService.vim.MissingNetworkIpConfig): vimService.vim.MissingNetworkIpConfig;
         };
         MissingPowerOffConfiguration: {
            (options?: vimService.vim.MissingPowerOffConfiguration): vimService.vim.MissingPowerOffConfiguration;
         };
         MissingPowerOnConfiguration: {
            (options?: vimService.vim.MissingPowerOnConfiguration): vimService.vim.MissingPowerOnConfiguration;
         };
         MissingWindowsCustResources: {
            (options?: vimService.vim.MissingWindowsCustResources): vimService.vim.MissingWindowsCustResources;
         };
         MksConnectionLimitReached: {
            (options?: vimService.vim.MksConnectionLimitReached): vimService.vim.MksConnectionLimitReached;
         };
         MountError: {
            (options?: vimService.vim.MountError): vimService.vim.MountError;
         };
         MultiWriterNotSupported: {
            (options?: vimService.vim.MultiWriterNotSupported): vimService.vim.MultiWriterNotSupported;
         };
         MultipleCertificatesVerifyFaultThumbprintData: {
            (options?: vimService.vim.MultipleCertificatesVerifyFaultThumbprintData): vimService.vim.MultipleCertificatesVerifyFaultThumbprintData;
         };
         ArrayOfMultipleCertificatesVerifyFaultThumbprintData: {
            (options?: vimService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData): vimService.vim.ArrayOfMultipleCertificatesVerifyFaultThumbprintData;
         };
         MultipleCertificatesVerifyFault: {
            (options?: vimService.vim.MultipleCertificatesVerifyFault): vimService.vim.MultipleCertificatesVerifyFault;
         };
         MultipleSnapshotsNotSupported: {
            (options?: vimService.vim.MultipleSnapshotsNotSupported): vimService.vim.MultipleSnapshotsNotSupported;
         };
         NamespaceFull: {
            (options?: vimService.vim.NamespaceFull): vimService.vim.NamespaceFull;
         };
         NamespaceLimitReached: {
            (options?: vimService.vim.NamespaceLimitReached): vimService.vim.NamespaceLimitReached;
         };
         NamespaceWriteProtected: {
            (options?: vimService.vim.NamespaceWriteProtected): vimService.vim.NamespaceWriteProtected;
         };
         NasConfigFault: {
            (options?: vimService.vim.NasConfigFault): vimService.vim.NasConfigFault;
         };
         NasConnectionLimitReached: {
            (options?: vimService.vim.NasConnectionLimitReached): vimService.vim.NasConnectionLimitReached;
         };
         NasSessionCredentialConflict: {
            (options?: vimService.vim.NasSessionCredentialConflict): vimService.vim.NasSessionCredentialConflict;
         };
         NasVolumeNotMounted: {
            (options?: vimService.vim.NasVolumeNotMounted): vimService.vim.NasVolumeNotMounted;
         };
         NetworkCopyFault: {
            (options?: vimService.vim.NetworkCopyFault): vimService.vim.NetworkCopyFault;
         };
         NetworkDisruptedAndConfigRolledBack: {
            (options?: vimService.vim.NetworkDisruptedAndConfigRolledBack): vimService.vim.NetworkDisruptedAndConfigRolledBack;
         };
         NetworkInaccessible: {
            (options?: vimService.vim.NetworkInaccessible): vimService.vim.NetworkInaccessible;
         };
         NetworksMayNotBeTheSame: {
            (options?: vimService.vim.NetworksMayNotBeTheSame): vimService.vim.NetworksMayNotBeTheSame;
         };
         NicSettingMismatch: {
            (options?: vimService.vim.NicSettingMismatch): vimService.vim.NicSettingMismatch;
         };
         NoActiveHostInCluster: {
            (options?: vimService.vim.NoActiveHostInCluster): vimService.vim.NoActiveHostInCluster;
         };
         NoAvailableIp: {
            (options?: vimService.vim.NoAvailableIp): vimService.vim.NoAvailableIp;
         };
         NoClientCertificate: {
            (options?: vimService.vim.NoClientCertificate): vimService.vim.NoClientCertificate;
         };
         NoCompatibleDatastore: {
            (options?: vimService.vim.NoCompatibleDatastore): vimService.vim.NoCompatibleDatastore;
         };
         NoCompatibleHardAffinityHost: {
            (options?: vimService.vim.NoCompatibleHardAffinityHost): vimService.vim.NoCompatibleHardAffinityHost;
         };
         NoCompatibleHost: {
            (options?: vimService.vim.NoCompatibleHost): vimService.vim.NoCompatibleHost;
         };
         NoCompatibleHostWithAccessToDevice: {
            (options?: vimService.vim.NoCompatibleHostWithAccessToDevice): vimService.vim.NoCompatibleHostWithAccessToDevice;
         };
         NoCompatibleSoftAffinityHost: {
            (options?: vimService.vim.NoCompatibleSoftAffinityHost): vimService.vim.NoCompatibleSoftAffinityHost;
         };
         NoConnectedDatastore: {
            (options?: vimService.vim.NoConnectedDatastore): vimService.vim.NoConnectedDatastore;
         };
         NoDiskFound: {
            (options?: vimService.vim.NoDiskFound): vimService.vim.NoDiskFound;
         };
         NoDiskSpace: {
            (options?: vimService.vim.NoDiskSpace): vimService.vim.NoDiskSpace;
         };
         NoDisksToCustomize: {
            (options?: vimService.vim.NoDisksToCustomize): vimService.vim.NoDisksToCustomize;
         };
         NoGateway: {
            (options?: vimService.vim.NoGateway): vimService.vim.NoGateway;
         };
         NoGuestHeartbeat: {
            (options?: vimService.vim.NoGuestHeartbeat): vimService.vim.NoGuestHeartbeat;
         };
         NoHost: {
            (options?: vimService.vim.NoHost): vimService.vim.NoHost;
         };
         NoHostSuitableForFtSecondary: {
            (options?: vimService.vim.NoHostSuitableForFtSecondary): vimService.vim.NoHostSuitableForFtSecondary;
         };
         NoLicenseServerConfigured: {
            (options?: vimService.vim.NoLicenseServerConfigured): vimService.vim.NoLicenseServerConfigured;
         };
         NoPeerHostFound: {
            (options?: vimService.vim.NoPeerHostFound): vimService.vim.NoPeerHostFound;
         };
         NoPermission: {
            (options?: vimService.vim.NoPermission): vimService.vim.NoPermission;
         };
         NoPermissionOnAD: {
            (options?: vimService.vim.NoPermissionOnAD): vimService.vim.NoPermissionOnAD;
         };
         NoPermissionOnHost: {
            (options?: vimService.vim.NoPermissionOnHost): vimService.vim.NoPermissionOnHost;
         };
         NoPermissionOnNasVolume: {
            (options?: vimService.vim.NoPermissionOnNasVolume): vimService.vim.NoPermissionOnNasVolume;
         };
         NoSubjectName: {
            (options?: vimService.vim.NoSubjectName): vimService.vim.NoSubjectName;
         };
         NoVcManagedIpConfigured: {
            (options?: vimService.vim.NoVcManagedIpConfigured): vimService.vim.NoVcManagedIpConfigured;
         };
         NoVirtualNic: {
            (options?: vimService.vim.NoVirtualNic): vimService.vim.NoVirtualNic;
         };
         NoVmInVApp: {
            (options?: vimService.vim.NoVmInVApp): vimService.vim.NoVmInVApp;
         };
         NonADUserRequired: {
            (options?: vimService.vim.NonADUserRequired): vimService.vim.NonADUserRequired;
         };
         NonHomeRDMVMotionNotSupported: {
            (options?: vimService.vim.NonHomeRDMVMotionNotSupported): vimService.vim.NonHomeRDMVMotionNotSupported;
         };
         NonPersistentDisksNotSupported: {
            (options?: vimService.vim.NonPersistentDisksNotSupported): vimService.vim.NonPersistentDisksNotSupported;
         };
         NonVmwareOuiMacNotSupportedHost: {
            (options?: vimService.vim.NonVmwareOuiMacNotSupportedHost): vimService.vim.NonVmwareOuiMacNotSupportedHost;
         };
         NotADirectory: {
            (options?: vimService.vim.NotADirectory): vimService.vim.NotADirectory;
         };
         NotAFile: {
            (options?: vimService.vim.NotAFile): vimService.vim.NotAFile;
         };
         NotAuthenticated: {
            (options?: vimService.vim.NotAuthenticated): vimService.vim.NotAuthenticated;
         };
         NotEnoughCpus: {
            (options?: vimService.vim.NotEnoughCpus): vimService.vim.NotEnoughCpus;
         };
         NotEnoughLogicalCpus: {
            (options?: vimService.vim.NotEnoughLogicalCpus): vimService.vim.NotEnoughLogicalCpus;
         };
         NotFound: {
            (options?: vimService.vim.NotFound): vimService.vim.NotFound;
         };
         NotSupportedDeviceForFTDeviceType: {
            "virtualVmxnet3": string;
            "paraVirtualSCSIController": string;
         };
         NotSupportedDeviceForFT: {
            (options?: vimService.vim.NotSupportedDeviceForFT): vimService.vim.NotSupportedDeviceForFT;
         };
         NotSupportedHost: {
            (options?: vimService.vim.NotSupportedHost): vimService.vim.NotSupportedHost;
         };
         NotSupportedHostForChecksum: {
            (options?: vimService.vim.NotSupportedHostForChecksum): vimService.vim.NotSupportedHostForChecksum;
         };
         NotSupportedHostForVFlash: {
            (options?: vimService.vim.NotSupportedHostForVFlash): vimService.vim.NotSupportedHostForVFlash;
         };
         NotSupportedHostForVmcp: {
            (options?: vimService.vim.NotSupportedHostForVmcp): vimService.vim.NotSupportedHostForVmcp;
         };
         NotSupportedHostForVmemFile: {
            (options?: vimService.vim.NotSupportedHostForVmemFile): vimService.vim.NotSupportedHostForVmemFile;
         };
         NotSupportedHostForVsan: {
            (options?: vimService.vim.NotSupportedHostForVsan): vimService.vim.NotSupportedHostForVsan;
         };
         NotSupportedHostInCluster: {
            (options?: vimService.vim.NotSupportedHostInCluster): vimService.vim.NotSupportedHostInCluster;
         };
         NotSupportedHostInDvs: {
            (options?: vimService.vim.NotSupportedHostInDvs): vimService.vim.NotSupportedHostInDvs;
         };
         NotSupportedHostInHACluster: {
            (options?: vimService.vim.NotSupportedHostInHACluster): vimService.vim.NotSupportedHostInHACluster;
         };
         NotUserConfigurableProperty: {
            (options?: vimService.vim.NotUserConfigurableProperty): vimService.vim.NotUserConfigurableProperty;
         };
         NumVirtualCoresPerSocketNotSupported: {
            (options?: vimService.vim.NumVirtualCoresPerSocketNotSupported): vimService.vim.NumVirtualCoresPerSocketNotSupported;
         };
         NumVirtualCpusExceedsLimit: {
            (options?: vimService.vim.NumVirtualCpusExceedsLimit): vimService.vim.NumVirtualCpusExceedsLimit;
         };
         NumVirtualCpusIncompatibleReason: {
            "recordReplay": string;
            "faultTolerance": string;
         };
         NumVirtualCpusIncompatible: {
            (options?: vimService.vim.NumVirtualCpusIncompatible): vimService.vim.NumVirtualCpusIncompatible;
         };
         NumVirtualCpusNotSupported: {
            (options?: vimService.vim.NumVirtualCpusNotSupported): vimService.vim.NumVirtualCpusNotSupported;
         };
         OperationDisabledByGuest: {
            (options?: vimService.vim.OperationDisabledByGuest): vimService.vim.OperationDisabledByGuest;
         };
         OperationDisallowedOnHost: {
            (options?: vimService.vim.OperationDisallowedOnHost): vimService.vim.OperationDisallowedOnHost;
         };
         OperationNotSupportedByGuest: {
            (options?: vimService.vim.OperationNotSupportedByGuest): vimService.vim.OperationNotSupportedByGuest;
         };
         OutOfBounds: {
            (options?: vimService.vim.OutOfBounds): vimService.vim.OutOfBounds;
         };
         OvfAttribute: {
            (options?: vimService.vim.OvfAttribute): vimService.vim.OvfAttribute;
         };
         OvfConnectedDevice: {
            (options?: vimService.vim.OvfConnectedDevice): vimService.vim.OvfConnectedDevice;
         };
         OvfConnectedDeviceFloppy: {
            (options?: vimService.vim.OvfConnectedDeviceFloppy): vimService.vim.OvfConnectedDeviceFloppy;
         };
         OvfConnectedDeviceIso: {
            (options?: vimService.vim.OvfConnectedDeviceIso): vimService.vim.OvfConnectedDeviceIso;
         };
         OvfConstraint: {
            (options?: vimService.vim.OvfConstraint): vimService.vim.OvfConstraint;
         };
         OvfConsumerCallbackFault: {
            (options?: vimService.vim.OvfConsumerCallbackFault): vimService.vim.OvfConsumerCallbackFault;
         };
         OvfConsumerCommunicationError: {
            (options?: vimService.vim.OvfConsumerCommunicationError): vimService.vim.OvfConsumerCommunicationError;
         };
         OvfConsumerFault: {
            (options?: vimService.vim.OvfConsumerFault): vimService.vim.OvfConsumerFault;
         };
         OvfConsumerInvalidSection: {
            (options?: vimService.vim.OvfConsumerInvalidSection): vimService.vim.OvfConsumerInvalidSection;
         };
         OvfConsumerPowerOnFault: {
            (options?: vimService.vim.OvfConsumerPowerOnFault): vimService.vim.OvfConsumerPowerOnFault;
         };
         OvfConsumerUndeclaredSection: {
            (options?: vimService.vim.OvfConsumerUndeclaredSection): vimService.vim.OvfConsumerUndeclaredSection;
         };
         OvfConsumerUndefinedPrefix: {
            (options?: vimService.vim.OvfConsumerUndefinedPrefix): vimService.vim.OvfConsumerUndefinedPrefix;
         };
         OvfConsumerValidationFault: {
            (options?: vimService.vim.OvfConsumerValidationFault): vimService.vim.OvfConsumerValidationFault;
         };
         OvfCpuCompatibility: {
            (options?: vimService.vim.OvfCpuCompatibility): vimService.vim.OvfCpuCompatibility;
         };
         OvfCpuCompatibilityCheckNotSupported: {
            (options?: vimService.vim.OvfCpuCompatibilityCheckNotSupported): vimService.vim.OvfCpuCompatibilityCheckNotSupported;
         };
         OvfDiskMappingNotFound: {
            (options?: vimService.vim.OvfDiskMappingNotFound): vimService.vim.OvfDiskMappingNotFound;
         };
         OvfDiskOrderConstraint: {
            (options?: vimService.vim.OvfDiskOrderConstraint): vimService.vim.OvfDiskOrderConstraint;
         };
         OvfDuplicateElement: {
            (options?: vimService.vim.OvfDuplicateElement): vimService.vim.OvfDuplicateElement;
         };
         OvfDuplicatedElementBoundary: {
            (options?: vimService.vim.OvfDuplicatedElementBoundary): vimService.vim.OvfDuplicatedElementBoundary;
         };
         OvfDuplicatedPropertyIdExport: {
            (options?: vimService.vim.OvfDuplicatedPropertyIdExport): vimService.vim.OvfDuplicatedPropertyIdExport;
         };
         OvfDuplicatedPropertyIdImport: {
            (options?: vimService.vim.OvfDuplicatedPropertyIdImport): vimService.vim.OvfDuplicatedPropertyIdImport;
         };
         OvfElement: {
            (options?: vimService.vim.OvfElement): vimService.vim.OvfElement;
         };
         OvfElementInvalidValue: {
            (options?: vimService.vim.OvfElementInvalidValue): vimService.vim.OvfElementInvalidValue;
         };
         OvfExport: {
            (options?: vimService.vim.OvfExport): vimService.vim.OvfExport;
         };
         OvfExportFailed: {
            (options?: vimService.vim.OvfExportFailed): vimService.vim.OvfExportFailed;
         };
         OvfFault: {
            (options?: vimService.vim.OvfFault): vimService.vim.OvfFault;
         };
         OvfHardwareCheck: {
            (options?: vimService.vim.OvfHardwareCheck): vimService.vim.OvfHardwareCheck;
         };
         OvfHardwareExport: {
            (options?: vimService.vim.OvfHardwareExport): vimService.vim.OvfHardwareExport;
         };
         OvfHostResourceConstraint: {
            (options?: vimService.vim.OvfHostResourceConstraint): vimService.vim.OvfHostResourceConstraint;
         };
         OvfHostValueNotParsed: {
            (options?: vimService.vim.OvfHostValueNotParsed): vimService.vim.OvfHostValueNotParsed;
         };
         OvfImport: {
            (options?: vimService.vim.OvfImport): vimService.vim.OvfImport;
         };
         OvfImportFailed: {
            (options?: vimService.vim.OvfImportFailed): vimService.vim.OvfImportFailed;
         };
         OvfInternalError: {
            (options?: vimService.vim.OvfInternalError): vimService.vim.OvfInternalError;
         };
         OvfInvalidPackage: {
            (options?: vimService.vim.OvfInvalidPackage): vimService.vim.OvfInvalidPackage;
         };
         OvfInvalidValue: {
            (options?: vimService.vim.OvfInvalidValue): vimService.vim.OvfInvalidValue;
         };
         OvfInvalidValueConfiguration: {
            (options?: vimService.vim.OvfInvalidValueConfiguration): vimService.vim.OvfInvalidValueConfiguration;
         };
         OvfInvalidValueEmpty: {
            (options?: vimService.vim.OvfInvalidValueEmpty): vimService.vim.OvfInvalidValueEmpty;
         };
         OvfInvalidValueFormatMalformed: {
            (options?: vimService.vim.OvfInvalidValueFormatMalformed): vimService.vim.OvfInvalidValueFormatMalformed;
         };
         OvfInvalidValueReference: {
            (options?: vimService.vim.OvfInvalidValueReference): vimService.vim.OvfInvalidValueReference;
         };
         OvfInvalidVmName: {
            (options?: vimService.vim.OvfInvalidVmName): vimService.vim.OvfInvalidVmName;
         };
         OvfMappedOsId: {
            (options?: vimService.vim.OvfMappedOsId): vimService.vim.OvfMappedOsId;
         };
         OvfMissingAttribute: {
            (options?: vimService.vim.OvfMissingAttribute): vimService.vim.OvfMissingAttribute;
         };
         OvfMissingElement: {
            (options?: vimService.vim.OvfMissingElement): vimService.vim.OvfMissingElement;
         };
         OvfMissingElementNormalBoundary: {
            (options?: vimService.vim.OvfMissingElementNormalBoundary): vimService.vim.OvfMissingElementNormalBoundary;
         };
         OvfMissingHardware: {
            (options?: vimService.vim.OvfMissingHardware): vimService.vim.OvfMissingHardware;
         };
         OvfNetworkMappingNotSupported: {
            (options?: vimService.vim.OvfNetworkMappingNotSupported): vimService.vim.OvfNetworkMappingNotSupported;
         };
         OvfNoHostNic: {
            (options?: vimService.vim.OvfNoHostNic): vimService.vim.OvfNoHostNic;
         };
         OvfNoSpaceOnController: {
            (options?: vimService.vim.OvfNoSpaceOnController): vimService.vim.OvfNoSpaceOnController;
         };
         OvfNoSupportedHardwareFamily: {
            (options?: vimService.vim.OvfNoSupportedHardwareFamily): vimService.vim.OvfNoSupportedHardwareFamily;
         };
         OvfProperty: {
            (options?: vimService.vim.OvfProperty): vimService.vim.OvfProperty;
         };
         OvfPropertyExport: {
            (options?: vimService.vim.OvfPropertyExport): vimService.vim.OvfPropertyExport;
         };
         OvfPropertyNetwork: {
            (options?: vimService.vim.OvfPropertyNetwork): vimService.vim.OvfPropertyNetwork;
         };
         OvfPropertyNetworkExport: {
            (options?: vimService.vim.OvfPropertyNetworkExport): vimService.vim.OvfPropertyNetworkExport;
         };
         OvfPropertyQualifier: {
            (options?: vimService.vim.OvfPropertyQualifier): vimService.vim.OvfPropertyQualifier;
         };
         OvfPropertyQualifierDuplicate: {
            (options?: vimService.vim.OvfPropertyQualifierDuplicate): vimService.vim.OvfPropertyQualifierDuplicate;
         };
         OvfPropertyQualifierIgnored: {
            (options?: vimService.vim.OvfPropertyQualifierIgnored): vimService.vim.OvfPropertyQualifierIgnored;
         };
         OvfPropertyType: {
            (options?: vimService.vim.OvfPropertyType): vimService.vim.OvfPropertyType;
         };
         OvfPropertyValue: {
            (options?: vimService.vim.OvfPropertyValue): vimService.vim.OvfPropertyValue;
         };
         OvfSystemFault: {
            (options?: vimService.vim.OvfSystemFault): vimService.vim.OvfSystemFault;
         };
         OvfToXmlUnsupportedElement: {
            (options?: vimService.vim.OvfToXmlUnsupportedElement): vimService.vim.OvfToXmlUnsupportedElement;
         };
         OvfUnableToExportDisk: {
            (options?: vimService.vim.OvfUnableToExportDisk): vimService.vim.OvfUnableToExportDisk;
         };
         OvfUnexpectedElement: {
            (options?: vimService.vim.OvfUnexpectedElement): vimService.vim.OvfUnexpectedElement;
         };
         OvfUnknownDevice: {
            (options?: vimService.vim.OvfUnknownDevice): vimService.vim.OvfUnknownDevice;
         };
         OvfUnknownDeviceBacking: {
            (options?: vimService.vim.OvfUnknownDeviceBacking): vimService.vim.OvfUnknownDeviceBacking;
         };
         OvfUnknownEntity: {
            (options?: vimService.vim.OvfUnknownEntity): vimService.vim.OvfUnknownEntity;
         };
         OvfUnsupportedAttribute: {
            (options?: vimService.vim.OvfUnsupportedAttribute): vimService.vim.OvfUnsupportedAttribute;
         };
         OvfUnsupportedAttributeValue: {
            (options?: vimService.vim.OvfUnsupportedAttributeValue): vimService.vim.OvfUnsupportedAttributeValue;
         };
         OvfUnsupportedDeviceBackingInfo: {
            (options?: vimService.vim.OvfUnsupportedDeviceBackingInfo): vimService.vim.OvfUnsupportedDeviceBackingInfo;
         };
         OvfUnsupportedDeviceBackingOption: {
            (options?: vimService.vim.OvfUnsupportedDeviceBackingOption): vimService.vim.OvfUnsupportedDeviceBackingOption;
         };
         OvfUnsupportedDeviceExport: {
            (options?: vimService.vim.OvfUnsupportedDeviceExport): vimService.vim.OvfUnsupportedDeviceExport;
         };
         OvfUnsupportedDiskProvisioning: {
            (options?: vimService.vim.OvfUnsupportedDiskProvisioning): vimService.vim.OvfUnsupportedDiskProvisioning;
         };
         OvfUnsupportedElement: {
            (options?: vimService.vim.OvfUnsupportedElement): vimService.vim.OvfUnsupportedElement;
         };
         OvfUnsupportedElementValue: {
            (options?: vimService.vim.OvfUnsupportedElementValue): vimService.vim.OvfUnsupportedElementValue;
         };
         OvfUnsupportedPackage: {
            (options?: vimService.vim.OvfUnsupportedPackage): vimService.vim.OvfUnsupportedPackage;
         };
         OvfUnsupportedSection: {
            (options?: vimService.vim.OvfUnsupportedSection): vimService.vim.OvfUnsupportedSection;
         };
         OvfUnsupportedSubType: {
            (options?: vimService.vim.OvfUnsupportedSubType): vimService.vim.OvfUnsupportedSubType;
         };
         OvfUnsupportedType: {
            (options?: vimService.vim.OvfUnsupportedType): vimService.vim.OvfUnsupportedType;
         };
         OvfWrongElement: {
            (options?: vimService.vim.OvfWrongElement): vimService.vim.OvfWrongElement;
         };
         OvfWrongNamespace: {
            (options?: vimService.vim.OvfWrongNamespace): vimService.vim.OvfWrongNamespace;
         };
         OvfXmlFormat: {
            (options?: vimService.vim.OvfXmlFormat): vimService.vim.OvfXmlFormat;
         };
         PatchAlreadyInstalled: {
            (options?: vimService.vim.PatchAlreadyInstalled): vimService.vim.PatchAlreadyInstalled;
         };
         PatchBinariesNotFound: {
            (options?: vimService.vim.PatchBinariesNotFound): vimService.vim.PatchBinariesNotFound;
         };
         PatchInstallFailed: {
            (options?: vimService.vim.PatchInstallFailed): vimService.vim.PatchInstallFailed;
         };
         PatchIntegrityError: {
            (options?: vimService.vim.PatchIntegrityError): vimService.vim.PatchIntegrityError;
         };
         PatchMetadataCorrupted: {
            (options?: vimService.vim.PatchMetadataCorrupted): vimService.vim.PatchMetadataCorrupted;
         };
         PatchMetadataInvalid: {
            (options?: vimService.vim.PatchMetadataInvalid): vimService.vim.PatchMetadataInvalid;
         };
         PatchMetadataNotFound: {
            (options?: vimService.vim.PatchMetadataNotFound): vimService.vim.PatchMetadataNotFound;
         };
         PatchMissingDependencies: {
            (options?: vimService.vim.PatchMissingDependencies): vimService.vim.PatchMissingDependencies;
         };
         PatchNotApplicable: {
            (options?: vimService.vim.PatchNotApplicable): vimService.vim.PatchNotApplicable;
         };
         PatchSuperseded: {
            (options?: vimService.vim.PatchSuperseded): vimService.vim.PatchSuperseded;
         };
         PhysCompatRDMNotSupported: {
            (options?: vimService.vim.PhysCompatRDMNotSupported): vimService.vim.PhysCompatRDMNotSupported;
         };
         PlatformConfigFault: {
            (options?: vimService.vim.PlatformConfigFault): vimService.vim.PlatformConfigFault;
         };
         PowerOnFtSecondaryFailed: {
            (options?: vimService.vim.PowerOnFtSecondaryFailed): vimService.vim.PowerOnFtSecondaryFailed;
         };
         PowerOnFtSecondaryTimedout: {
            (options?: vimService.vim.PowerOnFtSecondaryTimedout): vimService.vim.PowerOnFtSecondaryTimedout;
         };
         ProfileUpdateFailedUpdateFailure: {
            (options?: vimService.vim.ProfileUpdateFailedUpdateFailure): vimService.vim.ProfileUpdateFailedUpdateFailure;
         };
         ArrayOfProfileUpdateFailedUpdateFailure: {
            (options?: vimService.vim.ArrayOfProfileUpdateFailedUpdateFailure): vimService.vim.ArrayOfProfileUpdateFailedUpdateFailure;
         };
         ProfileUpdateFailed: {
            (options?: vimService.vim.ProfileUpdateFailed): vimService.vim.ProfileUpdateFailed;
         };
         QuestionPending: {
            (options?: vimService.vim.QuestionPending): vimService.vim.QuestionPending;
         };
         QuiesceDatastoreIOForHAFailed: {
            (options?: vimService.vim.QuiesceDatastoreIOForHAFailed): vimService.vim.QuiesceDatastoreIOForHAFailed;
         };
         RDMConversionNotSupported: {
            (options?: vimService.vim.RDMConversionNotSupported): vimService.vim.RDMConversionNotSupported;
         };
         RDMNotPreserved: {
            (options?: vimService.vim.RDMNotPreserved): vimService.vim.RDMNotPreserved;
         };
         RDMNotSupported: {
            (options?: vimService.vim.RDMNotSupported): vimService.vim.RDMNotSupported;
         };
         RDMNotSupportedOnDatastore: {
            (options?: vimService.vim.RDMNotSupportedOnDatastore): vimService.vim.RDMNotSupportedOnDatastore;
         };
         RDMPointsToInaccessibleDisk: {
            (options?: vimService.vim.RDMPointsToInaccessibleDisk): vimService.vim.RDMPointsToInaccessibleDisk;
         };
         RawDiskNotSupported: {
            (options?: vimService.vim.RawDiskNotSupported): vimService.vim.RawDiskNotSupported;
         };
         ReadHostResourcePoolTreeFailed: {
            (options?: vimService.vim.ReadHostResourcePoolTreeFailed): vimService.vim.ReadHostResourcePoolTreeFailed;
         };
         ReadOnlyDisksWithLegacyDestination: {
            (options?: vimService.vim.ReadOnlyDisksWithLegacyDestination): vimService.vim.ReadOnlyDisksWithLegacyDestination;
         };
         RebootRequired: {
            (options?: vimService.vim.RebootRequired): vimService.vim.RebootRequired;
         };
         RecordReplayDisabled: {
            (options?: vimService.vim.RecordReplayDisabled): vimService.vim.RecordReplayDisabled;
         };
         RemoteDeviceNotSupported: {
            (options?: vimService.vim.RemoteDeviceNotSupported): vimService.vim.RemoteDeviceNotSupported;
         };
         RemoveFailed: {
            (options?: vimService.vim.RemoveFailed): vimService.vim.RemoveFailed;
         };
         ReplicationConfigFault: {
            (options?: vimService.vim.ReplicationConfigFault): vimService.vim.ReplicationConfigFault;
         };
         ReplicationDiskConfigFaultReasonForFault: {
            "diskNotFound": string;
            "diskTypeNotSupported": string;
            "invalidDiskKey": string;
            "invalidDiskReplicationId": string;
            "duplicateDiskReplicationId": string;
            "invalidPersistentFilePath": string;
            "reconfigureDiskReplicationIdNotAllowed": string;
         };
         ReplicationDiskConfigFault: {
            (options?: vimService.vim.ReplicationDiskConfigFault): vimService.vim.ReplicationDiskConfigFault;
         };
         ReplicationFault: {
            (options?: vimService.vim.ReplicationFault): vimService.vim.ReplicationFault;
         };
         ReplicationIncompatibleWithFT: {
            (options?: vimService.vim.ReplicationIncompatibleWithFT): vimService.vim.ReplicationIncompatibleWithFT;
         };
         ReplicationInvalidOptions: {
            (options?: vimService.vim.ReplicationInvalidOptions): vimService.vim.ReplicationInvalidOptions;
         };
         ReplicationNotSupportedOnHost: {
            (options?: vimService.vim.ReplicationNotSupportedOnHost): vimService.vim.ReplicationNotSupportedOnHost;
         };
         ReplicationVmConfigFaultReasonForFault: {
            "incompatibleHwVersion": string;
            "invalidVmReplicationId": string;
            "invalidGenerationNumber": string;
            "outOfBoundsRpoValue": string;
            "invalidDestinationIpAddress": string;
            "invalidDestinationPort": string;
            "invalidExtraVmOptions": string;
            "staleGenerationNumber": string;
            "reconfigureVmReplicationIdNotAllowed": string;
            "cannotRetrieveVmReplicationConfiguration": string;
            "replicationAlreadyEnabled": string;
            "invalidPriorConfiguration": string;
            "replicationNotEnabled": string;
            "replicationConfigurationFailed": string;
         };
         ReplicationVmConfigFault: {
            (options?: vimService.vim.ReplicationVmConfigFault): vimService.vim.ReplicationVmConfigFault;
         };
         ReplicationVmFaultReasonForFault: {
            "notConfigured": string;
            "poweredOff": string;
            "suspended": string;
            "poweredOn": string;
            "offlineReplicating": string;
            "invalidState": string;
            "invalidInstanceId": string;
            "closeDiskError": string;
         };
         ReplicationVmFault: {
            (options?: vimService.vim.ReplicationVmFault): vimService.vim.ReplicationVmFault;
         };
         ReplicationVmInProgressFaultActivity: {
            "fullSync": string;
            "delta": string;
         };
         ReplicationVmInProgressFault: {
            (options?: vimService.vim.ReplicationVmInProgressFault): vimService.vim.ReplicationVmInProgressFault;
         };
         ResourceInUse: {
            (options?: vimService.vim.ResourceInUse): vimService.vim.ResourceInUse;
         };
         ResourceNotAvailable: {
            (options?: vimService.vim.ResourceNotAvailable): vimService.vim.ResourceNotAvailable;
         };
         RestrictedByAdministrator: {
            (options?: vimService.vim.RestrictedByAdministrator): vimService.vim.RestrictedByAdministrator;
         };
         RestrictedVersion: {
            (options?: vimService.vim.RestrictedVersion): vimService.vim.RestrictedVersion;
         };
         RollbackFailure: {
            (options?: vimService.vim.RollbackFailure): vimService.vim.RollbackFailure;
         };
         RuleViolation: {
            (options?: vimService.vim.RuleViolation): vimService.vim.RuleViolation;
         };
         SSLDisabledFault: {
            (options?: vimService.vim.SSLDisabledFault): vimService.vim.SSLDisabledFault;
         };
         SSLVerifyFault: {
            (options?: vimService.vim.SSLVerifyFault): vimService.vim.SSLVerifyFault;
         };
         SSPIChallenge: {
            (options?: vimService.vim.SSPIChallenge): vimService.vim.SSPIChallenge;
         };
         SecondaryVmAlreadyDisabled: {
            (options?: vimService.vim.SecondaryVmAlreadyDisabled): vimService.vim.SecondaryVmAlreadyDisabled;
         };
         SecondaryVmAlreadyEnabled: {
            (options?: vimService.vim.SecondaryVmAlreadyEnabled): vimService.vim.SecondaryVmAlreadyEnabled;
         };
         SecondaryVmAlreadyRegistered: {
            (options?: vimService.vim.SecondaryVmAlreadyRegistered): vimService.vim.SecondaryVmAlreadyRegistered;
         };
         SecondaryVmNotRegistered: {
            (options?: vimService.vim.SecondaryVmNotRegistered): vimService.vim.SecondaryVmNotRegistered;
         };
         SharedBusControllerNotSupported: {
            (options?: vimService.vim.SharedBusControllerNotSupported): vimService.vim.SharedBusControllerNotSupported;
         };
         ShrinkDiskFault: {
            (options?: vimService.vim.ShrinkDiskFault): vimService.vim.ShrinkDiskFault;
         };
         SnapshotCloneNotSupported: {
            (options?: vimService.vim.SnapshotCloneNotSupported): vimService.vim.SnapshotCloneNotSupported;
         };
         SnapshotCopyNotSupported: {
            (options?: vimService.vim.SnapshotCopyNotSupported): vimService.vim.SnapshotCopyNotSupported;
         };
         SnapshotDisabled: {
            (options?: vimService.vim.SnapshotDisabled): vimService.vim.SnapshotDisabled;
         };
         SnapshotFault: {
            (options?: vimService.vim.SnapshotFault): vimService.vim.SnapshotFault;
         };
         SnapshotIncompatibleDeviceInVm: {
            (options?: vimService.vim.SnapshotIncompatibleDeviceInVm): vimService.vim.SnapshotIncompatibleDeviceInVm;
         };
         SnapshotLocked: {
            (options?: vimService.vim.SnapshotLocked): vimService.vim.SnapshotLocked;
         };
         SnapshotMoveFromNonHomeNotSupported: {
            (options?: vimService.vim.SnapshotMoveFromNonHomeNotSupported): vimService.vim.SnapshotMoveFromNonHomeNotSupported;
         };
         SnapshotMoveNotSupported: {
            (options?: vimService.vim.SnapshotMoveNotSupported): vimService.vim.SnapshotMoveNotSupported;
         };
         SnapshotMoveToNonHomeNotSupported: {
            (options?: vimService.vim.SnapshotMoveToNonHomeNotSupported): vimService.vim.SnapshotMoveToNonHomeNotSupported;
         };
         SnapshotNoChange: {
            (options?: vimService.vim.SnapshotNoChange): vimService.vim.SnapshotNoChange;
         };
         SnapshotRevertIssue: {
            (options?: vimService.vim.SnapshotRevertIssue): vimService.vim.SnapshotRevertIssue;
         };
         SoftRuleVioCorrectionDisallowed: {
            (options?: vimService.vim.SoftRuleVioCorrectionDisallowed): vimService.vim.SoftRuleVioCorrectionDisallowed;
         };
         SoftRuleVioCorrectionImpact: {
            (options?: vimService.vim.SoftRuleVioCorrectionImpact): vimService.vim.SoftRuleVioCorrectionImpact;
         };
         SsdDiskNotAvailable: {
            (options?: vimService.vim.SsdDiskNotAvailable): vimService.vim.SsdDiskNotAvailable;
         };
         StorageDrsCannotMoveDiskInMultiWriterMode: {
            (options?: vimService.vim.StorageDrsCannotMoveDiskInMultiWriterMode): vimService.vim.StorageDrsCannotMoveDiskInMultiWriterMode;
         };
         StorageDrsCannotMoveFTVm: {
            (options?: vimService.vim.StorageDrsCannotMoveFTVm): vimService.vim.StorageDrsCannotMoveFTVm;
         };
         StorageDrsCannotMoveIndependentDisk: {
            (options?: vimService.vim.StorageDrsCannotMoveIndependentDisk): vimService.vim.StorageDrsCannotMoveIndependentDisk;
         };
         StorageDrsCannotMoveManuallyPlacedSwapFile: {
            (options?: vimService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile): vimService.vim.StorageDrsCannotMoveManuallyPlacedSwapFile;
         };
         StorageDrsCannotMoveManuallyPlacedVm: {
            (options?: vimService.vim.StorageDrsCannotMoveManuallyPlacedVm): vimService.vim.StorageDrsCannotMoveManuallyPlacedVm;
         };
         StorageDrsCannotMoveSharedDisk: {
            (options?: vimService.vim.StorageDrsCannotMoveSharedDisk): vimService.vim.StorageDrsCannotMoveSharedDisk;
         };
         StorageDrsCannotMoveTemplate: {
            (options?: vimService.vim.StorageDrsCannotMoveTemplate): vimService.vim.StorageDrsCannotMoveTemplate;
         };
         StorageDrsCannotMoveVmInUserFolder: {
            (options?: vimService.vim.StorageDrsCannotMoveVmInUserFolder): vimService.vim.StorageDrsCannotMoveVmInUserFolder;
         };
         StorageDrsCannotMoveVmWithMountedCDROM: {
            (options?: vimService.vim.StorageDrsCannotMoveVmWithMountedCDROM): vimService.vim.StorageDrsCannotMoveVmWithMountedCDROM;
         };
         StorageDrsCannotMoveVmWithNoFilesInLayout: {
            (options?: vimService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout): vimService.vim.StorageDrsCannotMoveVmWithNoFilesInLayout;
         };
         StorageDrsDatacentersCannotShareDatastore: {
            (options?: vimService.vim.StorageDrsDatacentersCannotShareDatastore): vimService.vim.StorageDrsDatacentersCannotShareDatastore;
         };
         StorageDrsDisabledOnVm: {
            (options?: vimService.vim.StorageDrsDisabledOnVm): vimService.vim.StorageDrsDisabledOnVm;
         };
         StorageDrsHbrDiskNotMovable: {
            (options?: vimService.vim.StorageDrsHbrDiskNotMovable): vimService.vim.StorageDrsHbrDiskNotMovable;
         };
         StorageDrsHmsMoveInProgress: {
            (options?: vimService.vim.StorageDrsHmsMoveInProgress): vimService.vim.StorageDrsHmsMoveInProgress;
         };
         StorageDrsHmsUnreachable: {
            (options?: vimService.vim.StorageDrsHmsUnreachable): vimService.vim.StorageDrsHmsUnreachable;
         };
         StorageDrsIolbDisabledInternally: {
            (options?: vimService.vim.StorageDrsIolbDisabledInternally): vimService.vim.StorageDrsIolbDisabledInternally;
         };
         StorageDrsRelocateDisabled: {
            (options?: vimService.vim.StorageDrsRelocateDisabled): vimService.vim.StorageDrsRelocateDisabled;
         };
         StorageDrsStaleHmsCollection: {
            (options?: vimService.vim.StorageDrsStaleHmsCollection): vimService.vim.StorageDrsStaleHmsCollection;
         };
         StorageDrsUnableToMoveFiles: {
            (options?: vimService.vim.StorageDrsUnableToMoveFiles): vimService.vim.StorageDrsUnableToMoveFiles;
         };
         StorageVMotionNotSupported: {
            (options?: vimService.vim.StorageVMotionNotSupported): vimService.vim.StorageVMotionNotSupported;
         };
         StorageVmotionIncompatible: {
            (options?: vimService.vim.StorageVmotionIncompatible): vimService.vim.StorageVmotionIncompatible;
         };
         SuspendedRelocateNotSupported: {
            (options?: vimService.vim.SuspendedRelocateNotSupported): vimService.vim.SuspendedRelocateNotSupported;
         };
         SwapDatastoreNotWritableOnHost: {
            (options?: vimService.vim.SwapDatastoreNotWritableOnHost): vimService.vim.SwapDatastoreNotWritableOnHost;
         };
         SwapDatastoreUnset: {
            (options?: vimService.vim.SwapDatastoreUnset): vimService.vim.SwapDatastoreUnset;
         };
         SwapPlacementOverrideNotSupported: {
            (options?: vimService.vim.SwapPlacementOverrideNotSupported): vimService.vim.SwapPlacementOverrideNotSupported;
         };
         SwitchIpUnset: {
            (options?: vimService.vim.SwitchIpUnset): vimService.vim.SwitchIpUnset;
         };
         SwitchNotInUpgradeMode: {
            (options?: vimService.vim.SwitchNotInUpgradeMode): vimService.vim.SwitchNotInUpgradeMode;
         };
         TaskInProgress: {
            (options?: vimService.vim.TaskInProgress): vimService.vim.TaskInProgress;
         };
         ThirdPartyLicenseAssignmentFailedReason: {
            "licenseAssignmentFailed": string;
            "moduleNotInstalled": string;
         };
         ThirdPartyLicenseAssignmentFailed: {
            (options?: vimService.vim.ThirdPartyLicenseAssignmentFailed): vimService.vim.ThirdPartyLicenseAssignmentFailed;
         };
         Timedout: {
            (options?: vimService.vim.Timedout): vimService.vim.Timedout;
         };
         TooManyConcurrentNativeClones: {
            (options?: vimService.vim.TooManyConcurrentNativeClones): vimService.vim.TooManyConcurrentNativeClones;
         };
         TooManyConsecutiveOverrides: {
            (options?: vimService.vim.TooManyConsecutiveOverrides): vimService.vim.TooManyConsecutiveOverrides;
         };
         TooManyDevices: {
            (options?: vimService.vim.TooManyDevices): vimService.vim.TooManyDevices;
         };
         TooManyDisksOnLegacyHost: {
            (options?: vimService.vim.TooManyDisksOnLegacyHost): vimService.vim.TooManyDisksOnLegacyHost;
         };
         TooManyGuestLogons: {
            (options?: vimService.vim.TooManyGuestLogons): vimService.vim.TooManyGuestLogons;
         };
         TooManyHosts: {
            (options?: vimService.vim.TooManyHosts): vimService.vim.TooManyHosts;
         };
         TooManyNativeCloneLevels: {
            (options?: vimService.vim.TooManyNativeCloneLevels): vimService.vim.TooManyNativeCloneLevels;
         };
         TooManyNativeClonesOnFile: {
            (options?: vimService.vim.TooManyNativeClonesOnFile): vimService.vim.TooManyNativeClonesOnFile;
         };
         TooManySnapshotLevels: {
            (options?: vimService.vim.TooManySnapshotLevels): vimService.vim.TooManySnapshotLevels;
         };
         ToolsAlreadyUpgraded: {
            (options?: vimService.vim.ToolsAlreadyUpgraded): vimService.vim.ToolsAlreadyUpgraded;
         };
         ToolsAutoUpgradeNotSupported: {
            (options?: vimService.vim.ToolsAutoUpgradeNotSupported): vimService.vim.ToolsAutoUpgradeNotSupported;
         };
         ToolsImageCopyFailed: {
            (options?: vimService.vim.ToolsImageCopyFailed): vimService.vim.ToolsImageCopyFailed;
         };
         ToolsImageNotAvailable: {
            (options?: vimService.vim.ToolsImageNotAvailable): vimService.vim.ToolsImageNotAvailable;
         };
         ToolsImageSignatureCheckFailed: {
            (options?: vimService.vim.ToolsImageSignatureCheckFailed): vimService.vim.ToolsImageSignatureCheckFailed;
         };
         ToolsInstallationInProgress: {
            (options?: vimService.vim.ToolsInstallationInProgress): vimService.vim.ToolsInstallationInProgress;
         };
         ToolsUnavailable: {
            (options?: vimService.vim.ToolsUnavailable): vimService.vim.ToolsUnavailable;
         };
         ToolsUpgradeCancelled: {
            (options?: vimService.vim.ToolsUpgradeCancelled): vimService.vim.ToolsUpgradeCancelled;
         };
         UnSupportedDatastoreForVFlash: {
            (options?: vimService.vim.UnSupportedDatastoreForVFlash): vimService.vim.UnSupportedDatastoreForVFlash;
         };
         UncommittedUndoableDisk: {
            (options?: vimService.vim.UncommittedUndoableDisk): vimService.vim.UncommittedUndoableDisk;
         };
         UnconfiguredPropertyValue: {
            (options?: vimService.vim.UnconfiguredPropertyValue): vimService.vim.UnconfiguredPropertyValue;
         };
         UncustomizableGuest: {
            (options?: vimService.vim.UncustomizableGuest): vimService.vim.UncustomizableGuest;
         };
         UnexpectedCustomizationFault: {
            (options?: vimService.vim.UnexpectedCustomizationFault): vimService.vim.UnexpectedCustomizationFault;
         };
         UnrecognizedHost: {
            (options?: vimService.vim.UnrecognizedHost): vimService.vim.UnrecognizedHost;
         };
         UnsharedSwapVMotionNotSupported: {
            (options?: vimService.vim.UnsharedSwapVMotionNotSupported): vimService.vim.UnsharedSwapVMotionNotSupported;
         };
         UnsupportedDatastore: {
            (options?: vimService.vim.UnsupportedDatastore): vimService.vim.UnsupportedDatastore;
         };
         UnsupportedGuest: {
            (options?: vimService.vim.UnsupportedGuest): vimService.vim.UnsupportedGuest;
         };
         UnsupportedVimApiVersion: {
            (options?: vimService.vim.UnsupportedVimApiVersion): vimService.vim.UnsupportedVimApiVersion;
         };
         UnsupportedVmxLocation: {
            (options?: vimService.vim.UnsupportedVmxLocation): vimService.vim.UnsupportedVmxLocation;
         };
         UnusedVirtualDiskBlocksNotScrubbed: {
            (options?: vimService.vim.UnusedVirtualDiskBlocksNotScrubbed): vimService.vim.UnusedVirtualDiskBlocksNotScrubbed;
         };
         UserNotFound: {
            (options?: vimService.vim.UserNotFound): vimService.vim.UserNotFound;
         };
         VAppConfigFault: {
            (options?: vimService.vim.VAppConfigFault): vimService.vim.VAppConfigFault;
         };
         VAppNotRunning: {
            (options?: vimService.vim.VAppNotRunning): vimService.vim.VAppNotRunning;
         };
         VAppOperationInProgress: {
            (options?: vimService.vim.VAppOperationInProgress): vimService.vim.VAppOperationInProgress;
         };
         VAppPropertyFault: {
            (options?: vimService.vim.VAppPropertyFault): vimService.vim.VAppPropertyFault;
         };
         VAppTaskInProgress: {
            (options?: vimService.vim.VAppTaskInProgress): vimService.vim.VAppTaskInProgress;
         };
         VFlashCacheHotConfigNotSupported: {
            (options?: vimService.vim.VFlashCacheHotConfigNotSupported): vimService.vim.VFlashCacheHotConfigNotSupported;
         };
         VFlashModuleNotSupportedReason: {
            "CacheModeNotSupported": string;
            "CacheConsistencyTypeNotSupported": string;
            "CacheBlockSizeNotSupported": string;
            "CacheReservationNotSupported": string;
            "DiskSizeNotSupported": string;
         };
         VFlashModuleNotSupported: {
            (options?: vimService.vim.VFlashModuleNotSupported): vimService.vim.VFlashModuleNotSupported;
         };
         VFlashModuleVersionIncompatible: {
            (options?: vimService.vim.VFlashModuleVersionIncompatible): vimService.vim.VFlashModuleVersionIncompatible;
         };
         VMINotSupported: {
            (options?: vimService.vim.VMINotSupported): vimService.vim.VMINotSupported;
         };
         VMOnConflictDVPort: {
            (options?: vimService.vim.VMOnConflictDVPort): vimService.vim.VMOnConflictDVPort;
         };
         VMOnVirtualIntranet: {
            (options?: vimService.vim.VMOnVirtualIntranet): vimService.vim.VMOnVirtualIntranet;
         };
         VMotionAcrossNetworkNotSupported: {
            (options?: vimService.vim.VMotionAcrossNetworkNotSupported): vimService.vim.VMotionAcrossNetworkNotSupported;
         };
         VMotionInterfaceIssue: {
            (options?: vimService.vim.VMotionInterfaceIssue): vimService.vim.VMotionInterfaceIssue;
         };
         VMotionLinkCapacityLow: {
            (options?: vimService.vim.VMotionLinkCapacityLow): vimService.vim.VMotionLinkCapacityLow;
         };
         VMotionLinkDown: {
            (options?: vimService.vim.VMotionLinkDown): vimService.vim.VMotionLinkDown;
         };
         VMotionNotConfigured: {
            (options?: vimService.vim.VMotionNotConfigured): vimService.vim.VMotionNotConfigured;
         };
         VMotionNotLicensed: {
            (options?: vimService.vim.VMotionNotLicensed): vimService.vim.VMotionNotLicensed;
         };
         VMotionNotSupported: {
            (options?: vimService.vim.VMotionNotSupported): vimService.vim.VMotionNotSupported;
         };
         VMotionProtocolIncompatible: {
            (options?: vimService.vim.VMotionProtocolIncompatible): vimService.vim.VMotionProtocolIncompatible;
         };
         VimFault: {
            (options?: vimService.vim.VimFault): vimService.vim.VimFault;
         };
         VirtualDiskBlocksNotFullyProvisioned: {
            (options?: vimService.vim.VirtualDiskBlocksNotFullyProvisioned): vimService.vim.VirtualDiskBlocksNotFullyProvisioned;
         };
         VirtualDiskModeNotSupported: {
            (options?: vimService.vim.VirtualDiskModeNotSupported): vimService.vim.VirtualDiskModeNotSupported;
         };
         VirtualEthernetCardNotSupported: {
            (options?: vimService.vim.VirtualEthernetCardNotSupported): vimService.vim.VirtualEthernetCardNotSupported;
         };
         VirtualHardwareCompatibilityIssue: {
            (options?: vimService.vim.VirtualHardwareCompatibilityIssue): vimService.vim.VirtualHardwareCompatibilityIssue;
         };
         VirtualHardwareVersionNotSupported: {
            (options?: vimService.vim.VirtualHardwareVersionNotSupported): vimService.vim.VirtualHardwareVersionNotSupported;
         };
         VmAlreadyExistsInDatacenter: {
            (options?: vimService.vim.VmAlreadyExistsInDatacenter): vimService.vim.VmAlreadyExistsInDatacenter;
         };
         VmConfigFault: {
            (options?: vimService.vim.VmConfigFault): vimService.vim.VmConfigFault;
         };
         VmConfigIncompatibleForFaultTolerance: {
            (options?: vimService.vim.VmConfigIncompatibleForFaultTolerance): vimService.vim.VmConfigIncompatibleForFaultTolerance;
         };
         VmConfigIncompatibleForRecordReplay: {
            (options?: vimService.vim.VmConfigIncompatibleForRecordReplay): vimService.vim.VmConfigIncompatibleForRecordReplay;
         };
         VmFaultToleranceConfigIssueReasonForIssue: {
            "haNotEnabled": string;
            "moreThanOneSecondary": string;
            "recordReplayNotSupported": string;
            "replayNotSupported": string;
            "templateVm": string;
            "multipleVCPU": string;
            "hostInactive": string;
            "ftUnsupportedHardware": string;
            "ftUnsupportedProduct": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "thinDisk": string;
            "verifySSLCertificateFlagNotSet": string;
            "hasSnapshots": string;
            "noConfig": string;
            "ftSecondaryVm": string;
            "hasLocalDisk": string;
            "esxAgentVm": string;
            "video3dEnabled": string;
            "hasUnsupportedDisk": string;
            "insufficientBandwidth": string;
            "hasNestedHVConfiguration": string;
            "hasVFlashConfiguration": string;
            "unsupportedProduct": string;
            "cpuHvUnsupported": string;
            "cpuHwmmuUnsupported": string;
            "cpuHvDisabled": string;
            "hasEFIFirmware": string;
         };
         VmFaultToleranceConfigIssue: {
            (options?: vimService.vim.VmFaultToleranceConfigIssue): vimService.vim.VmFaultToleranceConfigIssue;
         };
         VmFaultToleranceConfigIssueWrapper: {
            (options?: vimService.vim.VmFaultToleranceConfigIssueWrapper): vimService.vim.VmFaultToleranceConfigIssueWrapper;
         };
         VmFaultToleranceInvalidFileBackingDeviceType: {
            "virtualFloppy": string;
            "virtualCdrom": string;
            "virtualSerialPort": string;
            "virtualParallelPort": string;
            "virtualDisk": string;
         };
         VmFaultToleranceInvalidFileBacking: {
            (options?: vimService.vim.VmFaultToleranceInvalidFileBacking): vimService.vim.VmFaultToleranceInvalidFileBacking;
         };
         VmFaultToleranceIssue: {
            (options?: vimService.vim.VmFaultToleranceIssue): vimService.vim.VmFaultToleranceIssue;
         };
         VmFaultToleranceOpIssuesList: {
            (options?: vimService.vim.VmFaultToleranceOpIssuesList): vimService.vim.VmFaultToleranceOpIssuesList;
         };
         VmFaultToleranceTooManyFtVcpusOnHost: {
            (options?: vimService.vim.VmFaultToleranceTooManyFtVcpusOnHost): vimService.vim.VmFaultToleranceTooManyFtVcpusOnHost;
         };
         VmFaultToleranceTooManyVMsOnHost: {
            (options?: vimService.vim.VmFaultToleranceTooManyVMsOnHost): vimService.vim.VmFaultToleranceTooManyVMsOnHost;
         };
         VmHostAffinityRuleViolation: {
            (options?: vimService.vim.VmHostAffinityRuleViolation): vimService.vim.VmHostAffinityRuleViolation;
         };
         VmLimitLicense: {
            (options?: vimService.vim.VmLimitLicense): vimService.vim.VmLimitLicense;
         };
         VmMetadataManagerFault: {
            (options?: vimService.vim.VmMetadataManagerFault): vimService.vim.VmMetadataManagerFault;
         };
         VmMonitorIncompatibleForFaultTolerance: {
            (options?: vimService.vim.VmMonitorIncompatibleForFaultTolerance): vimService.vim.VmMonitorIncompatibleForFaultTolerance;
         };
         VmPowerOnDisabled: {
            (options?: vimService.vim.VmPowerOnDisabled): vimService.vim.VmPowerOnDisabled;
         };
         VmSmpFaultToleranceTooManyVMsOnHost: {
            (options?: vimService.vim.VmSmpFaultToleranceTooManyVMsOnHost): vimService.vim.VmSmpFaultToleranceTooManyVMsOnHost;
         };
         VmToolsUpgradeFault: {
            (options?: vimService.vim.VmToolsUpgradeFault): vimService.vim.VmToolsUpgradeFault;
         };
         VmValidateMaxDevice: {
            (options?: vimService.vim.VmValidateMaxDevice): vimService.vim.VmValidateMaxDevice;
         };
         VmWwnConflict: {
            (options?: vimService.vim.VmWwnConflict): vimService.vim.VmWwnConflict;
         };
         VmfsAlreadyMounted: {
            (options?: vimService.vim.VmfsAlreadyMounted): vimService.vim.VmfsAlreadyMounted;
         };
         VmfsAmbiguousMount: {
            (options?: vimService.vim.VmfsAmbiguousMount): vimService.vim.VmfsAmbiguousMount;
         };
         VmfsMountFault: {
            (options?: vimService.vim.VmfsMountFault): vimService.vim.VmfsMountFault;
         };
         VmotionInterfaceNotEnabled: {
            (options?: vimService.vim.VmotionInterfaceNotEnabled): vimService.vim.VmotionInterfaceNotEnabled;
         };
         VolumeEditorError: {
            (options?: vimService.vim.VolumeEditorError): vimService.vim.VolumeEditorError;
         };
         VramLimitLicense: {
            (options?: vimService.vim.VramLimitLicense): vimService.vim.VramLimitLicense;
         };
         VsanClusterUuidMismatch: {
            (options?: vimService.vim.VsanClusterUuidMismatch): vimService.vim.VsanClusterUuidMismatch;
         };
         VsanDiskFault: {
            (options?: vimService.vim.VsanDiskFault): vimService.vim.VsanDiskFault;
         };
         VsanFault: {
            (options?: vimService.vim.VsanFault): vimService.vim.VsanFault;
         };
         VsanIncompatibleDiskMapping: {
            (options?: vimService.vim.VsanIncompatibleDiskMapping): vimService.vim.VsanIncompatibleDiskMapping;
         };
         VspanDestPortConflict: {
            (options?: vimService.vim.VspanDestPortConflict): vimService.vim.VspanDestPortConflict;
         };
         VspanPortConflict: {
            (options?: vimService.vim.VspanPortConflict): vimService.vim.VspanPortConflict;
         };
         VspanPortMoveFault: {
            (options?: vimService.vim.VspanPortMoveFault): vimService.vim.VspanPortMoveFault;
         };
         VspanPortPromiscChangeFault: {
            (options?: vimService.vim.VspanPortPromiscChangeFault): vimService.vim.VspanPortPromiscChangeFault;
         };
         VspanPortgroupPromiscChangeFault: {
            (options?: vimService.vim.VspanPortgroupPromiscChangeFault): vimService.vim.VspanPortgroupPromiscChangeFault;
         };
         VspanPortgroupTypeChangeFault: {
            (options?: vimService.vim.VspanPortgroupTypeChangeFault): vimService.vim.VspanPortgroupTypeChangeFault;
         };
         VspanPromiscuousPortNotSupported: {
            (options?: vimService.vim.VspanPromiscuousPortNotSupported): vimService.vim.VspanPromiscuousPortNotSupported;
         };
         VspanSameSessionPortConflict: {
            (options?: vimService.vim.VspanSameSessionPortConflict): vimService.vim.VspanSameSessionPortConflict;
         };
         WakeOnLanNotSupported: {
            (options?: vimService.vim.WakeOnLanNotSupported): vimService.vim.WakeOnLanNotSupported;
         };
         WakeOnLanNotSupportedByVmotionNIC: {
            (options?: vimService.vim.WakeOnLanNotSupportedByVmotionNIC): vimService.vim.WakeOnLanNotSupportedByVmotionNIC;
         };
         WillLoseHAProtectionResolution: {
            "svmotion": string;
            "relocate": string;
         };
         WillLoseHAProtection: {
            (options?: vimService.vim.WillLoseHAProtection): vimService.vim.WillLoseHAProtection;
         };
         WillModifyConfigCpuRequirements: {
            (options?: vimService.vim.WillModifyConfigCpuRequirements): vimService.vim.WillModifyConfigCpuRequirements;
         };
         WillResetSnapshotDirectory: {
            (options?: vimService.vim.WillResetSnapshotDirectory): vimService.vim.WillResetSnapshotDirectory;
         };
         WipeDiskFault: {
            (options?: vimService.vim.WipeDiskFault): vimService.vim.WipeDiskFault;
         };
         HostActiveDirectoryAuthenticationCertificateDigest: {
            "SHA1": string;
         };
         HostActiveDirectoryInfoDomainMembershipStatus: {
            "unknown": string;
            "ok": string;
            "noServers": string;
            "clientTrustBroken": string;
            "serverTrustBroken": string;
            "inconsistentTrust": string;
            "otherProblem": string;
         };
         HostActiveDirectoryInfo: {
            (options?: vimService.vim.HostActiveDirectoryInfo): vimService.vim.HostActiveDirectoryInfo;
         };
         HostActiveDirectorySpec: {
            (options?: vimService.vim.HostActiveDirectorySpec): vimService.vim.HostActiveDirectorySpec;
         };
         HostActiveDirectory: {
            (options?: vimService.vim.HostActiveDirectory): vimService.vim.HostActiveDirectory;
         };
         ArrayOfHostActiveDirectory: {
            (options?: vimService.vim.ArrayOfHostActiveDirectory): vimService.vim.ArrayOfHostActiveDirectory;
         };
         HostAuthenticationManagerInfo: {
            (options?: vimService.vim.HostAuthenticationManagerInfo): vimService.vim.HostAuthenticationManagerInfo;
         };
         HostAuthenticationStoreInfo: {
            (options?: vimService.vim.HostAuthenticationStoreInfo): vimService.vim.HostAuthenticationStoreInfo;
         };
         ArrayOfHostAuthenticationStoreInfo: {
            (options?: vimService.vim.ArrayOfHostAuthenticationStoreInfo): vimService.vim.ArrayOfHostAuthenticationStoreInfo;
         };
         AutoStartAction: {
            "none": string;
            "systemDefault": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         AutoStartDefaults: {
            (options?: vimService.vim.AutoStartDefaults): vimService.vim.AutoStartDefaults;
         };
         AutoStartWaitHeartbeatSetting: {
            "yes": string;
            "no": string;
            "systemDefault": string;
         };
         AutoStartPowerInfo: {
            (options?: vimService.vim.AutoStartPowerInfo): vimService.vim.AutoStartPowerInfo;
         };
         ArrayOfAutoStartPowerInfo: {
            (options?: vimService.vim.ArrayOfAutoStartPowerInfo): vimService.vim.ArrayOfAutoStartPowerInfo;
         };
         HostAutoStartManagerConfig: {
            (options?: vimService.vim.HostAutoStartManagerConfig): vimService.vim.HostAutoStartManagerConfig;
         };
         HostBootDeviceInfo: {
            (options?: vimService.vim.HostBootDeviceInfo): vimService.vim.HostBootDeviceInfo;
         };
         HostBootDevice: {
            (options?: vimService.vim.HostBootDevice): vimService.vim.HostBootDevice;
         };
         ArrayOfHostBootDevice: {
            (options?: vimService.vim.ArrayOfHostBootDevice): vimService.vim.ArrayOfHostBootDevice;
         };
         HostCacheConfigurationSpec: {
            (options?: vimService.vim.HostCacheConfigurationSpec): vimService.vim.HostCacheConfigurationSpec;
         };
         HostCacheConfigurationInfo: {
            (options?: vimService.vim.HostCacheConfigurationInfo): vimService.vim.HostCacheConfigurationInfo;
         };
         ArrayOfHostCacheConfigurationInfo: {
            (options?: vimService.vim.ArrayOfHostCacheConfigurationInfo): vimService.vim.ArrayOfHostCacheConfigurationInfo;
         };
         HostReplayUnsupportedReason: {
            "incompatibleProduct": string;
            "incompatibleCpu": string;
            "hvDisabled": string;
            "cpuidLimitSet": string;
            "oldBIOS": string;
            "unknown": string;
         };
         HostCapabilityFtUnsupportedReason: {
            "vMotionNotLicensed": string;
            "missingVMotionNic": string;
            "missingFTLoggingNic": string;
            "ftNotLicensed": string;
            "haAgentIssue": string;
            "unsupportedProduct": string;
            "cpuHvUnsupported": string;
            "cpuHwmmuUnsupported": string;
            "cpuHvDisabled": string;
         };
         HostCapabilityVmDirectPathGen2UnsupportedReason: {
            "hostNptIncompatibleProduct": string;
            "hostNptIncompatibleHardware": string;
            "hostNptDisabled": string;
         };
         HostCapability: {
            (options?: vimService.vim.HostCapability): vimService.vim.HostCapability;
         };
         HostCertificateManagerCertificateInfoCertificateStatus: {
            "unknown": string;
            "expired": string;
            "expiring": string;
            "expiringShortly": string;
            "expirationImminent": string;
            "good": string;
            "revoked": string;
         };
         HostCertificateManagerCertificateInfo: {
            (options?: vimService.vim.HostCertificateManagerCertificateInfo): vimService.vim.HostCertificateManagerCertificateInfo;
         };
         HostConfigChangeMode: {
            "modify": string;
            "replace": string;
         };
         HostConfigChangeOperation: {
            "add": string;
            "remove": string;
            "edit": string;
            "ignore": string;
         };
         HostConfigChange: {
            (options?: vimService.vim.HostConfigChange): vimService.vim.HostConfigChange;
         };
         HostConfigInfo: {
            (options?: vimService.vim.HostConfigInfo): vimService.vim.HostConfigInfo;
         };
         HostConfigManager: {
            (options?: vimService.vim.HostConfigManager): vimService.vim.HostConfigManager;
         };
         HostConfigSpec: {
            (options?: vimService.vim.HostConfigSpec): vimService.vim.HostConfigSpec;
         };
         HostConnectInfoNetworkInfo: {
            (options?: vimService.vim.HostConnectInfoNetworkInfo): vimService.vim.HostConnectInfoNetworkInfo;
         };
         ArrayOfHostConnectInfoNetworkInfo: {
            (options?: vimService.vim.ArrayOfHostConnectInfoNetworkInfo): vimService.vim.ArrayOfHostConnectInfoNetworkInfo;
         };
         HostNewNetworkConnectInfo: {
            (options?: vimService.vim.HostNewNetworkConnectInfo): vimService.vim.HostNewNetworkConnectInfo;
         };
         HostDatastoreConnectInfo: {
            (options?: vimService.vim.HostDatastoreConnectInfo): vimService.vim.HostDatastoreConnectInfo;
         };
         ArrayOfHostDatastoreConnectInfo: {
            (options?: vimService.vim.ArrayOfHostDatastoreConnectInfo): vimService.vim.ArrayOfHostDatastoreConnectInfo;
         };
         HostDatastoreExistsConnectInfo: {
            (options?: vimService.vim.HostDatastoreExistsConnectInfo): vimService.vim.HostDatastoreExistsConnectInfo;
         };
         HostDatastoreNameConflictConnectInfo: {
            (options?: vimService.vim.HostDatastoreNameConflictConnectInfo): vimService.vim.HostDatastoreNameConflictConnectInfo;
         };
         HostLicenseConnectInfo: {
            (options?: vimService.vim.HostLicenseConnectInfo): vimService.vim.HostLicenseConnectInfo;
         };
         HostConnectInfo: {
            (options?: vimService.vim.HostConnectInfo): vimService.vim.HostConnectInfo;
         };
         HostConnectSpec: {
            (options?: vimService.vim.HostConnectSpec): vimService.vim.HostConnectSpec;
         };
         HostCpuIdInfo: {
            (options?: vimService.vim.HostCpuIdInfo): vimService.vim.HostCpuIdInfo;
         };
         ArrayOfHostCpuIdInfo: {
            (options?: vimService.vim.ArrayOfHostCpuIdInfo): vimService.vim.ArrayOfHostCpuIdInfo;
         };
         HostHyperThreadScheduleInfo: {
            (options?: vimService.vim.HostHyperThreadScheduleInfo): vimService.vim.HostHyperThreadScheduleInfo;
         };
         FileQueryFlags: {
            (options?: vimService.vim.FileQueryFlags): vimService.vim.FileQueryFlags;
         };
         FileInfo: {
            (options?: vimService.vim.FileInfo): vimService.vim.FileInfo;
         };
         ArrayOfFileInfo: {
            (options?: vimService.vim.ArrayOfFileInfo): vimService.vim.ArrayOfFileInfo;
         };
         FileQuery: {
            (options?: vimService.vim.FileQuery): vimService.vim.FileQuery;
         };
         ArrayOfFileQuery: {
            (options?: vimService.vim.ArrayOfFileQuery): vimService.vim.ArrayOfFileQuery;
         };
         VmConfigFileQueryFilter: {
            (options?: vimService.vim.VmConfigFileQueryFilter): vimService.vim.VmConfigFileQueryFilter;
         };
         VmConfigFileQueryFlags: {
            (options?: vimService.vim.VmConfigFileQueryFlags): vimService.vim.VmConfigFileQueryFlags;
         };
         VmConfigFileQuery: {
            (options?: vimService.vim.VmConfigFileQuery): vimService.vim.VmConfigFileQuery;
         };
         TemplateConfigFileQuery: {
            (options?: vimService.vim.TemplateConfigFileQuery): vimService.vim.TemplateConfigFileQuery;
         };
         VmDiskFileQueryFilter: {
            (options?: vimService.vim.VmDiskFileQueryFilter): vimService.vim.VmDiskFileQueryFilter;
         };
         VmDiskFileQueryFlags: {
            (options?: vimService.vim.VmDiskFileQueryFlags): vimService.vim.VmDiskFileQueryFlags;
         };
         VmDiskFileQuery: {
            (options?: vimService.vim.VmDiskFileQuery): vimService.vim.VmDiskFileQuery;
         };
         FolderFileQuery: {
            (options?: vimService.vim.FolderFileQuery): vimService.vim.FolderFileQuery;
         };
         VmSnapshotFileQuery: {
            (options?: vimService.vim.VmSnapshotFileQuery): vimService.vim.VmSnapshotFileQuery;
         };
         IsoImageFileQuery: {
            (options?: vimService.vim.IsoImageFileQuery): vimService.vim.IsoImageFileQuery;
         };
         FloppyImageFileQuery: {
            (options?: vimService.vim.FloppyImageFileQuery): vimService.vim.FloppyImageFileQuery;
         };
         VmNvramFileQuery: {
            (options?: vimService.vim.VmNvramFileQuery): vimService.vim.VmNvramFileQuery;
         };
         VmLogFileQuery: {
            (options?: vimService.vim.VmLogFileQuery): vimService.vim.VmLogFileQuery;
         };
         VmConfigFileInfo: {
            (options?: vimService.vim.VmConfigFileInfo): vimService.vim.VmConfigFileInfo;
         };
         TemplateConfigFileInfo: {
            (options?: vimService.vim.TemplateConfigFileInfo): vimService.vim.TemplateConfigFileInfo;
         };
         VmDiskFileInfo: {
            (options?: vimService.vim.VmDiskFileInfo): vimService.vim.VmDiskFileInfo;
         };
         FolderFileInfo: {
            (options?: vimService.vim.FolderFileInfo): vimService.vim.FolderFileInfo;
         };
         VmSnapshotFileInfo: {
            (options?: vimService.vim.VmSnapshotFileInfo): vimService.vim.VmSnapshotFileInfo;
         };
         IsoImageFileInfo: {
            (options?: vimService.vim.IsoImageFileInfo): vimService.vim.IsoImageFileInfo;
         };
         FloppyImageFileInfo: {
            (options?: vimService.vim.FloppyImageFileInfo): vimService.vim.FloppyImageFileInfo;
         };
         VmNvramFileInfo: {
            (options?: vimService.vim.VmNvramFileInfo): vimService.vim.VmNvramFileInfo;
         };
         VmLogFileInfo: {
            (options?: vimService.vim.VmLogFileInfo): vimService.vim.VmLogFileInfo;
         };
         HostDatastoreBrowserSearchSpec: {
            (options?: vimService.vim.HostDatastoreBrowserSearchSpec): vimService.vim.HostDatastoreBrowserSearchSpec;
         };
         HostDatastoreBrowserSearchResults: {
            (options?: vimService.vim.HostDatastoreBrowserSearchResults): vimService.vim.HostDatastoreBrowserSearchResults;
         };
         ArrayOfHostDatastoreBrowserSearchResults: {
            (options?: vimService.vim.ArrayOfHostDatastoreBrowserSearchResults): vimService.vim.ArrayOfHostDatastoreBrowserSearchResults;
         };
         HostDatastoreSystemCapabilities: {
            (options?: vimService.vim.HostDatastoreSystemCapabilities): vimService.vim.HostDatastoreSystemCapabilities;
         };
         HostDatastoreSystemVvolDatastoreSpec: {
            (options?: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): vimService.vim.HostDatastoreSystemVvolDatastoreSpec;
         };
         HostDatastoreSystemDatastoreResult: {
            (options?: vimService.vim.HostDatastoreSystemDatastoreResult): vimService.vim.HostDatastoreSystemDatastoreResult;
         };
         ArrayOfHostDatastoreSystemDatastoreResult: {
            (options?: vimService.vim.ArrayOfHostDatastoreSystemDatastoreResult): vimService.vim.ArrayOfHostDatastoreSystemDatastoreResult;
         };
         VmfsDatastoreInfo: {
            (options?: vimService.vim.VmfsDatastoreInfo): vimService.vim.VmfsDatastoreInfo;
         };
         NasDatastoreInfo: {
            (options?: vimService.vim.NasDatastoreInfo): vimService.vim.NasDatastoreInfo;
         };
         LocalDatastoreInfo: {
            (options?: vimService.vim.LocalDatastoreInfo): vimService.vim.LocalDatastoreInfo;
         };
         VmfsDatastoreSpec: {
            (options?: vimService.vim.VmfsDatastoreSpec): vimService.vim.VmfsDatastoreSpec;
         };
         VmfsDatastoreCreateSpec: {
            (options?: vimService.vim.VmfsDatastoreCreateSpec): vimService.vim.VmfsDatastoreCreateSpec;
         };
         VmfsDatastoreExtendSpec: {
            (options?: vimService.vim.VmfsDatastoreExtendSpec): vimService.vim.VmfsDatastoreExtendSpec;
         };
         VmfsDatastoreExpandSpec: {
            (options?: vimService.vim.VmfsDatastoreExpandSpec): vimService.vim.VmfsDatastoreExpandSpec;
         };
         VmfsDatastoreBaseOption: {
            (options?: vimService.vim.VmfsDatastoreBaseOption): vimService.vim.VmfsDatastoreBaseOption;
         };
         VmfsDatastoreSingleExtentOption: {
            (options?: vimService.vim.VmfsDatastoreSingleExtentOption): vimService.vim.VmfsDatastoreSingleExtentOption;
         };
         VmfsDatastoreAllExtentOption: {
            (options?: vimService.vim.VmfsDatastoreAllExtentOption): vimService.vim.VmfsDatastoreAllExtentOption;
         };
         VmfsDatastoreMultipleExtentOption: {
            (options?: vimService.vim.VmfsDatastoreMultipleExtentOption): vimService.vim.VmfsDatastoreMultipleExtentOption;
         };
         VmfsDatastoreOption: {
            (options?: vimService.vim.VmfsDatastoreOption): vimService.vim.VmfsDatastoreOption;
         };
         ArrayOfVmfsDatastoreOption: {
            (options?: vimService.vim.ArrayOfVmfsDatastoreOption): vimService.vim.ArrayOfVmfsDatastoreOption;
         };
         VvolDatastoreInfo: {
            (options?: vimService.vim.VvolDatastoreInfo): vimService.vim.VvolDatastoreInfo;
         };
         HostDateTimeConfig: {
            (options?: vimService.vim.HostDateTimeConfig): vimService.vim.HostDateTimeConfig;
         };
         HostDateTimeInfo: {
            (options?: vimService.vim.HostDateTimeInfo): vimService.vim.HostDateTimeInfo;
         };
         HostDateTimeSystemTimeZone: {
            (options?: vimService.vim.HostDateTimeSystemTimeZone): vimService.vim.HostDateTimeSystemTimeZone;
         };
         ArrayOfHostDateTimeSystemTimeZone: {
            (options?: vimService.vim.ArrayOfHostDateTimeSystemTimeZone): vimService.vim.ArrayOfHostDateTimeSystemTimeZone;
         };
         HostDevice: {
            (options?: vimService.vim.HostDevice): vimService.vim.HostDevice;
         };
         HostDhcpServiceSpec: {
            (options?: vimService.vim.HostDhcpServiceSpec): vimService.vim.HostDhcpServiceSpec;
         };
         HostDhcpServiceConfig: {
            (options?: vimService.vim.HostDhcpServiceConfig): vimService.vim.HostDhcpServiceConfig;
         };
         ArrayOfHostDhcpServiceConfig: {
            (options?: vimService.vim.ArrayOfHostDhcpServiceConfig): vimService.vim.ArrayOfHostDhcpServiceConfig;
         };
         HostDhcpService: {
            (options?: vimService.vim.HostDhcpService): vimService.vim.HostDhcpService;
         };
         ArrayOfHostDhcpService: {
            (options?: vimService.vim.ArrayOfHostDhcpService): vimService.vim.ArrayOfHostDhcpService;
         };
         DiagnosticPartitionStorageType: {
            "directAttached": string;
            "networkAttached": string;
         };
         DiagnosticPartitionType: {
            "singleHost": string;
            "multiHost": string;
         };
         HostDiagnosticPartitionCreateOption: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateOption): vimService.vim.HostDiagnosticPartitionCreateOption;
         };
         ArrayOfHostDiagnosticPartitionCreateOption: {
            (options?: vimService.vim.ArrayOfHostDiagnosticPartitionCreateOption): vimService.vim.ArrayOfHostDiagnosticPartitionCreateOption;
         };
         HostDiagnosticPartitionCreateSpec: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateSpec): vimService.vim.HostDiagnosticPartitionCreateSpec;
         };
         HostDiagnosticPartitionCreateDescription: {
            (options?: vimService.vim.HostDiagnosticPartitionCreateDescription): vimService.vim.HostDiagnosticPartitionCreateDescription;
         };
         HostDiagnosticPartition: {
            (options?: vimService.vim.HostDiagnosticPartition): vimService.vim.HostDiagnosticPartition;
         };
         ArrayOfHostDiagnosticPartition: {
            (options?: vimService.vim.ArrayOfHostDiagnosticPartition): vimService.vim.ArrayOfHostDiagnosticPartition;
         };
         HostDirectoryStoreInfo: {
            (options?: vimService.vim.HostDirectoryStoreInfo): vimService.vim.HostDirectoryStoreInfo;
         };
         HostDiskConfigurationResult: {
            (options?: vimService.vim.HostDiskConfigurationResult): vimService.vim.HostDiskConfigurationResult;
         };
         ArrayOfHostDiskConfigurationResult: {
            (options?: vimService.vim.ArrayOfHostDiskConfigurationResult): vimService.vim.ArrayOfHostDiskConfigurationResult;
         };
         HostDiskDimensionsChs: {
            (options?: vimService.vim.HostDiskDimensionsChs): vimService.vim.HostDiskDimensionsChs;
         };
         HostDiskDimensionsLba: {
            (options?: vimService.vim.HostDiskDimensionsLba): vimService.vim.HostDiskDimensionsLba;
         };
         HostDiskDimensions: {
            (options?: vimService.vim.HostDiskDimensions): vimService.vim.HostDiskDimensions;
         };
         HostDiskPartitionInfoPartitionFormat: {
            "gpt": string;
            "mbr": string;
            "unknown": string;
         };
         HostDiskPartitionInfoType: {
            "none": string;
            "vmfs": string;
            "linuxNative": string;
            "linuxSwap": string;
            "extended": string;
            "ntfs": string;
            "vmkDiagnostic": string;
            "vffs": string;
         };
         HostDiskPartitionAttributes: {
            (options?: vimService.vim.HostDiskPartitionAttributes): vimService.vim.HostDiskPartitionAttributes;
         };
         ArrayOfHostDiskPartitionAttributes: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionAttributes): vimService.vim.ArrayOfHostDiskPartitionAttributes;
         };
         HostDiskPartitionBlockRange: {
            (options?: vimService.vim.HostDiskPartitionBlockRange): vimService.vim.HostDiskPartitionBlockRange;
         };
         ArrayOfHostDiskPartitionBlockRange: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionBlockRange): vimService.vim.ArrayOfHostDiskPartitionBlockRange;
         };
         HostDiskPartitionSpec: {
            (options?: vimService.vim.HostDiskPartitionSpec): vimService.vim.HostDiskPartitionSpec;
         };
         HostDiskPartitionLayout: {
            (options?: vimService.vim.HostDiskPartitionLayout): vimService.vim.HostDiskPartitionLayout;
         };
         HostDiskPartitionInfo: {
            (options?: vimService.vim.HostDiskPartitionInfo): vimService.vim.HostDiskPartitionInfo;
         };
         ArrayOfHostDiskPartitionInfo: {
            (options?: vimService.vim.ArrayOfHostDiskPartitionInfo): vimService.vim.ArrayOfHostDiskPartitionInfo;
         };
         HostDnsConfig: {
            (options?: vimService.vim.HostDnsConfig): vimService.vim.HostDnsConfig;
         };
         HostDnsConfigSpec: {
            (options?: vimService.vim.HostDnsConfigSpec): vimService.vim.HostDnsConfigSpec;
         };
         HostEsxAgentHostManagerConfigInfo: {
            (options?: vimService.vim.HostEsxAgentHostManagerConfigInfo): vimService.vim.HostEsxAgentHostManagerConfigInfo;
         };
         HostFaultToleranceManagerComponentHealthInfo: {
            (options?: vimService.vim.HostFaultToleranceManagerComponentHealthInfo): vimService.vim.HostFaultToleranceManagerComponentHealthInfo;
         };
         FcoeConfigVlanRange: {
            (options?: vimService.vim.FcoeConfigVlanRange): vimService.vim.FcoeConfigVlanRange;
         };
         ArrayOfFcoeConfigVlanRange: {
            (options?: vimService.vim.ArrayOfFcoeConfigVlanRange): vimService.vim.ArrayOfFcoeConfigVlanRange;
         };
         FcoeConfigFcoeCapabilities: {
            (options?: vimService.vim.FcoeConfigFcoeCapabilities): vimService.vim.FcoeConfigFcoeCapabilities;
         };
         FcoeConfigFcoeSpecification: {
            (options?: vimService.vim.FcoeConfigFcoeSpecification): vimService.vim.FcoeConfigFcoeSpecification;
         };
         FcoeConfig: {
            (options?: vimService.vim.FcoeConfig): vimService.vim.FcoeConfig;
         };
         HostFeatureCapability: {
            (options?: vimService.vim.HostFeatureCapability): vimService.vim.HostFeatureCapability;
         };
         ArrayOfHostFeatureCapability: {
            (options?: vimService.vim.ArrayOfHostFeatureCapability): vimService.vim.ArrayOfHostFeatureCapability;
         };
         HostFeatureMask: {
            (options?: vimService.vim.HostFeatureMask): vimService.vim.HostFeatureMask;
         };
         ArrayOfHostFeatureMask: {
            (options?: vimService.vim.ArrayOfHostFeatureMask): vimService.vim.ArrayOfHostFeatureMask;
         };
         HostFeatureVersionKey: {
            "faultTolerance": string;
         };
         HostFeatureVersionInfo: {
            (options?: vimService.vim.HostFeatureVersionInfo): vimService.vim.HostFeatureVersionInfo;
         };
         ArrayOfHostFeatureVersionInfo: {
            (options?: vimService.vim.ArrayOfHostFeatureVersionInfo): vimService.vim.ArrayOfHostFeatureVersionInfo;
         };
         ModeInfo: {
            (options?: vimService.vim.ModeInfo): vimService.vim.ModeInfo;
         };
         HostFileAccess: {
            (options?: vimService.vim.HostFileAccess): vimService.vim.HostFileAccess;
         };
         HostFileSystemVolumeInfo: {
            (options?: vimService.vim.HostFileSystemVolumeInfo): vimService.vim.HostFileSystemVolumeInfo;
         };
         FileSystemMountInfoVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         HostFileSystemMountInfo: {
            (options?: vimService.vim.HostFileSystemMountInfo): vimService.vim.HostFileSystemMountInfo;
         };
         ArrayOfHostFileSystemMountInfo: {
            (options?: vimService.vim.ArrayOfHostFileSystemMountInfo): vimService.vim.ArrayOfHostFileSystemMountInfo;
         };
         HostFileSystemVolumeFileSystemType: {
            "VMFS": string;
            "NFS": string;
            "NFS41": string;
            "CIFS": string;
            "vsan": string;
            "VFFS": string;
            "VVOL": string;
            "OTHER": string;
         };
         HostFileSystemVolume: {
            (options?: vimService.vim.HostFileSystemVolume): vimService.vim.HostFileSystemVolume;
         };
         HostNasVolumeUserInfo: {
            (options?: vimService.vim.HostNasVolumeUserInfo): vimService.vim.HostNasVolumeUserInfo;
         };
         HostNasVolumeSecurityType: {
            "AUTH_SYS": string;
            "SEC_KRB5": string;
         };
         HostNasVolumeSpec: {
            (options?: vimService.vim.HostNasVolumeSpec): vimService.vim.HostNasVolumeSpec;
         };
         HostNasVolumeConfig: {
            (options?: vimService.vim.HostNasVolumeConfig): vimService.vim.HostNasVolumeConfig;
         };
         ArrayOfHostNasVolumeConfig: {
            (options?: vimService.vim.ArrayOfHostNasVolumeConfig): vimService.vim.ArrayOfHostNasVolumeConfig;
         };
         HostNasVolume: {
            (options?: vimService.vim.HostNasVolume): vimService.vim.HostNasVolume;
         };
         HostLocalFileSystemVolumeSpec: {
            (options?: vimService.vim.HostLocalFileSystemVolumeSpec): vimService.vim.HostLocalFileSystemVolumeSpec;
         };
         HostLocalFileSystemVolume: {
            (options?: vimService.vim.HostLocalFileSystemVolume): vimService.vim.HostLocalFileSystemVolume;
         };
         HostVfatVolume: {
            (options?: vimService.vim.HostVfatVolume): vimService.vim.HostVfatVolume;
         };
         HostFirewallConfigRuleSetConfig: {
            (options?: vimService.vim.HostFirewallConfigRuleSetConfig): vimService.vim.HostFirewallConfigRuleSetConfig;
         };
         ArrayOfHostFirewallConfigRuleSetConfig: {
            (options?: vimService.vim.ArrayOfHostFirewallConfigRuleSetConfig): vimService.vim.ArrayOfHostFirewallConfigRuleSetConfig;
         };
         HostFirewallConfig: {
            (options?: vimService.vim.HostFirewallConfig): vimService.vim.HostFirewallConfig;
         };
         HostFirewallDefaultPolicy: {
            (options?: vimService.vim.HostFirewallDefaultPolicy): vimService.vim.HostFirewallDefaultPolicy;
         };
         HostFirewallInfo: {
            (options?: vimService.vim.HostFirewallInfo): vimService.vim.HostFirewallInfo;
         };
         HostFlagInfo: {
            (options?: vimService.vim.HostFlagInfo): vimService.vim.HostFlagInfo;
         };
         HostForceMountedInfo: {
            (options?: vimService.vim.HostForceMountedInfo): vimService.vim.HostForceMountedInfo;
         };
         HostGatewaySpec: {
            (options?: vimService.vim.HostGatewaySpec): vimService.vim.HostGatewaySpec;
         };
         HostGraphicsInfoGraphicsType: {
            "basic": string;
            "shared": string;
            "direct": string;
         };
         HostGraphicsInfo: {
            (options?: vimService.vim.HostGraphicsInfo): vimService.vim.HostGraphicsInfo;
         };
         ArrayOfHostGraphicsInfo: {
            (options?: vimService.vim.ArrayOfHostGraphicsInfo): vimService.vim.ArrayOfHostGraphicsInfo;
         };
         HostHardwareInfo: {
            (options?: vimService.vim.HostHardwareInfo): vimService.vim.HostHardwareInfo;
         };
         HostSystemInfo: {
            (options?: vimService.vim.HostSystemInfo): vimService.vim.HostSystemInfo;
         };
         HostCpuPowerManagementInfoPolicyType: {
            "off": string;
            "staticPolicy": string;
            "dynamicPolicy": string;
         };
         HostCpuPowerManagementInfo: {
            (options?: vimService.vim.HostCpuPowerManagementInfo): vimService.vim.HostCpuPowerManagementInfo;
         };
         HostCpuInfo: {
            (options?: vimService.vim.HostCpuInfo): vimService.vim.HostCpuInfo;
         };
         HostCpuPackageVendor: {
            "unknown": string;
            "intel": string;
            "amd": string;
         };
         HostCpuPackage: {
            (options?: vimService.vim.HostCpuPackage): vimService.vim.HostCpuPackage;
         };
         ArrayOfHostCpuPackage: {
            (options?: vimService.vim.ArrayOfHostCpuPackage): vimService.vim.ArrayOfHostCpuPackage;
         };
         HostNumaInfo: {
            (options?: vimService.vim.HostNumaInfo): vimService.vim.HostNumaInfo;
         };
         HostNumaNode: {
            (options?: vimService.vim.HostNumaNode): vimService.vim.HostNumaNode;
         };
         ArrayOfHostNumaNode: {
            (options?: vimService.vim.ArrayOfHostNumaNode): vimService.vim.ArrayOfHostNumaNode;
         };
         HostBIOSInfo: {
            (options?: vimService.vim.HostBIOSInfo): vimService.vim.HostBIOSInfo;
         };
         HostReliableMemoryInfo: {
            (options?: vimService.vim.HostReliableMemoryInfo): vimService.vim.HostReliableMemoryInfo;
         };
         HostHardwareElementStatus: {
            "Unknown": string;
            "Green": string;
            "Yellow": string;
            "Red": string;
         };
         HostHardwareElementInfo: {
            (options?: vimService.vim.HostHardwareElementInfo): vimService.vim.HostHardwareElementInfo;
         };
         ArrayOfHostHardwareElementInfo: {
            (options?: vimService.vim.ArrayOfHostHardwareElementInfo): vimService.vim.ArrayOfHostHardwareElementInfo;
         };
         HostStorageOperationalInfo: {
            (options?: vimService.vim.HostStorageOperationalInfo): vimService.vim.HostStorageOperationalInfo;
         };
         ArrayOfHostStorageOperationalInfo: {
            (options?: vimService.vim.ArrayOfHostStorageOperationalInfo): vimService.vim.ArrayOfHostStorageOperationalInfo;
         };
         HostStorageElementInfo: {
            (options?: vimService.vim.HostStorageElementInfo): vimService.vim.HostStorageElementInfo;
         };
         ArrayOfHostStorageElementInfo: {
            (options?: vimService.vim.ArrayOfHostStorageElementInfo): vimService.vim.ArrayOfHostStorageElementInfo;
         };
         HostHardwareStatusInfo: {
            (options?: vimService.vim.HostHardwareStatusInfo): vimService.vim.HostHardwareStatusInfo;
         };
         HealthSystemRuntime: {
            (options?: vimService.vim.HealthSystemRuntime): vimService.vim.HealthSystemRuntime;
         };
         HostAccessMode: {
            "accessNone": string;
            "accessAdmin": string;
            "accessNoAccess": string;
            "accessReadOnly": string;
            "accessOther": string;
         };
         HostAccessControlEntry: {
            (options?: vimService.vim.HostAccessControlEntry): vimService.vim.HostAccessControlEntry;
         };
         ArrayOfHostAccessControlEntry: {
            (options?: vimService.vim.ArrayOfHostAccessControlEntry): vimService.vim.ArrayOfHostAccessControlEntry;
         };
         HostLockdownMode: {
            "lockdownDisabled": string;
            "lockdownNormal": string;
            "lockdownStrict": string;
         };
         HostHostBusAdapter: {
            (options?: vimService.vim.HostHostBusAdapter): vimService.vim.HostHostBusAdapter;
         };
         ArrayOfHostHostBusAdapter: {
            (options?: vimService.vim.ArrayOfHostHostBusAdapter): vimService.vim.ArrayOfHostHostBusAdapter;
         };
         HostParallelScsiHba: {
            (options?: vimService.vim.HostParallelScsiHba): vimService.vim.HostParallelScsiHba;
         };
         HostBlockHba: {
            (options?: vimService.vim.HostBlockHba): vimService.vim.HostBlockHba;
         };
         FibreChannelPortType: {
            "fabric": string;
            "loop": string;
            "pointToPoint": string;
            "unknown": string;
         };
         HostFibreChannelHba: {
            (options?: vimService.vim.HostFibreChannelHba): vimService.vim.HostFibreChannelHba;
         };
         HostInternetScsiHbaParamValue: {
            (options?: vimService.vim.HostInternetScsiHbaParamValue): vimService.vim.HostInternetScsiHbaParamValue;
         };
         ArrayOfHostInternetScsiHbaParamValue: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaParamValue): vimService.vim.ArrayOfHostInternetScsiHbaParamValue;
         };
         HostInternetScsiHbaDiscoveryCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaDiscoveryCapabilities): vimService.vim.HostInternetScsiHbaDiscoveryCapabilities;
         };
         InternetScsiSnsDiscoveryMethod: {
            "isnsStatic": string;
            "isnsDhcp": string;
            "isnsSlp": string;
         };
         SlpDiscoveryMethod: {
            "slpDhcp": string;
            "slpAutoUnicast": string;
            "slpAutoMulticast": string;
            "slpManual": string;
         };
         HostInternetScsiHbaDiscoveryProperties: {
            (options?: vimService.vim.HostInternetScsiHbaDiscoveryProperties): vimService.vim.HostInternetScsiHbaDiscoveryProperties;
         };
         HostInternetScsiHbaChapAuthenticationType: {
            "chapProhibited": string;
            "chapDiscouraged": string;
            "chapPreferred": string;
            "chapRequired": string;
         };
         HostInternetScsiHbaAuthenticationCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaAuthenticationCapabilities): vimService.vim.HostInternetScsiHbaAuthenticationCapabilities;
         };
         HostInternetScsiHbaAuthenticationProperties: {
            (options?: vimService.vim.HostInternetScsiHbaAuthenticationProperties): vimService.vim.HostInternetScsiHbaAuthenticationProperties;
         };
         HostInternetScsiHbaDigestType: {
            "digestProhibited": string;
            "digestDiscouraged": string;
            "digestPreferred": string;
            "digestRequired": string;
         };
         HostInternetScsiHbaDigestCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaDigestCapabilities): vimService.vim.HostInternetScsiHbaDigestCapabilities;
         };
         HostInternetScsiHbaDigestProperties: {
            (options?: vimService.vim.HostInternetScsiHbaDigestProperties): vimService.vim.HostInternetScsiHbaDigestProperties;
         };
         HostInternetScsiHbaIPCapabilities: {
            (options?: vimService.vim.HostInternetScsiHbaIPCapabilities): vimService.vim.HostInternetScsiHbaIPCapabilities;
         };
         HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType: {
            "DHCP": string;
            "AutoConfigured": string;
            "Static": string;
            "Other": string;
         };
         HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation: {
            "add": string;
            "remove": string;
         };
         HostInternetScsiHbaIscsiIpv6Address: {
            (options?: vimService.vim.HostInternetScsiHbaIscsiIpv6Address): vimService.vim.HostInternetScsiHbaIscsiIpv6Address;
         };
         ArrayOfHostInternetScsiHbaIscsiIpv6Address: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaIscsiIpv6Address): vimService.vim.ArrayOfHostInternetScsiHbaIscsiIpv6Address;
         };
         HostInternetScsiHbaIPv6Properties: {
            (options?: vimService.vim.HostInternetScsiHbaIPv6Properties): vimService.vim.HostInternetScsiHbaIPv6Properties;
         };
         HostInternetScsiHbaIPProperties: {
            (options?: vimService.vim.HostInternetScsiHbaIPProperties): vimService.vim.HostInternetScsiHbaIPProperties;
         };
         HostInternetScsiHbaSendTarget: {
            (options?: vimService.vim.HostInternetScsiHbaSendTarget): vimService.vim.HostInternetScsiHbaSendTarget;
         };
         ArrayOfHostInternetScsiHbaSendTarget: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaSendTarget): vimService.vim.ArrayOfHostInternetScsiHbaSendTarget;
         };
         HostInternetScsiHbaStaticTargetTargetDiscoveryMethod: {
            "staticMethod": string;
            "sendTargetMethod": string;
            "slpMethod": string;
            "isnsMethod": string;
            "unknownMethod": string;
         };
         HostInternetScsiHbaStaticTarget: {
            (options?: vimService.vim.HostInternetScsiHbaStaticTarget): vimService.vim.HostInternetScsiHbaStaticTarget;
         };
         ArrayOfHostInternetScsiHbaStaticTarget: {
            (options?: vimService.vim.ArrayOfHostInternetScsiHbaStaticTarget): vimService.vim.ArrayOfHostInternetScsiHbaStaticTarget;
         };
         HostInternetScsiHbaTargetSet: {
            (options?: vimService.vim.HostInternetScsiHbaTargetSet): vimService.vim.HostInternetScsiHbaTargetSet;
         };
         HostInternetScsiHbaNetworkBindingSupportType: {
            "notsupported": string;
            "optional": string;
            "required": string;
         };
         HostInternetScsiHba: {
            (options?: vimService.vim.HostInternetScsiHba): vimService.vim.HostInternetScsiHba;
         };
         HostFibreChannelOverEthernetHbaLinkInfo: {
            (options?: vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo): vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
         };
         HostFibreChannelOverEthernetHba: {
            (options?: vimService.vim.HostFibreChannelOverEthernetHba): vimService.vim.HostFibreChannelOverEthernetHba;
         };
         HostProxySwitchSpec: {
            (options?: vimService.vim.HostProxySwitchSpec): vimService.vim.HostProxySwitchSpec;
         };
         HostProxySwitchConfig: {
            (options?: vimService.vim.HostProxySwitchConfig): vimService.vim.HostProxySwitchConfig;
         };
         ArrayOfHostProxySwitchConfig: {
            (options?: vimService.vim.ArrayOfHostProxySwitchConfig): vimService.vim.ArrayOfHostProxySwitchConfig;
         };
         HostProxySwitchHostLagConfig: {
            (options?: vimService.vim.HostProxySwitchHostLagConfig): vimService.vim.HostProxySwitchHostLagConfig;
         };
         ArrayOfHostProxySwitchHostLagConfig: {
            (options?: vimService.vim.ArrayOfHostProxySwitchHostLagConfig): vimService.vim.ArrayOfHostProxySwitchHostLagConfig;
         };
         HostProxySwitch: {
            (options?: vimService.vim.HostProxySwitch): vimService.vim.HostProxySwitch;
         };
         ArrayOfHostProxySwitch: {
            (options?: vimService.vim.ArrayOfHostProxySwitch): vimService.vim.ArrayOfHostProxySwitch;
         };
         HostImageAcceptanceLevel: {
            "vmware_certified": string;
            "vmware_accepted": string;
            "partner": string;
            "community": string;
         };
         HostImageProfileSummary: {
            (options?: vimService.vim.HostImageProfileSummary): vimService.vim.HostImageProfileSummary;
         };
         HostIpConfigIpV6AddressConfigType: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         HostIpConfigIpV6AddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         HostIpConfigIpV6Address: {
            (options?: vimService.vim.HostIpConfigIpV6Address): vimService.vim.HostIpConfigIpV6Address;
         };
         ArrayOfHostIpConfigIpV6Address: {
            (options?: vimService.vim.ArrayOfHostIpConfigIpV6Address): vimService.vim.ArrayOfHostIpConfigIpV6Address;
         };
         HostIpConfigIpV6AddressConfiguration: {
            (options?: vimService.vim.HostIpConfigIpV6AddressConfiguration): vimService.vim.HostIpConfigIpV6AddressConfiguration;
         };
         HostIpConfig: {
            (options?: vimService.vim.HostIpConfig): vimService.vim.HostIpConfig;
         };
         HostIpRouteConfig: {
            (options?: vimService.vim.HostIpRouteConfig): vimService.vim.HostIpRouteConfig;
         };
         HostIpRouteConfigSpec: {
            (options?: vimService.vim.HostIpRouteConfigSpec): vimService.vim.HostIpRouteConfigSpec;
         };
         HostIpRouteEntry: {
            (options?: vimService.vim.HostIpRouteEntry): vimService.vim.HostIpRouteEntry;
         };
         ArrayOfHostIpRouteEntry: {
            (options?: vimService.vim.ArrayOfHostIpRouteEntry): vimService.vim.ArrayOfHostIpRouteEntry;
         };
         HostIpRouteOp: {
            (options?: vimService.vim.HostIpRouteOp): vimService.vim.HostIpRouteOp;
         };
         ArrayOfHostIpRouteOp: {
            (options?: vimService.vim.ArrayOfHostIpRouteOp): vimService.vim.ArrayOfHostIpRouteOp;
         };
         HostIpRouteTableConfig: {
            (options?: vimService.vim.HostIpRouteTableConfig): vimService.vim.HostIpRouteTableConfig;
         };
         HostIpRouteTableInfo: {
            (options?: vimService.vim.HostIpRouteTableInfo): vimService.vim.HostIpRouteTableInfo;
         };
         HostIpmiInfo: {
            (options?: vimService.vim.HostIpmiInfo): vimService.vim.HostIpmiInfo;
         };
         IscsiStatus: {
            (options?: vimService.vim.IscsiStatus): vimService.vim.IscsiStatus;
         };
         IscsiPortInfoPathStatus: {
            "notUsed": string;
            "active": string;
            "standBy": string;
            "lastActive": string;
         };
         IscsiPortInfo: {
            (options?: vimService.vim.IscsiPortInfo): vimService.vim.IscsiPortInfo;
         };
         ArrayOfIscsiPortInfo: {
            (options?: vimService.vim.ArrayOfIscsiPortInfo): vimService.vim.ArrayOfIscsiPortInfo;
         };
         IscsiDependencyEntity: {
            (options?: vimService.vim.IscsiDependencyEntity): vimService.vim.IscsiDependencyEntity;
         };
         ArrayOfIscsiDependencyEntity: {
            (options?: vimService.vim.ArrayOfIscsiDependencyEntity): vimService.vim.ArrayOfIscsiDependencyEntity;
         };
         IscsiMigrationDependency: {
            (options?: vimService.vim.IscsiMigrationDependency): vimService.vim.IscsiMigrationDependency;
         };
         KernelModuleSectionInfo: {
            (options?: vimService.vim.KernelModuleSectionInfo): vimService.vim.KernelModuleSectionInfo;
         };
         KernelModuleInfo: {
            (options?: vimService.vim.KernelModuleInfo): vimService.vim.KernelModuleInfo;
         };
         ArrayOfKernelModuleInfo: {
            (options?: vimService.vim.ArrayOfKernelModuleInfo): vimService.vim.ArrayOfKernelModuleInfo;
         };
         HostLicenseSpec: {
            (options?: vimService.vim.HostLicenseSpec): vimService.vim.HostLicenseSpec;
         };
         LinkDiscoveryProtocolConfigProtocolType: {
            "cdp": string;
            "lldp": string;
         };
         LinkDiscoveryProtocolConfigOperationType: {
            "none": string;
            "listen": string;
            "advertise": string;
            "both": string;
         };
         LinkDiscoveryProtocolConfig: {
            (options?: vimService.vim.LinkDiscoveryProtocolConfig): vimService.vim.LinkDiscoveryProtocolConfig;
         };
         HostAccountSpec: {
            (options?: vimService.vim.HostAccountSpec): vimService.vim.HostAccountSpec;
         };
         ArrayOfHostAccountSpec: {
            (options?: vimService.vim.ArrayOfHostAccountSpec): vimService.vim.ArrayOfHostAccountSpec;
         };
         HostPosixAccountSpec: {
            (options?: vimService.vim.HostPosixAccountSpec): vimService.vim.HostPosixAccountSpec;
         };
         HostLocalAuthenticationInfo: {
            (options?: vimService.vim.HostLocalAuthenticationInfo): vimService.vim.HostLocalAuthenticationInfo;
         };
         HostLowLevelProvisioningManagerVmRecoveryInfo: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo): vimService.vim.HostLowLevelProvisioningManagerVmRecoveryInfo;
         };
         HostLowLevelProvisioningManagerVmMigrationStatus: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerVmMigrationStatus): vimService.vim.HostLowLevelProvisioningManagerVmMigrationStatus;
         };
         HostLowLevelProvisioningManagerReloadTarget: {
            "currentConfig": string;
            "snapshotConfig": string;
         };
         HostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec): vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec;
         };
         HostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec): vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec;
         };
         HostLowLevelProvisioningManagerFileType: {
            "File": string;
            "VirtualDisk": string;
            "Directory": string;
         };
         HostLowLevelProvisioningManagerFileReserveSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec): vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerFileReserveSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveSpec;
         };
         HostLowLevelProvisioningManagerFileReserveResult: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileReserveResult): vimService.vim.HostLowLevelProvisioningManagerFileReserveResult;
         };
         ArrayOfHostLowLevelProvisioningManagerFileReserveResult: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveResult): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileReserveResult;
         };
         HostLowLevelProvisioningManagerFileDeleteSpec: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec): vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec;
         };
         ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec;
         };
         HostLowLevelProvisioningManagerFileDeleteResult: {
            (options?: vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult): vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult;
         };
         ArrayOfHostLowLevelProvisioningManagerFileDeleteResult: {
            (options?: vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteResult): vimService.vim.ArrayOfHostLowLevelProvisioningManagerFileDeleteResult;
         };
         HostMaintenanceSpec: {
            (options?: vimService.vim.HostMaintenanceSpec): vimService.vim.HostMaintenanceSpec;
         };
         ServiceConsoleReservationInfo: {
            (options?: vimService.vim.ServiceConsoleReservationInfo): vimService.vim.ServiceConsoleReservationInfo;
         };
         VirtualMachineMemoryAllocationPolicy: {
            "swapNone": string;
            "swapSome": string;
            "swapMost": string;
         };
         VirtualMachineMemoryReservationInfo: {
            (options?: vimService.vim.VirtualMachineMemoryReservationInfo): vimService.vim.VirtualMachineMemoryReservationInfo;
         };
         VirtualMachineMemoryReservationSpec: {
            (options?: vimService.vim.VirtualMachineMemoryReservationSpec): vimService.vim.VirtualMachineMemoryReservationSpec;
         };
         HostMemorySpec: {
            (options?: vimService.vim.HostMemorySpec): vimService.vim.HostMemorySpec;
         };
         HostMountMode: {
            "readWrite": string;
            "readOnly": string;
         };
         HostMountInfoInaccessibleReason: {
            "AllPathsDown_Start": string;
            "AllPathsDown_Timeout": string;
            "PermanentDeviceLoss": string;
         };
         HostMountInfo: {
            (options?: vimService.vim.HostMountInfo): vimService.vim.HostMountInfo;
         };
         MultipathState: {
            "standby": string;
            "active": string;
            "disabled": string;
            "dead": string;
            "unknown": string;
         };
         HostMultipathInfoLogicalUnitPolicy: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnitPolicy): vimService.vim.HostMultipathInfoLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnitStorageArrayTypePolicy: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy): vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         };
         HostMultipathInfoFixedLogicalUnitPolicy: {
            (options?: vimService.vim.HostMultipathInfoFixedLogicalUnitPolicy): vimService.vim.HostMultipathInfoFixedLogicalUnitPolicy;
         };
         HostMultipathInfoLogicalUnit: {
            (options?: vimService.vim.HostMultipathInfoLogicalUnit): vimService.vim.HostMultipathInfoLogicalUnit;
         };
         ArrayOfHostMultipathInfoLogicalUnit: {
            (options?: vimService.vim.ArrayOfHostMultipathInfoLogicalUnit): vimService.vim.ArrayOfHostMultipathInfoLogicalUnit;
         };
         HostMultipathInfoPath: {
            (options?: vimService.vim.HostMultipathInfoPath): vimService.vim.HostMultipathInfoPath;
         };
         ArrayOfHostMultipathInfoPath: {
            (options?: vimService.vim.ArrayOfHostMultipathInfoPath): vimService.vim.ArrayOfHostMultipathInfoPath;
         };
         HostMultipathInfo: {
            (options?: vimService.vim.HostMultipathInfo): vimService.vim.HostMultipathInfo;
         };
         HostMultipathStateInfoPath: {
            (options?: vimService.vim.HostMultipathStateInfoPath): vimService.vim.HostMultipathStateInfoPath;
         };
         ArrayOfHostMultipathStateInfoPath: {
            (options?: vimService.vim.ArrayOfHostMultipathStateInfoPath): vimService.vim.ArrayOfHostMultipathStateInfoPath;
         };
         HostMultipathStateInfo: {
            (options?: vimService.vim.HostMultipathStateInfo): vimService.vim.HostMultipathStateInfo;
         };
         HostNatServicePortForwardSpec: {
            (options?: vimService.vim.HostNatServicePortForwardSpec): vimService.vim.HostNatServicePortForwardSpec;
         };
         ArrayOfHostNatServicePortForwardSpec: {
            (options?: vimService.vim.ArrayOfHostNatServicePortForwardSpec): vimService.vim.ArrayOfHostNatServicePortForwardSpec;
         };
         HostNatServiceNameServiceSpec: {
            (options?: vimService.vim.HostNatServiceNameServiceSpec): vimService.vim.HostNatServiceNameServiceSpec;
         };
         HostNatServiceSpec: {
            (options?: vimService.vim.HostNatServiceSpec): vimService.vim.HostNatServiceSpec;
         };
         HostNatServiceConfig: {
            (options?: vimService.vim.HostNatServiceConfig): vimService.vim.HostNatServiceConfig;
         };
         ArrayOfHostNatServiceConfig: {
            (options?: vimService.vim.ArrayOfHostNatServiceConfig): vimService.vim.ArrayOfHostNatServiceConfig;
         };
         HostNatService: {
            (options?: vimService.vim.HostNatService): vimService.vim.HostNatService;
         };
         ArrayOfHostNatService: {
            (options?: vimService.vim.ArrayOfHostNatService): vimService.vim.ArrayOfHostNatService;
         };
         HostNetCapabilities: {
            (options?: vimService.vim.HostNetCapabilities): vimService.vim.HostNetCapabilities;
         };
         HostNetOffloadCapabilities: {
            (options?: vimService.vim.HostNetOffloadCapabilities): vimService.vim.HostNetOffloadCapabilities;
         };
         HostNetStackInstanceSystemStackKey: {
            "defaultTcpipStack": string;
            "vmotion": string;
            "vSphereProvisioning": string;
         };
         HostNetStackInstanceCongestionControlAlgorithmType: {
            "newreno": string;
            "cubic": string;
         };
         HostNetStackInstance: {
            (options?: vimService.vim.HostNetStackInstance): vimService.vim.HostNetStackInstance;
         };
         ArrayOfHostNetStackInstance: {
            (options?: vimService.vim.ArrayOfHostNetStackInstance): vimService.vim.ArrayOfHostNetStackInstance;
         };
         HostNetworkConfigResult: {
            (options?: vimService.vim.HostNetworkConfigResult): vimService.vim.HostNetworkConfigResult;
         };
         HostNetworkConfigNetStackSpec: {
            (options?: vimService.vim.HostNetworkConfigNetStackSpec): vimService.vim.HostNetworkConfigNetStackSpec;
         };
         ArrayOfHostNetworkConfigNetStackSpec: {
            (options?: vimService.vim.ArrayOfHostNetworkConfigNetStackSpec): vimService.vim.ArrayOfHostNetworkConfigNetStackSpec;
         };
         HostNetworkConfig: {
            (options?: vimService.vim.HostNetworkConfig): vimService.vim.HostNetworkConfig;
         };
         HostNetworkInfo: {
            (options?: vimService.vim.HostNetworkInfo): vimService.vim.HostNetworkInfo;
         };
         HostNetworkSecurityPolicy: {
            (options?: vimService.vim.HostNetworkSecurityPolicy): vimService.vim.HostNetworkSecurityPolicy;
         };
         HostNetworkTrafficShapingPolicy: {
            (options?: vimService.vim.HostNetworkTrafficShapingPolicy): vimService.vim.HostNetworkTrafficShapingPolicy;
         };
         HostNicFailureCriteria: {
            (options?: vimService.vim.HostNicFailureCriteria): vimService.vim.HostNicFailureCriteria;
         };
         HostNicOrderPolicy: {
            (options?: vimService.vim.HostNicOrderPolicy): vimService.vim.HostNicOrderPolicy;
         };
         HostNicTeamingPolicy: {
            (options?: vimService.vim.HostNicTeamingPolicy): vimService.vim.HostNicTeamingPolicy;
         };
         HostNetworkPolicy: {
            (options?: vimService.vim.HostNetworkPolicy): vimService.vim.HostNetworkPolicy;
         };
         HostNtpConfig: {
            (options?: vimService.vim.HostNtpConfig): vimService.vim.HostNtpConfig;
         };
         HostNumericSensorHealthState: {
            "unknown": string;
            "green": string;
            "yellow": string;
            "red": string;
         };
         HostNumericSensorType: {
            "fan": string;
            "power": string;
            "temperature": string;
            "voltage": string;
            "other": string;
         };
         HostNumericSensorInfo: {
            (options?: vimService.vim.HostNumericSensorInfo): vimService.vim.HostNumericSensorInfo;
         };
         ArrayOfHostNumericSensorInfo: {
            (options?: vimService.vim.ArrayOfHostNumericSensorInfo): vimService.vim.ArrayOfHostNumericSensorInfo;
         };
         HostOpaqueNetworkInfo: {
            (options?: vimService.vim.HostOpaqueNetworkInfo): vimService.vim.HostOpaqueNetworkInfo;
         };
         ArrayOfHostOpaqueNetworkInfo: {
            (options?: vimService.vim.ArrayOfHostOpaqueNetworkInfo): vimService.vim.ArrayOfHostOpaqueNetworkInfo;
         };
         HostOpaqueSwitchOpaqueSwitchState: {
            "up": string;
            "warning": string;
            "down": string;
         };
         HostOpaqueSwitchPhysicalNicZone: {
            (options?: vimService.vim.HostOpaqueSwitchPhysicalNicZone): vimService.vim.HostOpaqueSwitchPhysicalNicZone;
         };
         ArrayOfHostOpaqueSwitchPhysicalNicZone: {
            (options?: vimService.vim.ArrayOfHostOpaqueSwitchPhysicalNicZone): vimService.vim.ArrayOfHostOpaqueSwitchPhysicalNicZone;
         };
         HostOpaqueSwitch: {
            (options?: vimService.vim.HostOpaqueSwitch): vimService.vim.HostOpaqueSwitch;
         };
         ArrayOfHostOpaqueSwitch: {
            (options?: vimService.vim.ArrayOfHostOpaqueSwitch): vimService.vim.ArrayOfHostOpaqueSwitch;
         };
         HostPatchManagerResult: {
            (options?: vimService.vim.HostPatchManagerResult): vimService.vim.HostPatchManagerResult;
         };
         HostPatchManagerReason: {
            "obsoleted": string;
            "missingPatch": string;
            "missingLib": string;
            "hasDependentPatch": string;
            "conflictPatch": string;
            "conflictLib": string;
         };
         HostPatchManagerIntegrityStatus: {
            "validated": string;
            "keyNotFound": string;
            "keyRevoked": string;
            "keyExpired": string;
            "digestMismatch": string;
            "notEnoughSignatures": string;
            "validationError": string;
         };
         HostPatchManagerInstallState: {
            "hostRestarted": string;
            "imageActive": string;
         };
         HostPatchManagerStatusPrerequisitePatch: {
            (options?: vimService.vim.HostPatchManagerStatusPrerequisitePatch): vimService.vim.HostPatchManagerStatusPrerequisitePatch;
         };
         ArrayOfHostPatchManagerStatusPrerequisitePatch: {
            (options?: vimService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch): vimService.vim.ArrayOfHostPatchManagerStatusPrerequisitePatch;
         };
         HostPatchManagerStatus: {
            (options?: vimService.vim.HostPatchManagerStatus): vimService.vim.HostPatchManagerStatus;
         };
         ArrayOfHostPatchManagerStatus: {
            (options?: vimService.vim.ArrayOfHostPatchManagerStatus): vimService.vim.ArrayOfHostPatchManagerStatus;
         };
         HostPatchManagerLocator: {
            (options?: vimService.vim.HostPatchManagerLocator): vimService.vim.HostPatchManagerLocator;
         };
         HostPatchManagerPatchManagerOperationSpec: {
            (options?: vimService.vim.HostPatchManagerPatchManagerOperationSpec): vimService.vim.HostPatchManagerPatchManagerOperationSpec;
         };
         HostPathSelectionPolicyOption: {
            (options?: vimService.vim.HostPathSelectionPolicyOption): vimService.vim.HostPathSelectionPolicyOption;
         };
         ArrayOfHostPathSelectionPolicyOption: {
            (options?: vimService.vim.ArrayOfHostPathSelectionPolicyOption): vimService.vim.ArrayOfHostPathSelectionPolicyOption;
         };
         HostPciDevice: {
            (options?: vimService.vim.HostPciDevice): vimService.vim.HostPciDevice;
         };
         ArrayOfHostPciDevice: {
            (options?: vimService.vim.ArrayOfHostPciDevice): vimService.vim.ArrayOfHostPciDevice;
         };
         HostPciPassthruConfig: {
            (options?: vimService.vim.HostPciPassthruConfig): vimService.vim.HostPciPassthruConfig;
         };
         ArrayOfHostPciPassthruConfig: {
            (options?: vimService.vim.ArrayOfHostPciPassthruConfig): vimService.vim.ArrayOfHostPciPassthruConfig;
         };
         HostPciPassthruInfo: {
            (options?: vimService.vim.HostPciPassthruInfo): vimService.vim.HostPciPassthruInfo;
         };
         ArrayOfHostPciPassthruInfo: {
            (options?: vimService.vim.ArrayOfHostPciPassthruInfo): vimService.vim.ArrayOfHostPciPassthruInfo;
         };
         PhysicalNicSpec: {
            (options?: vimService.vim.PhysicalNicSpec): vimService.vim.PhysicalNicSpec;
         };
         PhysicalNicConfig: {
            (options?: vimService.vim.PhysicalNicConfig): vimService.vim.PhysicalNicConfig;
         };
         ArrayOfPhysicalNicConfig: {
            (options?: vimService.vim.ArrayOfPhysicalNicConfig): vimService.vim.ArrayOfPhysicalNicConfig;
         };
         PhysicalNicLinkInfo: {
            (options?: vimService.vim.PhysicalNicLinkInfo): vimService.vim.PhysicalNicLinkInfo;
         };
         ArrayOfPhysicalNicLinkInfo: {
            (options?: vimService.vim.ArrayOfPhysicalNicLinkInfo): vimService.vim.ArrayOfPhysicalNicLinkInfo;
         };
         PhysicalNicHint: {
            (options?: vimService.vim.PhysicalNicHint): vimService.vim.PhysicalNicHint;
         };
         PhysicalNicIpHint: {
            (options?: vimService.vim.PhysicalNicIpHint): vimService.vim.PhysicalNicIpHint;
         };
         ArrayOfPhysicalNicIpHint: {
            (options?: vimService.vim.ArrayOfPhysicalNicIpHint): vimService.vim.ArrayOfPhysicalNicIpHint;
         };
         PhysicalNicNameHint: {
            (options?: vimService.vim.PhysicalNicNameHint): vimService.vim.PhysicalNicNameHint;
         };
         ArrayOfPhysicalNicNameHint: {
            (options?: vimService.vim.ArrayOfPhysicalNicNameHint): vimService.vim.ArrayOfPhysicalNicNameHint;
         };
         PhysicalNicHintInfo: {
            (options?: vimService.vim.PhysicalNicHintInfo): vimService.vim.PhysicalNicHintInfo;
         };
         ArrayOfPhysicalNicHintInfo: {
            (options?: vimService.vim.ArrayOfPhysicalNicHintInfo): vimService.vim.ArrayOfPhysicalNicHintInfo;
         };
         PhysicalNicCdpDeviceCapability: {
            (options?: vimService.vim.PhysicalNicCdpDeviceCapability): vimService.vim.PhysicalNicCdpDeviceCapability;
         };
         PhysicalNicCdpInfo: {
            (options?: vimService.vim.PhysicalNicCdpInfo): vimService.vim.PhysicalNicCdpInfo;
         };
         LinkLayerDiscoveryProtocolInfo: {
            (options?: vimService.vim.LinkLayerDiscoveryProtocolInfo): vimService.vim.LinkLayerDiscoveryProtocolInfo;
         };
         PhysicalNicVmDirectPathGen2SupportedMode: {
            "upt": string;
         };
         PhysicalNicResourcePoolSchedulerDisallowedReason: {
            "userOptOut": string;
            "hardwareUnsupported": string;
         };
         PhysicalNic: {
            (options?: vimService.vim.PhysicalNic): vimService.vim.PhysicalNic;
         };
         ArrayOfPhysicalNic: {
            (options?: vimService.vim.ArrayOfPhysicalNic): vimService.vim.ArrayOfPhysicalNic;
         };
         HostPlugStoreTopologyAdapter: {
            (options?: vimService.vim.HostPlugStoreTopologyAdapter): vimService.vim.HostPlugStoreTopologyAdapter;
         };
         ArrayOfHostPlugStoreTopologyAdapter: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyAdapter): vimService.vim.ArrayOfHostPlugStoreTopologyAdapter;
         };
         HostPlugStoreTopologyPath: {
            (options?: vimService.vim.HostPlugStoreTopologyPath): vimService.vim.HostPlugStoreTopologyPath;
         };
         ArrayOfHostPlugStoreTopologyPath: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyPath): vimService.vim.ArrayOfHostPlugStoreTopologyPath;
         };
         HostPlugStoreTopologyDevice: {
            (options?: vimService.vim.HostPlugStoreTopologyDevice): vimService.vim.HostPlugStoreTopologyDevice;
         };
         ArrayOfHostPlugStoreTopologyDevice: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyDevice): vimService.vim.ArrayOfHostPlugStoreTopologyDevice;
         };
         HostPlugStoreTopologyPlugin: {
            (options?: vimService.vim.HostPlugStoreTopologyPlugin): vimService.vim.HostPlugStoreTopologyPlugin;
         };
         ArrayOfHostPlugStoreTopologyPlugin: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyPlugin): vimService.vim.ArrayOfHostPlugStoreTopologyPlugin;
         };
         HostPlugStoreTopologyTarget: {
            (options?: vimService.vim.HostPlugStoreTopologyTarget): vimService.vim.HostPlugStoreTopologyTarget;
         };
         ArrayOfHostPlugStoreTopologyTarget: {
            (options?: vimService.vim.ArrayOfHostPlugStoreTopologyTarget): vimService.vim.ArrayOfHostPlugStoreTopologyTarget;
         };
         HostPlugStoreTopology: {
            (options?: vimService.vim.HostPlugStoreTopology): vimService.vim.HostPlugStoreTopology;
         };
         PortGroupConnecteeType: {
            "virtualMachine": string;
            "systemManagement": string;
            "host": string;
            "unknown": string;
         };
         HostPortGroupSpec: {
            (options?: vimService.vim.HostPortGroupSpec): vimService.vim.HostPortGroupSpec;
         };
         HostPortGroupConfig: {
            (options?: vimService.vim.HostPortGroupConfig): vimService.vim.HostPortGroupConfig;
         };
         ArrayOfHostPortGroupConfig: {
            (options?: vimService.vim.ArrayOfHostPortGroupConfig): vimService.vim.ArrayOfHostPortGroupConfig;
         };
         HostPortGroupPort: {
            (options?: vimService.vim.HostPortGroupPort): vimService.vim.HostPortGroupPort;
         };
         ArrayOfHostPortGroupPort: {
            (options?: vimService.vim.ArrayOfHostPortGroupPort): vimService.vim.ArrayOfHostPortGroupPort;
         };
         HostPortGroup: {
            (options?: vimService.vim.HostPortGroup): vimService.vim.HostPortGroup;
         };
         ArrayOfHostPortGroup: {
            (options?: vimService.vim.ArrayOfHostPortGroup): vimService.vim.ArrayOfHostPortGroup;
         };
         HostPowerPolicy: {
            (options?: vimService.vim.HostPowerPolicy): vimService.vim.HostPowerPolicy;
         };
         ArrayOfHostPowerPolicy: {
            (options?: vimService.vim.ArrayOfHostPowerPolicy): vimService.vim.ArrayOfHostPowerPolicy;
         };
         PowerSystemCapability: {
            (options?: vimService.vim.PowerSystemCapability): vimService.vim.PowerSystemCapability;
         };
         PowerSystemInfo: {
            (options?: vimService.vim.PowerSystemInfo): vimService.vim.PowerSystemInfo;
         };
         HostProtocolEndpointPEType: {
            "block": string;
            "nas": string;
         };
         HostProtocolEndpoint: {
            (options?: vimService.vim.HostProtocolEndpoint): vimService.vim.HostProtocolEndpoint;
         };
         ArrayOfHostProtocolEndpoint: {
            (options?: vimService.vim.ArrayOfHostProtocolEndpoint): vimService.vim.ArrayOfHostProtocolEndpoint;
         };
         HostResignatureRescanResult: {
            (options?: vimService.vim.HostResignatureRescanResult): vimService.vim.HostResignatureRescanResult;
         };
         HostFirewallRulesetIpNetwork: {
            (options?: vimService.vim.HostFirewallRulesetIpNetwork): vimService.vim.HostFirewallRulesetIpNetwork;
         };
         ArrayOfHostFirewallRulesetIpNetwork: {
            (options?: vimService.vim.ArrayOfHostFirewallRulesetIpNetwork): vimService.vim.ArrayOfHostFirewallRulesetIpNetwork;
         };
         HostFirewallRulesetIpList: {
            (options?: vimService.vim.HostFirewallRulesetIpList): vimService.vim.HostFirewallRulesetIpList;
         };
         HostFirewallRulesetRulesetSpec: {
            (options?: vimService.vim.HostFirewallRulesetRulesetSpec): vimService.vim.HostFirewallRulesetRulesetSpec;
         };
         HostFirewallRuleDirection: {
            "inbound": string;
            "outbound": string;
         };
         HostFirewallRulePortType: {
            "src": string;
            "dst": string;
         };
         HostFirewallRuleProtocol: {
            "tcp": string;
            "udp": string;
         };
         HostFirewallRule: {
            (options?: vimService.vim.HostFirewallRule): vimService.vim.HostFirewallRule;
         };
         ArrayOfHostFirewallRule: {
            (options?: vimService.vim.ArrayOfHostFirewallRule): vimService.vim.ArrayOfHostFirewallRule;
         };
         HostFirewallRuleset: {
            (options?: vimService.vim.HostFirewallRuleset): vimService.vim.HostFirewallRuleset;
         };
         ArrayOfHostFirewallRuleset: {
            (options?: vimService.vim.ArrayOfHostFirewallRuleset): vimService.vim.ArrayOfHostFirewallRuleset;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfoState: {
            "inactive": string;
            "active": string;
            "deactivating": string;
            "activating": string;
         };
         HostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo): vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo: {
            (options?: vimService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo): vimService.vim.ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo;
         };
         HostPlacedVirtualNicIdentifier: {
            (options?: vimService.vim.HostPlacedVirtualNicIdentifier): vimService.vim.HostPlacedVirtualNicIdentifier;
         };
         ArrayOfHostPlacedVirtualNicIdentifier: {
            (options?: vimService.vim.ArrayOfHostPlacedVirtualNicIdentifier): vimService.vim.ArrayOfHostPlacedVirtualNicIdentifier;
         };
         HostPnicNetworkResourceInfo: {
            (options?: vimService.vim.HostPnicNetworkResourceInfo): vimService.vim.HostPnicNetworkResourceInfo;
         };
         ArrayOfHostPnicNetworkResourceInfo: {
            (options?: vimService.vim.ArrayOfHostPnicNetworkResourceInfo): vimService.vim.ArrayOfHostPnicNetworkResourceInfo;
         };
         HostNetworkResourceRuntime: {
            (options?: vimService.vim.HostNetworkResourceRuntime): vimService.vim.HostNetworkResourceRuntime;
         };
         HostRuntimeInfoNetworkRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfoNetworkRuntimeInfo): vimService.vim.HostRuntimeInfoNetworkRuntimeInfo;
         };
         HostRuntimeInfo: {
            (options?: vimService.vim.HostRuntimeInfo): vimService.vim.HostRuntimeInfo;
         };
         HostScsiDiskPartition: {
            (options?: vimService.vim.HostScsiDiskPartition): vimService.vim.HostScsiDiskPartition;
         };
         ArrayOfHostScsiDiskPartition: {
            (options?: vimService.vim.ArrayOfHostScsiDiskPartition): vimService.vim.ArrayOfHostScsiDiskPartition;
         };
         HostScsiDisk: {
            (options?: vimService.vim.HostScsiDisk): vimService.vim.HostScsiDisk;
         };
         ArrayOfHostScsiDisk: {
            (options?: vimService.vim.ArrayOfHostScsiDisk): vimService.vim.ArrayOfHostScsiDisk;
         };
         ScsiLunType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "opticalDevice": string;
            "mediaChanger": string;
            "communications": string;
            "storageArrayController": string;
            "enclosure": string;
            "unknown": string;
         };
         ScsiLunCapabilities: {
            (options?: vimService.vim.ScsiLunCapabilities): vimService.vim.ScsiLunCapabilities;
         };
         ScsiLunDurableName: {
            (options?: vimService.vim.ScsiLunDurableName): vimService.vim.ScsiLunDurableName;
         };
         ArrayOfScsiLunDurableName: {
            (options?: vimService.vim.ArrayOfScsiLunDurableName): vimService.vim.ArrayOfScsiLunDurableName;
         };
         ScsiLunState: {
            "unknownState": string;
            "ok": string;
            "error": string;
            "off": string;
            "quiesced": string;
            "degraded": string;
            "lostCommunication": string;
            "timeout": string;
         };
         ScsiLunDescriptorQuality: {
            "highQuality": string;
            "mediumQuality": string;
            "lowQuality": string;
            "unknownQuality": string;
         };
         ScsiLunDescriptor: {
            (options?: vimService.vim.ScsiLunDescriptor): vimService.vim.ScsiLunDescriptor;
         };
         ArrayOfScsiLunDescriptor: {
            (options?: vimService.vim.ArrayOfScsiLunDescriptor): vimService.vim.ArrayOfScsiLunDescriptor;
         };
         ScsiLunVStorageSupportStatus: {
            "vStorageSupported": string;
            "vStorageUnsupported": string;
            "vStorageUnknown": string;
         };
         ScsiLun: {
            (options?: vimService.vim.ScsiLun): vimService.vim.ScsiLun;
         };
         ArrayOfScsiLun: {
            (options?: vimService.vim.ArrayOfScsiLun): vimService.vim.ArrayOfScsiLun;
         };
         HostScsiTopologyInterface: {
            (options?: vimService.vim.HostScsiTopologyInterface): vimService.vim.HostScsiTopologyInterface;
         };
         ArrayOfHostScsiTopologyInterface: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyInterface): vimService.vim.ArrayOfHostScsiTopologyInterface;
         };
         HostScsiTopologyTarget: {
            (options?: vimService.vim.HostScsiTopologyTarget): vimService.vim.HostScsiTopologyTarget;
         };
         ArrayOfHostScsiTopologyTarget: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyTarget): vimService.vim.ArrayOfHostScsiTopologyTarget;
         };
         HostScsiTopologyLun: {
            (options?: vimService.vim.HostScsiTopologyLun): vimService.vim.HostScsiTopologyLun;
         };
         ArrayOfHostScsiTopologyLun: {
            (options?: vimService.vim.ArrayOfHostScsiTopologyLun): vimService.vim.ArrayOfHostScsiTopologyLun;
         };
         HostScsiTopology: {
            (options?: vimService.vim.HostScsiTopology): vimService.vim.HostScsiTopology;
         };
         HostSecuritySpec: {
            (options?: vimService.vim.HostSecuritySpec): vimService.vim.HostSecuritySpec;
         };
         HostServicePolicy: {
            "on": string;
            "automatic": string;
            "off": string;
         };
         HostServiceSourcePackage: {
            (options?: vimService.vim.HostServiceSourcePackage): vimService.vim.HostServiceSourcePackage;
         };
         HostService: {
            (options?: vimService.vim.HostService): vimService.vim.HostService;
         };
         ArrayOfHostService: {
            (options?: vimService.vim.ArrayOfHostService): vimService.vim.ArrayOfHostService;
         };
         HostServiceConfig: {
            (options?: vimService.vim.HostServiceConfig): vimService.vim.HostServiceConfig;
         };
         ArrayOfHostServiceConfig: {
            (options?: vimService.vim.ArrayOfHostServiceConfig): vimService.vim.ArrayOfHostServiceConfig;
         };
         HostServiceInfo: {
            (options?: vimService.vim.HostServiceInfo): vimService.vim.HostServiceInfo;
         };
         HostSnmpDestination: {
            (options?: vimService.vim.HostSnmpDestination): vimService.vim.HostSnmpDestination;
         };
         ArrayOfHostSnmpDestination: {
            (options?: vimService.vim.ArrayOfHostSnmpDestination): vimService.vim.ArrayOfHostSnmpDestination;
         };
         HostSnmpConfigSpec: {
            (options?: vimService.vim.HostSnmpConfigSpec): vimService.vim.HostSnmpConfigSpec;
         };
         HostSnmpAgentCapability: {
            "COMPLETE": string;
            "DIAGNOSTICS": string;
            "CONFIGURATION": string;
         };
         HostSnmpSystemAgentLimits: {
            (options?: vimService.vim.HostSnmpSystemAgentLimits): vimService.vim.HostSnmpSystemAgentLimits;
         };
         HostSriovConfig: {
            (options?: vimService.vim.HostSriovConfig): vimService.vim.HostSriovConfig;
         };
         HostSriovInfo: {
            (options?: vimService.vim.HostSriovInfo): vimService.vim.HostSriovInfo;
         };
         HostSslThumbprintInfo: {
            (options?: vimService.vim.HostSslThumbprintInfo): vimService.vim.HostSslThumbprintInfo;
         };
         ArrayOfHostSslThumbprintInfo: {
            (options?: vimService.vim.ArrayOfHostSslThumbprintInfo): vimService.vim.ArrayOfHostSslThumbprintInfo;
         };
         HostStorageArrayTypePolicyOption: {
            (options?: vimService.vim.HostStorageArrayTypePolicyOption): vimService.vim.HostStorageArrayTypePolicyOption;
         };
         ArrayOfHostStorageArrayTypePolicyOption: {
            (options?: vimService.vim.ArrayOfHostStorageArrayTypePolicyOption): vimService.vim.ArrayOfHostStorageArrayTypePolicyOption;
         };
         HostStorageDeviceInfo: {
            (options?: vimService.vim.HostStorageDeviceInfo): vimService.vim.HostStorageDeviceInfo;
         };
         HostStorageSystemVmfsVolumeResult: {
            (options?: vimService.vim.HostStorageSystemVmfsVolumeResult): vimService.vim.HostStorageSystemVmfsVolumeResult;
         };
         ArrayOfHostStorageSystemVmfsVolumeResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemVmfsVolumeResult): vimService.vim.ArrayOfHostStorageSystemVmfsVolumeResult;
         };
         HostStorageSystemScsiLunResult: {
            (options?: vimService.vim.HostStorageSystemScsiLunResult): vimService.vim.HostStorageSystemScsiLunResult;
         };
         ArrayOfHostStorageSystemScsiLunResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemScsiLunResult): vimService.vim.ArrayOfHostStorageSystemScsiLunResult;
         };
         HostStorageSystemDiskLocatorLedResult: {
            (options?: vimService.vim.HostStorageSystemDiskLocatorLedResult): vimService.vim.HostStorageSystemDiskLocatorLedResult;
         };
         ArrayOfHostStorageSystemDiskLocatorLedResult: {
            (options?: vimService.vim.ArrayOfHostStorageSystemDiskLocatorLedResult): vimService.vim.ArrayOfHostStorageSystemDiskLocatorLedResult;
         };
         HostHardwareSummary: {
            (options?: vimService.vim.HostHardwareSummary): vimService.vim.HostHardwareSummary;
         };
         HostListSummaryQuickStats: {
            (options?: vimService.vim.HostListSummaryQuickStats): vimService.vim.HostListSummaryQuickStats;
         };
         HostConfigSummary: {
            (options?: vimService.vim.HostConfigSummary): vimService.vim.HostConfigSummary;
         };
         HostListSummaryGatewaySummary: {
            (options?: vimService.vim.HostListSummaryGatewaySummary): vimService.vim.HostListSummaryGatewaySummary;
         };
         HostListSummary: {
            (options?: vimService.vim.HostListSummary): vimService.vim.HostListSummary;
         };
         HostSystemHealthInfo: {
            (options?: vimService.vim.HostSystemHealthInfo): vimService.vim.HostSystemHealthInfo;
         };
         HostSystemIdentificationInfoIdentifier: {
            "AssetTag": string;
            "ServiceTag": string;
            "OemSpecificString": string;
         };
         HostSystemIdentificationInfo: {
            (options?: vimService.vim.HostSystemIdentificationInfo): vimService.vim.HostSystemIdentificationInfo;
         };
         ArrayOfHostSystemIdentificationInfo: {
            (options?: vimService.vim.ArrayOfHostSystemIdentificationInfo): vimService.vim.ArrayOfHostSystemIdentificationInfo;
         };
         HostSystemResourceInfo: {
            (options?: vimService.vim.HostSystemResourceInfo): vimService.vim.HostSystemResourceInfo;
         };
         ArrayOfHostSystemResourceInfo: {
            (options?: vimService.vim.ArrayOfHostSystemResourceInfo): vimService.vim.ArrayOfHostSystemResourceInfo;
         };
         HostSystemSwapConfigurationSystemSwapOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationSystemSwapOption): vimService.vim.HostSystemSwapConfigurationSystemSwapOption;
         };
         ArrayOfHostSystemSwapConfigurationSystemSwapOption: {
            (options?: vimService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption): vimService.vim.ArrayOfHostSystemSwapConfigurationSystemSwapOption;
         };
         HostSystemSwapConfigurationDisabledOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationDisabledOption): vimService.vim.HostSystemSwapConfigurationDisabledOption;
         };
         HostSystemSwapConfigurationHostCacheOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationHostCacheOption): vimService.vim.HostSystemSwapConfigurationHostCacheOption;
         };
         HostSystemSwapConfigurationHostLocalSwapOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationHostLocalSwapOption): vimService.vim.HostSystemSwapConfigurationHostLocalSwapOption;
         };
         HostSystemSwapConfigurationDatastoreOption: {
            (options?: vimService.vim.HostSystemSwapConfigurationDatastoreOption): vimService.vim.HostSystemSwapConfigurationDatastoreOption;
         };
         HostSystemSwapConfiguration: {
            (options?: vimService.vim.HostSystemSwapConfiguration): vimService.vim.HostSystemSwapConfiguration;
         };
         HostTargetTransport: {
            (options?: vimService.vim.HostTargetTransport): vimService.vim.HostTargetTransport;
         };
         HostParallelScsiTargetTransport: {
            (options?: vimService.vim.HostParallelScsiTargetTransport): vimService.vim.HostParallelScsiTargetTransport;
         };
         HostBlockAdapterTargetTransport: {
            (options?: vimService.vim.HostBlockAdapterTargetTransport): vimService.vim.HostBlockAdapterTargetTransport;
         };
         HostFibreChannelTargetTransport: {
            (options?: vimService.vim.HostFibreChannelTargetTransport): vimService.vim.HostFibreChannelTargetTransport;
         };
         HostInternetScsiTargetTransport: {
            (options?: vimService.vim.HostInternetScsiTargetTransport): vimService.vim.HostInternetScsiTargetTransport;
         };
         HostFibreChannelOverEthernetTargetTransport: {
            (options?: vimService.vim.HostFibreChannelOverEthernetTargetTransport): vimService.vim.HostFibreChannelOverEthernetTargetTransport;
         };
         HostTpmAttestationReport: {
            (options?: vimService.vim.HostTpmAttestationReport): vimService.vim.HostTpmAttestationReport;
         };
         HostTpmBootSecurityOptionEventDetails: {
            (options?: vimService.vim.HostTpmBootSecurityOptionEventDetails): vimService.vim.HostTpmBootSecurityOptionEventDetails;
         };
         HostTpmCommandEventDetails: {
            (options?: vimService.vim.HostTpmCommandEventDetails): vimService.vim.HostTpmCommandEventDetails;
         };
         HostDigestInfoDigestMethodType: {
            "SHA1": string;
            "MD5": string;
         };
         HostDigestInfo: {
            (options?: vimService.vim.HostDigestInfo): vimService.vim.HostDigestInfo;
         };
         HostTpmDigestInfo: {
            (options?: vimService.vim.HostTpmDigestInfo): vimService.vim.HostTpmDigestInfo;
         };
         ArrayOfHostTpmDigestInfo: {
            (options?: vimService.vim.ArrayOfHostTpmDigestInfo): vimService.vim.ArrayOfHostTpmDigestInfo;
         };
         HostTpmEventDetails: {
            (options?: vimService.vim.HostTpmEventDetails): vimService.vim.HostTpmEventDetails;
         };
         HostTpmEventLogEntry: {
            (options?: vimService.vim.HostTpmEventLogEntry): vimService.vim.HostTpmEventLogEntry;
         };
         ArrayOfHostTpmEventLogEntry: {
            (options?: vimService.vim.ArrayOfHostTpmEventLogEntry): vimService.vim.ArrayOfHostTpmEventLogEntry;
         };
         HostTpmOptionEventDetails: {
            (options?: vimService.vim.HostTpmOptionEventDetails): vimService.vim.HostTpmOptionEventDetails;
         };
         HostTpmSoftwareComponentEventDetails: {
            (options?: vimService.vim.HostTpmSoftwareComponentEventDetails): vimService.vim.HostTpmSoftwareComponentEventDetails;
         };
         HostUnresolvedVmfsExtentUnresolvedReason: {
            "diskIdMismatch": string;
            "uuidConflict": string;
         };
         HostUnresolvedVmfsExtent: {
            (options?: vimService.vim.HostUnresolvedVmfsExtent): vimService.vim.HostUnresolvedVmfsExtent;
         };
         ArrayOfHostUnresolvedVmfsExtent: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsExtent): vimService.vim.ArrayOfHostUnresolvedVmfsExtent;
         };
         HostUnresolvedVmfsResignatureSpec: {
            (options?: vimService.vim.HostUnresolvedVmfsResignatureSpec): vimService.vim.HostUnresolvedVmfsResignatureSpec;
         };
         HostUnresolvedVmfsResolutionResult: {
            (options?: vimService.vim.HostUnresolvedVmfsResolutionResult): vimService.vim.HostUnresolvedVmfsResolutionResult;
         };
         ArrayOfHostUnresolvedVmfsResolutionResult: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsResolutionResult): vimService.vim.ArrayOfHostUnresolvedVmfsResolutionResult;
         };
         HostUnresolvedVmfsResolutionSpecVmfsUuidResolution: {
            "resignature": string;
            "forceMount": string;
         };
         HostUnresolvedVmfsResolutionSpec: {
            (options?: vimService.vim.HostUnresolvedVmfsResolutionSpec): vimService.vim.HostUnresolvedVmfsResolutionSpec;
         };
         ArrayOfHostUnresolvedVmfsResolutionSpec: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec): vimService.vim.ArrayOfHostUnresolvedVmfsResolutionSpec;
         };
         HostUnresolvedVmfsVolumeResolveStatus: {
            (options?: vimService.vim.HostUnresolvedVmfsVolumeResolveStatus): vimService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         };
         HostUnresolvedVmfsVolume: {
            (options?: vimService.vim.HostUnresolvedVmfsVolume): vimService.vim.HostUnresolvedVmfsVolume;
         };
         ArrayOfHostUnresolvedVmfsVolume: {
            (options?: vimService.vim.ArrayOfHostUnresolvedVmfsVolume): vimService.vim.ArrayOfHostUnresolvedVmfsVolume;
         };
         HostVFlashManagerVFlashResourceConfigSpec: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): vimService.vim.HostVFlashManagerVFlashResourceConfigSpec;
         };
         HostVFlashManagerVFlashResourceConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceConfigInfo): vimService.vim.HostVFlashManagerVFlashResourceConfigInfo;
         };
         HostVFlashManagerVFlashResourceRunTimeInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo): vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
         };
         HostVFlashManagerVFlashCacheConfigSpec: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): vimService.vim.HostVFlashManagerVFlashCacheConfigSpec;
         };
         HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption: {
            (options?: vimService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption): vimService.vim.ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         };
         HostVFlashManagerVFlashCacheConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfo): vimService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         };
         HostVFlashManagerVFlashConfigInfo: {
            (options?: vimService.vim.HostVFlashManagerVFlashConfigInfo): vimService.vim.HostVFlashManagerVFlashConfigInfo;
         };
         HostVFlashResourceConfigurationResult: {
            (options?: vimService.vim.HostVFlashResourceConfigurationResult): vimService.vim.HostVFlashResourceConfigurationResult;
         };
         HostVMotionConfig: {
            (options?: vimService.vim.HostVMotionConfig): vimService.vim.HostVMotionConfig;
         };
         HostVMotionInfo: {
            (options?: vimService.vim.HostVMotionInfo): vimService.vim.HostVMotionInfo;
         };
         HostVMotionNetConfig: {
            (options?: vimService.vim.HostVMotionNetConfig): vimService.vim.HostVMotionNetConfig;
         };
         HostVffsSpec: {
            (options?: vimService.vim.HostVffsSpec): vimService.vim.HostVffsSpec;
         };
         HostVffsVolume: {
            (options?: vimService.vim.HostVffsVolume): vimService.vim.HostVffsVolume;
         };
         HostVirtualNicSpec: {
            (options?: vimService.vim.HostVirtualNicSpec): vimService.vim.HostVirtualNicSpec;
         };
         HostVirtualNicConfig: {
            (options?: vimService.vim.HostVirtualNicConfig): vimService.vim.HostVirtualNicConfig;
         };
         ArrayOfHostVirtualNicConfig: {
            (options?: vimService.vim.ArrayOfHostVirtualNicConfig): vimService.vim.ArrayOfHostVirtualNicConfig;
         };
         HostVirtualNicOpaqueNetworkSpec: {
            (options?: vimService.vim.HostVirtualNicOpaqueNetworkSpec): vimService.vim.HostVirtualNicOpaqueNetworkSpec;
         };
         HostVirtualNic: {
            (options?: vimService.vim.HostVirtualNic): vimService.vim.HostVirtualNic;
         };
         ArrayOfHostVirtualNic: {
            (options?: vimService.vim.ArrayOfHostVirtualNic): vimService.vim.ArrayOfHostVirtualNic;
         };
         HostVirtualNicConnection: {
            (options?: vimService.vim.HostVirtualNicConnection): vimService.vim.HostVirtualNicConnection;
         };
         HostVirtualNicManagerNicType: {
            "vmotion": string;
            "faultToleranceLogging": string;
            "vSphereReplication": string;
            "vSphereReplicationNFC": string;
            "management": string;
            "vsan": string;
            "vSphereProvisioning": string;
         };
         HostVirtualNicManagerNicTypeSelection: {
            (options?: vimService.vim.HostVirtualNicManagerNicTypeSelection): vimService.vim.HostVirtualNicManagerNicTypeSelection;
         };
         ArrayOfHostVirtualNicManagerNicTypeSelection: {
            (options?: vimService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection): vimService.vim.ArrayOfHostVirtualNicManagerNicTypeSelection;
         };
         VirtualNicManagerNetConfig: {
            (options?: vimService.vim.VirtualNicManagerNetConfig): vimService.vim.VirtualNicManagerNetConfig;
         };
         ArrayOfVirtualNicManagerNetConfig: {
            (options?: vimService.vim.ArrayOfVirtualNicManagerNetConfig): vimService.vim.ArrayOfVirtualNicManagerNetConfig;
         };
         HostVirtualNicManagerInfo: {
            (options?: vimService.vim.HostVirtualNicManagerInfo): vimService.vim.HostVirtualNicManagerInfo;
         };
         HostVirtualSwitchBridge: {
            (options?: vimService.vim.HostVirtualSwitchBridge): vimService.vim.HostVirtualSwitchBridge;
         };
         HostVirtualSwitchAutoBridge: {
            (options?: vimService.vim.HostVirtualSwitchAutoBridge): vimService.vim.HostVirtualSwitchAutoBridge;
         };
         HostVirtualSwitchSimpleBridge: {
            (options?: vimService.vim.HostVirtualSwitchSimpleBridge): vimService.vim.HostVirtualSwitchSimpleBridge;
         };
         HostVirtualSwitchBondBridge: {
            (options?: vimService.vim.HostVirtualSwitchBondBridge): vimService.vim.HostVirtualSwitchBondBridge;
         };
         HostVirtualSwitchBeaconConfig: {
            (options?: vimService.vim.HostVirtualSwitchBeaconConfig): vimService.vim.HostVirtualSwitchBeaconConfig;
         };
         HostVirtualSwitchSpec: {
            (options?: vimService.vim.HostVirtualSwitchSpec): vimService.vim.HostVirtualSwitchSpec;
         };
         HostVirtualSwitchConfig: {
            (options?: vimService.vim.HostVirtualSwitchConfig): vimService.vim.HostVirtualSwitchConfig;
         };
         ArrayOfHostVirtualSwitchConfig: {
            (options?: vimService.vim.ArrayOfHostVirtualSwitchConfig): vimService.vim.ArrayOfHostVirtualSwitchConfig;
         };
         HostVirtualSwitch: {
            (options?: vimService.vim.HostVirtualSwitch): vimService.vim.HostVirtualSwitch;
         };
         ArrayOfHostVirtualSwitch: {
            (options?: vimService.vim.ArrayOfHostVirtualSwitch): vimService.vim.ArrayOfHostVirtualSwitch;
         };
         HostVmciAccessManagerMode: {
            "grant": string;
            "replace": string;
            "revoke": string;
         };
         HostVmciAccessManagerAccessSpec: {
            (options?: vimService.vim.HostVmciAccessManagerAccessSpec): vimService.vim.HostVmciAccessManagerAccessSpec;
         };
         ArrayOfHostVmciAccessManagerAccessSpec: {
            (options?: vimService.vim.ArrayOfHostVmciAccessManagerAccessSpec): vimService.vim.ArrayOfHostVmciAccessManagerAccessSpec;
         };
         HostVmfsRescanResult: {
            (options?: vimService.vim.HostVmfsRescanResult): vimService.vim.HostVmfsRescanResult;
         };
         ArrayOfHostVmfsRescanResult: {
            (options?: vimService.vim.ArrayOfHostVmfsRescanResult): vimService.vim.ArrayOfHostVmfsRescanResult;
         };
         HostVmfsSpec: {
            (options?: vimService.vim.HostVmfsSpec): vimService.vim.HostVmfsSpec;
         };
         HostVmfsVolume: {
            (options?: vimService.vim.HostVmfsVolume): vimService.vim.HostVmfsVolume;
         };
         HostVsanInternalSystemCmmdsQuery: {
            (options?: vimService.vim.HostVsanInternalSystemCmmdsQuery): vimService.vim.HostVsanInternalSystemCmmdsQuery;
         };
         ArrayOfHostVsanInternalSystemCmmdsQuery: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery): vimService.vim.ArrayOfHostVsanInternalSystemCmmdsQuery;
         };
         VsanPolicyCost: {
            (options?: vimService.vim.VsanPolicyCost): vimService.vim.VsanPolicyCost;
         };
         VsanPolicySatisfiability: {
            (options?: vimService.vim.VsanPolicySatisfiability): vimService.vim.VsanPolicySatisfiability;
         };
         ArrayOfVsanPolicySatisfiability: {
            (options?: vimService.vim.ArrayOfVsanPolicySatisfiability): vimService.vim.ArrayOfVsanPolicySatisfiability;
         };
         VsanPolicyChangeBatch: {
            (options?: vimService.vim.VsanPolicyChangeBatch): vimService.vim.VsanPolicyChangeBatch;
         };
         ArrayOfVsanPolicyChangeBatch: {
            (options?: vimService.vim.ArrayOfVsanPolicyChangeBatch): vimService.vim.ArrayOfVsanPolicyChangeBatch;
         };
         VsanNewPolicyBatch: {
            (options?: vimService.vim.VsanNewPolicyBatch): vimService.vim.VsanNewPolicyBatch;
         };
         ArrayOfVsanNewPolicyBatch: {
            (options?: vimService.vim.ArrayOfVsanNewPolicyBatch): vimService.vim.ArrayOfVsanNewPolicyBatch;
         };
         HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult: {
            (options?: vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult): vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult;
         };
         ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult): vimService.vim.ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult;
         };
         HostVsanInternalSystemDeleteVsanObjectsResult: {
            (options?: vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult): vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult;
         };
         ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult): vimService.vim.ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult;
         };
         HostVsanInternalSystemVsanObjectOperationResult: {
            (options?: vimService.vim.HostVsanInternalSystemVsanObjectOperationResult): vimService.vim.HostVsanInternalSystemVsanObjectOperationResult;
         };
         ArrayOfHostVsanInternalSystemVsanObjectOperationResult: {
            (options?: vimService.vim.ArrayOfHostVsanInternalSystemVsanObjectOperationResult): vimService.vim.ArrayOfHostVsanInternalSystemVsanObjectOperationResult;
         };
         HostVvolVolumeSpecification: {
            (options?: vimService.vim.HostVvolVolumeSpecification): vimService.vim.HostVvolVolumeSpecification;
         };
         VVolHostPE: {
            (options?: vimService.vim.VVolHostPE): vimService.vim.VVolHostPE;
         };
         ArrayOfVVolHostPE: {
            (options?: vimService.vim.ArrayOfVVolHostPE): vimService.vim.ArrayOfVVolHostPE;
         };
         HostVvolVolume: {
            (options?: vimService.vim.HostVvolVolume): vimService.vim.HostVvolVolume;
         };
         NetDhcpConfigInfoDhcpOptions: {
            (options?: vimService.vim.NetDhcpConfigInfoDhcpOptions): vimService.vim.NetDhcpConfigInfoDhcpOptions;
         };
         NetDhcpConfigInfo: {
            (options?: vimService.vim.NetDhcpConfigInfo): vimService.vim.NetDhcpConfigInfo;
         };
         NetDhcpConfigSpecDhcpOptionsSpec: {
            (options?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec): vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         };
         NetDhcpConfigSpec: {
            (options?: vimService.vim.NetDhcpConfigSpec): vimService.vim.NetDhcpConfigSpec;
         };
         NetDnsConfigInfo: {
            (options?: vimService.vim.NetDnsConfigInfo): vimService.vim.NetDnsConfigInfo;
         };
         NetDnsConfigSpec: {
            (options?: vimService.vim.NetDnsConfigSpec): vimService.vim.NetDnsConfigSpec;
         };
         NetIpConfigInfoIpAddressOrigin: {
            "other": string;
            "manual": string;
            "dhcp": string;
            "linklayer": string;
            "random": string;
         };
         NetIpConfigInfoIpAddressStatus: {
            "preferred": string;
            "deprecated": string;
            "invalid": string;
            "inaccessible": string;
            "unknown": string;
            "tentative": string;
            "duplicate": string;
         };
         NetIpConfigInfoIpAddress: {
            (options?: vimService.vim.NetIpConfigInfoIpAddress): vimService.vim.NetIpConfigInfoIpAddress;
         };
         ArrayOfNetIpConfigInfoIpAddress: {
            (options?: vimService.vim.ArrayOfNetIpConfigInfoIpAddress): vimService.vim.ArrayOfNetIpConfigInfoIpAddress;
         };
         NetIpConfigInfo: {
            (options?: vimService.vim.NetIpConfigInfo): vimService.vim.NetIpConfigInfo;
         };
         NetIpConfigSpecIpAddressSpec: {
            (options?: vimService.vim.NetIpConfigSpecIpAddressSpec): vimService.vim.NetIpConfigSpecIpAddressSpec;
         };
         ArrayOfNetIpConfigSpecIpAddressSpec: {
            (options?: vimService.vim.ArrayOfNetIpConfigSpecIpAddressSpec): vimService.vim.ArrayOfNetIpConfigSpecIpAddressSpec;
         };
         NetIpConfigSpec: {
            (options?: vimService.vim.NetIpConfigSpec): vimService.vim.NetIpConfigSpec;
         };
         NetIpRouteConfigInfoGateway: {
            (options?: vimService.vim.NetIpRouteConfigInfoGateway): vimService.vim.NetIpRouteConfigInfoGateway;
         };
         NetIpRouteConfigInfoIpRoute: {
            (options?: vimService.vim.NetIpRouteConfigInfoIpRoute): vimService.vim.NetIpRouteConfigInfoIpRoute;
         };
         ArrayOfNetIpRouteConfigInfoIpRoute: {
            (options?: vimService.vim.ArrayOfNetIpRouteConfigInfoIpRoute): vimService.vim.ArrayOfNetIpRouteConfigInfoIpRoute;
         };
         NetIpRouteConfigInfo: {
            (options?: vimService.vim.NetIpRouteConfigInfo): vimService.vim.NetIpRouteConfigInfo;
         };
         NetIpRouteConfigSpecGatewaySpec: {
            (options?: vimService.vim.NetIpRouteConfigSpecGatewaySpec): vimService.vim.NetIpRouteConfigSpecGatewaySpec;
         };
         NetIpRouteConfigSpecIpRouteSpec: {
            (options?: vimService.vim.NetIpRouteConfigSpecIpRouteSpec): vimService.vim.NetIpRouteConfigSpecIpRouteSpec;
         };
         ArrayOfNetIpRouteConfigSpecIpRouteSpec: {
            (options?: vimService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec): vimService.vim.ArrayOfNetIpRouteConfigSpecIpRouteSpec;
         };
         NetIpRouteConfigSpec: {
            (options?: vimService.vim.NetIpRouteConfigSpec): vimService.vim.NetIpRouteConfigSpec;
         };
         NetIpStackInfoEntryType: {
            "other": string;
            "invalid": string;
            "dynamic": string;
            "manual": string;
         };
         NetIpStackInfoPreference: {
            "reserved": string;
            "low": string;
            "medium": string;
            "high": string;
         };
         NetIpStackInfoNetToMedia: {
            (options?: vimService.vim.NetIpStackInfoNetToMedia): vimService.vim.NetIpStackInfoNetToMedia;
         };
         ArrayOfNetIpStackInfoNetToMedia: {
            (options?: vimService.vim.ArrayOfNetIpStackInfoNetToMedia): vimService.vim.ArrayOfNetIpStackInfoNetToMedia;
         };
         NetIpStackInfoDefaultRouter: {
            (options?: vimService.vim.NetIpStackInfoDefaultRouter): vimService.vim.NetIpStackInfoDefaultRouter;
         };
         ArrayOfNetIpStackInfoDefaultRouter: {
            (options?: vimService.vim.ArrayOfNetIpStackInfoDefaultRouter): vimService.vim.ArrayOfNetIpStackInfoDefaultRouter;
         };
         NetIpStackInfo: {
            (options?: vimService.vim.NetIpStackInfo): vimService.vim.NetIpStackInfo;
         };
         NetBIOSConfigInfoMode: {
            "unknown": string;
            "enabled": string;
            "disabled": string;
            "enabledViaDHCP": string;
         };
         NetBIOSConfigInfo: {
            (options?: vimService.vim.NetBIOSConfigInfo): vimService.vim.NetBIOSConfigInfo;
         };
         WinNetBIOSConfigInfo: {
            (options?: vimService.vim.WinNetBIOSConfigInfo): vimService.vim.WinNetBIOSConfigInfo;
         };
         ArrayUpdateOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         ArrayUpdateSpec: {
            (options?: vimService.vim.ArrayUpdateSpec): vimService.vim.ArrayUpdateSpec;
         };
         BoolOption: {
            (options?: vimService.vim.BoolOption): vimService.vim.BoolOption;
         };
         ChoiceOption: {
            (options?: vimService.vim.ChoiceOption): vimService.vim.ChoiceOption;
         };
         FloatOption: {
            (options?: vimService.vim.FloatOption): vimService.vim.FloatOption;
         };
         IntOption: {
            (options?: vimService.vim.IntOption): vimService.vim.IntOption;
         };
         LongOption: {
            (options?: vimService.vim.LongOption): vimService.vim.LongOption;
         };
         OptionDef: {
            (options?: vimService.vim.OptionDef): vimService.vim.OptionDef;
         };
         ArrayOfOptionDef: {
            (options?: vimService.vim.ArrayOfOptionDef): vimService.vim.ArrayOfOptionDef;
         };
         OptionType: {
            (options?: vimService.vim.OptionType): vimService.vim.OptionType;
         };
         OptionValue: {
            (options?: vimService.vim.OptionValue): vimService.vim.OptionValue;
         };
         ArrayOfOptionValue: {
            (options?: vimService.vim.ArrayOfOptionValue): vimService.vim.ArrayOfOptionValue;
         };
         StringOption: {
            (options?: vimService.vim.StringOption): vimService.vim.StringOption;
         };
         ApplyProfile: {
            (options?: vimService.vim.ApplyProfile): vimService.vim.ApplyProfile;
         };
         ArrayOfApplyProfile: {
            (options?: vimService.vim.ArrayOfApplyProfile): vimService.vim.ArrayOfApplyProfile;
         };
         ProfileApplyProfileElement: {
            (options?: vimService.vim.ProfileApplyProfileElement): vimService.vim.ProfileApplyProfileElement;
         };
         ProfileApplyProfileProperty: {
            (options?: vimService.vim.ProfileApplyProfileProperty): vimService.vim.ProfileApplyProfileProperty;
         };
         ArrayOfProfileApplyProfileProperty: {
            (options?: vimService.vim.ArrayOfProfileApplyProfileProperty): vimService.vim.ArrayOfProfileApplyProfileProperty;
         };
         ComplianceLocator: {
            (options?: vimService.vim.ComplianceLocator): vimService.vim.ComplianceLocator;
         };
         ArrayOfComplianceLocator: {
            (options?: vimService.vim.ArrayOfComplianceLocator): vimService.vim.ArrayOfComplianceLocator;
         };
         ComplianceProfile: {
            (options?: vimService.vim.ComplianceProfile): vimService.vim.ComplianceProfile;
         };
         ComplianceResultStatus: {
            "compliant": string;
            "nonCompliant": string;
            "unknown": string;
         };
         ComplianceFailure: {
            (options?: vimService.vim.ComplianceFailure): vimService.vim.ComplianceFailure;
         };
         ArrayOfComplianceFailure: {
            (options?: vimService.vim.ArrayOfComplianceFailure): vimService.vim.ArrayOfComplianceFailure;
         };
         ComplianceResult: {
            (options?: vimService.vim.ComplianceResult): vimService.vim.ComplianceResult;
         };
         ArrayOfComplianceResult: {
            (options?: vimService.vim.ArrayOfComplianceResult): vimService.vim.ArrayOfComplianceResult;
         };
         ProfileDeferredPolicyOptionParameter: {
            (options?: vimService.vim.ProfileDeferredPolicyOptionParameter): vimService.vim.ProfileDeferredPolicyOptionParameter;
         };
         ArrayOfProfileDeferredPolicyOptionParameter: {
            (options?: vimService.vim.ArrayOfProfileDeferredPolicyOptionParameter): vimService.vim.ArrayOfProfileDeferredPolicyOptionParameter;
         };
         ProfileExpression: {
            (options?: vimService.vim.ProfileExpression): vimService.vim.ProfileExpression;
         };
         ArrayOfProfileExpression: {
            (options?: vimService.vim.ArrayOfProfileExpression): vimService.vim.ArrayOfProfileExpression;
         };
         ProfileSimpleExpression: {
            (options?: vimService.vim.ProfileSimpleExpression): vimService.vim.ProfileSimpleExpression;
         };
         ProfileCompositeExpression: {
            (options?: vimService.vim.ProfileCompositeExpression): vimService.vim.ProfileCompositeExpression;
         };
         ProfileExpressionMetadata: {
            (options?: vimService.vim.ProfileExpressionMetadata): vimService.vim.ProfileExpressionMetadata;
         };
         ArrayOfProfileExpressionMetadata: {
            (options?: vimService.vim.ArrayOfProfileExpressionMetadata): vimService.vim.ArrayOfProfileExpressionMetadata;
         };
         ProfileNumericComparator: {
            "lessThan": string;
            "lessThanEqual": string;
            "equal": string;
            "notEqual": string;
            "greaterThanEqual": string;
            "greaterThan": string;
         };
         ProfileParameterMetadata: {
            (options?: vimService.vim.ProfileParameterMetadata): vimService.vim.ProfileParameterMetadata;
         };
         ArrayOfProfileParameterMetadata: {
            (options?: vimService.vim.ArrayOfProfileParameterMetadata): vimService.vim.ArrayOfProfileParameterMetadata;
         };
         ProfilePolicy: {
            (options?: vimService.vim.ProfilePolicy): vimService.vim.ProfilePolicy;
         };
         ArrayOfProfilePolicy: {
            (options?: vimService.vim.ArrayOfProfilePolicy): vimService.vim.ArrayOfProfilePolicy;
         };
         ProfilePolicyOptionMetadata: {
            (options?: vimService.vim.ProfilePolicyOptionMetadata): vimService.vim.ProfilePolicyOptionMetadata;
         };
         ArrayOfProfilePolicyOptionMetadata: {
            (options?: vimService.vim.ArrayOfProfilePolicyOptionMetadata): vimService.vim.ArrayOfProfilePolicyOptionMetadata;
         };
         ProfileCompositePolicyOptionMetadata: {
            (options?: vimService.vim.ProfileCompositePolicyOptionMetadata): vimService.vim.ProfileCompositePolicyOptionMetadata;
         };
         UserInputRequiredParameterMetadata: {
            (options?: vimService.vim.UserInputRequiredParameterMetadata): vimService.vim.UserInputRequiredParameterMetadata;
         };
         ProfilePolicyMetadata: {
            (options?: vimService.vim.ProfilePolicyMetadata): vimService.vim.ProfilePolicyMetadata;
         };
         ArrayOfProfilePolicyMetadata: {
            (options?: vimService.vim.ArrayOfProfilePolicyMetadata): vimService.vim.ArrayOfProfilePolicyMetadata;
         };
         PolicyOption: {
            (options?: vimService.vim.PolicyOption): vimService.vim.PolicyOption;
         };
         ArrayOfPolicyOption: {
            (options?: vimService.vim.ArrayOfPolicyOption): vimService.vim.ArrayOfPolicyOption;
         };
         CompositePolicyOption: {
            (options?: vimService.vim.CompositePolicyOption): vimService.vim.CompositePolicyOption;
         };
         ProfileCreateSpec: {
            (options?: vimService.vim.ProfileCreateSpec): vimService.vim.ProfileCreateSpec;
         };
         ProfileSerializedCreateSpec: {
            (options?: vimService.vim.ProfileSerializedCreateSpec): vimService.vim.ProfileSerializedCreateSpec;
         };
         ProfileConfigInfo: {
            (options?: vimService.vim.ProfileConfigInfo): vimService.vim.ProfileConfigInfo;
         };
         ProfileDescriptionSection: {
            (options?: vimService.vim.ProfileDescriptionSection): vimService.vim.ProfileDescriptionSection;
         };
         ArrayOfProfileDescriptionSection: {
            (options?: vimService.vim.ArrayOfProfileDescriptionSection): vimService.vim.ArrayOfProfileDescriptionSection;
         };
         ProfileDescription: {
            (options?: vimService.vim.ProfileDescription): vimService.vim.ProfileDescription;
         };
         ProfileMetadataProfileSortSpec: {
            (options?: vimService.vim.ProfileMetadataProfileSortSpec): vimService.vim.ProfileMetadataProfileSortSpec;
         };
         ArrayOfProfileMetadataProfileSortSpec: {
            (options?: vimService.vim.ArrayOfProfileMetadataProfileSortSpec): vimService.vim.ArrayOfProfileMetadataProfileSortSpec;
         };
         ProfileMetadata: {
            (options?: vimService.vim.ProfileMetadata): vimService.vim.ProfileMetadata;
         };
         ArrayOfProfileMetadata: {
            (options?: vimService.vim.ArrayOfProfileMetadata): vimService.vim.ArrayOfProfileMetadata;
         };
         ProfilePropertyPath: {
            (options?: vimService.vim.ProfilePropertyPath): vimService.vim.ProfilePropertyPath;
         };
         ArrayOfProfilePropertyPath: {
            (options?: vimService.vim.ArrayOfProfilePropertyPath): vimService.vim.ArrayOfProfilePropertyPath;
         };
         ProfileProfileStructure: {
            (options?: vimService.vim.ProfileProfileStructure): vimService.vim.ProfileProfileStructure;
         };
         ProfileProfileStructureProperty: {
            (options?: vimService.vim.ProfileProfileStructureProperty): vimService.vim.ProfileProfileStructureProperty;
         };
         ArrayOfProfileProfileStructureProperty: {
            (options?: vimService.vim.ArrayOfProfileProfileStructureProperty): vimService.vim.ArrayOfProfileProfileStructureProperty;
         };
         ClusterProfileConfigInfo: {
            (options?: vimService.vim.ClusterProfileConfigInfo): vimService.vim.ClusterProfileConfigInfo;
         };
         ClusterProfileCreateSpec: {
            (options?: vimService.vim.ClusterProfileCreateSpec): vimService.vim.ClusterProfileCreateSpec;
         };
         ClusterProfileConfigSpec: {
            (options?: vimService.vim.ClusterProfileConfigSpec): vimService.vim.ClusterProfileConfigSpec;
         };
         ClusterProfileCompleteConfigSpec: {
            (options?: vimService.vim.ClusterProfileCompleteConfigSpec): vimService.vim.ClusterProfileCompleteConfigSpec;
         };
         ClusterProfileServiceType: {
            "DRS": string;
            "HA": string;
            "DPM": string;
            "FT": string;
         };
         ClusterProfileConfigServiceCreateSpec: {
            (options?: vimService.vim.ClusterProfileConfigServiceCreateSpec): vimService.vim.ClusterProfileConfigServiceCreateSpec;
         };
         AnswerFile: {
            (options?: vimService.vim.AnswerFile): vimService.vim.AnswerFile;
         };
         AnswerFileStatusError: {
            (options?: vimService.vim.AnswerFileStatusError): vimService.vim.AnswerFileStatusError;
         };
         ArrayOfAnswerFileStatusError: {
            (options?: vimService.vim.ArrayOfAnswerFileStatusError): vimService.vim.ArrayOfAnswerFileStatusError;
         };
         AnswerFileStatusResult: {
            (options?: vimService.vim.AnswerFileStatusResult): vimService.vim.AnswerFileStatusResult;
         };
         ArrayOfAnswerFileStatusResult: {
            (options?: vimService.vim.ArrayOfAnswerFileStatusResult): vimService.vim.ArrayOfAnswerFileStatusResult;
         };
         ProfileExecuteResultStatus: {
            "success": string;
            "needInput": string;
            "error": string;
         };
         ProfileExecuteError: {
            (options?: vimService.vim.ProfileExecuteError): vimService.vim.ProfileExecuteError;
         };
         ArrayOfProfileExecuteError: {
            (options?: vimService.vim.ArrayOfProfileExecuteError): vimService.vim.ArrayOfProfileExecuteError;
         };
         ProfileExecuteResult: {
            (options?: vimService.vim.ProfileExecuteResult): vimService.vim.ProfileExecuteResult;
         };
         HostApplyProfile: {
            (options?: vimService.vim.HostApplyProfile): vimService.vim.HostApplyProfile;
         };
         PhysicalNicProfile: {
            (options?: vimService.vim.PhysicalNicProfile): vimService.vim.PhysicalNicProfile;
         };
         ArrayOfPhysicalNicProfile: {
            (options?: vimService.vim.ArrayOfPhysicalNicProfile): vimService.vim.ArrayOfPhysicalNicProfile;
         };
         HostMemoryProfile: {
            (options?: vimService.vim.HostMemoryProfile): vimService.vim.HostMemoryProfile;
         };
         UserProfile: {
            (options?: vimService.vim.UserProfile): vimService.vim.UserProfile;
         };
         ArrayOfUserProfile: {
            (options?: vimService.vim.ArrayOfUserProfile): vimService.vim.ArrayOfUserProfile;
         };
         UserGroupProfile: {
            (options?: vimService.vim.UserGroupProfile): vimService.vim.UserGroupProfile;
         };
         ArrayOfUserGroupProfile: {
            (options?: vimService.vim.ArrayOfUserGroupProfile): vimService.vim.ArrayOfUserGroupProfile;
         };
         SecurityProfile: {
            (options?: vimService.vim.SecurityProfile): vimService.vim.SecurityProfile;
         };
         OptionProfile: {
            (options?: vimService.vim.OptionProfile): vimService.vim.OptionProfile;
         };
         ArrayOfOptionProfile: {
            (options?: vimService.vim.ArrayOfOptionProfile): vimService.vim.ArrayOfOptionProfile;
         };
         DateTimeProfile: {
            (options?: vimService.vim.DateTimeProfile): vimService.vim.DateTimeProfile;
         };
         ServiceProfile: {
            (options?: vimService.vim.ServiceProfile): vimService.vim.ServiceProfile;
         };
         ArrayOfServiceProfile: {
            (options?: vimService.vim.ArrayOfServiceProfile): vimService.vim.ArrayOfServiceProfile;
         };
         FirewallProfileRulesetProfile: {
            (options?: vimService.vim.FirewallProfileRulesetProfile): vimService.vim.FirewallProfileRulesetProfile;
         };
         ArrayOfFirewallProfileRulesetProfile: {
            (options?: vimService.vim.ArrayOfFirewallProfileRulesetProfile): vimService.vim.ArrayOfFirewallProfileRulesetProfile;
         };
         FirewallProfile: {
            (options?: vimService.vim.FirewallProfile): vimService.vim.FirewallProfile;
         };
         NasStorageProfile: {
            (options?: vimService.vim.NasStorageProfile): vimService.vim.NasStorageProfile;
         };
         ArrayOfNasStorageProfile: {
            (options?: vimService.vim.ArrayOfNasStorageProfile): vimService.vim.ArrayOfNasStorageProfile;
         };
         StorageProfile: {
            (options?: vimService.vim.StorageProfile): vimService.vim.StorageProfile;
         };
         NetworkProfileDnsConfigProfile: {
            (options?: vimService.vim.NetworkProfileDnsConfigProfile): vimService.vim.NetworkProfileDnsConfigProfile;
         };
         NetworkProfile: {
            (options?: vimService.vim.NetworkProfile): vimService.vim.NetworkProfile;
         };
         DvsVNicProfile: {
            (options?: vimService.vim.DvsVNicProfile): vimService.vim.DvsVNicProfile;
         };
         DvsServiceConsoleVNicProfile: {
            (options?: vimService.vim.DvsServiceConsoleVNicProfile): vimService.vim.DvsServiceConsoleVNicProfile;
         };
         ArrayOfDvsServiceConsoleVNicProfile: {
            (options?: vimService.vim.ArrayOfDvsServiceConsoleVNicProfile): vimService.vim.ArrayOfDvsServiceConsoleVNicProfile;
         };
         DvsHostVNicProfile: {
            (options?: vimService.vim.DvsHostVNicProfile): vimService.vim.DvsHostVNicProfile;
         };
         ArrayOfDvsHostVNicProfile: {
            (options?: vimService.vim.ArrayOfDvsHostVNicProfile): vimService.vim.ArrayOfDvsHostVNicProfile;
         };
         DvsProfile: {
            (options?: vimService.vim.DvsProfile): vimService.vim.DvsProfile;
         };
         ArrayOfDvsProfile: {
            (options?: vimService.vim.ArrayOfDvsProfile): vimService.vim.ArrayOfDvsProfile;
         };
         PnicUplinkProfile: {
            (options?: vimService.vim.PnicUplinkProfile): vimService.vim.PnicUplinkProfile;
         };
         ArrayOfPnicUplinkProfile: {
            (options?: vimService.vim.ArrayOfPnicUplinkProfile): vimService.vim.ArrayOfPnicUplinkProfile;
         };
         IpRouteProfile: {
            (options?: vimService.vim.IpRouteProfile): vimService.vim.IpRouteProfile;
         };
         StaticRouteProfile: {
            (options?: vimService.vim.StaticRouteProfile): vimService.vim.StaticRouteProfile;
         };
         ArrayOfStaticRouteProfile: {
            (options?: vimService.vim.ArrayOfStaticRouteProfile): vimService.vim.ArrayOfStaticRouteProfile;
         };
         LinkProfile: {
            (options?: vimService.vim.LinkProfile): vimService.vim.LinkProfile;
         };
         NumPortsProfile: {
            (options?: vimService.vim.NumPortsProfile): vimService.vim.NumPortsProfile;
         };
         VirtualSwitchProfile: {
            (options?: vimService.vim.VirtualSwitchProfile): vimService.vim.VirtualSwitchProfile;
         };
         ArrayOfVirtualSwitchProfile: {
            (options?: vimService.vim.ArrayOfVirtualSwitchProfile): vimService.vim.ArrayOfVirtualSwitchProfile;
         };
         NetStackInstanceProfile: {
            (options?: vimService.vim.NetStackInstanceProfile): vimService.vim.NetStackInstanceProfile;
         };
         ArrayOfNetStackInstanceProfile: {
            (options?: vimService.vim.ArrayOfNetStackInstanceProfile): vimService.vim.ArrayOfNetStackInstanceProfile;
         };
         VlanProfile: {
            (options?: vimService.vim.VlanProfile): vimService.vim.VlanProfile;
         };
         VirtualSwitchSelectionProfile: {
            (options?: vimService.vim.VirtualSwitchSelectionProfile): vimService.vim.VirtualSwitchSelectionProfile;
         };
         PortGroupProfile: {
            (options?: vimService.vim.PortGroupProfile): vimService.vim.PortGroupProfile;
         };
         VmPortGroupProfile: {
            (options?: vimService.vim.VmPortGroupProfile): vimService.vim.VmPortGroupProfile;
         };
         ArrayOfVmPortGroupProfile: {
            (options?: vimService.vim.ArrayOfVmPortGroupProfile): vimService.vim.ArrayOfVmPortGroupProfile;
         };
         HostPortGroupProfile: {
            (options?: vimService.vim.HostPortGroupProfile): vimService.vim.HostPortGroupProfile;
         };
         ArrayOfHostPortGroupProfile: {
            (options?: vimService.vim.ArrayOfHostPortGroupProfile): vimService.vim.ArrayOfHostPortGroupProfile;
         };
         ServiceConsolePortGroupProfile: {
            (options?: vimService.vim.ServiceConsolePortGroupProfile): vimService.vim.ServiceConsolePortGroupProfile;
         };
         ArrayOfServiceConsolePortGroupProfile: {
            (options?: vimService.vim.ArrayOfServiceConsolePortGroupProfile): vimService.vim.ArrayOfServiceConsolePortGroupProfile;
         };
         NetworkPolicyProfile: {
            (options?: vimService.vim.NetworkPolicyProfile): vimService.vim.NetworkPolicyProfile;
         };
         IpAddressProfile: {
            (options?: vimService.vim.IpAddressProfile): vimService.vim.IpAddressProfile;
         };
         AuthenticationProfile: {
            (options?: vimService.vim.AuthenticationProfile): vimService.vim.AuthenticationProfile;
         };
         ActiveDirectoryProfile: {
            (options?: vimService.vim.ActiveDirectoryProfile): vimService.vim.ActiveDirectoryProfile;
         };
         PermissionProfile: {
            (options?: vimService.vim.PermissionProfile): vimService.vim.PermissionProfile;
         };
         ArrayOfPermissionProfile: {
            (options?: vimService.vim.ArrayOfPermissionProfile): vimService.vim.ArrayOfPermissionProfile;
         };
         HostProfileConfigInfo: {
            (options?: vimService.vim.HostProfileConfigInfo): vimService.vim.HostProfileConfigInfo;
         };
         HostProfileConfigSpec: {
            (options?: vimService.vim.HostProfileConfigSpec): vimService.vim.HostProfileConfigSpec;
         };
         HostProfileSerializedHostProfileSpec: {
            (options?: vimService.vim.HostProfileSerializedHostProfileSpec): vimService.vim.HostProfileSerializedHostProfileSpec;
         };
         HostProfileCompleteConfigSpec: {
            (options?: vimService.vim.HostProfileCompleteConfigSpec): vimService.vim.HostProfileCompleteConfigSpec;
         };
         HostProfileHostBasedConfigSpec: {
            (options?: vimService.vim.HostProfileHostBasedConfigSpec): vimService.vim.HostProfileHostBasedConfigSpec;
         };
         HostProfileManagerTaskListRequirement: {
            "maintenanceModeRequired": string;
            "rebootRequired": string;
         };
         HostProfileManagerConfigTaskList: {
            (options?: vimService.vim.HostProfileManagerConfigTaskList): vimService.vim.HostProfileManagerConfigTaskList;
         };
         AnswerFileCreateSpec: {
            (options?: vimService.vim.AnswerFileCreateSpec): vimService.vim.AnswerFileCreateSpec;
         };
         AnswerFileOptionsCreateSpec: {
            (options?: vimService.vim.AnswerFileOptionsCreateSpec): vimService.vim.AnswerFileOptionsCreateSpec;
         };
         AnswerFileSerializedCreateSpec: {
            (options?: vimService.vim.AnswerFileSerializedCreateSpec): vimService.vim.AnswerFileSerializedCreateSpec;
         };
         HostProfileManagerAnswerFileStatus: {
            "valid": string;
            "invalid": string;
            "unknown": string;
         };
         ScheduledTaskDetail: {
            (options?: vimService.vim.ScheduledTaskDetail): vimService.vim.ScheduledTaskDetail;
         };
         ArrayOfScheduledTaskDetail: {
            (options?: vimService.vim.ArrayOfScheduledTaskDetail): vimService.vim.ArrayOfScheduledTaskDetail;
         };
         ScheduledTaskDescription: {
            (options?: vimService.vim.ScheduledTaskDescription): vimService.vim.ScheduledTaskDescription;
         };
         ScheduledTaskInfo: {
            (options?: vimService.vim.ScheduledTaskInfo): vimService.vim.ScheduledTaskInfo;
         };
         TaskScheduler: {
            (options?: vimService.vim.TaskScheduler): vimService.vim.TaskScheduler;
         };
         AfterStartupTaskScheduler: {
            (options?: vimService.vim.AfterStartupTaskScheduler): vimService.vim.AfterStartupTaskScheduler;
         };
         OnceTaskScheduler: {
            (options?: vimService.vim.OnceTaskScheduler): vimService.vim.OnceTaskScheduler;
         };
         RecurrentTaskScheduler: {
            (options?: vimService.vim.RecurrentTaskScheduler): vimService.vim.RecurrentTaskScheduler;
         };
         HourlyTaskScheduler: {
            (options?: vimService.vim.HourlyTaskScheduler): vimService.vim.HourlyTaskScheduler;
         };
         DailyTaskScheduler: {
            (options?: vimService.vim.DailyTaskScheduler): vimService.vim.DailyTaskScheduler;
         };
         WeeklyTaskScheduler: {
            (options?: vimService.vim.WeeklyTaskScheduler): vimService.vim.WeeklyTaskScheduler;
         };
         MonthlyTaskScheduler: {
            (options?: vimService.vim.MonthlyTaskScheduler): vimService.vim.MonthlyTaskScheduler;
         };
         MonthlyByDayTaskScheduler: {
            (options?: vimService.vim.MonthlyByDayTaskScheduler): vimService.vim.MonthlyByDayTaskScheduler;
         };
         DayOfWeek: {
            "sunday": string;
            "monday": string;
            "tuesday": string;
            "wednesday": string;
            "thursday": string;
            "friday": string;
            "saturday": string;
         };
         WeekOfMonth: {
            "first": string;
            "second": string;
            "third": string;
            "fourth": string;
            "last": string;
         };
         MonthlyByWeekdayTaskScheduler: {
            (options?: vimService.vim.MonthlyByWeekdayTaskScheduler): vimService.vim.MonthlyByWeekdayTaskScheduler;
         };
         ScheduledTaskSpec: {
            (options?: vimService.vim.ScheduledTaskSpec): vimService.vim.ScheduledTaskSpec;
         };
         ApplyStorageRecommendationResult: {
            (options?: vimService.vim.ApplyStorageRecommendationResult): vimService.vim.ApplyStorageRecommendationResult;
         };
         StorageDrsConfigInfo: {
            (options?: vimService.vim.StorageDrsConfigInfo): vimService.vim.StorageDrsConfigInfo;
         };
         StorageDrsConfigSpec: {
            (options?: vimService.vim.StorageDrsConfigSpec): vimService.vim.StorageDrsConfigSpec;
         };
         StorageDrsVmConfigSpec: {
            (options?: vimService.vim.StorageDrsVmConfigSpec): vimService.vim.StorageDrsVmConfigSpec;
         };
         ArrayOfStorageDrsVmConfigSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsVmConfigSpec): vimService.vim.ArrayOfStorageDrsVmConfigSpec;
         };
         HbrDiskMigrationAction: {
            (options?: vimService.vim.HbrDiskMigrationAction): vimService.vim.HbrDiskMigrationAction;
         };
         PlacementAffinityRuleRuleType: {
            "affinity": string;
            "antiAffinity": string;
            "softAffinity": string;
            "softAntiAffinity": string;
         };
         PlacementAffinityRuleRuleScope: {
            "cluster": string;
            "host": string;
            "storagePod": string;
            "datastore": string;
         };
         PlacementAffinityRule: {
            (options?: vimService.vim.PlacementAffinityRule): vimService.vim.PlacementAffinityRule;
         };
         ArrayOfPlacementAffinityRule: {
            (options?: vimService.vim.ArrayOfPlacementAffinityRule): vimService.vim.ArrayOfPlacementAffinityRule;
         };
         PlacementRankResult: {
            (options?: vimService.vim.PlacementRankResult): vimService.vim.PlacementRankResult;
         };
         PlacementRankSpec: {
            (options?: vimService.vim.PlacementRankSpec): vimService.vim.PlacementRankSpec;
         };
         StorageDrsPlacementRankVmSpec: {
            (options?: vimService.vim.StorageDrsPlacementRankVmSpec): vimService.vim.StorageDrsPlacementRankVmSpec;
         };
         ArrayOfStorageDrsPlacementRankVmSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsPlacementRankVmSpec): vimService.vim.ArrayOfStorageDrsPlacementRankVmSpec;
         };
         StorageDrsPodConfigInfoBehavior: {
            "manual": string;
            "automated": string;
         };
         StorageDrsPodConfigInfo: {
            (options?: vimService.vim.StorageDrsPodConfigInfo): vimService.vim.StorageDrsPodConfigInfo;
         };
         StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode: {
            "utilization": string;
            "freeSpace": string;
         };
         StorageDrsSpaceLoadBalanceConfig: {
            (options?: vimService.vim.StorageDrsSpaceLoadBalanceConfig): vimService.vim.StorageDrsSpaceLoadBalanceConfig;
         };
         StorageDrsIoLoadBalanceConfig: {
            (options?: vimService.vim.StorageDrsIoLoadBalanceConfig): vimService.vim.StorageDrsIoLoadBalanceConfig;
         };
         StorageDrsAutomationConfig: {
            (options?: vimService.vim.StorageDrsAutomationConfig): vimService.vim.StorageDrsAutomationConfig;
         };
         StorageDrsPodConfigSpec: {
            (options?: vimService.vim.StorageDrsPodConfigSpec): vimService.vim.StorageDrsPodConfigSpec;
         };
         StorageDrsOptionSpec: {
            (options?: vimService.vim.StorageDrsOptionSpec): vimService.vim.StorageDrsOptionSpec;
         };
         ArrayOfStorageDrsOptionSpec: {
            (options?: vimService.vim.ArrayOfStorageDrsOptionSpec): vimService.vim.ArrayOfStorageDrsOptionSpec;
         };
         VmPodConfigForPlacement: {
            (options?: vimService.vim.VmPodConfigForPlacement): vimService.vim.VmPodConfigForPlacement;
         };
         ArrayOfVmPodConfigForPlacement: {
            (options?: vimService.vim.ArrayOfVmPodConfigForPlacement): vimService.vim.ArrayOfVmPodConfigForPlacement;
         };
         PodDiskLocator: {
            (options?: vimService.vim.PodDiskLocator): vimService.vim.PodDiskLocator;
         };
         ArrayOfPodDiskLocator: {
            (options?: vimService.vim.ArrayOfPodDiskLocator): vimService.vim.ArrayOfPodDiskLocator;
         };
         StorageDrsPodSelectionSpec: {
            (options?: vimService.vim.StorageDrsPodSelectionSpec): vimService.vim.StorageDrsPodSelectionSpec;
         };
         StorageMigrationAction: {
            (options?: vimService.vim.StorageMigrationAction): vimService.vim.StorageMigrationAction;
         };
         StoragePlacementAction: {
            (options?: vimService.vim.StoragePlacementAction): vimService.vim.StoragePlacementAction;
         };
         StoragePlacementResult: {
            (options?: vimService.vim.StoragePlacementResult): vimService.vim.StoragePlacementResult;
         };
         StoragePlacementSpecPlacementType: {
            "create": string;
            "reconfigure": string;
            "relocate": string;
            "clone": string;
         };
         StoragePlacementSpec: {
            (options?: vimService.vim.StoragePlacementSpec): vimService.vim.StoragePlacementSpec;
         };
         VirtualDiskAntiAffinityRuleSpec: {
            (options?: vimService.vim.VirtualDiskAntiAffinityRuleSpec): vimService.vim.VirtualDiskAntiAffinityRuleSpec;
         };
         StorageDrsVmConfigInfo: {
            (options?: vimService.vim.StorageDrsVmConfigInfo): vimService.vim.StorageDrsVmConfigInfo;
         };
         ArrayOfStorageDrsVmConfigInfo: {
            (options?: vimService.vim.ArrayOfStorageDrsVmConfigInfo): vimService.vim.ArrayOfStorageDrsVmConfigInfo;
         };
         VAppCloneSpecNetworkMappingPair: {
            (options?: vimService.vim.VAppCloneSpecNetworkMappingPair): vimService.vim.VAppCloneSpecNetworkMappingPair;
         };
         ArrayOfVAppCloneSpecNetworkMappingPair: {
            (options?: vimService.vim.ArrayOfVAppCloneSpecNetworkMappingPair): vimService.vim.ArrayOfVAppCloneSpecNetworkMappingPair;
         };
         VAppCloneSpecResourceMap: {
            (options?: vimService.vim.VAppCloneSpecResourceMap): vimService.vim.VAppCloneSpecResourceMap;
         };
         ArrayOfVAppCloneSpecResourceMap: {
            (options?: vimService.vim.ArrayOfVAppCloneSpecResourceMap): vimService.vim.ArrayOfVAppCloneSpecResourceMap;
         };
         VAppCloneSpecProvisioningType: {
            "sameAsSource": string;
            "thin": string;
            "thick": string;
         };
         VAppCloneSpec: {
            (options?: vimService.vim.VAppCloneSpec): vimService.vim.VAppCloneSpec;
         };
         VAppAutoStartAction: {
            "none": string;
            "powerOn": string;
            "powerOff": string;
            "guestShutdown": string;
            "suspend": string;
         };
         VAppEntityConfigInfo: {
            (options?: vimService.vim.VAppEntityConfigInfo): vimService.vim.VAppEntityConfigInfo;
         };
         ArrayOfVAppEntityConfigInfo: {
            (options?: vimService.vim.ArrayOfVAppEntityConfigInfo): vimService.vim.ArrayOfVAppEntityConfigInfo;
         };
         VAppIPAssignmentInfoIpAllocationPolicy: {
            "dhcpPolicy": string;
            "transientPolicy": string;
            "fixedPolicy": string;
            "fixedAllocatedPolicy": string;
         };
         VAppIPAssignmentInfoAllocationSchemes: {
            "dhcp": string;
            "ovfenv": string;
         };
         VAppIPAssignmentInfoProtocols: {
            "IPv4": string;
            "IPv6": string;
         };
         VAppIPAssignmentInfo: {
            (options?: vimService.vim.VAppIPAssignmentInfo): vimService.vim.VAppIPAssignmentInfo;
         };
         IpPoolIpPoolConfigInfo: {
            (options?: vimService.vim.IpPoolIpPoolConfigInfo): vimService.vim.IpPoolIpPoolConfigInfo;
         };
         IpPoolAssociation: {
            (options?: vimService.vim.IpPoolAssociation): vimService.vim.IpPoolAssociation;
         };
         ArrayOfIpPoolAssociation: {
            (options?: vimService.vim.ArrayOfIpPoolAssociation): vimService.vim.ArrayOfIpPoolAssociation;
         };
         IpPool: {
            (options?: vimService.vim.IpPool): vimService.vim.IpPool;
         };
         ArrayOfIpPool: {
            (options?: vimService.vim.ArrayOfIpPool): vimService.vim.ArrayOfIpPool;
         };
         VAppOvfSectionInfo: {
            (options?: vimService.vim.VAppOvfSectionInfo): vimService.vim.VAppOvfSectionInfo;
         };
         ArrayOfVAppOvfSectionInfo: {
            (options?: vimService.vim.ArrayOfVAppOvfSectionInfo): vimService.vim.ArrayOfVAppOvfSectionInfo;
         };
         VAppProductInfo: {
            (options?: vimService.vim.VAppProductInfo): vimService.vim.VAppProductInfo;
         };
         ArrayOfVAppProductInfo: {
            (options?: vimService.vim.ArrayOfVAppProductInfo): vimService.vim.ArrayOfVAppProductInfo;
         };
         VAppPropertyInfo: {
            (options?: vimService.vim.VAppPropertyInfo): vimService.vim.VAppPropertyInfo;
         };
         ArrayOfVAppPropertyInfo: {
            (options?: vimService.vim.ArrayOfVAppPropertyInfo): vimService.vim.ArrayOfVAppPropertyInfo;
         };
         VAppConfigInfo: {
            (options?: vimService.vim.VAppConfigInfo): vimService.vim.VAppConfigInfo;
         };
         VAppConfigSpec: {
            (options?: vimService.vim.VAppConfigSpec): vimService.vim.VAppConfigSpec;
         };
         VirtualAppImportSpec: {
            (options?: vimService.vim.VirtualAppImportSpec): vimService.vim.VirtualAppImportSpec;
         };
         VmConfigInfo: {
            (options?: vimService.vim.VmConfigInfo): vimService.vim.VmConfigInfo;
         };
         VmConfigSpec: {
            (options?: vimService.vim.VmConfigSpec): vimService.vim.VmConfigSpec;
         };
         VAppProductSpec: {
            (options?: vimService.vim.VAppProductSpec): vimService.vim.VAppProductSpec;
         };
         ArrayOfVAppProductSpec: {
            (options?: vimService.vim.ArrayOfVAppProductSpec): vimService.vim.ArrayOfVAppProductSpec;
         };
         VAppPropertySpec: {
            (options?: vimService.vim.VAppPropertySpec): vimService.vim.VAppPropertySpec;
         };
         ArrayOfVAppPropertySpec: {
            (options?: vimService.vim.ArrayOfVAppPropertySpec): vimService.vim.ArrayOfVAppPropertySpec;
         };
         VAppOvfSectionSpec: {
            (options?: vimService.vim.VAppOvfSectionSpec): vimService.vim.VAppOvfSectionSpec;
         };
         ArrayOfVAppOvfSectionSpec: {
            (options?: vimService.vim.ArrayOfVAppOvfSectionSpec): vimService.vim.ArrayOfVAppOvfSectionSpec;
         };
         VirtualMachineAffinityInfo: {
            (options?: vimService.vim.VirtualMachineAffinityInfo): vimService.vim.VirtualMachineAffinityInfo;
         };
         VirtualMachineBootOptionsNetworkBootProtocolType: {
            "ipv4": string;
            "ipv6": string;
         };
         VirtualMachineBootOptionsBootableDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableDevice): vimService.vim.VirtualMachineBootOptionsBootableDevice;
         };
         ArrayOfVirtualMachineBootOptionsBootableDevice: {
            (options?: vimService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice): vimService.vim.ArrayOfVirtualMachineBootOptionsBootableDevice;
         };
         VirtualMachineBootOptionsBootableDiskDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableDiskDevice): vimService.vim.VirtualMachineBootOptionsBootableDiskDevice;
         };
         VirtualMachineBootOptionsBootableEthernetDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableEthernetDevice): vimService.vim.VirtualMachineBootOptionsBootableEthernetDevice;
         };
         VirtualMachineBootOptionsBootableFloppyDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableFloppyDevice): vimService.vim.VirtualMachineBootOptionsBootableFloppyDevice;
         };
         VirtualMachineBootOptionsBootableCdromDevice: {
            (options?: vimService.vim.VirtualMachineBootOptionsBootableCdromDevice): vimService.vim.VirtualMachineBootOptionsBootableCdromDevice;
         };
         VirtualMachineBootOptions: {
            (options?: vimService.vim.VirtualMachineBootOptions): vimService.vim.VirtualMachineBootOptions;
         };
         VirtualMachineCapability: {
            (options?: vimService.vim.VirtualMachineCapability): vimService.vim.VirtualMachineCapability;
         };
         VirtualMachineCdromInfo: {
            (options?: vimService.vim.VirtualMachineCdromInfo): vimService.vim.VirtualMachineCdromInfo;
         };
         ArrayOfVirtualMachineCdromInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineCdromInfo): vimService.vim.ArrayOfVirtualMachineCdromInfo;
         };
         VirtualMachineCloneSpec: {
            (options?: vimService.vim.VirtualMachineCloneSpec): vimService.vim.VirtualMachineCloneSpec;
         };
         VirtualMachineConfigInfoNpivWwnType: {
            "vc": string;
            "host": string;
            "external": string;
         };
         VirtualMachineConfigInfoSwapPlacementType: {
            "inherit": string;
            "vmDirectory": string;
            "hostLocal": string;
         };
         VirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair): vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair;
         };
         ArrayOfVirtualMachineConfigInfoDatastoreUrlPair: {
            (options?: vimService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair): vimService.vim.ArrayOfVirtualMachineConfigInfoDatastoreUrlPair;
         };
         VirtualMachineConfigInfoOverheadInfo: {
            (options?: vimService.vim.VirtualMachineConfigInfoOverheadInfo): vimService.vim.VirtualMachineConfigInfoOverheadInfo;
         };
         VirtualMachineConfigInfo: {
            (options?: vimService.vim.VirtualMachineConfigInfo): vimService.vim.VirtualMachineConfigInfo;
         };
         VirtualMachineConfigOption: {
            (options?: vimService.vim.VirtualMachineConfigOption): vimService.vim.VirtualMachineConfigOption;
         };
         VirtualMachineConfigOptionDescriptor: {
            (options?: vimService.vim.VirtualMachineConfigOptionDescriptor): vimService.vim.VirtualMachineConfigOptionDescriptor;
         };
         ArrayOfVirtualMachineConfigOptionDescriptor: {
            (options?: vimService.vim.ArrayOfVirtualMachineConfigOptionDescriptor): vimService.vim.ArrayOfVirtualMachineConfigOptionDescriptor;
         };
         VirtualMachineConfigSpecNpivWwnOp: {
            "generate": string;
            "set": string;
            "remove": string;
            "extend": string;
         };
         VirtualMachineCpuIdInfoSpec: {
            (options?: vimService.vim.VirtualMachineCpuIdInfoSpec): vimService.vim.VirtualMachineCpuIdInfoSpec;
         };
         ArrayOfVirtualMachineCpuIdInfoSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineCpuIdInfoSpec): vimService.vim.ArrayOfVirtualMachineCpuIdInfoSpec;
         };
         VirtualMachineConfigSpec: {
            (options?: vimService.vim.VirtualMachineConfigSpec): vimService.vim.VirtualMachineConfigSpec;
         };
         ConfigTarget: {
            (options?: vimService.vim.ConfigTarget): vimService.vim.ConfigTarget;
         };
         VirtualMachineConsolePreferences: {
            (options?: vimService.vim.VirtualMachineConsolePreferences): vimService.vim.VirtualMachineConsolePreferences;
         };
         VirtualMachineCreateChildSpec: {
            (options?: vimService.vim.VirtualMachineCreateChildSpec): vimService.vim.VirtualMachineCreateChildSpec;
         };
         VirtualMachineDatastoreInfo: {
            (options?: vimService.vim.VirtualMachineDatastoreInfo): vimService.vim.VirtualMachineDatastoreInfo;
         };
         ArrayOfVirtualMachineDatastoreInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineDatastoreInfo): vimService.vim.ArrayOfVirtualMachineDatastoreInfo;
         };
         VirtualMachineDatastoreVolumeOption: {
            (options?: vimService.vim.VirtualMachineDatastoreVolumeOption): vimService.vim.VirtualMachineDatastoreVolumeOption;
         };
         ArrayOfVirtualMachineDatastoreVolumeOption: {
            (options?: vimService.vim.ArrayOfVirtualMachineDatastoreVolumeOption): vimService.vim.ArrayOfVirtualMachineDatastoreVolumeOption;
         };
         DatastoreOption: {
            (options?: vimService.vim.DatastoreOption): vimService.vim.DatastoreOption;
         };
         VirtualMachinePowerOpType: {
            "soft": string;
            "hard": string;
            "preset": string;
         };
         VirtualMachineStandbyActionType: {
            "checkpoint": string;
            "powerOnSuspend": string;
         };
         VirtualMachineDefaultPowerOpInfo: {
            (options?: vimService.vim.VirtualMachineDefaultPowerOpInfo): vimService.vim.VirtualMachineDefaultPowerOpInfo;
         };
         VirtualMachineDefaultProfileSpec: {
            (options?: vimService.vim.VirtualMachineDefaultProfileSpec): vimService.vim.VirtualMachineDefaultProfileSpec;
         };
         VirtualMachineDefinedProfileSpec: {
            (options?: vimService.vim.VirtualMachineDefinedProfileSpec): vimService.vim.VirtualMachineDefinedProfileSpec;
         };
         VirtualMachineDeviceRuntimeInfoDeviceRuntimeState: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState): vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm: {
            "vmNptIncompatibleGuest": string;
            "vmNptIncompatibleGuestDriver": string;
            "vmNptIncompatibleAdapterType": string;
            "vmNptDisabledOrDisconnectedAdapter": string;
            "vmNptIncompatibleAdapterFeatures": string;
            "vmNptIncompatibleBackingType": string;
            "vmNptInsufficientMemoryReservation": string;
            "vmNptFaultToleranceOrRecordReplayConfigured": string;
            "vmNptConflictingIOChainConfigured": string;
            "vmNptMonitorBlocks": string;
            "vmNptConflictingOperationInProgress": string;
            "vmNptRuntimeError": string;
            "vmNptOutOfIntrVector": string;
            "vmNptVMCIActive": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther: {
            "vmNptIncompatibleHost": string;
            "vmNptIncompatibleNetwork": string;
         };
         VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState): vimService.vim.VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState;
         };
         VirtualMachineDeviceRuntimeInfo: {
            (options?: vimService.vim.VirtualMachineDeviceRuntimeInfo): vimService.vim.VirtualMachineDeviceRuntimeInfo;
         };
         ArrayOfVirtualMachineDeviceRuntimeInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo): vimService.vim.ArrayOfVirtualMachineDeviceRuntimeInfo;
         };
         VirtualMachineDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineDiskDeviceInfo): vimService.vim.VirtualMachineDiskDeviceInfo;
         };
         VirtualMachineEmptyProfileSpec: {
            (options?: vimService.vim.VirtualMachineEmptyProfileSpec): vimService.vim.VirtualMachineEmptyProfileSpec;
         };
         FaultToleranceConfigInfo: {
            (options?: vimService.vim.FaultToleranceConfigInfo): vimService.vim.FaultToleranceConfigInfo;
         };
         FaultTolerancePrimaryConfigInfo: {
            (options?: vimService.vim.FaultTolerancePrimaryConfigInfo): vimService.vim.FaultTolerancePrimaryConfigInfo;
         };
         FaultToleranceSecondaryConfigInfo: {
            (options?: vimService.vim.FaultToleranceSecondaryConfigInfo): vimService.vim.FaultToleranceSecondaryConfigInfo;
         };
         FaultToleranceConfigSpec: {
            (options?: vimService.vim.FaultToleranceConfigSpec): vimService.vim.FaultToleranceConfigSpec;
         };
         FaultToleranceMetaSpec: {
            (options?: vimService.vim.FaultToleranceMetaSpec): vimService.vim.FaultToleranceMetaSpec;
         };
         FaultToleranceSecondaryOpResult: {
            (options?: vimService.vim.FaultToleranceSecondaryOpResult): vimService.vim.FaultToleranceSecondaryOpResult;
         };
         FaultToleranceDiskSpec: {
            (options?: vimService.vim.FaultToleranceDiskSpec): vimService.vim.FaultToleranceDiskSpec;
         };
         ArrayOfFaultToleranceDiskSpec: {
            (options?: vimService.vim.ArrayOfFaultToleranceDiskSpec): vimService.vim.ArrayOfFaultToleranceDiskSpec;
         };
         FaultToleranceVMConfigSpec: {
            (options?: vimService.vim.FaultToleranceVMConfigSpec): vimService.vim.FaultToleranceVMConfigSpec;
         };
         VirtualMachineFeatureRequirement: {
            (options?: vimService.vim.VirtualMachineFeatureRequirement): vimService.vim.VirtualMachineFeatureRequirement;
         };
         ArrayOfVirtualMachineFeatureRequirement: {
            (options?: vimService.vim.ArrayOfVirtualMachineFeatureRequirement): vimService.vim.ArrayOfVirtualMachineFeatureRequirement;
         };
         VirtualMachineFileInfo: {
            (options?: vimService.vim.VirtualMachineFileInfo): vimService.vim.VirtualMachineFileInfo;
         };
         VirtualMachineFileLayoutDiskLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutDiskLayout): vimService.vim.VirtualMachineFileLayoutDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutDiskLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutDiskLayout;
         };
         VirtualMachineFileLayoutSnapshotLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutSnapshotLayout): vimService.vim.VirtualMachineFileLayoutSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutSnapshotLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutSnapshotLayout;
         };
         VirtualMachineFileLayout: {
            (options?: vimService.vim.VirtualMachineFileLayout): vimService.vim.VirtualMachineFileLayout;
         };
         VirtualMachineFileLayoutExFileType: {
            "config": string;
            "extendedConfig": string;
            "diskDescriptor": string;
            "diskExtent": string;
            "digestDescriptor": string;
            "digestExtent": string;
            "diskReplicationState": string;
            "log": string;
            "stat": string;
            "namespaceData": string;
            "nvram": string;
            "snapshotData": string;
            "snapshotMemory": string;
            "snapshotList": string;
            "snapshotManifestList": string;
            "suspend": string;
            "suspendMemory": string;
            "swap": string;
            "uwswap": string;
            "core": string;
            "screenshot": string;
            "ftMetadata": string;
            "guestCustomization": string;
         };
         VirtualMachineFileLayoutExFileInfo: {
            (options?: vimService.vim.VirtualMachineFileLayoutExFileInfo): vimService.vim.VirtualMachineFileLayoutExFileInfo;
         };
         ArrayOfVirtualMachineFileLayoutExFileInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo): vimService.vim.ArrayOfVirtualMachineFileLayoutExFileInfo;
         };
         VirtualMachineFileLayoutExDiskUnit: {
            (options?: vimService.vim.VirtualMachineFileLayoutExDiskUnit): vimService.vim.VirtualMachineFileLayoutExDiskUnit;
         };
         ArrayOfVirtualMachineFileLayoutExDiskUnit: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit): vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskUnit;
         };
         VirtualMachineFileLayoutExDiskLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutExDiskLayout): vimService.vim.VirtualMachineFileLayoutExDiskLayout;
         };
         ArrayOfVirtualMachineFileLayoutExDiskLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutExDiskLayout;
         };
         VirtualMachineFileLayoutExSnapshotLayout: {
            (options?: vimService.vim.VirtualMachineFileLayoutExSnapshotLayout): vimService.vim.VirtualMachineFileLayoutExSnapshotLayout;
         };
         ArrayOfVirtualMachineFileLayoutExSnapshotLayout: {
            (options?: vimService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout): vimService.vim.ArrayOfVirtualMachineFileLayoutExSnapshotLayout;
         };
         VirtualMachineFileLayoutEx: {
            (options?: vimService.vim.VirtualMachineFileLayoutEx): vimService.vim.VirtualMachineFileLayoutEx;
         };
         VirtualMachineHtSharing: {
            "any": string;
            "none": string;
            "internal": string;
         };
         VirtualMachinePowerOffBehavior: {
            "powerOff": string;
            "revert": string;
            "prompt": string;
            "take": string;
         };
         VirtualMachineFlagInfoMonitorType: {
            "release": string;
            "debug": string;
            "stats": string;
         };
         VirtualMachineFlagInfoVirtualMmuUsage: {
            "automatic": string;
            "on": string;
            "off": string;
         };
         VirtualMachineFlagInfoVirtualExecUsage: {
            "hvAuto": string;
            "hvOn": string;
            "hvOff": string;
         };
         VirtualMachineFlagInfo: {
            (options?: vimService.vim.VirtualMachineFlagInfo): vimService.vim.VirtualMachineFlagInfo;
         };
         VirtualMachineFloppyInfo: {
            (options?: vimService.vim.VirtualMachineFloppyInfo): vimService.vim.VirtualMachineFloppyInfo;
         };
         ArrayOfVirtualMachineFloppyInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineFloppyInfo): vimService.vim.ArrayOfVirtualMachineFloppyInfo;
         };
         VirtualMachineForkConfigInfoChildType: {
            "none": string;
            "persistent": string;
            "nonpersistent": string;
         };
         VirtualMachineForkConfigInfo: {
            (options?: vimService.vim.VirtualMachineForkConfigInfo): vimService.vim.VirtualMachineForkConfigInfo;
         };
         VirtualMachineToolsStatus: {
            "toolsNotInstalled": string;
            "toolsNotRunning": string;
            "toolsOld": string;
            "toolsOk": string;
         };
         VirtualMachineToolsVersionStatus: {
            "guestToolsNotInstalled": string;
            "guestToolsNeedUpgrade": string;
            "guestToolsCurrent": string;
            "guestToolsUnmanaged": string;
            "guestToolsTooOld": string;
            "guestToolsSupportedOld": string;
            "guestToolsSupportedNew": string;
            "guestToolsTooNew": string;
            "guestToolsBlacklisted": string;
         };
         VirtualMachineToolsRunningStatus: {
            "guestToolsNotRunning": string;
            "guestToolsRunning": string;
            "guestToolsExecutingScripts": string;
         };
         GuestDiskInfo: {
            (options?: vimService.vim.GuestDiskInfo): vimService.vim.GuestDiskInfo;
         };
         ArrayOfGuestDiskInfo: {
            (options?: vimService.vim.ArrayOfGuestDiskInfo): vimService.vim.ArrayOfGuestDiskInfo;
         };
         GuestNicInfo: {
            (options?: vimService.vim.GuestNicInfo): vimService.vim.GuestNicInfo;
         };
         ArrayOfGuestNicInfo: {
            (options?: vimService.vim.ArrayOfGuestNicInfo): vimService.vim.ArrayOfGuestNicInfo;
         };
         GuestStackInfo: {
            (options?: vimService.vim.GuestStackInfo): vimService.vim.GuestStackInfo;
         };
         ArrayOfGuestStackInfo: {
            (options?: vimService.vim.ArrayOfGuestStackInfo): vimService.vim.ArrayOfGuestStackInfo;
         };
         GuestScreenInfo: {
            (options?: vimService.vim.GuestScreenInfo): vimService.vim.GuestScreenInfo;
         };
         VirtualMachineGuestState: {
            "running": string;
            "shuttingDown": string;
            "resetting": string;
            "standby": string;
            "notRunning": string;
            "unknown": string;
         };
         GuestInfoAppStateType: {
            "none": string;
            "appStateOk": string;
            "appStateNeedReset": string;
         };
         GuestInfoNamespaceGenerationInfo: {
            (options?: vimService.vim.GuestInfoNamespaceGenerationInfo): vimService.vim.GuestInfoNamespaceGenerationInfo;
         };
         ArrayOfGuestInfoNamespaceGenerationInfo: {
            (options?: vimService.vim.ArrayOfGuestInfoNamespaceGenerationInfo): vimService.vim.ArrayOfGuestInfoNamespaceGenerationInfo;
         };
         GuestInfo: {
            (options?: vimService.vim.GuestInfo): vimService.vim.GuestInfo;
         };
         VirtualMachineGuestOsFamily: {
            "windowsGuest": string;
            "linuxGuest": string;
            "netwareGuest": string;
            "solarisGuest": string;
            "darwinGuestFamily": string;
            "otherGuestFamily": string;
         };
         VirtualMachineGuestOsIdentifier: {
            "dosGuest": string;
            "win31Guest": string;
            "win95Guest": string;
            "win98Guest": string;
            "winMeGuest": string;
            "winNTGuest": string;
            "win2000ProGuest": string;
            "win2000ServGuest": string;
            "win2000AdvServGuest": string;
            "winXPHomeGuest": string;
            "winXPProGuest": string;
            "winXPPro64Guest": string;
            "winNetWebGuest": string;
            "winNetStandardGuest": string;
            "winNetEnterpriseGuest": string;
            "winNetDatacenterGuest": string;
            "winNetBusinessGuest": string;
            "winNetStandard64Guest": string;
            "winNetEnterprise64Guest": string;
            "winLonghornGuest": string;
            "winLonghorn64Guest": string;
            "winNetDatacenter64Guest": string;
            "winVistaGuest": string;
            "winVista64Guest": string;
            "windows7Guest": string;
            "windows7_64Guest": string;
            "windows7Server64Guest": string;
            "windows8Guest": string;
            "windows8_64Guest": string;
            "windows8Server64Guest": string;
            "windows9Guest": string;
            "windows9_64Guest": string;
            "windows9Server64Guest": string;
            "windowsHyperVGuest": string;
            "freebsdGuest": string;
            "freebsd64Guest": string;
            "redhatGuest": string;
            "rhel2Guest": string;
            "rhel3Guest": string;
            "rhel3_64Guest": string;
            "rhel4Guest": string;
            "rhel4_64Guest": string;
            "rhel5Guest": string;
            "rhel5_64Guest": string;
            "rhel6Guest": string;
            "rhel6_64Guest": string;
            "rhel7Guest": string;
            "rhel7_64Guest": string;
            "centosGuest": string;
            "centos64Guest": string;
            "oracleLinuxGuest": string;
            "oracleLinux64Guest": string;
            "suseGuest": string;
            "suse64Guest": string;
            "slesGuest": string;
            "sles64Guest": string;
            "sles10Guest": string;
            "sles10_64Guest": string;
            "sles11Guest": string;
            "sles11_64Guest": string;
            "sles12Guest": string;
            "sles12_64Guest": string;
            "nld9Guest": string;
            "oesGuest": string;
            "sjdsGuest": string;
            "mandrakeGuest": string;
            "mandrivaGuest": string;
            "mandriva64Guest": string;
            "turboLinuxGuest": string;
            "turboLinux64Guest": string;
            "ubuntuGuest": string;
            "ubuntu64Guest": string;
            "debian4Guest": string;
            "debian4_64Guest": string;
            "debian5Guest": string;
            "debian5_64Guest": string;
            "debian6Guest": string;
            "debian6_64Guest": string;
            "debian7Guest": string;
            "debian7_64Guest": string;
            "debian8Guest": string;
            "debian8_64Guest": string;
            "asianux3Guest": string;
            "asianux3_64Guest": string;
            "asianux4Guest": string;
            "asianux4_64Guest": string;
            "asianux5_64Guest": string;
            "opensuseGuest": string;
            "opensuse64Guest": string;
            "fedoraGuest": string;
            "fedora64Guest": string;
            "coreos64Guest": string;
            "other24xLinuxGuest": string;
            "other26xLinuxGuest": string;
            "otherLinuxGuest": string;
            "other3xLinuxGuest": string;
            "genericLinuxGuest": string;
            "other24xLinux64Guest": string;
            "other26xLinux64Guest": string;
            "other3xLinux64Guest": string;
            "otherLinux64Guest": string;
            "solaris6Guest": string;
            "solaris7Guest": string;
            "solaris8Guest": string;
            "solaris9Guest": string;
            "solaris10Guest": string;
            "solaris10_64Guest": string;
            "solaris11_64Guest": string;
            "os2Guest": string;
            "eComStationGuest": string;
            "eComStation2Guest": string;
            "netware4Guest": string;
            "netware5Guest": string;
            "netware6Guest": string;
            "openServer5Guest": string;
            "openServer6Guest": string;
            "unixWare7Guest": string;
            "darwinGuest": string;
            "darwin64Guest": string;
            "darwin10Guest": string;
            "darwin10_64Guest": string;
            "darwin11Guest": string;
            "darwin11_64Guest": string;
            "darwin12_64Guest": string;
            "darwin13_64Guest": string;
            "darwin14_64Guest": string;
            "vmkernelGuest": string;
            "vmkernel5Guest": string;
            "vmkernel6Guest": string;
            "otherGuest": string;
            "otherGuest64": string;
         };
         GuestOsDescriptorFirmwareType: {
            "bios": string;
            "efi": string;
         };
         GuestOsDescriptorSupportLevel: {
            "experimental": string;
            "legacy": string;
            "terminated": string;
            "supported": string;
            "unsupported": string;
            "deprecated": string;
            "techPreview": string;
         };
         GuestOsDescriptor: {
            (options?: vimService.vim.GuestOsDescriptor): vimService.vim.GuestOsDescriptor;
         };
         ArrayOfGuestOsDescriptor: {
            (options?: vimService.vim.ArrayOfGuestOsDescriptor): vimService.vim.ArrayOfGuestOsDescriptor;
         };
         VirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo): vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo;
         };
         ArrayOfVirtualMachineIdeDiskDevicePartitionInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo): vimService.vim.ArrayOfVirtualMachineIdeDiskDevicePartitionInfo;
         };
         VirtualMachineIdeDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineIdeDiskDeviceInfo): vimService.vim.VirtualMachineIdeDiskDeviceInfo;
         };
         ArrayOfVirtualMachineIdeDiskDeviceInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo): vimService.vim.ArrayOfVirtualMachineIdeDiskDeviceInfo;
         };
         VirtualMachineLegacyNetworkSwitchInfo: {
            (options?: vimService.vim.VirtualMachineLegacyNetworkSwitchInfo): vimService.vim.VirtualMachineLegacyNetworkSwitchInfo;
         };
         ArrayOfVirtualMachineLegacyNetworkSwitchInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo): vimService.vim.ArrayOfVirtualMachineLegacyNetworkSwitchInfo;
         };
         VirtualMachineMessage: {
            (options?: vimService.vim.VirtualMachineMessage): vimService.vim.VirtualMachineMessage;
         };
         ArrayOfVirtualMachineMessage: {
            (options?: vimService.vim.ArrayOfVirtualMachineMessage): vimService.vim.ArrayOfVirtualMachineMessage;
         };
         VirtualMachineMetadataManagerVmMetadataOwnerOwner: {
            "ComVmwareVsphereHA": string;
         };
         VirtualMachineMetadataManagerVmMetadataOwner: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataOwner): vimService.vim.VirtualMachineMetadataManagerVmMetadataOwner;
         };
         VirtualMachineMetadataManagerVmMetadataOp: {
            "Update": string;
            "Remove": string;
         };
         VirtualMachineMetadataManagerVmMetadata: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadata): vimService.vim.VirtualMachineMetadataManagerVmMetadata;
         };
         VirtualMachineMetadataManagerVmMetadataInput: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataInput): vimService.vim.VirtualMachineMetadataManagerVmMetadataInput;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataInput: {
            (options?: vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput): vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataInput;
         };
         VirtualMachineMetadataManagerVmMetadataResult: {
            (options?: vimService.vim.VirtualMachineMetadataManagerVmMetadataResult): vimService.vim.VirtualMachineMetadataManagerVmMetadataResult;
         };
         ArrayOfVirtualMachineMetadataManagerVmMetadataResult: {
            (options?: vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult): vimService.vim.ArrayOfVirtualMachineMetadataManagerVmMetadataResult;
         };
         VirtualMachineNetworkInfo: {
            (options?: vimService.vim.VirtualMachineNetworkInfo): vimService.vim.VirtualMachineNetworkInfo;
         };
         ArrayOfVirtualMachineNetworkInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineNetworkInfo): vimService.vim.ArrayOfVirtualMachineNetworkInfo;
         };
         VirtualMachineNetworkShaperInfo: {
            (options?: vimService.vim.VirtualMachineNetworkShaperInfo): vimService.vim.VirtualMachineNetworkShaperInfo;
         };
         OpaqueNetworkTargetInfo: {
            (options?: vimService.vim.OpaqueNetworkTargetInfo): vimService.vim.OpaqueNetworkTargetInfo;
         };
         ArrayOfOpaqueNetworkTargetInfo: {
            (options?: vimService.vim.ArrayOfOpaqueNetworkTargetInfo): vimService.vim.ArrayOfOpaqueNetworkTargetInfo;
         };
         VirtualMachineParallelInfo: {
            (options?: vimService.vim.VirtualMachineParallelInfo): vimService.vim.VirtualMachineParallelInfo;
         };
         ArrayOfVirtualMachineParallelInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineParallelInfo): vimService.vim.ArrayOfVirtualMachineParallelInfo;
         };
         VirtualMachinePciPassthroughInfo: {
            (options?: vimService.vim.VirtualMachinePciPassthroughInfo): vimService.vim.VirtualMachinePciPassthroughInfo;
         };
         ArrayOfVirtualMachinePciPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachinePciPassthroughInfo): vimService.vim.ArrayOfVirtualMachinePciPassthroughInfo;
         };
         VirtualMachinePciSharedGpuPassthroughInfo: {
            (options?: vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo): vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo;
         };
         ArrayOfVirtualMachinePciSharedGpuPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachinePciSharedGpuPassthroughInfo): vimService.vim.ArrayOfVirtualMachinePciSharedGpuPassthroughInfo;
         };
         VirtualMachineProfileRawData: {
            (options?: vimService.vim.VirtualMachineProfileRawData): vimService.vim.VirtualMachineProfileRawData;
         };
         VirtualMachineProfileSpec: {
            (options?: vimService.vim.VirtualMachineProfileSpec): vimService.vim.VirtualMachineProfileSpec;
         };
         ArrayOfVirtualMachineProfileSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineProfileSpec): vimService.vim.ArrayOfVirtualMachineProfileSpec;
         };
         VirtualMachineQuestionInfo: {
            (options?: vimService.vim.VirtualMachineQuestionInfo): vimService.vim.VirtualMachineQuestionInfo;
         };
         VirtualMachineRelocateTransformation: {
            "flat": string;
            "sparse": string;
         };
         VirtualMachineRelocateSpecDiskLocator: {
            (options?: vimService.vim.VirtualMachineRelocateSpecDiskLocator): vimService.vim.VirtualMachineRelocateSpecDiskLocator;
         };
         ArrayOfVirtualMachineRelocateSpecDiskLocator: {
            (options?: vimService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator): vimService.vim.ArrayOfVirtualMachineRelocateSpecDiskLocator;
         };
         VirtualMachineRelocateDiskMoveOptions: {
            "moveAllDiskBackingsAndAllowSharing": string;
            "moveAllDiskBackingsAndDisallowSharing": string;
            "moveChildMostDiskBacking": string;
            "createNewChildDiskBacking": string;
            "moveAllDiskBackingsAndConsolidate": string;
         };
         VirtualMachineRelocateSpec: {
            (options?: vimService.vim.VirtualMachineRelocateSpec): vimService.vim.VirtualMachineRelocateSpec;
         };
         ReplicationInfoDiskSettings: {
            (options?: vimService.vim.ReplicationInfoDiskSettings): vimService.vim.ReplicationInfoDiskSettings;
         };
         ArrayOfReplicationInfoDiskSettings: {
            (options?: vimService.vim.ArrayOfReplicationInfoDiskSettings): vimService.vim.ArrayOfReplicationInfoDiskSettings;
         };
         ReplicationConfigSpec: {
            (options?: vimService.vim.ReplicationConfigSpec): vimService.vim.ReplicationConfigSpec;
         };
         VirtualMachineRuntimeInfoDasProtectionState: {
            (options?: vimService.vim.VirtualMachineRuntimeInfoDasProtectionState): vimService.vim.VirtualMachineRuntimeInfoDasProtectionState;
         };
         VirtualMachineRuntimeInfo: {
            (options?: vimService.vim.VirtualMachineRuntimeInfo): vimService.vim.VirtualMachineRuntimeInfo;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradePolicy: {
            "never": string;
            "onSoftPowerOff": string;
            "always": string;
         };
         ScheduledHardwareUpgradeInfoHardwareUpgradeStatus: {
            "none": string;
            "pending": string;
            "success": string;
            "failed": string;
         };
         ScheduledHardwareUpgradeInfo: {
            (options?: vimService.vim.ScheduledHardwareUpgradeInfo): vimService.vim.ScheduledHardwareUpgradeInfo;
         };
         VirtualMachineScsiDiskDeviceInfo: {
            (options?: vimService.vim.VirtualMachineScsiDiskDeviceInfo): vimService.vim.VirtualMachineScsiDiskDeviceInfo;
         };
         ArrayOfVirtualMachineScsiDiskDeviceInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo): vimService.vim.ArrayOfVirtualMachineScsiDiskDeviceInfo;
         };
         VirtualMachineScsiPassthroughType: {
            "disk": string;
            "tape": string;
            "printer": string;
            "processor": string;
            "worm": string;
            "cdrom": string;
            "scanner": string;
            "optical": string;
            "media": string;
            "com": string;
            "raid": string;
            "unknown": string;
         };
         VirtualMachineScsiPassthroughInfo: {
            (options?: vimService.vim.VirtualMachineScsiPassthroughInfo): vimService.vim.VirtualMachineScsiPassthroughInfo;
         };
         ArrayOfVirtualMachineScsiPassthroughInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineScsiPassthroughInfo): vimService.vim.ArrayOfVirtualMachineScsiPassthroughInfo;
         };
         VirtualMachineSerialInfo: {
            (options?: vimService.vim.VirtualMachineSerialInfo): vimService.vim.VirtualMachineSerialInfo;
         };
         ArrayOfVirtualMachineSerialInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSerialInfo): vimService.vim.ArrayOfVirtualMachineSerialInfo;
         };
         VirtualMachineSnapshotInfo: {
            (options?: vimService.vim.VirtualMachineSnapshotInfo): vimService.vim.VirtualMachineSnapshotInfo;
         };
         VirtualMachineSnapshotTree: {
            (options?: vimService.vim.VirtualMachineSnapshotTree): vimService.vim.VirtualMachineSnapshotTree;
         };
         ArrayOfVirtualMachineSnapshotTree: {
            (options?: vimService.vim.ArrayOfVirtualMachineSnapshotTree): vimService.vim.ArrayOfVirtualMachineSnapshotTree;
         };
         VirtualMachineSoundInfo: {
            (options?: vimService.vim.VirtualMachineSoundInfo): vimService.vim.VirtualMachineSoundInfo;
         };
         ArrayOfVirtualMachineSoundInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSoundInfo): vimService.vim.ArrayOfVirtualMachineSoundInfo;
         };
         VirtualMachineSriovInfo: {
            (options?: vimService.vim.VirtualMachineSriovInfo): vimService.vim.VirtualMachineSriovInfo;
         };
         ArrayOfVirtualMachineSriovInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineSriovInfo): vimService.vim.ArrayOfVirtualMachineSriovInfo;
         };
         VirtualMachineUsageOnDatastore: {
            (options?: vimService.vim.VirtualMachineUsageOnDatastore): vimService.vim.VirtualMachineUsageOnDatastore;
         };
         ArrayOfVirtualMachineUsageOnDatastore: {
            (options?: vimService.vim.ArrayOfVirtualMachineUsageOnDatastore): vimService.vim.ArrayOfVirtualMachineUsageOnDatastore;
         };
         VirtualMachineStorageInfo: {
            (options?: vimService.vim.VirtualMachineStorageInfo): vimService.vim.VirtualMachineStorageInfo;
         };
         VirtualMachineConfigSummary: {
            (options?: vimService.vim.VirtualMachineConfigSummary): vimService.vim.VirtualMachineConfigSummary;
         };
         VirtualMachineQuickStats: {
            (options?: vimService.vim.VirtualMachineQuickStats): vimService.vim.VirtualMachineQuickStats;
         };
         VirtualMachineGuestSummary: {
            (options?: vimService.vim.VirtualMachineGuestSummary): vimService.vim.VirtualMachineGuestSummary;
         };
         VirtualMachineStorageSummary: {
            (options?: vimService.vim.VirtualMachineStorageSummary): vimService.vim.VirtualMachineStorageSummary;
         };
         VirtualMachineSummary: {
            (options?: vimService.vim.VirtualMachineSummary): vimService.vim.VirtualMachineSummary;
         };
         ArrayOfVirtualMachineSummary: {
            (options?: vimService.vim.ArrayOfVirtualMachineSummary): vimService.vim.ArrayOfVirtualMachineSummary;
         };
         VirtualMachineTargetInfoConfigurationTag: {
            "compliant": string;
            "clusterWide": string;
         };
         VirtualMachineTargetInfo: {
            (options?: vimService.vim.VirtualMachineTargetInfo): vimService.vim.VirtualMachineTargetInfo;
         };
         UpgradePolicy: {
            "manual": string;
            "upgradeAtPowerCycle": string;
         };
         ToolsConfigInfoToolsLastInstallInfo: {
            (options?: vimService.vim.ToolsConfigInfoToolsLastInstallInfo): vimService.vim.ToolsConfigInfoToolsLastInstallInfo;
         };
         ToolsConfigInfo: {
            (options?: vimService.vim.ToolsConfigInfo): vimService.vim.ToolsConfigInfo;
         };
         VirtualMachineUsbInfoSpeed: {
            "low": string;
            "full": string;
            "high": string;
            "superSpeed": string;
            "unknownSpeed": string;
         };
         VirtualMachineUsbInfoFamily: {
            "audio": string;
            "hid": string;
            "hid_bootable": string;
            "physical": string;
            "communication": string;
            "imaging": string;
            "printer": string;
            "storage": string;
            "hub": string;
            "smart_card": string;
            "security": string;
            "video": string;
            "wireless": string;
            "bluetooth": string;
            "wusb": string;
            "pda": string;
            "vendor_specific": string;
            "other": string;
            "unknownFamily": string;
         };
         VirtualMachineUsbInfo: {
            (options?: vimService.vim.VirtualMachineUsbInfo): vimService.vim.VirtualMachineUsbInfo;
         };
         ArrayOfVirtualMachineUsbInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineUsbInfo): vimService.vim.ArrayOfVirtualMachineUsbInfo;
         };
         VirtualMachineVFlashModuleInfo: {
            (options?: vimService.vim.VirtualMachineVFlashModuleInfo): vimService.vim.VirtualMachineVFlashModuleInfo;
         };
         ArrayOfVirtualMachineVFlashModuleInfo: {
            (options?: vimService.vim.ArrayOfVirtualMachineVFlashModuleInfo): vimService.vim.ArrayOfVirtualMachineVFlashModuleInfo;
         };
         VirtualHardware: {
            (options?: vimService.vim.VirtualHardware): vimService.vim.VirtualHardware;
         };
         VirtualHardwareOption: {
            (options?: vimService.vim.VirtualHardwareOption): vimService.vim.VirtualHardwareOption;
         };
         VirtualMachineImportSpec: {
            (options?: vimService.vim.VirtualMachineImportSpec): vimService.vim.VirtualMachineImportSpec;
         };
         CheckResult: {
            (options?: vimService.vim.CheckResult): vimService.vim.CheckResult;
         };
         ArrayOfCheckResult: {
            (options?: vimService.vim.ArrayOfCheckResult): vimService.vim.ArrayOfCheckResult;
         };
         CheckTestType: {
            "sourceTests": string;
            "hostTests": string;
            "resourcePoolTests": string;
            "datastoreTests": string;
            "networkTests": string;
         };
         CustomizationIPSettingsIpV6AddressSpec: {
            (options?: vimService.vim.CustomizationIPSettingsIpV6AddressSpec): vimService.vim.CustomizationIPSettingsIpV6AddressSpec;
         };
         CustomizationNetBIOSMode: {
            "enableNetBIOSViaDhcp": string;
            "enableNetBIOS": string;
            "disableNetBIOS": string;
         };
         CustomizationIPSettings: {
            (options?: vimService.vim.CustomizationIPSettings): vimService.vim.CustomizationIPSettings;
         };
         CustomizationSpec: {
            (options?: vimService.vim.CustomizationSpec): vimService.vim.CustomizationSpec;
         };
         CustomizationName: {
            (options?: vimService.vim.CustomizationName): vimService.vim.CustomizationName;
         };
         CustomizationFixedName: {
            (options?: vimService.vim.CustomizationFixedName): vimService.vim.CustomizationFixedName;
         };
         CustomizationPrefixName: {
            (options?: vimService.vim.CustomizationPrefixName): vimService.vim.CustomizationPrefixName;
         };
         CustomizationVirtualMachineName: {
            (options?: vimService.vim.CustomizationVirtualMachineName): vimService.vim.CustomizationVirtualMachineName;
         };
         CustomizationUnknownName: {
            (options?: vimService.vim.CustomizationUnknownName): vimService.vim.CustomizationUnknownName;
         };
         CustomizationCustomName: {
            (options?: vimService.vim.CustomizationCustomName): vimService.vim.CustomizationCustomName;
         };
         CustomizationPassword: {
            (options?: vimService.vim.CustomizationPassword): vimService.vim.CustomizationPassword;
         };
         CustomizationOptions: {
            (options?: vimService.vim.CustomizationOptions): vimService.vim.CustomizationOptions;
         };
         CustomizationSysprepRebootOption: {
            "reboot": string;
            "noreboot": string;
            "shutdown": string;
         };
         CustomizationWinOptions: {
            (options?: vimService.vim.CustomizationWinOptions): vimService.vim.CustomizationWinOptions;
         };
         CustomizationLinuxOptions: {
            (options?: vimService.vim.CustomizationLinuxOptions): vimService.vim.CustomizationLinuxOptions;
         };
         CustomizationGuiUnattended: {
            (options?: vimService.vim.CustomizationGuiUnattended): vimService.vim.CustomizationGuiUnattended;
         };
         CustomizationUserData: {
            (options?: vimService.vim.CustomizationUserData): vimService.vim.CustomizationUserData;
         };
         CustomizationGuiRunOnce: {
            (options?: vimService.vim.CustomizationGuiRunOnce): vimService.vim.CustomizationGuiRunOnce;
         };
         CustomizationIdentification: {
            (options?: vimService.vim.CustomizationIdentification): vimService.vim.CustomizationIdentification;
         };
         CustomizationLicenseDataMode: {
            "perServer": string;
            "perSeat": string;
         };
         CustomizationLicenseFilePrintData: {
            (options?: vimService.vim.CustomizationLicenseFilePrintData): vimService.vim.CustomizationLicenseFilePrintData;
         };
         CustomizationIdentitySettings: {
            (options?: vimService.vim.CustomizationIdentitySettings): vimService.vim.CustomizationIdentitySettings;
         };
         CustomizationSysprepText: {
            (options?: vimService.vim.CustomizationSysprepText): vimService.vim.CustomizationSysprepText;
         };
         CustomizationSysprep: {
            (options?: vimService.vim.CustomizationSysprep): vimService.vim.CustomizationSysprep;
         };
         CustomizationLinuxPrep: {
            (options?: vimService.vim.CustomizationLinuxPrep): vimService.vim.CustomizationLinuxPrep;
         };
         CustomizationGlobalIPSettings: {
            (options?: vimService.vim.CustomizationGlobalIPSettings): vimService.vim.CustomizationGlobalIPSettings;
         };
         CustomizationIpGenerator: {
            (options?: vimService.vim.CustomizationIpGenerator): vimService.vim.CustomizationIpGenerator;
         };
         CustomizationDhcpIpGenerator: {
            (options?: vimService.vim.CustomizationDhcpIpGenerator): vimService.vim.CustomizationDhcpIpGenerator;
         };
         CustomizationFixedIp: {
            (options?: vimService.vim.CustomizationFixedIp): vimService.vim.CustomizationFixedIp;
         };
         CustomizationUnknownIpGenerator: {
            (options?: vimService.vim.CustomizationUnknownIpGenerator): vimService.vim.CustomizationUnknownIpGenerator;
         };
         CustomizationCustomIpGenerator: {
            (options?: vimService.vim.CustomizationCustomIpGenerator): vimService.vim.CustomizationCustomIpGenerator;
         };
         CustomizationIpV6Generator: {
            (options?: vimService.vim.CustomizationIpV6Generator): vimService.vim.CustomizationIpV6Generator;
         };
         ArrayOfCustomizationIpV6Generator: {
            (options?: vimService.vim.ArrayOfCustomizationIpV6Generator): vimService.vim.ArrayOfCustomizationIpV6Generator;
         };
         CustomizationDhcpIpV6Generator: {
            (options?: vimService.vim.CustomizationDhcpIpV6Generator): vimService.vim.CustomizationDhcpIpV6Generator;
         };
         CustomizationStatelessIpV6Generator: {
            (options?: vimService.vim.CustomizationStatelessIpV6Generator): vimService.vim.CustomizationStatelessIpV6Generator;
         };
         CustomizationFixedIpV6: {
            (options?: vimService.vim.CustomizationFixedIpV6): vimService.vim.CustomizationFixedIpV6;
         };
         CustomizationAutoIpV6Generator: {
            (options?: vimService.vim.CustomizationAutoIpV6Generator): vimService.vim.CustomizationAutoIpV6Generator;
         };
         CustomizationUnknownIpV6Generator: {
            (options?: vimService.vim.CustomizationUnknownIpV6Generator): vimService.vim.CustomizationUnknownIpV6Generator;
         };
         CustomizationCustomIpV6Generator: {
            (options?: vimService.vim.CustomizationCustomIpV6Generator): vimService.vim.CustomizationCustomIpV6Generator;
         };
         CustomizationAdapterMapping: {
            (options?: vimService.vim.CustomizationAdapterMapping): vimService.vim.CustomizationAdapterMapping;
         };
         ArrayOfCustomizationAdapterMapping: {
            (options?: vimService.vim.ArrayOfCustomizationAdapterMapping): vimService.vim.ArrayOfCustomizationAdapterMapping;
         };
         HostDiskMappingPartitionInfo: {
            (options?: vimService.vim.HostDiskMappingPartitionInfo): vimService.vim.HostDiskMappingPartitionInfo;
         };
         HostDiskMappingInfo: {
            (options?: vimService.vim.HostDiskMappingInfo): vimService.vim.HostDiskMappingInfo;
         };
         HostDiskMappingPartitionOption: {
            (options?: vimService.vim.HostDiskMappingPartitionOption): vimService.vim.HostDiskMappingPartitionOption;
         };
         ArrayOfHostDiskMappingPartitionOption: {
            (options?: vimService.vim.ArrayOfHostDiskMappingPartitionOption): vimService.vim.ArrayOfHostDiskMappingPartitionOption;
         };
         HostDiskMappingOption: {
            (options?: vimService.vim.HostDiskMappingOption): vimService.vim.HostDiskMappingOption;
         };
         ParaVirtualSCSIController: {
            (options?: vimService.vim.ParaVirtualSCSIController): vimService.vim.ParaVirtualSCSIController;
         };
         ParaVirtualSCSIControllerOption: {
            (options?: vimService.vim.ParaVirtualSCSIControllerOption): vimService.vim.ParaVirtualSCSIControllerOption;
         };
         VirtualAHCIController: {
            (options?: vimService.vim.VirtualAHCIController): vimService.vim.VirtualAHCIController;
         };
         VirtualAHCIControllerOption: {
            (options?: vimService.vim.VirtualAHCIControllerOption): vimService.vim.VirtualAHCIControllerOption;
         };
         VirtualBusLogicController: {
            (options?: vimService.vim.VirtualBusLogicController): vimService.vim.VirtualBusLogicController;
         };
         VirtualBusLogicControllerOption: {
            (options?: vimService.vim.VirtualBusLogicControllerOption): vimService.vim.VirtualBusLogicControllerOption;
         };
         VirtualCdromIsoBackingInfo: {
            (options?: vimService.vim.VirtualCdromIsoBackingInfo): vimService.vim.VirtualCdromIsoBackingInfo;
         };
         VirtualCdromPassthroughBackingInfo: {
            (options?: vimService.vim.VirtualCdromPassthroughBackingInfo): vimService.vim.VirtualCdromPassthroughBackingInfo;
         };
         VirtualCdromRemotePassthroughBackingInfo: {
            (options?: vimService.vim.VirtualCdromRemotePassthroughBackingInfo): vimService.vim.VirtualCdromRemotePassthroughBackingInfo;
         };
         VirtualCdromAtapiBackingInfo: {
            (options?: vimService.vim.VirtualCdromAtapiBackingInfo): vimService.vim.VirtualCdromAtapiBackingInfo;
         };
         VirtualCdromRemoteAtapiBackingInfo: {
            (options?: vimService.vim.VirtualCdromRemoteAtapiBackingInfo): vimService.vim.VirtualCdromRemoteAtapiBackingInfo;
         };
         VirtualCdrom: {
            (options?: vimService.vim.VirtualCdrom): vimService.vim.VirtualCdrom;
         };
         VirtualCdromIsoBackingOption: {
            (options?: vimService.vim.VirtualCdromIsoBackingOption): vimService.vim.VirtualCdromIsoBackingOption;
         };
         VirtualCdromPassthroughBackingOption: {
            (options?: vimService.vim.VirtualCdromPassthroughBackingOption): vimService.vim.VirtualCdromPassthroughBackingOption;
         };
         VirtualCdromRemotePassthroughBackingOption: {
            (options?: vimService.vim.VirtualCdromRemotePassthroughBackingOption): vimService.vim.VirtualCdromRemotePassthroughBackingOption;
         };
         VirtualCdromAtapiBackingOption: {
            (options?: vimService.vim.VirtualCdromAtapiBackingOption): vimService.vim.VirtualCdromAtapiBackingOption;
         };
         VirtualCdromRemoteAtapiBackingOption: {
            (options?: vimService.vim.VirtualCdromRemoteAtapiBackingOption): vimService.vim.VirtualCdromRemoteAtapiBackingOption;
         };
         VirtualCdromOption: {
            (options?: vimService.vim.VirtualCdromOption): vimService.vim.VirtualCdromOption;
         };
         VirtualController: {
            (options?: vimService.vim.VirtualController): vimService.vim.VirtualController;
         };
         VirtualControllerOption: {
            (options?: vimService.vim.VirtualControllerOption): vimService.vim.VirtualControllerOption;
         };
         VirtualDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceBackingInfo): vimService.vim.VirtualDeviceBackingInfo;
         };
         VirtualDeviceFileBackingInfo: {
            (options?: vimService.vim.VirtualDeviceFileBackingInfo): vimService.vim.VirtualDeviceFileBackingInfo;
         };
         VirtualDeviceDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceDeviceBackingInfo): vimService.vim.VirtualDeviceDeviceBackingInfo;
         };
         VirtualDeviceRemoteDeviceBackingInfo: {
            (options?: vimService.vim.VirtualDeviceRemoteDeviceBackingInfo): vimService.vim.VirtualDeviceRemoteDeviceBackingInfo;
         };
         VirtualDevicePipeBackingInfo: {
            (options?: vimService.vim.VirtualDevicePipeBackingInfo): vimService.vim.VirtualDevicePipeBackingInfo;
         };
         VirtualDeviceURIBackingInfo: {
            (options?: vimService.vim.VirtualDeviceURIBackingInfo): vimService.vim.VirtualDeviceURIBackingInfo;
         };
         VirtualDeviceConnectInfoStatus: {
            "ok": string;
            "recoverableError": string;
            "unrecoverableError": string;
            "untried": string;
         };
         VirtualDeviceConnectInfo: {
            (options?: vimService.vim.VirtualDeviceConnectInfo): vimService.vim.VirtualDeviceConnectInfo;
         };
         VirtualDeviceBusSlotInfo: {
            (options?: vimService.vim.VirtualDeviceBusSlotInfo): vimService.vim.VirtualDeviceBusSlotInfo;
         };
         VirtualDevicePciBusSlotInfo: {
            (options?: vimService.vim.VirtualDevicePciBusSlotInfo): vimService.vim.VirtualDevicePciBusSlotInfo;
         };
         VirtualDevice: {
            (options?: vimService.vim.VirtualDevice): vimService.vim.VirtualDevice;
         };
         ArrayOfVirtualDevice: {
            (options?: vimService.vim.ArrayOfVirtualDevice): vimService.vim.ArrayOfVirtualDevice;
         };
         VirtualDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceBackingOption): vimService.vim.VirtualDeviceBackingOption;
         };
         ArrayOfVirtualDeviceBackingOption: {
            (options?: vimService.vim.ArrayOfVirtualDeviceBackingOption): vimService.vim.ArrayOfVirtualDeviceBackingOption;
         };
         VirtualDeviceFileExtension: {
            "iso": string;
            "flp": string;
            "vmdk": string;
            "dsk": string;
            "rdm": string;
         };
         VirtualDeviceFileBackingOption: {
            (options?: vimService.vim.VirtualDeviceFileBackingOption): vimService.vim.VirtualDeviceFileBackingOption;
         };
         VirtualDeviceDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceDeviceBackingOption): vimService.vim.VirtualDeviceDeviceBackingOption;
         };
         VirtualDeviceRemoteDeviceBackingOption: {
            (options?: vimService.vim.VirtualDeviceRemoteDeviceBackingOption): vimService.vim.VirtualDeviceRemoteDeviceBackingOption;
         };
         VirtualDevicePipeBackingOption: {
            (options?: vimService.vim.VirtualDevicePipeBackingOption): vimService.vim.VirtualDevicePipeBackingOption;
         };
         VirtualDeviceURIBackingOptionDirection: {
            "server": string;
            "client": string;
         };
         VirtualDeviceURIBackingOption: {
            (options?: vimService.vim.VirtualDeviceURIBackingOption): vimService.vim.VirtualDeviceURIBackingOption;
         };
         VirtualDeviceConnectOption: {
            (options?: vimService.vim.VirtualDeviceConnectOption): vimService.vim.VirtualDeviceConnectOption;
         };
         VirtualDeviceBusSlotOption: {
            (options?: vimService.vim.VirtualDeviceBusSlotOption): vimService.vim.VirtualDeviceBusSlotOption;
         };
         VirtualDeviceOption: {
            (options?: vimService.vim.VirtualDeviceOption): vimService.vim.VirtualDeviceOption;
         };
         ArrayOfVirtualDeviceOption: {
            (options?: vimService.vim.ArrayOfVirtualDeviceOption): vimService.vim.ArrayOfVirtualDeviceOption;
         };
         VirtualDeviceConfigSpecOperation: {
            "add": string;
            "remove": string;
            "edit": string;
         };
         VirtualDeviceConfigSpecFileOperation: {
            "create": string;
            "destroy": string;
            "replace": string;
         };
         VirtualDeviceConfigSpec: {
            (options?: vimService.vim.VirtualDeviceConfigSpec): vimService.vim.VirtualDeviceConfigSpec;
         };
         ArrayOfVirtualDeviceConfigSpec: {
            (options?: vimService.vim.ArrayOfVirtualDeviceConfigSpec): vimService.vim.ArrayOfVirtualDeviceConfigSpec;
         };
         VirtualDiskDeltaDiskFormat: {
            "redoLogFormat": string;
            "nativeFormat": string;
            "seSparseFormat": string;
         };
         VirtualDiskDeltaDiskFormatVariant: {
            "vmfsSparseVariant": string;
            "vsanSparseVariant": string;
         };
         VirtualDiskSharing: {
            "sharingNone": string;
            "sharingMultiWriter": string;
         };
         VirtualDiskSparseVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskSparseVer1BackingInfo): vimService.vim.VirtualDiskSparseVer1BackingInfo;
         };
         VirtualDiskSparseVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskSparseVer2BackingInfo): vimService.vim.VirtualDiskSparseVer2BackingInfo;
         };
         VirtualDiskFlatVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskFlatVer1BackingInfo): vimService.vim.VirtualDiskFlatVer1BackingInfo;
         };
         VirtualDiskFlatVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskFlatVer2BackingInfo): vimService.vim.VirtualDiskFlatVer2BackingInfo;
         };
         VirtualDiskSeSparseBackingInfo: {
            (options?: vimService.vim.VirtualDiskSeSparseBackingInfo): vimService.vim.VirtualDiskSeSparseBackingInfo;
         };
         VirtualDiskRawDiskVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskRawDiskVer2BackingInfo): vimService.vim.VirtualDiskRawDiskVer2BackingInfo;
         };
         VirtualDiskPartitionedRawDiskVer2BackingInfo: {
            (options?: vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo): vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingInfo;
         };
         VirtualDiskRawDiskMappingVer1BackingInfo: {
            (options?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo): vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
         };
         VirtualDiskVFlashCacheConfigInfoCacheConsistencyType: {
            "strong": string;
            "weak": string;
         };
         VirtualDiskVFlashCacheConfigInfoCacheMode: {
            "write_thru": string;
            "write_back": string;
         };
         VirtualDiskVFlashCacheConfigInfo: {
            (options?: vimService.vim.VirtualDiskVFlashCacheConfigInfo): vimService.vim.VirtualDiskVFlashCacheConfigInfo;
         };
         VirtualDisk: {
            (options?: vimService.vim.VirtualDisk): vimService.vim.VirtualDisk;
         };
         ArrayOfVirtualDisk: {
            (options?: vimService.vim.ArrayOfVirtualDisk): vimService.vim.ArrayOfVirtualDisk;
         };
         VirtualDiskId: {
            (options?: vimService.vim.VirtualDiskId): vimService.vim.VirtualDiskId;
         };
         ArrayOfVirtualDiskId: {
            (options?: vimService.vim.ArrayOfVirtualDiskId): vimService.vim.ArrayOfVirtualDiskId;
         };
         VirtualDiskMode: {
            "persistent": string;
            "nonpersistent": string;
            "undoable": string;
            "independent_persistent": string;
            "independent_nonpersistent": string;
            "append": string;
         };
         VirtualDiskCompatibilityMode: {
            "virtualMode": string;
            "physicalMode": string;
         };
         VirtualDiskSparseVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskSparseVer1BackingOption): vimService.vim.VirtualDiskSparseVer1BackingOption;
         };
         VirtualDiskSparseVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskSparseVer2BackingOption): vimService.vim.VirtualDiskSparseVer2BackingOption;
         };
         VirtualDiskFlatVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskFlatVer1BackingOption): vimService.vim.VirtualDiskFlatVer1BackingOption;
         };
         VirtualDiskDeltaDiskFormatsSupported: {
            (options?: vimService.vim.VirtualDiskDeltaDiskFormatsSupported): vimService.vim.VirtualDiskDeltaDiskFormatsSupported;
         };
         ArrayOfVirtualDiskDeltaDiskFormatsSupported: {
            (options?: vimService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported): vimService.vim.ArrayOfVirtualDiskDeltaDiskFormatsSupported;
         };
         VirtualDiskFlatVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskFlatVer2BackingOption): vimService.vim.VirtualDiskFlatVer2BackingOption;
         };
         VirtualDiskSeSparseBackingOption: {
            (options?: vimService.vim.VirtualDiskSeSparseBackingOption): vimService.vim.VirtualDiskSeSparseBackingOption;
         };
         VirtualDiskRawDiskVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskRawDiskVer2BackingOption): vimService.vim.VirtualDiskRawDiskVer2BackingOption;
         };
         VirtualDiskPartitionedRawDiskVer2BackingOption: {
            (options?: vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption): vimService.vim.VirtualDiskPartitionedRawDiskVer2BackingOption;
         };
         VirtualDiskRawDiskMappingVer1BackingOption: {
            (options?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingOption): vimService.vim.VirtualDiskRawDiskMappingVer1BackingOption;
         };
         VirtualDiskOptionVFlashCacheConfigOption: {
            (options?: vimService.vim.VirtualDiskOptionVFlashCacheConfigOption): vimService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         };
         VirtualDiskOption: {
            (options?: vimService.vim.VirtualDiskOption): vimService.vim.VirtualDiskOption;
         };
         VirtualDiskConfigSpec: {
            (options?: vimService.vim.VirtualDiskConfigSpec): vimService.vim.VirtualDiskConfigSpec;
         };
         VirtualE1000: {
            (options?: vimService.vim.VirtualE1000): vimService.vim.VirtualE1000;
         };
         VirtualE1000Option: {
            (options?: vimService.vim.VirtualE1000Option): vimService.vim.VirtualE1000Option;
         };
         VirtualE1000e: {
            (options?: vimService.vim.VirtualE1000e): vimService.vim.VirtualE1000e;
         };
         VirtualE1000eOption: {
            (options?: vimService.vim.VirtualE1000eOption): vimService.vim.VirtualE1000eOption;
         };
         VirtualEnsoniq1371: {
            (options?: vimService.vim.VirtualEnsoniq1371): vimService.vim.VirtualEnsoniq1371;
         };
         VirtualEnsoniq1371Option: {
            (options?: vimService.vim.VirtualEnsoniq1371Option): vimService.vim.VirtualEnsoniq1371Option;
         };
         VirtualEthernetCardNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardNetworkBackingInfo): vimService.vim.VirtualEthernetCardNetworkBackingInfo;
         };
         VirtualEthernetCardLegacyNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardLegacyNetworkBackingInfo): vimService.vim.VirtualEthernetCardLegacyNetworkBackingInfo;
         };
         VirtualEthernetCardDistributedVirtualPortBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo): vimService.vim.VirtualEthernetCardDistributedVirtualPortBackingInfo;
         };
         VirtualEthernetCardOpaqueNetworkBackingInfo: {
            (options?: vimService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo): vimService.vim.VirtualEthernetCardOpaqueNetworkBackingInfo;
         };
         VirtualEthernetCardResourceAllocation: {
            (options?: vimService.vim.VirtualEthernetCardResourceAllocation): vimService.vim.VirtualEthernetCardResourceAllocation;
         };
         VirtualEthernetCard: {
            (options?: vimService.vim.VirtualEthernetCard): vimService.vim.VirtualEthernetCard;
         };
         VirtualEthernetCardNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardNetworkBackingOption): vimService.vim.VirtualEthernetCardNetworkBackingOption;
         };
         VirtualEthernetCardOpaqueNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardOpaqueNetworkBackingOption): vimService.vim.VirtualEthernetCardOpaqueNetworkBackingOption;
         };
         VirtualEthernetCardLegacyNetworkDeviceName: {
            "bridged": string;
            "nat": string;
            "hostonly": string;
         };
         VirtualEthernetCardLegacyNetworkBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardLegacyNetworkBackingOption): vimService.vim.VirtualEthernetCardLegacyNetworkBackingOption;
         };
         VirtualEthernetCardDVPortBackingOption: {
            (options?: vimService.vim.VirtualEthernetCardDVPortBackingOption): vimService.vim.VirtualEthernetCardDVPortBackingOption;
         };
         VirtualEthernetCardMacType: {
            "manual": string;
            "generated": string;
            "assigned": string;
         };
         VirtualEthernetCardOption: {
            (options?: vimService.vim.VirtualEthernetCardOption): vimService.vim.VirtualEthernetCardOption;
         };
         VirtualFloppyImageBackingInfo: {
            (options?: vimService.vim.VirtualFloppyImageBackingInfo): vimService.vim.VirtualFloppyImageBackingInfo;
         };
         VirtualFloppyDeviceBackingInfo: {
            (options?: vimService.vim.VirtualFloppyDeviceBackingInfo): vimService.vim.VirtualFloppyDeviceBackingInfo;
         };
         VirtualFloppyRemoteDeviceBackingInfo: {
            (options?: vimService.vim.VirtualFloppyRemoteDeviceBackingInfo): vimService.vim.VirtualFloppyRemoteDeviceBackingInfo;
         };
         VirtualFloppy: {
            (options?: vimService.vim.VirtualFloppy): vimService.vim.VirtualFloppy;
         };
         VirtualFloppyImageBackingOption: {
            (options?: vimService.vim.VirtualFloppyImageBackingOption): vimService.vim.VirtualFloppyImageBackingOption;
         };
         VirtualFloppyDeviceBackingOption: {
            (options?: vimService.vim.VirtualFloppyDeviceBackingOption): vimService.vim.VirtualFloppyDeviceBackingOption;
         };
         VirtualFloppyRemoteDeviceBackingOption: {
            (options?: vimService.vim.VirtualFloppyRemoteDeviceBackingOption): vimService.vim.VirtualFloppyRemoteDeviceBackingOption;
         };
         VirtualFloppyOption: {
            (options?: vimService.vim.VirtualFloppyOption): vimService.vim.VirtualFloppyOption;
         };
         VirtualHdAudioCard: {
            (options?: vimService.vim.VirtualHdAudioCard): vimService.vim.VirtualHdAudioCard;
         };
         VirtualHdAudioCardOption: {
            (options?: vimService.vim.VirtualHdAudioCardOption): vimService.vim.VirtualHdAudioCardOption;
         };
         VirtualIDEController: {
            (options?: vimService.vim.VirtualIDEController): vimService.vim.VirtualIDEController;
         };
         VirtualIDEControllerOption: {
            (options?: vimService.vim.VirtualIDEControllerOption): vimService.vim.VirtualIDEControllerOption;
         };
         VirtualKeyboard: {
            (options?: vimService.vim.VirtualKeyboard): vimService.vim.VirtualKeyboard;
         };
         VirtualKeyboardOption: {
            (options?: vimService.vim.VirtualKeyboardOption): vimService.vim.VirtualKeyboardOption;
         };
         VirtualLsiLogicController: {
            (options?: vimService.vim.VirtualLsiLogicController): vimService.vim.VirtualLsiLogicController;
         };
         VirtualLsiLogicControllerOption: {
            (options?: vimService.vim.VirtualLsiLogicControllerOption): vimService.vim.VirtualLsiLogicControllerOption;
         };
         VirtualLsiLogicSASController: {
            (options?: vimService.vim.VirtualLsiLogicSASController): vimService.vim.VirtualLsiLogicSASController;
         };
         VirtualLsiLogicSASControllerOption: {
            (options?: vimService.vim.VirtualLsiLogicSASControllerOption): vimService.vim.VirtualLsiLogicSASControllerOption;
         };
         VirtualPCIController: {
            (options?: vimService.vim.VirtualPCIController): vimService.vim.VirtualPCIController;
         };
         VirtualPCIControllerOption: {
            (options?: vimService.vim.VirtualPCIControllerOption): vimService.vim.VirtualPCIControllerOption;
         };
         VirtualPCIPassthroughDeviceBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo): vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
         };
         VirtualPCIPassthroughPluginBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughPluginBackingInfo): vimService.vim.VirtualPCIPassthroughPluginBackingInfo;
         };
         VirtualPCIPassthroughVmiopBackingInfo: {
            (options?: vimService.vim.VirtualPCIPassthroughVmiopBackingInfo): vimService.vim.VirtualPCIPassthroughVmiopBackingInfo;
         };
         VirtualPCIPassthrough: {
            (options?: vimService.vim.VirtualPCIPassthrough): vimService.vim.VirtualPCIPassthrough;
         };
         VirtualPCIPassthroughDeviceBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughDeviceBackingOption): vimService.vim.VirtualPCIPassthroughDeviceBackingOption;
         };
         VirtualPCIPassthroughPluginBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughPluginBackingOption): vimService.vim.VirtualPCIPassthroughPluginBackingOption;
         };
         VirtualPCIPassthroughVmiopBackingOption: {
            (options?: vimService.vim.VirtualPCIPassthroughVmiopBackingOption): vimService.vim.VirtualPCIPassthroughVmiopBackingOption;
         };
         VirtualPCIPassthroughOption: {
            (options?: vimService.vim.VirtualPCIPassthroughOption): vimService.vim.VirtualPCIPassthroughOption;
         };
         VirtualPCNet32: {
            (options?: vimService.vim.VirtualPCNet32): vimService.vim.VirtualPCNet32;
         };
         VirtualPCNet32Option: {
            (options?: vimService.vim.VirtualPCNet32Option): vimService.vim.VirtualPCNet32Option;
         };
         VirtualPS2Controller: {
            (options?: vimService.vim.VirtualPS2Controller): vimService.vim.VirtualPS2Controller;
         };
         VirtualPS2ControllerOption: {
            (options?: vimService.vim.VirtualPS2ControllerOption): vimService.vim.VirtualPS2ControllerOption;
         };
         VirtualParallelPortFileBackingInfo: {
            (options?: vimService.vim.VirtualParallelPortFileBackingInfo): vimService.vim.VirtualParallelPortFileBackingInfo;
         };
         VirtualParallelPortDeviceBackingInfo: {
            (options?: vimService.vim.VirtualParallelPortDeviceBackingInfo): vimService.vim.VirtualParallelPortDeviceBackingInfo;
         };
         VirtualParallelPort: {
            (options?: vimService.vim.VirtualParallelPort): vimService.vim.VirtualParallelPort;
         };
         VirtualParallelPortFileBackingOption: {
            (options?: vimService.vim.VirtualParallelPortFileBackingOption): vimService.vim.VirtualParallelPortFileBackingOption;
         };
         VirtualParallelPortDeviceBackingOption: {
            (options?: vimService.vim.VirtualParallelPortDeviceBackingOption): vimService.vim.VirtualParallelPortDeviceBackingOption;
         };
         VirtualParallelPortOption: {
            (options?: vimService.vim.VirtualParallelPortOption): vimService.vim.VirtualParallelPortOption;
         };
         VirtualPointingDeviceDeviceBackingInfo: {
            (options?: vimService.vim.VirtualPointingDeviceDeviceBackingInfo): vimService.vim.VirtualPointingDeviceDeviceBackingInfo;
         };
         VirtualPointingDevice: {
            (options?: vimService.vim.VirtualPointingDevice): vimService.vim.VirtualPointingDevice;
         };
         VirtualPointingDeviceHostChoice: {
            "autodetect": string;
            "intellimouseExplorer": string;
            "intellimousePs2": string;
            "logitechMouseman": string;
            "microsoft_serial": string;
            "mouseSystems": string;
            "mousemanSerial": string;
            "ps2": string;
         };
         VirtualPointingDeviceBackingOption: {
            (options?: vimService.vim.VirtualPointingDeviceBackingOption): vimService.vim.VirtualPointingDeviceBackingOption;
         };
         VirtualPointingDeviceOption: {
            (options?: vimService.vim.VirtualPointingDeviceOption): vimService.vim.VirtualPointingDeviceOption;
         };
         VirtualSATAController: {
            (options?: vimService.vim.VirtualSATAController): vimService.vim.VirtualSATAController;
         };
         VirtualSATAControllerOption: {
            (options?: vimService.vim.VirtualSATAControllerOption): vimService.vim.VirtualSATAControllerOption;
         };
         VirtualSCSISharing: {
            "noSharing": string;
            "virtualSharing": string;
            "physicalSharing": string;
         };
         ArrayOfVirtualSCSISharing: {
            (options?: vimService.vim.ArrayOfVirtualSCSISharing): vimService.vim.ArrayOfVirtualSCSISharing;
         };
         VirtualSCSIController: {
            (options?: vimService.vim.VirtualSCSIController): vimService.vim.VirtualSCSIController;
         };
         VirtualSCSIControllerOption: {
            (options?: vimService.vim.VirtualSCSIControllerOption): vimService.vim.VirtualSCSIControllerOption;
         };
         VirtualSCSIPassthroughDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSCSIPassthroughDeviceBackingInfo): vimService.vim.VirtualSCSIPassthroughDeviceBackingInfo;
         };
         VirtualSCSIPassthrough: {
            (options?: vimService.vim.VirtualSCSIPassthrough): vimService.vim.VirtualSCSIPassthrough;
         };
         VirtualSCSIPassthroughDeviceBackingOption: {
            (options?: vimService.vim.VirtualSCSIPassthroughDeviceBackingOption): vimService.vim.VirtualSCSIPassthroughDeviceBackingOption;
         };
         VirtualSCSIPassthroughOption: {
            (options?: vimService.vim.VirtualSCSIPassthroughOption): vimService.vim.VirtualSCSIPassthroughOption;
         };
         VirtualSIOController: {
            (options?: vimService.vim.VirtualSIOController): vimService.vim.VirtualSIOController;
         };
         VirtualSIOControllerOption: {
            (options?: vimService.vim.VirtualSIOControllerOption): vimService.vim.VirtualSIOControllerOption;
         };
         VirtualSerialPortFileBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortFileBackingInfo): vimService.vim.VirtualSerialPortFileBackingInfo;
         };
         VirtualSerialPortDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortDeviceBackingInfo): vimService.vim.VirtualSerialPortDeviceBackingInfo;
         };
         VirtualSerialPortPipeBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortPipeBackingInfo): vimService.vim.VirtualSerialPortPipeBackingInfo;
         };
         VirtualSerialPortURIBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortURIBackingInfo): vimService.vim.VirtualSerialPortURIBackingInfo;
         };
         VirtualSerialPortThinPrintBackingInfo: {
            (options?: vimService.vim.VirtualSerialPortThinPrintBackingInfo): vimService.vim.VirtualSerialPortThinPrintBackingInfo;
         };
         VirtualSerialPort: {
            (options?: vimService.vim.VirtualSerialPort): vimService.vim.VirtualSerialPort;
         };
         VirtualSerialPortEndPoint: {
            "client": string;
            "server": string;
         };
         VirtualSerialPortFileBackingOption: {
            (options?: vimService.vim.VirtualSerialPortFileBackingOption): vimService.vim.VirtualSerialPortFileBackingOption;
         };
         VirtualSerialPortDeviceBackingOption: {
            (options?: vimService.vim.VirtualSerialPortDeviceBackingOption): vimService.vim.VirtualSerialPortDeviceBackingOption;
         };
         VirtualSerialPortPipeBackingOption: {
            (options?: vimService.vim.VirtualSerialPortPipeBackingOption): vimService.vim.VirtualSerialPortPipeBackingOption;
         };
         VirtualSerialPortURIBackingOption: {
            (options?: vimService.vim.VirtualSerialPortURIBackingOption): vimService.vim.VirtualSerialPortURIBackingOption;
         };
         VirtualSerialPortThinPrintBackingOption: {
            (options?: vimService.vim.VirtualSerialPortThinPrintBackingOption): vimService.vim.VirtualSerialPortThinPrintBackingOption;
         };
         VirtualSerialPortOption: {
            (options?: vimService.vim.VirtualSerialPortOption): vimService.vim.VirtualSerialPortOption;
         };
         VirtualSoundBlaster16: {
            (options?: vimService.vim.VirtualSoundBlaster16): vimService.vim.VirtualSoundBlaster16;
         };
         VirtualSoundBlaster16Option: {
            (options?: vimService.vim.VirtualSoundBlaster16Option): vimService.vim.VirtualSoundBlaster16Option;
         };
         VirtualSoundCardDeviceBackingInfo: {
            (options?: vimService.vim.VirtualSoundCardDeviceBackingInfo): vimService.vim.VirtualSoundCardDeviceBackingInfo;
         };
         VirtualSoundCard: {
            (options?: vimService.vim.VirtualSoundCard): vimService.vim.VirtualSoundCard;
         };
         VirtualSoundCardDeviceBackingOption: {
            (options?: vimService.vim.VirtualSoundCardDeviceBackingOption): vimService.vim.VirtualSoundCardDeviceBackingOption;
         };
         VirtualSoundCardOption: {
            (options?: vimService.vim.VirtualSoundCardOption): vimService.vim.VirtualSoundCardOption;
         };
         VirtualSriovEthernetCardSriovBackingInfo: {
            (options?: vimService.vim.VirtualSriovEthernetCardSriovBackingInfo): vimService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         };
         VirtualSriovEthernetCard: {
            (options?: vimService.vim.VirtualSriovEthernetCard): vimService.vim.VirtualSriovEthernetCard;
         };
         VirtualSriovEthernetCardSriovBackingOption: {
            (options?: vimService.vim.VirtualSriovEthernetCardSriovBackingOption): vimService.vim.VirtualSriovEthernetCardSriovBackingOption;
         };
         VirtualSriovEthernetCardOption: {
            (options?: vimService.vim.VirtualSriovEthernetCardOption): vimService.vim.VirtualSriovEthernetCardOption;
         };
         VirtualUSBUSBBackingInfo: {
            (options?: vimService.vim.VirtualUSBUSBBackingInfo): vimService.vim.VirtualUSBUSBBackingInfo;
         };
         VirtualUSBRemoteHostBackingInfo: {
            (options?: vimService.vim.VirtualUSBRemoteHostBackingInfo): vimService.vim.VirtualUSBRemoteHostBackingInfo;
         };
         VirtualUSBRemoteClientBackingInfo: {
            (options?: vimService.vim.VirtualUSBRemoteClientBackingInfo): vimService.vim.VirtualUSBRemoteClientBackingInfo;
         };
         VirtualUSB: {
            (options?: vimService.vim.VirtualUSB): vimService.vim.VirtualUSB;
         };
         VirtualUSBControllerPciBusSlotInfo: {
            (options?: vimService.vim.VirtualUSBControllerPciBusSlotInfo): vimService.vim.VirtualUSBControllerPciBusSlotInfo;
         };
         VirtualUSBController: {
            (options?: vimService.vim.VirtualUSBController): vimService.vim.VirtualUSBController;
         };
         VirtualUSBControllerOption: {
            (options?: vimService.vim.VirtualUSBControllerOption): vimService.vim.VirtualUSBControllerOption;
         };
         VirtualUSBUSBBackingOption: {
            (options?: vimService.vim.VirtualUSBUSBBackingOption): vimService.vim.VirtualUSBUSBBackingOption;
         };
         VirtualUSBRemoteHostBackingOption: {
            (options?: vimService.vim.VirtualUSBRemoteHostBackingOption): vimService.vim.VirtualUSBRemoteHostBackingOption;
         };
         VirtualUSBRemoteClientBackingOption: {
            (options?: vimService.vim.VirtualUSBRemoteClientBackingOption): vimService.vim.VirtualUSBRemoteClientBackingOption;
         };
         VirtualUSBOption: {
            (options?: vimService.vim.VirtualUSBOption): vimService.vim.VirtualUSBOption;
         };
         VirtualUSBXHCIController: {
            (options?: vimService.vim.VirtualUSBXHCIController): vimService.vim.VirtualUSBXHCIController;
         };
         VirtualUSBXHCIControllerOption: {
            (options?: vimService.vim.VirtualUSBXHCIControllerOption): vimService.vim.VirtualUSBXHCIControllerOption;
         };
         VirtualMachineVMCIDeviceAction: {
            "allow": string;
            "deny": string;
         };
         VirtualMachineVMCIDeviceProtocol: {
            "hypervisor": string;
            "doorbell": string;
            "queuepair": string;
            "datagram": string;
            "stream": string;
            "anyProtocol": string;
         };
         VirtualMachineVMCIDeviceDirection: {
            "guest": string;
            "host": string;
            "anyDirection": string;
         };
         VirtualMachineVMCIDeviceFilterSpec: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceFilterSpec): vimService.vim.VirtualMachineVMCIDeviceFilterSpec;
         };
         ArrayOfVirtualMachineVMCIDeviceFilterSpec: {
            (options?: vimService.vim.ArrayOfVirtualMachineVMCIDeviceFilterSpec): vimService.vim.ArrayOfVirtualMachineVMCIDeviceFilterSpec;
         };
         VirtualMachineVMCIDeviceFilterInfo: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceFilterInfo): vimService.vim.VirtualMachineVMCIDeviceFilterInfo;
         };
         VirtualMachineVMCIDevice: {
            (options?: vimService.vim.VirtualMachineVMCIDevice): vimService.vim.VirtualMachineVMCIDevice;
         };
         VirtualMachineVMCIDeviceOptionFilterSpecOption: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption): vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption;
         };
         VirtualMachineVMCIDeviceOption: {
            (options?: vimService.vim.VirtualMachineVMCIDeviceOption): vimService.vim.VirtualMachineVMCIDeviceOption;
         };
         VirtualMachineVMIROM: {
            (options?: vimService.vim.VirtualMachineVMIROM): vimService.vim.VirtualMachineVMIROM;
         };
         VirtualVMIROMOption: {
            (options?: vimService.vim.VirtualVMIROMOption): vimService.vim.VirtualVMIROMOption;
         };
         VirtualMachineVideoCardUse3dRenderer: {
            "automatic": string;
            "software": string;
            "hardware": string;
         };
         VirtualMachineVideoCard: {
            (options?: vimService.vim.VirtualMachineVideoCard): vimService.vim.VirtualMachineVideoCard;
         };
         VirtualVideoCardOption: {
            (options?: vimService.vim.VirtualVideoCardOption): vimService.vim.VirtualVideoCardOption;
         };
         VirtualVmxnet: {
            (options?: vimService.vim.VirtualVmxnet): vimService.vim.VirtualVmxnet;
         };
         VirtualVmxnet2: {
            (options?: vimService.vim.VirtualVmxnet2): vimService.vim.VirtualVmxnet2;
         };
         VirtualVmxnet2Option: {
            (options?: vimService.vim.VirtualVmxnet2Option): vimService.vim.VirtualVmxnet2Option;
         };
         VirtualVmxnet3: {
            (options?: vimService.vim.VirtualVmxnet3): vimService.vim.VirtualVmxnet3;
         };
         VirtualVmxnet3Option: {
            (options?: vimService.vim.VirtualVmxnet3Option): vimService.vim.VirtualVmxnet3Option;
         };
         VirtualVmxnetOption: {
            (options?: vimService.vim.VirtualVmxnetOption): vimService.vim.VirtualVmxnetOption;
         };
         GuestAuthSubject: {
            (options?: vimService.vim.GuestAuthSubject): vimService.vim.GuestAuthSubject;
         };
         ArrayOfGuestAuthSubject: {
            (options?: vimService.vim.ArrayOfGuestAuthSubject): vimService.vim.ArrayOfGuestAuthSubject;
         };
         GuestAuthAnySubject: {
            (options?: vimService.vim.GuestAuthAnySubject): vimService.vim.GuestAuthAnySubject;
         };
         GuestAuthNamedSubject: {
            (options?: vimService.vim.GuestAuthNamedSubject): vimService.vim.GuestAuthNamedSubject;
         };
         GuestAuthAliasInfo: {
            (options?: vimService.vim.GuestAuthAliasInfo): vimService.vim.GuestAuthAliasInfo;
         };
         ArrayOfGuestAuthAliasInfo: {
            (options?: vimService.vim.ArrayOfGuestAuthAliasInfo): vimService.vim.ArrayOfGuestAuthAliasInfo;
         };
         GuestAliases: {
            (options?: vimService.vim.GuestAliases): vimService.vim.GuestAliases;
         };
         ArrayOfGuestAliases: {
            (options?: vimService.vim.ArrayOfGuestAliases): vimService.vim.ArrayOfGuestAliases;
         };
         GuestMappedAliases: {
            (options?: vimService.vim.GuestMappedAliases): vimService.vim.GuestMappedAliases;
         };
         ArrayOfGuestMappedAliases: {
            (options?: vimService.vim.ArrayOfGuestMappedAliases): vimService.vim.ArrayOfGuestMappedAliases;
         };
         GuestFileAttributes: {
            (options?: vimService.vim.GuestFileAttributes): vimService.vim.GuestFileAttributes;
         };
         GuestPosixFileAttributes: {
            (options?: vimService.vim.GuestPosixFileAttributes): vimService.vim.GuestPosixFileAttributes;
         };
         GuestWindowsFileAttributes: {
            (options?: vimService.vim.GuestWindowsFileAttributes): vimService.vim.GuestWindowsFileAttributes;
         };
         GuestFileType: {
            "file": string;
            "directory": string;
            "symlink": string;
         };
         GuestFileInfo: {
            (options?: vimService.vim.GuestFileInfo): vimService.vim.GuestFileInfo;
         };
         ArrayOfGuestFileInfo: {
            (options?: vimService.vim.ArrayOfGuestFileInfo): vimService.vim.ArrayOfGuestFileInfo;
         };
         GuestListFileInfo: {
            (options?: vimService.vim.GuestListFileInfo): vimService.vim.GuestListFileInfo;
         };
         FileTransferInformation: {
            (options?: vimService.vim.FileTransferInformation): vimService.vim.FileTransferInformation;
         };
         GuestAuthentication: {
            (options?: vimService.vim.GuestAuthentication): vimService.vim.GuestAuthentication;
         };
         NamePasswordAuthentication: {
            (options?: vimService.vim.NamePasswordAuthentication): vimService.vim.NamePasswordAuthentication;
         };
         GuestProgramSpec: {
            (options?: vimService.vim.GuestProgramSpec): vimService.vim.GuestProgramSpec;
         };
         GuestWindowsProgramSpec: {
            (options?: vimService.vim.GuestWindowsProgramSpec): vimService.vim.GuestWindowsProgramSpec;
         };
         GuestProcessInfo: {
            (options?: vimService.vim.GuestProcessInfo): vimService.vim.GuestProcessInfo;
         };
         ArrayOfGuestProcessInfo: {
            (options?: vimService.vim.ArrayOfGuestProcessInfo): vimService.vim.ArrayOfGuestProcessInfo;
         };
         SAMLTokenAuthentication: {
            (options?: vimService.vim.SAMLTokenAuthentication): vimService.vim.SAMLTokenAuthentication;
         };
         SSPIAuthentication: {
            (options?: vimService.vim.SSPIAuthentication): vimService.vim.SSPIAuthentication;
         };
         TicketedSessionAuthentication: {
            (options?: vimService.vim.TicketedSessionAuthentication): vimService.vim.TicketedSessionAuthentication;
         };
         GuestRegKeyWowSpec: {
            "WOWNative": string;
            "WOW32": string;
            "WOW64": string;
         };
         GuestRegKeyNameSpec: {
            (options?: vimService.vim.GuestRegKeyNameSpec): vimService.vim.GuestRegKeyNameSpec;
         };
         GuestRegKeySpec: {
            (options?: vimService.vim.GuestRegKeySpec): vimService.vim.GuestRegKeySpec;
         };
         GuestRegKeyRecordSpec: {
            (options?: vimService.vim.GuestRegKeyRecordSpec): vimService.vim.GuestRegKeyRecordSpec;
         };
         ArrayOfGuestRegKeyRecordSpec: {
            (options?: vimService.vim.ArrayOfGuestRegKeyRecordSpec): vimService.vim.ArrayOfGuestRegKeyRecordSpec;
         };
         GuestRegValueNameSpec: {
            (options?: vimService.vim.GuestRegValueNameSpec): vimService.vim.GuestRegValueNameSpec;
         };
         GuestRegValueDataSpec: {
            (options?: vimService.vim.GuestRegValueDataSpec): vimService.vim.GuestRegValueDataSpec;
         };
         GuestRegValueDwordSpec: {
            (options?: vimService.vim.GuestRegValueDwordSpec): vimService.vim.GuestRegValueDwordSpec;
         };
         GuestRegValueQwordSpec: {
            (options?: vimService.vim.GuestRegValueQwordSpec): vimService.vim.GuestRegValueQwordSpec;
         };
         GuestRegValueStringSpec: {
            (options?: vimService.vim.GuestRegValueStringSpec): vimService.vim.GuestRegValueStringSpec;
         };
         GuestRegValueExpandStringSpec: {
            (options?: vimService.vim.GuestRegValueExpandStringSpec): vimService.vim.GuestRegValueExpandStringSpec;
         };
         GuestRegValueMultiStringSpec: {
            (options?: vimService.vim.GuestRegValueMultiStringSpec): vimService.vim.GuestRegValueMultiStringSpec;
         };
         GuestRegValueBinarySpec: {
            (options?: vimService.vim.GuestRegValueBinarySpec): vimService.vim.GuestRegValueBinarySpec;
         };
         GuestRegValueSpec: {
            (options?: vimService.vim.GuestRegValueSpec): vimService.vim.GuestRegValueSpec;
         };
         ArrayOfGuestRegValueSpec: {
            (options?: vimService.vim.ArrayOfGuestRegValueSpec): vimService.vim.ArrayOfGuestRegValueSpec;
         };
         VsanClusterConfigInfoHostDefaultInfo: {
            (options?: vimService.vim.VsanClusterConfigInfoHostDefaultInfo): vimService.vim.VsanClusterConfigInfoHostDefaultInfo;
         };
         VsanClusterConfigInfo: {
            (options?: vimService.vim.VsanClusterConfigInfo): vimService.vim.VsanClusterConfigInfo;
         };
         VsanHostClusterStatusStateCompletionEstimate: {
            (options?: vimService.vim.VsanHostClusterStatusStateCompletionEstimate): vimService.vim.VsanHostClusterStatusStateCompletionEstimate;
         };
         VsanHostClusterStatusState: {
            (options?: vimService.vim.VsanHostClusterStatusState): vimService.vim.VsanHostClusterStatusState;
         };
         VsanHostClusterStatus: {
            (options?: vimService.vim.VsanHostClusterStatus): vimService.vim.VsanHostClusterStatus;
         };
         VsanHostConfigInfoStorageInfo: {
            (options?: vimService.vim.VsanHostConfigInfoStorageInfo): vimService.vim.VsanHostConfigInfoStorageInfo;
         };
         VsanHostConfigInfoClusterInfo: {
            (options?: vimService.vim.VsanHostConfigInfoClusterInfo): vimService.vim.VsanHostConfigInfoClusterInfo;
         };
         VsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig): vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig;
         };
         ArrayOfVsanHostConfigInfoNetworkInfoPortConfig: {
            (options?: vimService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig): vimService.vim.ArrayOfVsanHostConfigInfoNetworkInfoPortConfig;
         };
         VsanHostConfigInfoNetworkInfo: {
            (options?: vimService.vim.VsanHostConfigInfoNetworkInfo): vimService.vim.VsanHostConfigInfoNetworkInfo;
         };
         VsanHostFaultDomainInfo: {
            (options?: vimService.vim.VsanHostFaultDomainInfo): vimService.vim.VsanHostFaultDomainInfo;
         };
         VsanHostConfigInfo: {
            (options?: vimService.vim.VsanHostConfigInfo): vimService.vim.VsanHostConfigInfo;
         };
         ArrayOfVsanHostConfigInfo: {
            (options?: vimService.vim.ArrayOfVsanHostConfigInfo): vimService.vim.ArrayOfVsanHostConfigInfo;
         };
         VsanHostDecommissionModeObjectAction: {
            "noAction": string;
            "ensureObjectAccessibility": string;
            "evacuateAllData": string;
         };
         VsanHostDecommissionMode: {
            (options?: vimService.vim.VsanHostDecommissionMode): vimService.vim.VsanHostDecommissionMode;
         };
         VsanHostDiskMapInfo: {
            (options?: vimService.vim.VsanHostDiskMapInfo): vimService.vim.VsanHostDiskMapInfo;
         };
         ArrayOfVsanHostDiskMapInfo: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapInfo): vimService.vim.ArrayOfVsanHostDiskMapInfo;
         };
         VsanHostDiskMapResult: {
            (options?: vimService.vim.VsanHostDiskMapResult): vimService.vim.VsanHostDiskMapResult;
         };
         ArrayOfVsanHostDiskMapResult: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapResult): vimService.vim.ArrayOfVsanHostDiskMapResult;
         };
         VsanHostDiskMapping: {
            (options?: vimService.vim.VsanHostDiskMapping): vimService.vim.VsanHostDiskMapping;
         };
         ArrayOfVsanHostDiskMapping: {
            (options?: vimService.vim.ArrayOfVsanHostDiskMapping): vimService.vim.ArrayOfVsanHostDiskMapping;
         };
         VsanHostDiskResultState: {
            "inUse": string;
            "eligible": string;
            "ineligible": string;
         };
         VsanHostDiskResult: {
            (options?: vimService.vim.VsanHostDiskResult): vimService.vim.VsanHostDiskResult;
         };
         ArrayOfVsanHostDiskResult: {
            (options?: vimService.vim.ArrayOfVsanHostDiskResult): vimService.vim.ArrayOfVsanHostDiskResult;
         };
         VsanHostHealthState: {
            "unknown": string;
            "healthy": string;
            "unhealthy": string;
         };
         VsanHostIpConfig: {
            (options?: vimService.vim.VsanHostIpConfig): vimService.vim.VsanHostIpConfig;
         };
         VsanHostMembershipInfo: {
            (options?: vimService.vim.VsanHostMembershipInfo): vimService.vim.VsanHostMembershipInfo;
         };
         ArrayOfVsanHostMembershipInfo: {
            (options?: vimService.vim.ArrayOfVsanHostMembershipInfo): vimService.vim.ArrayOfVsanHostMembershipInfo;
         };
         VsanHostNodeState: {
            "error": string;
            "disabled": string;
            "agent": string;
            "master": string;
            "backup": string;
            "starting": string;
            "stopping": string;
            "enteringMaintenanceMode": string;
            "exitingMaintenanceMode": string;
            "decommissioning": string;
         };
         VsanHostVsanDiskInfo: {
            (options?: vimService.vim.VsanHostVsanDiskInfo): vimService.vim.VsanHostVsanDiskInfo;
         };
         VsanDiskIssueType: {
            "nonExist": string;
            "stampMismatch": string;
            "unknown": string;
         };
         VsanHostRuntimeInfoDiskIssue: {
            (options?: vimService.vim.VsanHostRuntimeInfoDiskIssue): vimService.vim.VsanHostRuntimeInfoDiskIssue;
         };
         ArrayOfVsanHostRuntimeInfoDiskIssue: {
            (options?: vimService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue): vimService.vim.ArrayOfVsanHostRuntimeInfoDiskIssue;
         };
         VsanHostRuntimeInfo: {
            (options?: vimService.vim.VsanHostRuntimeInfo): vimService.vim.VsanHostRuntimeInfo;
         };
         ID: {
            (options?: vimService.vim.ID): vimService.vim.ID;
         };
      }
      vimPort: {
         addAuthorizationRole(_this: vimService.vim.ManagedObjectReference, name: string, privIds: Array<string>): Promise<number>;
         removeAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, failIfUsed: boolean): Promise<void>;
         updateAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, newName: string, privIds: Array<string>): Promise<void>;
         mergePermissions(_this: vimService.vim.ManagedObjectReference, srcRoleId: number, dstRoleId: number): Promise<void>;
         retrieveRolePermissions(_this: vimService.vim.ManagedObjectReference, roleId: number): Promise<Array<vimService.vim.Permission>>;
         retrieveEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, inherited: boolean): Promise<Array<vimService.vim.Permission>>;
         retrieveAllPermissions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Permission>>;
         setEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         resetEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         removeEntityPermission(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, user: string, isGroup: boolean): Promise<void>;
         hasPrivilegeOnEntity(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, sessionId: string, privId: Array<string>): Promise<Array<boolean>>;
         hasPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>, sessionId: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         certMgrRefreshCACertificatesAndCRLsTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRefreshCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRevokeCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureClusterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ClusterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         applyRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         cancelRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         recommendHostsForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterHostRecommendation>>;
         addHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, asConnected: boolean, resourcePool: vimService.vim.ManagedObjectReference, license: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         moveHostIntoTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, resourcePool: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         refreshRecommendation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         evcManager(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveDasAdvancedRuntimeInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterDasAdvancedRuntimeInfo>;
         clusterEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ClusterEnterMaintenanceResult>;
         placeVm(_this: vimService.vim.ManagedObjectReference, placementSpec: vimService.vim.PlacementSpec): Promise<vimService.vim.PlacementResult>;
         findRulesForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterRuleInfo>>;
         stampAllRulesWithUuidTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         getResourceUsage(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterResourceUsageSummary>;
         reconfigureComputeResourceTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ComputeResourceConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         addCustomFieldDef(_this: vimService.vim.ManagedObjectReference, name: string, moType: string, fieldDefPolicy: vimService.vim.PrivilegePolicyDef, fieldPolicy: vimService.vim.PrivilegePolicyDef): Promise<vimService.vim.CustomFieldDef>;
         removeCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         renameCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number, name: string): Promise<void>;
         setField(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, key: number, value: string): Promise<void>;
         doesCustomizationSpecExist(_this: vimService.vim.ManagedObjectReference, name: string): Promise<boolean>;
         getCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.CustomizationSpecItem>;
         createCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         overwriteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         deleteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         duplicateCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         renameCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         customizationSpecItemToXml(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<string>;
         xmlToCustomizationSpecItem(_this: vimService.vim.ManagedObjectReference, specItemXml: string): Promise<vimService.vim.CustomizationSpecItem>;
         checkCustomizationResources(_this: vimService.vim.ManagedObjectReference, guestOs: string): Promise<void>;
         queryConnectionInfo(_this: vimService.vim.ManagedObjectReference, hostname: string, port: number, username: string, password: string, sslThumbprint: string): Promise<vimService.vim.HostConnectInfo>;
         queryConnectionInfoViaSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec): Promise<vimService.vim.HostConnectInfo>;
         powerOnMultiVMTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ManagedObjectReference>;
         queryDatacenterConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         reconfigureDatacenterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DatacenterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         refreshDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshDatastoreStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, mountPathDatastoreMapping: Array<vimService.vim.DatastoreMountPathDatastorePair>): Promise<vimService.vim.ManagedObjectReference>;
         renameDatastore(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<void>;
         destroyDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         datastoreEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StoragePlacementResult>;
         datastoreExitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDirectory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, displayName: string, policy: string): Promise<string>;
         deleteDirectory(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         queryDescriptions(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.DiagnosticManagerLogDescriptor>>;
         browseDiagnosticLog(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, key: string, start: number, lines: number): Promise<vimService.vim.DiagnosticManagerLogHeader>;
         generateLogBundlesTask(_this: vimService.vim.ManagedObjectReference, includeDefault: boolean, host: Array<vimService.vim.ManagedObjectReference>, supportOptions: Array<vimService.vim.KeyValue>): Promise<vimService.vim.ManagedObjectReference>;
         fetchDVPortKeys(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<string>>;
         fetchDVPorts(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<vimService.vim.DistributedVirtualPort>>;
         queryUsedVlanIdInDvs(_this: vimService.vim.ManagedObjectReference): Promise<Array<number>>;
         reconfigureDvsTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         performDvsProductSpecOperationTask(_this: vimService.vim.ManagedObjectReference, operation: string, productSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.ManagedObjectReference>;
         mergeDvsTask(_this: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         addDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.DVPortgroupConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         moveDVPortTask(_this: vimService.vim.ManagedObjectReference, portKey: Array<string>, destinationPortgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDvsCapability(_this: vimService.vim.ManagedObjectReference, capability: vimService.vim.DVSCapability): Promise<void>;
         reconfigureDVPortTask(_this: vimService.vim.ManagedObjectReference, port: Array<vimService.vim.DVPortConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         refreshDVPortState(_this: vimService.vim.ManagedObjectReference, portKeys: Array<string>): Promise<void>;
         rectifyDvsHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         updateNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         addNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         removeNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         dvsReconfigureVmVnicNetworkResourcePoolTask(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         enableNetworkResourceManagement(_this: vimService.vim.ManagedObjectReference, enable: boolean): Promise<void>;
         dVSRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         createDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSHealthCheckConfigTask(_this: vimService.vim.ManagedObjectReference, healthCheckConfig: Array<vimService.vim.DVSHealthCheckConfig>): Promise<vimService.vim.ManagedObjectReference>;
         lookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         queryConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         queryConfigOption(_this: vimService.vim.ManagedObjectReference, key: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigOptionEx(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ConfigTarget>;
         queryTargetCapabilities(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostCapability>;
         setCustomValue(_this: vimService.vim.ManagedObjectReference, key: string, value: string): Promise<void>;
         unregisterExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<void>;
         findExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<vimService.vim.Extension>;
         registerExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         updateExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         getPublicKey(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         setPublicKey(_this: vimService.vim.ManagedObjectReference, extensionKey: string, publicKey: string): Promise<void>;
         setExtensionCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, certificatePem: string): Promise<void>;
         queryManagedBy(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryExtensionIpAllocationUsage(_this: vimService.vim.ManagedObjectReference, extensionKeys: Array<string>): Promise<Array<vimService.vim.ExtensionManagerIpAllocationUsage>>;
         moveDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         copyDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         deleteDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makeDirectory(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, createParentDirectories: boolean): Promise<void>;
         changeOwner(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, owner: string): Promise<void>;
         createFolder(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoFolderTask(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, asTemplate: boolean, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createCluster(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createClusterEx(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpecEx): Promise<vimService.vim.ManagedObjectReference>;
         addStandaloneHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, compResSpec: vimService.vim.ComputeResourceConfigSpec, addConnected: boolean, license: string): Promise<vimService.vim.ManagedObjectReference>;
         createDatacenter(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         unregisterAndDestroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDVSTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         createStoragePod(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         setCollectorPageSize(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<void>;
         rewindCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryTpmAttestationReport(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostTpmAttestationReport>;
         queryHostConnectionInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostConnectInfo>;
         updateSystemResources(_this: vimService.vim.ManagedObjectReference, resourceInfo: vimService.vim.HostSystemResourceInfo): Promise<void>;
         updateSystemSwapConfiguration(_this: vimService.vim.ManagedObjectReference, sysSwapConfig: vimService.vim.HostSystemSwapConfiguration): Promise<void>;
         reconnectHostTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec, reconnectSpec: vimService.vim.HostSystemReconnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         disconnectHostTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enterMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number, evacuatePoweredOffVms: boolean, maintenanceSpec: vimService.vim.HostMaintenanceSpec): Promise<vimService.vim.ManagedObjectReference>;
         exitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         rebootHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         shutdownHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerDownHostToStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number, evacuatePoweredOffVms: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerUpHostFromStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number): Promise<vimService.vim.ManagedObjectReference>;
         queryMemoryOverhead(_this: vimService.vim.ManagedObjectReference, memorySize: number, videoRamSize: number, numVcpus: number): Promise<number>;
         queryMemoryOverheadEx(_this: vimService.vim.ManagedObjectReference, vmConfigInfo: vimService.vim.VirtualMachineConfigInfo): Promise<number>;
         reconfigureHostForDASTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateFlags(_this: vimService.vim.ManagedObjectReference, flagInfo: vimService.vim.HostFlagInfo): Promise<void>;
         enterLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         exitLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireCimServicesTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostServiceTicket>;
         updateIpmi(_this: vimService.vim.ManagedObjectReference, ipmiInfo: vimService.vim.HostIpmiInfo): Promise<void>;
         retrieveHardwareUptime(_this: vimService.vim.ManagedObjectReference): Promise<number>;
         httpNfcLeaseGetManifest(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HttpNfcLeaseManifestEntry>>;
         httpNfcLeaseComplete(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         httpNfcLeaseAbort(_this: vimService.vim.ManagedObjectReference, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         httpNfcLeaseProgress(_this: vimService.vim.ManagedObjectReference, percent: number): Promise<void>;
         installIoFilterTask(_this: vimService.vim.ManagedObjectReference, vibUrl: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         uninstallIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         upgradeIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference, vibUrl: string): Promise<vimService.vim.ManagedObjectReference>;
         queryIoFilterIssues(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.IoFilterQueryIssueResult>;
         queryIoFilterInfo(_this: vimService.vim.ManagedObjectReference, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterIoFilterInfo>>;
         resolveInstallationErrorsOnHostTask(_this: vimService.vim.ManagedObjectReference, filterId: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resolveInstallationErrorsOnClusterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryDisksUsingFilter(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualDiskId>>;
         queryIpPools(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.IpPool>>;
         createIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<number>;
         updateIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<void>;
         destroyIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, id: number, force: boolean): Promise<void>;
         allocateIpv4Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         allocateIpv6Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         releaseIpAllocation(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<void>;
         queryIPAllocations(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, extensionKey: string): Promise<Array<vimService.vim.IpPoolManagerIpAllocation>>;
         updateAssignedLicense(_this: vimService.vim.ManagedObjectReference, entity: string, licenseKey: string, entityDisplayName: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeAssignedLicense(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<void>;
         queryAssignedLicenses(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>>;
         querySupportedFeatures(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseFeatureInfo>>;
         queryLicenseSourceAvailability(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseAvailabilityInfo>>;
         queryLicenseUsage(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.LicenseUsageInfo>;
         setLicenseEdition(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<void>;
         checkLicenseFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         enableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         disableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         configureLicenseSource(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, licenseSource: vimService.vim.LicenseSource): Promise<void>;
         updateLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         addLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<void>;
         decodeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         updateLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string, labelValue: string): Promise<void>;
         removeLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string): Promise<void>;
         reload(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         renameTask(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<vimService.vim.ManagedObjectReference>;
         destroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyNetwork(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         lookupVmOverheadMemory(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<number>;
         validateHost(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, host: vimService.vim.ManagedObjectReference, vhp: vimService.vim.OvfValidateHostParams): Promise<vimService.vim.OvfValidateHostResult>;
         parseDescriptor(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, pdp: vimService.vim.OvfParseDescriptorParams): Promise<vimService.vim.OvfParseDescriptorResult>;
         createImportSpec(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, resourcePool: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, cisp: vimService.vim.OvfCreateImportSpecParams): Promise<vimService.vim.OvfCreateImportSpecResult>;
         createDescriptor(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, cdp: vimService.vim.OvfCreateDescriptorParams): Promise<vimService.vim.OvfCreateDescriptorResult>;
         queryPerfProviderSummary(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<vimService.vim.PerfProviderSummary>;
         queryAvailablePerfMetric(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, beginTime: Date, endTime: Date, intervalId: number): Promise<Array<vimService.vim.PerfMetricId>>;
         queryPerfCounter(_this: vimService.vim.ManagedObjectReference, counterId: Array<number>): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerfCounterByLevel(_this: vimService.vim.ManagedObjectReference, level: number): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerf(_this: vimService.vim.ManagedObjectReference, querySpec: Array<vimService.vim.PerfQuerySpec>): Promise<Array<vimService.vim.PerfEntityMetricBase>>;
         queryPerfComposite(_this: vimService.vim.ManagedObjectReference, querySpec: vimService.vim.PerfQuerySpec): Promise<vimService.vim.PerfCompositeMetric>;
         createPerfInterval(_this: vimService.vim.ManagedObjectReference, intervalId: vimService.vim.PerfInterval): Promise<void>;
         removePerfInterval(_this: vimService.vim.ManagedObjectReference, samplePeriod: number): Promise<void>;
         updatePerfInterval(_this: vimService.vim.ManagedObjectReference, interval: vimService.vim.PerfInterval): Promise<void>;
         updateCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counterLevelMap: Array<vimService.vim.PerformanceManagerCounterLevelMapping>): Promise<void>;
         resetCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counters: Array<number>): Promise<void>;
         estimateDatabaseSize(_this: vimService.vim.ManagedObjectReference, dbSizeParam: vimService.vim.DatabaseSizeParam): Promise<vimService.vim.DatabaseSizeEstimate>;
         updateConfig(_this: vimService.vim.ManagedObjectReference, name: string, config: vimService.vim.ResourceConfigSpec): Promise<void>;
         moveIntoResourcePool(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         updateChildResourceConfiguration(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.ResourceConfigSpec>): Promise<void>;
         createResourcePool(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ResourceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         destroyChildren(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createVApp(_this: vimService.vim.ManagedObjectReference, name: string, resSpec: vimService.vim.ResourceConfigSpec, configSpec: vimService.vim.VAppConfigSpec, vmFolder: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createChildVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerChildVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         importVApp(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ImportSpec, folder: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryResourceConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ResourceConfigOption>;
         refreshRuntime(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         findByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByDatastorePath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, path: string): Promise<vimService.vim.ManagedObjectReference>;
         findByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByInventoryPath(_this: vimService.vim.ManagedObjectReference, inventoryPath: string): Promise<vimService.vim.ManagedObjectReference>;
         findChild(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         findAllByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         currentTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         retrieveServiceContent(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ServiceContent>;
         validateMigration(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Event>>;
         queryVMotionCompatibility(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, compatibility: Array<string>): Promise<Array<vimService.vim.HostVMotionCompatibility>>;
         retrieveProductComponents(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProductComponentInfo>>;
         queryServiceList(_this: vimService.vim.ManagedObjectReference, serviceName: string, location: Array<string>): Promise<Array<vimService.vim.ServiceManagerServiceInfo>>;
         updateServiceMessage(_this: vimService.vim.ManagedObjectReference, message: string): Promise<void>;
         loginByToken(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<vimService.vim.UserSession>;
         login(_this: vimService.vim.ManagedObjectReference, userName: string, password: string, locale: string): Promise<vimService.vim.UserSession>;
         loginBySSPI(_this: vimService.vim.ManagedObjectReference, base64Token: string, locale: string): Promise<vimService.vim.UserSession>;
         logout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireLocalTicket(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<vimService.vim.SessionManagerLocalTicket>;
         acquireGenericServiceTicket(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.SessionManagerServiceRequestSpec): Promise<vimService.vim.SessionManagerGenericServiceTicket>;
         terminateSession(_this: vimService.vim.ManagedObjectReference, sessionId: Array<string>): Promise<void>;
         setLocale(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<void>;
         loginExtensionBySubjectName(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         loginExtensionByCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         impersonateUser(_this: vimService.vim.ManagedObjectReference, userName: string, locale: string): Promise<vimService.vim.UserSession>;
         sessionIsActive(_this: vimService.vim.ManagedObjectReference, sessionID: string, userName: string): Promise<boolean>;
         acquireCloneTicket(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         cloneSession(_this: vimService.vim.ManagedObjectReference, cloneTicket: string): Promise<vimService.vim.UserSession>;
         executeSimpleCommand(_this: vimService.vim.ManagedObjectReference, arguments: Array<string>): Promise<string>;
         configureDatastoreIORMTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageIORMConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryIORMConfigOption(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StorageIORMConfigOption>;
         queryDatastorePerformanceSummary(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.StoragePerformanceSummary>>;
         applyStorageDrsRecommendationToPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, key: string): Promise<vimService.vim.ManagedObjectReference>;
         applyStorageDrsRecommendationTask(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         cancelStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         refreshStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference): Promise<void>;
         configureStorageDrsForPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageDrsConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         recommendDatastores(_this: vimService.vim.ManagedObjectReference, storageSpec: vimService.vim.StoragePlacementSpec): Promise<vimService.vim.StoragePlacementResult>;
         cancelTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateProgress(_this: vimService.vim.ManagedObjectReference, percentDone: number): Promise<void>;
         setTaskState(_this: vimService.vim.ManagedObjectReference, state: vimService.vim.TaskInfoState, result: any, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         setTaskDescription(_this: vimService.vim.ManagedObjectReference, description: vimService.vim.LocalizableMessage): Promise<void>;
         readNextTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         readPreviousTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         createCollectorForTasks(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.TaskFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         createTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, taskTypeId: string, initiatedBy: string, cancelable: boolean, parentTaskKey: string, activationId: string): Promise<vimService.vim.TaskInfo>;
         retrieveUserGroups(_this: vimService.vim.ManagedObjectReference, domain: string, searchStr: string, belongsToGroup: string, belongsToUser: string, exactMatch: boolean, findUsers: boolean, findGroups: boolean): Promise<Array<vimService.vim.UserSearchResult>>;
         updateVAppConfig(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppConfigSpec): Promise<void>;
         updateLinkedChildren(_this: vimService.vim.ManagedObjectReference, addChangeSet: Array<vimService.vim.VirtualAppLinkInfo>, removeSet: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         cloneVAppTask(_this: vimService.vim.ManagedObjectReference, name: string, target: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVApp(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOnVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVAppTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         suspendVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         unregisterVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualDiskSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         moveVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, force: boolean, profile: Array<vimService.vim.VirtualMachineProfileSpec>): Promise<vimService.vim.ManagedObjectReference>;
         copyVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, destSpec: vimService.vim.VirtualDiskSpec, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         extendVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, newCapacityKb: number, eagerZero: boolean): Promise<vimService.vim.ManagedObjectReference>;
         queryVirtualDiskFragmentation(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<number>;
         defragmentVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shrinkVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, copy: boolean): Promise<vimService.vim.ManagedObjectReference>;
         inflateVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         eagerZeroVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         zeroFillVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, uuid: string): Promise<void>;
         queryVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<string>;
         queryVirtualDiskGeometry(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostDiskDimensionsChs>;
         importUnmanagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference, vvolId: string): Promise<void>;
         refreshStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSnapshotTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesce: boolean): Promise<vimService.vim.ManagedObjectReference>;
         revertToCurrentSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeAllSnapshotsTask(_this: vimService.vim.ManagedObjectReference, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         consolidateVMDisksTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         estimateStorageForConsolidateSnapshotsTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         reconfigVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         upgradeVMTask(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.ManagedObjectReference>;
         extractOvfEnvironment(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         powerOnVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         suspendVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resetVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shutdownGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         rebootGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         standbyGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         answerVM(_this: vimService.vim.ManagedObjectReference, questionId: string, answerChoice: string): Promise<void>;
         customizeVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<vimService.vim.ManagedObjectReference>;
         checkCustomizationSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<void>;
         migrateVMTask(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, priority: vimService.vim.VirtualMachineMovePriority, state: vimService.vim.VirtualMachinePowerState): Promise<vimService.vim.ManagedObjectReference>;
         relocateVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, priority: vimService.vim.VirtualMachineMovePriority): Promise<vimService.vim.ManagedObjectReference>;
         cloneVMTask(_this: vimService.vim.ManagedObjectReference, folder: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.VirtualMachineCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVm(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         markAsTemplate(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         markAsVirtualMachine(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         unregisterVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetGuestInformation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstallerImage(_this: vimService.vim.ManagedObjectReference, isoImage: vimService.vim.VirtualDeviceBackingInfo, auth: vimService.vim.GuestAuthentication): Promise<void>;
         unmountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         upgradeToolsTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string): Promise<vimService.vim.ManagedObjectReference>;
         upgradeToolsFromImageTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string, isoImage: vimService.vim.VirtualDeviceBackingInfo, auth: vimService.vim.GuestAuthentication): Promise<vimService.vim.ManagedObjectReference>;
         acquireMksTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineMksTicket>;
         acquireTicket(_this: vimService.vim.ManagedObjectReference, ticketType: string): Promise<vimService.vim.VirtualMachineTicket>;
         setScreenResolution(_this: vimService.vim.ManagedObjectReference, width: number, height: number): Promise<void>;
         defragmentAllDisks(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createSecondaryVMExTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, spec: vimService.vim.FaultToleranceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         turnOffFaultToleranceForVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makePrimaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         terminateFaultTolerantVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         disableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setDisplayTopology(_this: vimService.vim.ManagedObjectReference, displays: Array<vimService.vim.VirtualMachineDisplayTopology>): Promise<void>;
         startRecordingTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<vimService.vim.ManagedObjectReference>;
         stopRecordingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         startReplayingTask(_this: vimService.vim.ManagedObjectReference, replaySnapshot: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         stopReplayingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         promoteDisksTask(_this: vimService.vim.ManagedObjectReference, unlink: boolean, disks: Array<vimService.vim.VirtualDisk>): Promise<vimService.vim.ManagedObjectReference>;
         createScreenshotTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryChangedDiskAreas(_this: vimService.vim.ManagedObjectReference, snapshot: vimService.vim.ManagedObjectReference, deviceKey: number, startOffset: number, changeId: string): Promise<vimService.vim.DiskChangeInfo>;
         queryUnownedFiles(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         reloadVirtualMachineFromPathTask(_this: vimService.vim.ManagedObjectReference, configurationPath: string): Promise<vimService.vim.ManagedObjectReference>;
         queryFaultToleranceCompatibility(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         queryFaultToleranceCompatibilityEx(_this: vimService.vim.ManagedObjectReference, forLegacyFt: boolean): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         terminateVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         sendNMI(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         performVsanUpgradePreflightCheck(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, downgradeFormat: boolean): Promise<vimService.vim.VsanUpgradeSystemPreflightCheckResult>;
         queryVsanUpgradeStatus(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanUpgradeSystemUpgradeStatus>;
         performVsanUpgradeTask(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, performObjectUpgrade: boolean, downgradeFormat: boolean, allowReducedRedundancy: boolean, excludeHosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         removeAlarm(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAlarm(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<void>;
         createAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<vimService.vim.ManagedObjectReference>;
         getAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         areAlarmActionsEnabled(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         enableAlarmActions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         getAlarmState(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.AlarmState>>;
         acknowledgeAlarm(_this: vimService.vim.ManagedObjectReference, alarm: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<void>;
         configureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         disableEvcModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkConfigureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         checkAddHostEvcTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         dVPortgroupRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         queryAvailableDvsSpec(_this: vimService.vim.ManagedObjectReference, recommended: boolean): Promise<Array<vimService.vim.DistributedVirtualSwitchProductSpec>>;
         queryCompatibleHostForNewDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryCompatibleHostForExistingDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, dvs: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryDvsCompatibleHostSpec(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>>;
         queryDvsFeatureCapability(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.DVSFeatureCapability>;
         queryDvsByUuid(_this: vimService.vim.ManagedObjectReference, uuid: string): Promise<vimService.vim.ManagedObjectReference>;
         queryDvsConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.DVSManagerDvsConfigTarget>;
         queryDvsCheckCompatibility(_this: vimService.vim.ManagedObjectReference, hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer, dvsProductSpec: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>): Promise<Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>>;
         rectifyDvsOnHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerExportEntityTask(_this: vimService.vim.ManagedObjectReference, selectionSet: Array<vimService.vim.SelectionSet>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerImportEntityTask(_this: vimService.vim.ManagedObjectReference, entityBackup: Array<vimService.vim.EntityBackupConfig>, importType: string): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerLookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, switchUuid: string, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSLacpGroupConfigTask(_this: vimService.vim.ManagedObjectReference, lacpGroupSpec: Array<vimService.vim.VMwareDvsLacpGroupSpec>): Promise<vimService.vim.ManagedObjectReference>;
         readNextEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         readPreviousEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         retrieveArgumentDescription(_this: vimService.vim.ManagedObjectReference, eventTypeId: string): Promise<Array<vimService.vim.EventArgDesc>>;
         createCollectorForEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         logUserEvent(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, msg: string): Promise<void>;
         queryEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<Array<vimService.vim.Event>>;
         postEvent(_this: vimService.vim.ManagedObjectReference, eventToPost: vimService.vim.Event, taskInfo: vimService.vim.TaskInfo): Promise<void>;
         joinDomainTask(_this: vimService.vim.ManagedObjectReference, domainName: string, userName: string, password: string): Promise<vimService.vim.ManagedObjectReference>;
         joinDomainWithCAMTask(_this: vimService.vim.ManagedObjectReference, domainName: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         importCertificateForCAMTask(_this: vimService.vim.ManagedObjectReference, certPath: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         leaveCurrentDomainTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         enableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         installSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference, certs: Array<string>): Promise<void>;
         removeSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, issuer: string, serial: string): Promise<void>;
         removeSmartCardTrustAnchorByFingerprint(_this: vimService.vim.ManagedObjectReference, fingerprint: string, digest: string): Promise<void>;
         listSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         disableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAutostart(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostAutoStartManagerConfig): Promise<void>;
         autoStartPowerOn(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         autoStartPowerOff(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryBootDevices(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostBootDeviceInfo>;
         updateBootDevice(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         configureHostCacheTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostCacheConfigurationSpec): Promise<vimService.vim.ManagedObjectReference>;
         generateCertificateSigningRequest(_this: vimService.vim.ManagedObjectReference, useIpAddressAsCommonName: boolean): Promise<string>;
         generateCertificateSigningRequestByDn(_this: vimService.vim.ManagedObjectReference, distinguishedName: string): Promise<string>;
         installServerCertificate(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceCACertificatesAndCRLs(_this: vimService.vim.ManagedObjectReference, caCert: Array<string>, caCrl: Array<string>): Promise<void>;
         listCACertificates(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         listCACertificateRevocationLists(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         enableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         disableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         searchDatastoreTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         searchDatastoreSubFoldersTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteFile(_this: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         updateLocalSwapDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableDisksForVmfs(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostScsiDisk>>;
         queryVmfsDatastoreCreateOptions(_this: vimService.vim.ManagedObjectReference, devicePath: string, vmfsMajorVersion: number): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         createVmfsDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryVmfsDatastoreExtendOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, devicePath: string, suppressExpandCandidates: boolean): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         queryVmfsDatastoreExpandOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         extendVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExtendSpec): Promise<vimService.vim.ManagedObjectReference>;
         expandVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExpandSpec): Promise<vimService.vim.ManagedObjectReference>;
         createNasDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostNasVolumeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createLocalDatastore(_this: vimService.vim.ManagedObjectReference, name: string, path: string): Promise<vimService.vim.ManagedObjectReference>;
         createVvolDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): Promise<vimService.vim.ManagedObjectReference>;
         removeDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         removeDatastoreExTask(_this: vimService.vim.ManagedObjectReference, datastore: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         configureDatastorePrincipal(_this: vimService.vim.ManagedObjectReference, userName: string, password: string): Promise<void>;
         queryUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resignatureUnresolvedVmfsVolumeTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: vimService.vim.HostUnresolvedVmfsResignatureSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDateTimeConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDateTimeConfig): Promise<void>;
         queryAvailableTimeZones(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDateTimeSystemTimeZone>>;
         queryDateTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         updateDateTime(_this: vimService.vim.ManagedObjectReference, dateTime: Date): Promise<void>;
         refreshDateTimeSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailablePartition(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDiagnosticPartition>>;
         selectActivePartition(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition): Promise<void>;
         queryPartitionCreateOptions(_this: vimService.vim.ManagedObjectReference, storageType: string, diagnosticType: string): Promise<Array<vimService.vim.HostDiagnosticPartitionCreateOption>>;
         queryPartitionCreateDesc(_this: vimService.vim.ManagedObjectReference, diskUuid: string, diagnosticType: string): Promise<vimService.vim.HostDiagnosticPartitionCreateDescription>;
         createDiagnosticPartition(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDiagnosticPartitionCreateSpec): Promise<void>;
         esxAgentHostManagerUpdateConfig(_this: vimService.vim.ManagedObjectReference, configInfo: vimService.vim.HostEsxAgentHostManagerConfigInfo): Promise<void>;
         updateDefaultPolicy(_this: vimService.vim.ManagedObjectReference, defaultPolicy: vimService.vim.HostFirewallDefaultPolicy): Promise<void>;
         enableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         disableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         updateRuleset(_this: vimService.vim.ManagedObjectReference, id: string, spec: vimService.vim.HostFirewallRulesetRulesetSpec): Promise<void>;
         refreshFirewall(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetFirmwareToFactoryDefaults(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         backupFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         queryFirmwareConfigUploadURL(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         restoreFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<void>;
         refreshGraphicsManager(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         isSharedGraphicsActive(_this: vimService.vim.ManagedObjectReference): Promise<boolean>;
         refreshHealthStatusSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetSystemHealthInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveHostAccessControlEntries(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostAccessControlEntry>>;
         changeAccessMode(_this: vimService.vim.ManagedObjectReference, principal: string, isGroup: boolean, accessMode: vimService.vim.HostAccessMode): Promise<void>;
         queryDcuiAccess(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateDcuiAccess(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         querySystemUsers(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateSystemUsers(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         queryLockdownExceptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateLockdownExceptions(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         changeLockdownMode(_this: vimService.vim.ManagedObjectReference, mode: vimService.vim.HostLockdownMode): Promise<void>;
         hostImageConfigGetAcceptance(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         hostImageConfigGetProfile(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostImageProfileSummary>;
         updateHostImageAcceptanceLevel(_this: vimService.vim.ManagedObjectReference, newAcceptanceLevel: string): Promise<void>;
         queryVnicStatus(_this: vimService.vim.ManagedObjectReference, vnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryPnicStatus(_this: vimService.vim.ManagedObjectReference, pnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryBoundVnics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         queryCandidateNics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         bindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string): Promise<void>;
         unbindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string, force: boolean): Promise<void>;
         queryMigrationDependencies(_this: vimService.vim.ManagedObjectReference, pnicDevice: Array<string>): Promise<vimService.vim.IscsiMigrationDependency>;
         queryModules(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.KernelModuleInfo>>;
         updateModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string, options: string): Promise<void>;
         queryConfiguredModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string): Promise<string>;
         createUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         updateUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         createGroup(_this: vimService.vim.ManagedObjectReference, group: vimService.vim.HostAccountSpec): Promise<void>;
         removeUser(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<void>;
         removeGroup(_this: vimService.vim.ManagedObjectReference, groupName: string): Promise<void>;
         assignUserToGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         unassignUserFromGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         reconfigureServiceConsoleReservation(_this: vimService.vim.ManagedObjectReference, cfgBytes: number): Promise<void>;
         reconfigureVirtualMachineReservation(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineMemoryReservationSpec): Promise<void>;
         updateNetworkConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostNetworkConfig, changeMode: string): Promise<vimService.vim.HostNetworkConfigResult>;
         updateDnsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDnsConfig): Promise<void>;
         updateIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateConsoleIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateIpRouteTableConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteTableConfig): Promise<void>;
         addVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         removeVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string): Promise<void>;
         updateVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         addPortGroup(_this: vimService.vim.ManagedObjectReference, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         removePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string): Promise<void>;
         updatePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         updatePhysicalNicLinkSpeed(_this: vimService.vim.ManagedObjectReference, device: string, linkSpeed: vimService.vim.PhysicalNicLinkInfo): Promise<void>;
         queryNetworkHint(_this: vimService.vim.ManagedObjectReference, device: Array<string>): Promise<Array<vimService.vim.PhysicalNicHintInfo>>;
         addVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         addServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         restartServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         refreshNetworkSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         checkHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         stageHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: string, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         uninstallHostPatchTask(_this: vimService.vim.ManagedObjectReference, bulletinIds: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryHostPatchTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         refresh(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updatePassthruConfig(_this: vimService.vim.ManagedObjectReference, config: Array<vimService.vim.HostPciPassthruConfig>): Promise<void>;
         configurePowerPolicy(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         updateServicePolicy(_this: vimService.vim.ManagedObjectReference, id: string, policy: string): Promise<void>;
         startService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         stopService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         restartService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         uninstallService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         refreshServices(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureSnmpAgent(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostSnmpConfigSpec): Promise<void>;
         sendTestNotification(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<Array<vimService.vim.HostDiskPartitionInfo>>;
         computeDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: string, layout: vimService.vim.HostDiskPartitionLayout, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         computeDiskPartitionInfoForResize(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition, blockRange: vimService.vim.HostDiskPartitionBlockRange, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         updateDiskPartitions(_this: vimService.vim.ManagedObjectReference, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         formatVmfs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVmfsSpec): Promise<vimService.vim.HostVmfsVolume>;
         mountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         mountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         unmapVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteVmfsVolumeState(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanVmfs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         expandVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         upgradeVmfs(_this: vimService.vim.ManagedObjectReference, vmfsPath: string): Promise<void>;
         upgradeVmLayout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryUnresolvedVmfsVolume(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resolveMultipleUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<Array<vimService.vim.HostUnresolvedVmfsResolutionResult>>;
         resolveMultipleUnresolvedVmfsVolumesExTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<vimService.vim.ManagedObjectReference>;
         unmountForceMountedVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanHba(_this: vimService.vim.ManagedObjectReference, hbaDevice: string): Promise<void>;
         rescanAllHba(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateSoftwareInternetScsiEnabled(_this: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         updateInternetScsiDiscoveryProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties): Promise<void>;
         updateInternetScsiAuthenticationProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties, targetSet: vimService.vim.HostInternetScsiHbaTargetSet): Promise<void>;
         updateInternetScsiDigestProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, digestProperties: vimService.vim.HostInternetScsiHbaDigestProperties): Promise<void>;
         updateInternetScsiAdvancedOptions(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, options: Array<vimService.vim.HostInternetScsiHbaParamValue>): Promise<void>;
         updateInternetScsiIPProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, ipProperties: vimService.vim.HostInternetScsiHbaIPProperties): Promise<void>;
         updateInternetScsiName(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiName: string): Promise<void>;
         updateInternetScsiAlias(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiAlias: string): Promise<void>;
         addInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         removeInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         addInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         removeInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         enableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         disableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         setMultipathLunPolicy(_this: vimService.vim.ManagedObjectReference, lunId: string, policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy): Promise<void>;
         queryPathSelectionPolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostPathSelectionPolicyOption>>;
         queryStorageArrayTypePolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostStorageArrayTypePolicyOption>>;
         updateScsiLunDisplayName(_this: vimService.vim.ManagedObjectReference, lunUuid: string, displayName: string): Promise<void>;
         detachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         detachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteScsiLunState(_this: vimService.vim.ManagedObjectReference, lunCanonicalName: string): Promise<void>;
         attachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         attachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         refreshStorageSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         discoverFcoeHbas(_this: vimService.vim.ManagedObjectReference, fcoeSpec: vimService.vim.FcoeConfigFcoeSpecification): Promise<void>;
         markForRemoval(_this: vimService.vim.ManagedObjectReference, hbaName: string, remove: boolean): Promise<void>;
         formatVffs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVffsSpec): Promise<vimService.vim.HostVffsVolume>;
         extendVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         destroyVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<void>;
         mountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         unmountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         deleteVffsVolumeState(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         rescanVffs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableSsds(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<Array<vimService.vim.HostScsiDisk>>;
         setNFSUser(_this: vimService.vim.ManagedObjectReference, user: string, password: string): Promise<void>;
         changeNFSUserPassword(_this: vimService.vim.ManagedObjectReference, password: string): Promise<void>;
         queryNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostNasVolumeUserInfo>;
         clearNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         turnDiskLocatorLedOnTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         turnDiskLocatorLedOffTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         markAsSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         configureVFlashResourceExTask(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         hostConfigureVFlashResource(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): Promise<void>;
         hostRemoveVFlashResource(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         hostConfigVFlashCache(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): Promise<void>;
         hostGetVFlashModuleDefaultConfig(_this: vimService.vim.ManagedObjectReference, vFlashModule: string): Promise<vimService.vim.VirtualDiskVFlashCacheConfigInfo>;
         updateIpConfig(_this: vimService.vim.ManagedObjectReference, ipConfig: vimService.vim.HostIpConfig): Promise<void>;
         selectVnic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         deselectVnic(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryNetConfig(_this: vimService.vim.ManagedObjectReference, nicType: string): Promise<vimService.vim.VirtualNicManagerNetConfig>;
         selectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         deselectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         queryCmmds(_this: vimService.vim.ManagedObjectReference, queries: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>): Promise<string>;
         queryPhysicalVsanDisks(_this: vimService.vim.ManagedObjectReference, props: Array<string>): Promise<string>;
         queryVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         queryObjectsOnPhysicalVsanDisk(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<string>;
         abdicateDomOwnership(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<Array<string>>;
         queryVsanStatistics(_this: vimService.vim.ManagedObjectReference, labels: Array<string>): Promise<string>;
         reconfigureDomObject(_this: vimService.vim.ManagedObjectReference, uuid: string, policy: string): Promise<void>;
         querySyncingVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         runVsanPhysicalDiskDiagnostics(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>>;
         getVsanObjExtAttrs(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         reconfigurationSatisfiable(_this: vimService.vim.ManagedObjectReference, pcbs: Array<vimService.vim.VsanPolicyChangeBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         canProvisionObjects(_this: vimService.vim.ManagedObjectReference, npbs: Array<vimService.vim.VsanNewPolicyBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         deleteVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, force: boolean): Promise<Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>>;
         upgradeVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, newVersion: number): Promise<Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>>;
         queryVsanObjectUuidsByFilter(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, limit: number, version: number): Promise<Array<string>>;
         queryDisksForVsan(_this: vimService.vim.ManagedObjectReference, canonicalName: Array<string>): Promise<Array<vimService.vim.VsanHostDiskResult>>;
         addDisksTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>): Promise<vimService.vim.ManagedObjectReference>;
         initializeDisksTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         unmountDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         updateVsanTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VsanHostConfigInfo): Promise<vimService.vim.ManagedObjectReference>;
         queryHostStatus(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanHostClusterStatus>;
         evacuateVsanNodeTask(_this: vimService.vim.ManagedObjectReference, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         recommissionVsanNodeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryOptions(_this: vimService.vim.ManagedObjectReference, name: string): Promise<Array<vimService.vim.OptionValue>>;
         updateOptions(_this: vimService.vim.ManagedObjectReference, changedValue: Array<vimService.vim.OptionValue>): Promise<void>;
         checkComplianceTask(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ComplianceResult>>;
         clearComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryExpressionMetadata(_this: vimService.vim.ManagedObjectReference, expressionName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileExpressionMetadata>>;
         retrieveDescription(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileDescription>;
         destroyProfile(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         associateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         dissociateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         checkProfileComplianceTask(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         exportProfile(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         createProfile(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.ProfileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryPolicyMetadata(_this: vimService.vim.ManagedObjectReference, policyName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfilePolicyMetadata>>;
         findAssociatedProfile(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         updateClusterProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.ClusterProfileConfigSpec): Promise<void>;
         updateReferenceHost(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         updateHostProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostProfileConfigSpec): Promise<void>;
         executeHostProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, deferredParam: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ProfileExecuteResult>;
         applyHostConfigTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, userInput: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ManagedObjectReference>;
         generateConfigTaskList(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostProfileManagerConfigTaskList>;
         generateHostProfileTaskListTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryHostProfileMetadata(_this: vimService.vim.ManagedObjectReference, profileName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileMetadata>>;
         queryProfileStructure(_this: vimService.vim.ManagedObjectReference, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileProfileStructure>;
         createDefaultProfile(_this: vimService.vim.ManagedObjectReference, profileType: string, profileTypeName: string, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ApplyProfile>;
         updateAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.AnswerFileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveAnswerFile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.AnswerFile>;
         retrieveAnswerFileForProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, applyProfile: vimService.vim.HostApplyProfile): Promise<vimService.vim.AnswerFile>;
         exportAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkAnswerFileStatusTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryAnswerFileStatus(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.AnswerFileStatusResult>>;
         removeScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureScheduledTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<void>;
         runScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveEntityScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         createObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         openInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         closeInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         modifyListView(_this: vimService.vim.ManagedObjectReference, add: Array<vimService.vim.ManagedObjectReference>, remove: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyView(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createInventoryView(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createContainerView(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, type: Array<string>, recursive: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         revertToSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeSnapshotTask(_this: vimService.vim.ManagedObjectReference, removeChildren: boolean, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         renameSnapshot(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<void>;
         exportSnapshot(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkCompatibilityTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         queryVMotionCompatibilityExTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         checkMigrateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         checkRelocateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         addGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, mapCert: boolean, base64Cert: string, aliasInfo: vimService.vim.GuestAuthAliasInfo): Promise<void>;
         removeGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string, subject: vimService.vim.GuestAuthSubject): Promise<void>;
         removeGuestAliasByCert(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string): Promise<void>;
         listGuestAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string): Promise<Array<vimService.vim.GuestAliases>>;
         listGuestMappedAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<Array<vimService.vim.GuestMappedAliases>>;
         validateCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         acquireCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, requestedAuth: vimService.vim.GuestAuthentication, sessionID: number): Promise<vimService.vim.GuestAuthentication>;
         releaseCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         makeDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, createParentDirectories: boolean): Promise<void>;
         deleteFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string): Promise<void>;
         deleteDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, recursive: boolean): Promise<void>;
         moveDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcDirectoryPath: string, dstDirectoryPath: string): Promise<void>;
         moveFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcFilePath: string, dstFilePath: string, overwrite: boolean): Promise<void>;
         createTemporaryFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         createTemporaryDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         listFilesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string, index: number, maxResults: number, matchPattern: string): Promise<vimService.vim.GuestListFileInfo>;
         changeFileAttributesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes): Promise<void>;
         initiateFileTransferFromGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string): Promise<vimService.vim.FileTransferInformation>;
         initiateFileTransferToGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes, fileSize: number, overwrite: boolean): Promise<string>;
         startProgramInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, spec: vimService.vim.GuestProgramSpec): Promise<number>;
         listProcessesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pids: Array<number>): Promise<Array<vimService.vim.GuestProcessInfo>>;
         terminateProcessInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pid: number): Promise<void>;
         readEnvironmentVariableInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, names: Array<string>): Promise<Array<string>>;
         createRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, isVolatile: boolean, classType: string): Promise<void>;
         listRegistryKeysInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegKeyRecordSpec>>;
         deleteRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean): Promise<void>;
         setRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, value: vimService.vim.GuestRegValueSpec): Promise<void>;
         listRegistryValuesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, expandStrings: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegValueSpec>>;
         deleteRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, valueName: vimService.vim.GuestRegValueNameSpec): Promise<void>;
         destroyPropertyFilter(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createFilter(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.PropertyFilterSpec, partialUpdates: boolean): Promise<vimService.vim.ManagedObjectReference>;
         retrieveProperties(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>): Promise<Array<vimService.vim.ObjectContent>>;
         checkForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         waitForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         cancelWaitForUpdates(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         waitForUpdatesEx(_this: vimService.vim.ManagedObjectReference, version: string, options: vimService.vim.WaitOptions): Promise<vimService.vim.UpdateSet>;
         retrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>, options: vimService.vim.RetrieveOptions): Promise<vimService.vim.RetrieveResult>;
         continueRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<vimService.vim.RetrieveResult>;
         cancelRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<void>;
         createPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
      }
   }
   namespace vimService {
      interface xs {
      }
      namespace xs {
         interface AnyType {
            value: string;
         }
         interface AnyURI {
            value: string;
         }
         interface Base64Binary {
            value: string;
         }
         interface Boolean {
            value: string;
         }
         interface Byte {
            value: string;
         }
         interface DateTime {
            value: string;
         }
         interface Double {
            value: string;
         }
         interface Float {
            value: string;
         }
         interface ID {
            value: string;
         }
         interface Int {
            value: string;
         }
         interface Integer {
            value: string;
         }
         interface Long {
            value: string;
         }
         interface NCName {
            value: string;
         }
         interface NegativeInteger {
            value: string;
         }
         interface NonNegativeInteger {
            value: string;
         }
         interface NonPositiveInteger {
            value: string;
         }
         interface PositiveInteger {
            value: string;
         }
         interface QName {
            value: string;
         }
         interface Short {
            value: string;
         }
         interface String {
            value: string;
         }
         interface UnsignedLong {
            value: string;
         }
      }
      interface vim {
      }
      namespace vim {
         interface DynamicArray {
            val: Array<any>;
         }
         interface DynamicData {
         }
         interface DynamicProperty {
            name: string;
            val: any;
         }
         interface ArrayOfDynamicProperty {
            dynamicProperty?: Array<vimService.vim.DynamicProperty>;
         }
         interface KeyAnyValue extends vimService.vim.DynamicData {
            key: string;
            value: any;
         }
         interface ArrayOfKeyAnyValue {
            keyAnyValue?: Array<vimService.vim.KeyAnyValue>;
         }
         interface LocalizableMessage extends vimService.vim.DynamicData {
            key: string;
            arg?: Array<vimService.vim.KeyAnyValue>;
            message?: string;
         }
         interface ArrayOfLocalizableMessage {
            localizableMessage?: Array<vimService.vim.LocalizableMessage>;
         }
         interface LocalizedMethodFault extends vimService.vim.DynamicData {
            fault: vimService.vim.MethodFault;
            localizedMessage?: string;
         }
         interface MethodFault {
            faultCause?: vimService.vim.LocalizedMethodFault;
            faultMessage?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfMethodFault {
            methodFault?: Array<vimService.vim.MethodFault>;
         }
         interface RuntimeFault extends vimService.vim.MethodFault {
         }
         interface HostCommunication extends vimService.vim.RuntimeFault {
         }
         interface HostNotConnected extends vimService.vim.HostCommunication {
         }
         interface HostNotReachable extends vimService.vim.HostCommunication {
         }
         interface InvalidArgument extends vimService.vim.RuntimeFault {
            invalidProperty?: string;
         }
         interface InvalidRequest extends vimService.vim.RuntimeFault {
         }
         interface InvalidType extends vimService.vim.InvalidRequest {
            argument?: string;
         }
         interface ManagedObjectNotFound extends vimService.vim.RuntimeFault {
            obj: vimService.vim.ManagedObjectReference;
         }
         interface MethodNotFound extends vimService.vim.InvalidRequest {
            receiver: vimService.vim.ManagedObjectReference;
            method: string;
         }
         interface NotEnoughLicenses extends vimService.vim.RuntimeFault {
         }
         interface NotImplemented extends vimService.vim.RuntimeFault {
         }
         interface NotSupported extends vimService.vim.RuntimeFault {
         }
         interface RequestCanceled extends vimService.vim.RuntimeFault {
         }
         interface SecurityError extends vimService.vim.RuntimeFault {
         }
         interface SystemError extends vimService.vim.RuntimeFault {
            reason: string;
         }
         interface UnexpectedFault extends vimService.vim.RuntimeFault {
            faultName: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ManagedObjectReference extends vimService.xs.String {
            type: string;
            value: string;
         }
         interface ArrayOfString {
            string?: Array<string>;
         }
         interface ArrayOfAnyType {
            anyType?: Array<any>;
         }
         interface ArrayOfAnyURI {
            anyURI?: Array<string>;
         }
         interface ArrayOfManagedObjectReference {
            managedObjectReference?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfBoolean {
            boolean?: Array<boolean>;
         }
         interface ArrayOfByte {
            byte?: Array<number>;
         }
         interface ArrayOfDouble {
            double?: Array<number>;
         }
         interface ArrayOfInt {
            int?: Array<number>;
         }
         interface ArrayOfLong {
            long?: Array<number>;
         }
         interface ArrayOfShort {
            short?: Array<number>;
         }
         interface InvalidCollectorVersion extends vimService.vim.MethodFault {
         }
         interface InvalidProperty extends vimService.vim.MethodFault {
            name: string;
         }
         interface PropertyFilterSpec extends vimService.vim.DynamicData {
            propSet: Array<vimService.vim.PropertySpec>;
            objectSet: Array<vimService.vim.ObjectSpec>;
            reportMissingObjectsInResults?: boolean;
         }
         interface ArrayOfPropertyFilterSpec {
            propertyFilterSpec?: Array<vimService.vim.PropertyFilterSpec>;
         }
         interface PropertySpec extends vimService.vim.DynamicData {
            type: string;
            all?: boolean;
            pathSet?: Array<string>;
         }
         interface ArrayOfPropertySpec {
            propertySpec?: Array<vimService.vim.PropertySpec>;
         }
         interface ObjectSpec extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            skip?: boolean;
            selectSet?: Array<vimService.vim.SelectionSpec>;
         }
         interface ArrayOfObjectSpec {
            objectSpec?: Array<vimService.vim.ObjectSpec>;
         }
         interface SelectionSpec extends vimService.vim.DynamicData {
            name?: string;
         }
         interface ArrayOfSelectionSpec {
            selectionSpec?: Array<vimService.vim.SelectionSpec>;
         }
         interface TraversalSpec extends vimService.vim.SelectionSpec {
            type: string;
            path: string;
            skip?: boolean;
            selectSet?: Array<vimService.vim.SelectionSpec>;
         }
         interface ObjectContent extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            propSet?: Array<vimService.vim.DynamicProperty>;
            missingSet?: Array<vimService.vim.MissingProperty>;
         }
         interface ArrayOfObjectContent {
            objectContent?: Array<vimService.vim.ObjectContent>;
         }
         interface UpdateSet extends vimService.vim.DynamicData {
            version: string;
            filterSet?: Array<vimService.vim.PropertyFilterUpdate>;
            truncated?: boolean;
         }
         interface PropertyFilterUpdate extends vimService.vim.DynamicData {
            filter: vimService.vim.ManagedObjectReference;
            objectSet?: Array<vimService.vim.ObjectUpdate>;
            missingSet?: Array<vimService.vim.MissingObject>;
         }
         interface ArrayOfPropertyFilterUpdate {
            propertyFilterUpdate?: Array<vimService.vim.PropertyFilterUpdate>;
         }
         enum ObjectUpdateKind {
            "modify",
            "enter",
            "leave",
         }
         interface ObjectUpdate extends vimService.vim.DynamicData {
            kind: vimService.vim.ObjectUpdateKind;
            obj: vimService.vim.ManagedObjectReference;
            changeSet?: Array<vimService.vim.PropertyChange>;
            missingSet?: Array<vimService.vim.MissingProperty>;
         }
         interface ArrayOfObjectUpdate {
            objectUpdate?: Array<vimService.vim.ObjectUpdate>;
         }
         enum PropertyChangeOp {
            "add",
            "remove",
            "assign",
            "indirectRemove",
         }
         interface PropertyChange extends vimService.vim.DynamicData {
            name: string;
            op: vimService.vim.PropertyChangeOp;
            val?: any;
         }
         interface ArrayOfPropertyChange {
            propertyChange?: Array<vimService.vim.PropertyChange>;
         }
         interface MissingProperty extends vimService.vim.DynamicData {
            path: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfMissingProperty {
            missingProperty?: Array<vimService.vim.MissingProperty>;
         }
         interface MissingObject extends vimService.vim.DynamicData {
            obj: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfMissingObject {
            missingObject?: Array<vimService.vim.MissingObject>;
         }
         interface WaitOptions extends vimService.vim.DynamicData {
            maxWaitSeconds?: number;
            maxObjectUpdates?: number;
         }
         interface RetrieveOptions extends vimService.vim.DynamicData {
            maxObjects?: number;
         }
         interface RetrieveResult extends vimService.vim.DynamicData {
            token?: string;
            objects: Array<vimService.vim.ObjectContent>;
         }
         interface AboutInfo extends vimService.vim.DynamicData {
            name: string;
            fullName: string;
            vendor: string;
            version: string;
            build: string;
            localeVersion?: string;
            localeBuild?: string;
            osType: string;
            productLineId: string;
            apiType: string;
            apiVersion: string;
            instanceUuid?: string;
            licenseProductName?: string;
            licenseProductVersion?: string;
         }
         interface AuthorizationDescription extends vimService.vim.DynamicData {
            privilege: Array<vimService.vim.ElementDescription>;
            privilegeGroup: Array<vimService.vim.ElementDescription>;
         }
         interface Permission extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            principal: string;
            group: boolean;
            roleId: number;
            propagate: boolean;
         }
         interface ArrayOfPermission {
            permission?: Array<vimService.vim.Permission>;
         }
         interface AuthorizationRole extends vimService.vim.DynamicData {
            roleId: number;
            system: boolean;
            name: string;
            info: vimService.vim.Description;
            privilege?: Array<string>;
         }
         interface ArrayOfAuthorizationRole {
            authorizationRole?: Array<vimService.vim.AuthorizationRole>;
         }
         interface AuthorizationPrivilege extends vimService.vim.DynamicData {
            privId: string;
            onParent: boolean;
            name: string;
            privGroupName: string;
         }
         interface ArrayOfAuthorizationPrivilege {
            authorizationPrivilege?: Array<vimService.vim.AuthorizationPrivilege>;
         }
         interface PrivilegeAvailability extends vimService.vim.DynamicData {
            privId: string;
            isGranted: boolean;
         }
         interface ArrayOfPrivilegeAvailability {
            privilegeAvailability?: Array<vimService.vim.PrivilegeAvailability>;
         }
         interface EntityPrivilege extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            privAvailability: Array<vimService.vim.PrivilegeAvailability>;
         }
         interface ArrayOfEntityPrivilege {
            entityPrivilege?: Array<vimService.vim.EntityPrivilege>;
         }
         enum BatchResultResult {
            "success",
            "fail",
         }
         interface BatchResult extends vimService.vim.DynamicData {
            result: string;
            hostKey: string;
            ds?: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface BoolPolicy extends vimService.vim.InheritablePolicy {
            value?: boolean;
         }
         interface Capability extends vimService.vim.DynamicData {
            provisioningSupported: boolean;
            multiHostSupported: boolean;
            userShellAccessSupported: boolean;
            supportedEVCMode?: Array<vimService.vim.EVCMode>;
            networkBackupAndRestoreSupported?: boolean;
         }
         interface ClusterComputeResourceSummary extends vimService.vim.ComputeResourceSummary {
            currentFailoverLevel: number;
            admissionControlInfo?: vimService.vim.ClusterDasAdmissionControlInfo;
            numVmotions: number;
            targetBalance?: number;
            currentBalance?: number;
            usageSummary?: vimService.vim.ClusterUsageSummary;
            currentEVCModeKey?: string;
            dasData?: vimService.vim.ClusterDasData;
         }
         interface ComputeResourceSummary extends vimService.vim.DynamicData {
            totalCpu: number;
            totalMemory: number;
            numCpuCores: number;
            numCpuThreads: number;
            effectiveCpu: number;
            effectiveMemory: number;
            numHosts: number;
            numEffectiveHosts: number;
            overallStatus: vimService.vim.ManagedEntityStatus;
         }
         interface ComputeResourceConfigInfo extends vimService.vim.DynamicData {
            vmSwapPlacement: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState {
            "licensed",
            "unlicensed",
            "unknown",
         }
         interface ComputeResourceHostSPBMLicenseInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            licenseState: vimService.vim.ComputeResourceHostSPBMLicenseInfoHostSPBMLicenseState;
         }
         interface ArrayOfComputeResourceHostSPBMLicenseInfo {
            computeResourceHostSPBMLicenseInfo?: Array<vimService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface ComputeResourceConfigSpec extends vimService.vim.DynamicData {
            vmSwapPlacement?: string;
            spbmEnabled?: boolean;
            defaultHardwareVersionKey?: string;
         }
         enum ConfigSpecOperation {
            "add",
            "edit",
            "remove",
         }
         interface CustomFieldDef extends vimService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            managedObjectType?: string;
            fieldDefPrivileges?: vimService.vim.PrivilegePolicyDef;
            fieldInstancePrivileges?: vimService.vim.PrivilegePolicyDef;
         }
         interface ArrayOfCustomFieldDef {
            customFieldDef?: Array<vimService.vim.CustomFieldDef>;
         }
         interface CustomFieldValue extends vimService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfCustomFieldValue {
            customFieldValue?: Array<vimService.vim.CustomFieldValue>;
         }
         interface CustomFieldStringValue extends vimService.vim.CustomFieldValue {
            value: string;
         }
         interface CustomizationSpecInfo extends vimService.vim.DynamicData {
            name: string;
            description: string;
            type: string;
            changeVersion?: string;
            lastUpdateTime?: Date;
         }
         interface ArrayOfCustomizationSpecInfo {
            customizationSpecInfo?: Array<vimService.vim.CustomizationSpecInfo>;
         }
         interface CustomizationSpecItem extends vimService.vim.DynamicData {
            info: vimService.vim.CustomizationSpecInfo;
            spec: vimService.vim.CustomizationSpec;
         }
         interface DatacenterConfigInfo extends vimService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         interface DatacenterConfigSpec extends vimService.vim.DynamicData {
            defaultHardwareVersionKey?: string;
         }
         enum DatastoreAccessible {
            "True",
            "False",
         }
         enum DatastoreSummaryMaintenanceModeState {
            "normal",
            "enteringMaintenance",
            "inMaintenance",
         }
         interface DatastoreSummary extends vimService.vim.DynamicData {
            datastore?: vimService.vim.ManagedObjectReference;
            name: string;
            url: string;
            capacity: number;
            freeSpace: number;
            uncommitted?: number;
            accessible: boolean;
            multipleHostAccess?: boolean;
            type: string;
            maintenanceMode?: string;
         }
         interface DatastoreInfo extends vimService.vim.DynamicData {
            name: string;
            url: string;
            freeSpace: number;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            maxMemoryFileSize?: number;
            timestamp?: Date;
            containerId?: string;
         }
         interface DatastoreCapability extends vimService.vim.DynamicData {
            directoryHierarchySupported: boolean;
            rawDiskMappingsSupported: boolean;
            perFileThinProvisioningSupported: boolean;
            storageIORMSupported?: boolean;
            nativeSnapshotSupported?: boolean;
            nativeSnapshotCopySupported?: boolean;
            topLevelDirectoryCreateSupported?: boolean;
            seSparseSupported?: boolean;
         }
         interface DatastoreHostMount extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            mountInfo: vimService.vim.HostMountInfo;
         }
         interface ArrayOfDatastoreHostMount {
            datastoreHostMount?: Array<vimService.vim.DatastoreHostMount>;
         }
         interface DatastoreMountPathDatastorePair extends vimService.vim.DynamicData {
            oldMountPath: string;
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatastoreMountPathDatastorePair {
            datastoreMountPathDatastorePair?: Array<vimService.vim.DatastoreMountPathDatastorePair>;
         }
         interface Description extends vimService.vim.DynamicData {
            label: string;
            summary: string;
         }
         enum DiagnosticManagerLogCreator {
            "vpxd",
            "vpxa",
            "hostd",
            "serverd",
            "install",
            "vpxClient",
            "recordLog",
         }
         enum DiagnosticManagerLogFormat {
            "plain",
         }
         interface DiagnosticManagerLogDescriptor extends vimService.vim.DynamicData {
            key: string;
            fileName: string;
            creator: string;
            format: string;
            mimeType: string;
            info: vimService.vim.Description;
         }
         interface ArrayOfDiagnosticManagerLogDescriptor {
            diagnosticManagerLogDescriptor?: Array<vimService.vim.DiagnosticManagerLogDescriptor>;
         }
         interface DiagnosticManagerLogHeader extends vimService.vim.DynamicData {
            lineStart: number;
            lineEnd: number;
            lineText?: Array<string>;
         }
         interface DiagnosticManagerBundleInfo extends vimService.vim.DynamicData {
            system?: vimService.vim.ManagedObjectReference;
            url: string;
         }
         interface ArrayOfDiagnosticManagerBundleInfo {
            diagnosticManagerBundleInfo?: Array<vimService.vim.DiagnosticManagerBundleInfo>;
         }
         enum DistributedVirtualSwitchProductSpecOperationType {
            "preInstall",
            "upgrade",
            "notifyAvailableUpgrade",
            "proceedWithUpgrade",
            "updateBundleInfo",
         }
         interface DVSContactInfo extends vimService.vim.DynamicData {
            name?: string;
            contact?: string;
         }
         enum DistributedVirtualSwitchNicTeamingPolicyMode {
            "loadbalance_ip",
            "loadbalance_srcmac",
            "loadbalance_srcid",
            "failover_explicit",
            "loadbalance_loadbased",
         }
         interface DVSNetworkResourceManagementCapability extends vimService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            networkResourcePoolHighShareValue: number;
            qosSupported: boolean;
            userDefinedNetworkResourcePoolsSupported: boolean;
            networkResourceControlVersion3Supported?: boolean;
         }
         interface DVSRollbackCapability extends vimService.vim.DynamicData {
            rollbackSupported: boolean;
         }
         interface DVSBackupRestoreCapability extends vimService.vim.DynamicData {
            backupRestoreSupported: boolean;
         }
         interface DVSFeatureCapability extends vimService.vim.DynamicData {
            networkResourceManagementSupported: boolean;
            vmDirectPathGen2Supported: boolean;
            nicTeamingPolicy?: Array<string>;
            networkResourcePoolHighShareValue?: number;
            networkResourceManagementCapability?: vimService.vim.DVSNetworkResourceManagementCapability;
            healthCheckCapability?: vimService.vim.DVSHealthCheckCapability;
            rollbackCapability?: vimService.vim.DVSRollbackCapability;
            backupRestoreCapability?: vimService.vim.DVSBackupRestoreCapability;
            networkFilterSupported?: boolean;
         }
         interface DVSHealthCheckCapability extends vimService.vim.DynamicData {
         }
         interface DVSCapability extends vimService.vim.DynamicData {
            dvsOperationSupported?: boolean;
            dvPortGroupOperationSupported?: boolean;
            dvPortOperationSupported?: boolean;
            compatibleHostComponentProductInfo?: Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>;
            featuresSupported?: vimService.vim.DVSFeatureCapability;
         }
         interface DVSSummary extends vimService.vim.DynamicData {
            name: string;
            uuid: string;
            numPorts: number;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            hostMember?: Array<vimService.vim.ManagedObjectReference>;
            vm?: Array<vimService.vim.ManagedObjectReference>;
            host?: Array<vimService.vim.ManagedObjectReference>;
            portgroupName?: Array<string>;
            description?: string;
            contact?: vimService.vim.DVSContactInfo;
            numHosts?: number;
         }
         interface DVSPolicy extends vimService.vim.DynamicData {
            autoPreInstallAllowed?: boolean;
            autoUpgradeAllowed?: boolean;
            partialUpgradeAllowed?: boolean;
         }
         interface DVSUplinkPortPolicy extends vimService.vim.DynamicData {
         }
         interface DVSNameArrayUplinkPortPolicy extends vimService.vim.DVSUplinkPortPolicy {
            uplinkPortName: Array<string>;
         }
         interface DVSConfigSpec extends vimService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numStandalonePorts?: number;
            maxPorts?: number;
            uplinkPortPolicy?: vimService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            host?: Array<vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
            extensionKey?: string;
            description?: string;
            policy?: vimService.vim.DVSPolicy;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            contact?: vimService.vim.DVSContactInfo;
            switchIpAddress?: string;
            defaultProxySwitchMaxNumPorts?: number;
            infrastructureTrafficResourceConfig?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
            networkResourceControlVersion?: string;
         }
         interface DVSCreateSpec extends vimService.vim.DynamicData {
            configSpec: vimService.vim.DVSConfigSpec;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            capability?: vimService.vim.DVSCapability;
         }
         interface DVSConfigInfo extends vimService.vim.DynamicData {
            uuid: string;
            name: string;
            numStandalonePorts: number;
            numPorts: number;
            maxPorts: number;
            uplinkPortPolicy: vimService.vim.DVSUplinkPortPolicy;
            uplinkPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            defaultPortConfig: vimService.vim.DVPortSetting;
            host?: Array<vimService.vim.DistributedVirtualSwitchHostMember>;
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
            targetInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            extensionKey?: string;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            policy?: vimService.vim.DVSPolicy;
            description?: string;
            configVersion: string;
            contact: vimService.vim.DVSContactInfo;
            switchIpAddress?: string;
            createTime: Date;
            networkResourceManagementEnabled?: boolean;
            defaultProxySwitchMaxNumPorts?: number;
            healthCheckConfig?: Array<vimService.vim.DVSHealthCheckConfig>;
            infrastructureTrafficResourceConfig?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
            networkResourceControlVersion?: string;
            vmVnicNetworkResourcePool?: Array<vimService.vim.DVSVmVnicNetworkResourcePool>;
            pnicCapacityRatioForReservation?: number;
         }
         enum DistributedVirtualSwitchNetworkResourceControlVersion {
            "version2",
            "version3",
         }
         enum DistributedVirtualSwitchHostInfrastructureTrafficClass {
            "management",
            "faultTolerance",
            "vmotion",
            "virtualMachine",
            "iSCSI",
            "nfs",
            "hbr",
            "vsan",
            "vdp",
         }
         interface DvsHostInfrastructureTrafficResourceAllocation extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            reservation?: number;
         }
         interface DvsHostInfrastructureTrafficResource extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            allocationInfo: vimService.vim.DvsHostInfrastructureTrafficResourceAllocation;
         }
         interface ArrayOfDvsHostInfrastructureTrafficResource {
            dvsHostInfrastructureTrafficResource?: Array<vimService.vim.DvsHostInfrastructureTrafficResource>;
         }
         interface DVSHealthCheckConfig extends vimService.vim.DynamicData {
            enable?: boolean;
            interval?: number;
         }
         interface ArrayOfDVSHealthCheckConfig {
            dVSHealthCheckConfig?: Array<vimService.vim.DVSHealthCheckConfig>;
         }
         interface DvsResourceRuntimeInfo extends vimService.vim.DynamicData {
            capacity?: number;
            usage?: number;
            available?: number;
            allocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
            vmVnicNetworkResourcePoolRuntime?: Array<vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo>;
         }
         interface DVSRuntimeInfo extends vimService.vim.DynamicData {
            hostMemberRuntime?: Array<vimService.vim.HostMemberRuntimeInfo>;
            resourceRuntimeInfo?: vimService.vim.DvsResourceRuntimeInfo;
         }
         enum DrsInjectorWorkloadCorrelationState {
            "Correlated",
            "Uncorrelated",
         }
         interface EVCMode extends vimService.vim.ElementDescription {
            guaranteedCPUFeatures?: Array<vimService.vim.HostCpuIdInfo>;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            vendor: string;
            track?: Array<string>;
            vendorTier: number;
         }
         interface ArrayOfEVCMode {
            eVCMode?: Array<vimService.vim.EVCMode>;
         }
         interface ElementDescription extends vimService.vim.Description {
            key: string;
         }
         interface ArrayOfElementDescription {
            elementDescription?: Array<vimService.vim.ElementDescription>;
         }
         interface EnumDescription extends vimService.vim.DynamicData {
            key: string;
            tags: Array<vimService.vim.ElementDescription>;
         }
         interface ArrayOfEnumDescription {
            enumDescription?: Array<vimService.vim.EnumDescription>;
         }
         interface EnvironmentBrowserConfigOptionQuerySpec extends vimService.vim.DynamicData {
            key?: string;
            host?: vimService.vim.ManagedObjectReference;
            guestId?: Array<string>;
         }
         interface ExtendedDescription extends vimService.vim.Description {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ExtendedElementDescription extends vimService.vim.ElementDescription {
            messageCatalogKeyPrefix: string;
            messageArg?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ExtensionServerInfo extends vimService.vim.DynamicData {
            url: string;
            description: vimService.vim.Description;
            company: string;
            type: string;
            adminEmail: Array<string>;
            serverThumbprint?: string;
         }
         interface ArrayOfExtensionServerInfo {
            extensionServerInfo?: Array<vimService.vim.ExtensionServerInfo>;
         }
         interface ExtensionClientInfo extends vimService.vim.DynamicData {
            version: string;
            description: vimService.vim.Description;
            company: string;
            type: string;
            url: string;
         }
         interface ArrayOfExtensionClientInfo {
            extensionClientInfo?: Array<vimService.vim.ExtensionClientInfo>;
         }
         interface ExtensionTaskTypeInfo extends vimService.vim.DynamicData {
            taskID: string;
         }
         interface ArrayOfExtensionTaskTypeInfo {
            extensionTaskTypeInfo?: Array<vimService.vim.ExtensionTaskTypeInfo>;
         }
         interface ExtensionEventTypeInfo extends vimService.vim.DynamicData {
            eventID: string;
            eventTypeSchema?: string;
         }
         interface ArrayOfExtensionEventTypeInfo {
            extensionEventTypeInfo?: Array<vimService.vim.ExtensionEventTypeInfo>;
         }
         interface ExtensionFaultTypeInfo extends vimService.vim.DynamicData {
            faultID: string;
         }
         interface ArrayOfExtensionFaultTypeInfo {
            extensionFaultTypeInfo?: Array<vimService.vim.ExtensionFaultTypeInfo>;
         }
         interface ExtensionPrivilegeInfo extends vimService.vim.DynamicData {
            privID: string;
            privGroupName: string;
         }
         interface ArrayOfExtensionPrivilegeInfo {
            extensionPrivilegeInfo?: Array<vimService.vim.ExtensionPrivilegeInfo>;
         }
         interface ExtensionResourceInfo extends vimService.vim.DynamicData {
            locale: string;
            module: string;
            data: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfExtensionResourceInfo {
            extensionResourceInfo?: Array<vimService.vim.ExtensionResourceInfo>;
         }
         interface ExtensionHealthInfo extends vimService.vim.DynamicData {
            url: string;
         }
         interface ExtensionOvfConsumerInfo extends vimService.vim.DynamicData {
            callbackUrl: string;
            sectionType: Array<string>;
         }
         interface Extension extends vimService.vim.DynamicData {
            description: vimService.vim.Description;
            key: string;
            company?: string;
            type?: string;
            version: string;
            subjectName?: string;
            server?: Array<vimService.vim.ExtensionServerInfo>;
            client?: Array<vimService.vim.ExtensionClientInfo>;
            taskList?: Array<vimService.vim.ExtensionTaskTypeInfo>;
            eventList?: Array<vimService.vim.ExtensionEventTypeInfo>;
            faultList?: Array<vimService.vim.ExtensionFaultTypeInfo>;
            privilegeList?: Array<vimService.vim.ExtensionPrivilegeInfo>;
            resourceList?: Array<vimService.vim.ExtensionResourceInfo>;
            lastHeartbeatTime: Date;
            healthInfo?: vimService.vim.ExtensionHealthInfo;
            ovfConsumerInfo?: vimService.vim.ExtensionOvfConsumerInfo;
            extendedProductInfo?: vimService.vim.ExtExtendedProductInfo;
            managedEntityInfo?: Array<vimService.vim.ExtManagedEntityInfo>;
            shownInSolutionManager?: boolean;
            solutionManagerInfo?: vimService.vim.ExtSolutionManagerInfo;
         }
         interface ArrayOfExtension {
            extension?: Array<vimService.vim.Extension>;
         }
         interface ExtensionManagerIpAllocationUsage extends vimService.vim.DynamicData {
            extensionKey: string;
            numAddresses: number;
         }
         interface ArrayOfExtensionManagerIpAllocationUsage {
            extensionManagerIpAllocationUsage?: Array<vimService.vim.ExtensionManagerIpAllocationUsage>;
         }
         enum ReplicationVmState {
            "none",
            "paused",
            "syncing",
            "idle",
            "active",
            "error",
         }
         interface ReplicationVmProgressInfo extends vimService.vim.DynamicData {
            progress: number;
            bytesTransferred: number;
            bytesToTransfer: number;
            checksumTotalBytes?: number;
            checksumComparedBytes?: number;
         }
         interface HbrManagerReplicationVmInfo extends vimService.vim.DynamicData {
            state: string;
            progressInfo?: vimService.vim.ReplicationVmProgressInfo;
            imageId?: string;
            lastError?: vimService.vim.LocalizedMethodFault;
         }
         enum QuiesceMode {
            "application",
            "filesystem",
            "none",
         }
         interface HbrManagerVmReplicationCapability extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            supportedQuiesceMode: string;
            compressionSupported: boolean;
            maxSupportedSourceDiskCapacity: number;
            minRpo?: number;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHbrManagerVmReplicationCapability {
            hbrManagerVmReplicationCapability?: Array<vimService.vim.HbrManagerVmReplicationCapability>;
         }
         interface HostServiceTicket extends vimService.vim.DynamicData {
            host?: string;
            port?: number;
            sslThumbprint?: string;
            service: string;
            serviceVersion: string;
            sessionId: string;
         }
         enum HostSystemConnectionState {
            "connected",
            "notResponding",
            "disconnected",
         }
         enum HostSystemPowerState {
            "poweredOn",
            "poweredOff",
            "standBy",
            "unknown",
         }
         enum HostStandbyMode {
            "entering",
            "exiting",
            "in",
            "none",
         }
         interface HostSystemReconnectSpec extends vimService.vim.DynamicData {
            syncState?: boolean;
         }
         enum HttpNfcLeaseState {
            "initializing",
            "ready",
            "done",
            "error",
         }
         interface HttpNfcLeaseDatastoreLeaseInfo extends vimService.vim.DynamicData {
            datastoreKey: string;
            hosts: Array<vimService.vim.HttpNfcLeaseHostInfo>;
         }
         interface ArrayOfHttpNfcLeaseDatastoreLeaseInfo {
            httpNfcLeaseDatastoreLeaseInfo?: Array<vimService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseHostInfo extends vimService.vim.DynamicData {
            url: string;
            sslThumbprint: string;
         }
         interface ArrayOfHttpNfcLeaseHostInfo {
            httpNfcLeaseHostInfo?: Array<vimService.vim.HttpNfcLeaseHostInfo>;
         }
         interface HttpNfcLeaseInfo extends vimService.vim.DynamicData {
            lease: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            deviceUrl?: Array<vimService.vim.HttpNfcLeaseDeviceUrl>;
            totalDiskCapacityInKB: number;
            leaseTimeout: number;
            hostMap?: Array<vimService.vim.HttpNfcLeaseDatastoreLeaseInfo>;
         }
         interface HttpNfcLeaseDeviceUrl extends vimService.vim.DynamicData {
            key: string;
            importKey: string;
            url: string;
            sslThumbprint: string;
            disk?: boolean;
            targetId?: string;
            datastoreKey?: string;
            fileSize?: number;
         }
         interface ArrayOfHttpNfcLeaseDeviceUrl {
            httpNfcLeaseDeviceUrl?: Array<vimService.vim.HttpNfcLeaseDeviceUrl>;
         }
         interface HttpNfcLeaseManifestEntry extends vimService.vim.DynamicData {
            key: string;
            sha1: string;
            size: number;
            disk: boolean;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfHttpNfcLeaseManifestEntry {
            httpNfcLeaseManifestEntry?: Array<vimService.vim.HttpNfcLeaseManifestEntry>;
         }
         interface ImportSpec extends vimService.vim.DynamicData {
            entityConfig?: vimService.vim.VAppEntityConfigInfo;
            instantiationOst?: vimService.vim.OvfConsumerOstNode;
         }
         interface ArrayOfImportSpec {
            importSpec?: Array<vimService.vim.ImportSpec>;
         }
         interface InheritablePolicy extends vimService.vim.DynamicData {
            inherited: boolean;
         }
         interface IntExpression extends vimService.vim.NegatableExpression {
            value?: number;
         }
         interface IntPolicy extends vimService.vim.InheritablePolicy {
            value?: number;
         }
         interface IoFilterInfo extends vimService.vim.DynamicData {
            id: string;
            name: string;
            vendor: string;
            version: string;
            summary?: string;
            releaseDate?: string;
         }
         interface HostIoFilterInfo extends vimService.vim.IoFilterInfo {
            available: boolean;
         }
         interface ArrayOfHostIoFilterInfo {
            hostIoFilterInfo?: Array<vimService.vim.HostIoFilterInfo>;
         }
         enum IoFilterOperation {
            "install",
            "uninstall",
            "upgrade",
         }
         interface ClusterIoFilterInfo extends vimService.vim.IoFilterInfo {
            opType: string;
         }
         interface ArrayOfClusterIoFilterInfo {
            clusterIoFilterInfo?: Array<vimService.vim.ClusterIoFilterInfo>;
         }
         interface IoFilterHostIssue extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            issue: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfIoFilterHostIssue {
            ioFilterHostIssue?: Array<vimService.vim.IoFilterHostIssue>;
         }
         interface IoFilterQueryIssueResult extends vimService.vim.DynamicData {
            opType: string;
            hostIssue?: Array<vimService.vim.IoFilterHostIssue>;
         }
         interface IpAddress extends vimService.vim.NegatableExpression {
         }
         interface IpPoolManagerIpAllocation extends vimService.vim.DynamicData {
            ipAddress: string;
            allocationId: string;
         }
         interface ArrayOfIpPoolManagerIpAllocation {
            ipPoolManagerIpAllocation?: Array<vimService.vim.IpPoolManagerIpAllocation>;
         }
         interface IpRange extends vimService.vim.IpAddress {
            addressPrefix: string;
            prefixLength?: number;
         }
         interface KeyValue extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfKeyValue {
            keyValue?: Array<vimService.vim.KeyValue>;
         }
         enum LatencySensitivitySensitivityLevel {
            "low",
            "normal",
            "medium",
            "high",
            "custom",
         }
         interface LatencySensitivity extends vimService.vim.DynamicData {
            level: vimService.vim.LatencySensitivitySensitivityLevel;
            sensitivity?: number;
         }
         interface LicenseAssignmentManagerLicenseAssignment extends vimService.vim.DynamicData {
            entityId: string;
            scope?: string;
            entityDisplayName?: string;
            assignedLicense: vimService.vim.LicenseManagerLicenseInfo;
            properties?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfLicenseAssignmentManagerLicenseAssignment {
            licenseAssignmentManagerLicenseAssignment?: Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>;
         }
         enum LicenseManagerState {
            "initializing",
            "normal",
            "marginal",
            "fault",
         }
         enum LicenseManagerLicenseKey {
            "esxFull",
            "esxVmtn",
            "esxExpress",
            "san",
            "iscsi",
            "nas",
            "vsmp",
            "backup",
            "vc",
            "vcExpress",
            "esxHost",
            "gsxHost",
            "serverHost",
            "drsPower",
            "vmotion",
            "drs",
            "das",
         }
         interface LicenseSource extends vimService.vim.DynamicData {
         }
         interface LicenseServerSource extends vimService.vim.LicenseSource {
            licenseServer: string;
         }
         interface LocalLicenseSource extends vimService.vim.LicenseSource {
            licenseKeys: string;
         }
         interface EvaluationLicenseSource extends vimService.vim.LicenseSource {
            remainingHours?: number;
         }
         enum LicenseFeatureInfoUnit {
            "host",
            "cpuCore",
            "cpuPackage",
            "server",
            "vm",
         }
         enum LicenseFeatureInfoState {
            "enabled",
            "disabled",
            "optional",
         }
         enum LicenseFeatureInfoSourceRestriction {
            "unrestricted",
            "served",
            "file",
         }
         interface LicenseFeatureInfo extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            featureDescription?: string;
            state?: vimService.vim.LicenseFeatureInfoState;
            costUnit: string;
            sourceRestriction?: string;
            dependentKey?: Array<string>;
            edition?: boolean;
            expiresOn?: Date;
         }
         interface ArrayOfLicenseFeatureInfo {
            licenseFeatureInfo?: Array<vimService.vim.LicenseFeatureInfo>;
         }
         enum LicenseReservationInfoState {
            "notUsed",
            "noLicense",
            "unlicensedUse",
            "licensed",
         }
         interface LicenseReservationInfo extends vimService.vim.DynamicData {
            key: string;
            state: vimService.vim.LicenseReservationInfoState;
            required: number;
         }
         interface ArrayOfLicenseReservationInfo {
            licenseReservationInfo?: Array<vimService.vim.LicenseReservationInfo>;
         }
         interface LicenseAvailabilityInfo extends vimService.vim.DynamicData {
            feature: vimService.vim.LicenseFeatureInfo;
            total: number;
            available: number;
         }
         interface ArrayOfLicenseAvailabilityInfo {
            licenseAvailabilityInfo?: Array<vimService.vim.LicenseAvailabilityInfo>;
         }
         interface LicenseDiagnostics extends vimService.vim.DynamicData {
            sourceLastChanged: Date;
            sourceLost: string;
            sourceLatency: number;
            licenseRequests: string;
            licenseRequestFailures: string;
            licenseFeatureUnknowns: string;
            opState: vimService.vim.LicenseManagerState;
            lastStatusUpdate: Date;
            opFailureMessage: string;
         }
         interface LicenseUsageInfo extends vimService.vim.DynamicData {
            source: vimService.vim.LicenseSource;
            sourceAvailable: boolean;
            reservationInfo?: Array<vimService.vim.LicenseReservationInfo>;
            featureInfo?: Array<vimService.vim.LicenseFeatureInfo>;
         }
         interface LicenseManagerEvaluationInfo extends vimService.vim.DynamicData {
            properties: Array<vimService.vim.KeyAnyValue>;
         }
         enum HostLicensableResourceKey {
            "numCpuPackages",
            "numCpuCores",
            "memorySize",
            "memoryForVms",
            "numVmsStarted",
            "numVmsStarting",
         }
         interface HostLicensableResourceInfo extends vimService.vim.DynamicData {
            resource: Array<vimService.vim.KeyAnyValue>;
         }
         interface LicenseManagerLicenseInfo extends vimService.vim.DynamicData {
            licenseKey: string;
            editionKey: string;
            name: string;
            total: number;
            used?: number;
            costUnit: string;
            properties?: Array<vimService.vim.KeyAnyValue>;
            labels?: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfLicenseManagerLicenseInfo {
            licenseManagerLicenseInfo?: Array<vimService.vim.LicenseManagerLicenseInfo>;
         }
         interface LocalizationManagerMessageCatalog extends vimService.vim.DynamicData {
            moduleName: string;
            catalogName: string;
            locale: string;
            catalogUri: string;
            lastModified?: Date;
            md5sum?: string;
            version?: string;
         }
         interface ArrayOfLocalizationManagerMessageCatalog {
            localizationManagerMessageCatalog?: Array<vimService.vim.LocalizationManagerMessageCatalog>;
         }
         interface LongPolicy extends vimService.vim.InheritablePolicy {
            value?: number;
         }
         interface MacAddress extends vimService.vim.NegatableExpression {
         }
         interface MacRange extends vimService.vim.MacAddress {
            address: string;
            mask: string;
         }
         enum ManagedEntityStatus {
            "gray",
            "green",
            "yellow",
            "red",
         }
         interface MethodDescription extends vimService.vim.Description {
            key: string;
         }
         interface NegatableExpression extends vimService.vim.DynamicData {
            negate?: boolean;
         }
         interface NetworkSummary extends vimService.vim.DynamicData {
            network?: vimService.vim.ManagedObjectReference;
            name: string;
            accessible: boolean;
            ipPoolName?: string;
            ipPoolId?: number;
         }
         interface NumericRange extends vimService.vim.DynamicData {
            start: number;
            end: number;
         }
         interface ArrayOfNumericRange {
            numericRange?: Array<vimService.vim.NumericRange>;
         }
         interface OpaqueNetworkSummary extends vimService.vim.NetworkSummary {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface OvfConsumerOvfSection extends vimService.vim.DynamicData {
            lineNumber: number;
            xml: string;
         }
         interface ArrayOfOvfConsumerOvfSection {
            ovfConsumerOvfSection?: Array<vimService.vim.OvfConsumerOvfSection>;
         }
         enum OvfConsumerOstNodeType {
            "envelope",
            "virtualSystem",
            "virtualSystemCollection",
         }
         interface OvfConsumerOstNode extends vimService.vim.DynamicData {
            id: string;
            type: string;
            section?: Array<vimService.vim.OvfConsumerOvfSection>;
            child?: Array<vimService.vim.OvfConsumerOstNode>;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfConsumerOstNode {
            ovfConsumerOstNode?: Array<vimService.vim.OvfConsumerOstNode>;
         }
         interface OvfOptionInfo extends vimService.vim.DynamicData {
            option: string;
            description: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfOvfOptionInfo {
            ovfOptionInfo?: Array<vimService.vim.OvfOptionInfo>;
         }
         interface OvfDeploymentOption extends vimService.vim.DynamicData {
            key: string;
            label: string;
            description: string;
         }
         interface ArrayOfOvfDeploymentOption {
            ovfDeploymentOption?: Array<vimService.vim.OvfDeploymentOption>;
         }
         interface OvfManagerCommonParams extends vimService.vim.DynamicData {
            locale: string;
            deploymentOption: string;
            msgBundle?: Array<vimService.vim.KeyValue>;
            importOption?: Array<string>;
         }
         interface OvfValidateHostParams extends vimService.vim.OvfManagerCommonParams {
         }
         interface OvfValidateHostResult extends vimService.vim.DynamicData {
            downloadSize?: number;
            flatDeploymentSize?: number;
            sparseDeploymentSize?: number;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            supportedDiskProvisioning?: Array<string>;
         }
         interface OvfParseDescriptorParams extends vimService.vim.OvfManagerCommonParams {
         }
         interface OvfParseDescriptorResult extends vimService.vim.DynamicData {
            eula?: Array<string>;
            network?: Array<vimService.vim.OvfNetworkInfo>;
            ipAllocationScheme?: Array<string>;
            ipProtocols?: Array<string>;
            property?: Array<vimService.vim.VAppPropertyInfo>;
            productInfo?: vimService.vim.VAppProductInfo;
            annotation: string;
            approximateDownloadSize?: number;
            approximateFlatDeploymentSize?: number;
            approximateSparseDeploymentSize?: number;
            defaultEntityName: string;
            virtualApp: boolean;
            deploymentOption?: Array<vimService.vim.OvfDeploymentOption>;
            defaultDeploymentOption: string;
            entityName?: Array<vimService.vim.KeyValue>;
            annotatedOst?: vimService.vim.OvfConsumerOstNode;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface OvfNetworkInfo extends vimService.vim.DynamicData {
            name: string;
            description: string;
         }
         interface ArrayOfOvfNetworkInfo {
            ovfNetworkInfo?: Array<vimService.vim.OvfNetworkInfo>;
         }
         enum OvfCreateImportSpecParamsDiskProvisioningType {
            "monolithicSparse",
            "monolithicFlat",
            "twoGbMaxExtentSparse",
            "twoGbMaxExtentFlat",
            "thin",
            "thick",
            "seSparse",
            "eagerZeroedThick",
            "sparse",
            "flat",
         }
         interface OvfCreateImportSpecParams extends vimService.vim.OvfManagerCommonParams {
            entityName: string;
            hostSystem?: vimService.vim.ManagedObjectReference;
            networkMapping?: Array<vimService.vim.OvfNetworkMapping>;
            ipAllocationPolicy?: string;
            ipProtocol?: string;
            propertyMapping?: Array<vimService.vim.KeyValue>;
            resourceMapping?: Array<vimService.vim.OvfResourceMap>;
            diskProvisioning?: string;
            instantiationOst?: vimService.vim.OvfConsumerOstNode;
         }
         interface OvfResourceMap extends vimService.vim.DynamicData {
            source: string;
            parent?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfResourceMap {
            ovfResourceMap?: Array<vimService.vim.OvfResourceMap>;
         }
         interface OvfNetworkMapping extends vimService.vim.DynamicData {
            name: string;
            network: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfOvfNetworkMapping {
            ovfNetworkMapping?: Array<vimService.vim.OvfNetworkMapping>;
         }
         interface OvfCreateImportSpecResult extends vimService.vim.DynamicData {
            importSpec?: vimService.vim.ImportSpec;
            fileItem?: Array<vimService.vim.OvfFileItem>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface OvfFileItem extends vimService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size?: number;
            cimType: number;
            create: boolean;
         }
         interface ArrayOfOvfFileItem {
            ovfFileItem?: Array<vimService.vim.OvfFileItem>;
         }
         interface OvfCreateDescriptorParams extends vimService.vim.DynamicData {
            ovfFiles?: Array<vimService.vim.OvfFile>;
            name?: string;
            description?: string;
            includeImageFiles?: boolean;
            exportOption?: Array<string>;
            snapshot?: vimService.vim.ManagedObjectReference;
         }
         interface OvfCreateDescriptorResult extends vimService.vim.DynamicData {
            ovfDescriptor: string;
            error?: Array<vimService.vim.LocalizedMethodFault>;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            includeImageFiles?: boolean;
         }
         interface OvfFile extends vimService.vim.DynamicData {
            deviceId: string;
            path: string;
            compressionMethod?: string;
            chunkSize?: number;
            size: number;
            capacity?: number;
            populatedSize?: number;
         }
         interface ArrayOfOvfFile {
            ovfFile?: Array<vimService.vim.OvfFile>;
         }
         interface PasswordField extends vimService.vim.DynamicData {
            value: string;
         }
         interface PerformanceDescription extends vimService.vim.DynamicData {
            counterType: Array<vimService.vim.ElementDescription>;
            statsType: Array<vimService.vim.ElementDescription>;
         }
         enum PerfFormat {
            "normal",
            "csv",
         }
         interface PerfProviderSummary extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            currentSupported: boolean;
            summarySupported: boolean;
            refreshRate?: number;
         }
         enum PerfSummaryType {
            "average",
            "maximum",
            "minimum",
            "latest",
            "summation",
            "none",
         }
         enum PerfStatsType {
            "absolute",
            "delta",
            "rate",
         }
         enum PerformanceManagerUnit {
            "percent",
            "kiloBytes",
            "megaBytes",
            "megaHertz",
            "number",
            "microsecond",
            "millisecond",
            "second",
            "kiloBytesPerSecond",
            "megaBytesPerSecond",
            "watt",
            "joule",
            "teraBytes",
         }
         interface PerfCounterInfo extends vimService.vim.DynamicData {
            key: number;
            nameInfo: vimService.vim.ElementDescription;
            groupInfo: vimService.vim.ElementDescription;
            unitInfo: vimService.vim.ElementDescription;
            rollupType: vimService.vim.PerfSummaryType;
            statsType: vimService.vim.PerfStatsType;
            level?: number;
            perDeviceLevel?: number;
            associatedCounterId?: Array<number>;
         }
         interface ArrayOfPerfCounterInfo {
            perfCounterInfo?: Array<vimService.vim.PerfCounterInfo>;
         }
         interface PerfMetricId extends vimService.vim.DynamicData {
            counterId: number;
            instance: string;
         }
         interface ArrayOfPerfMetricId {
            perfMetricId?: Array<vimService.vim.PerfMetricId>;
         }
         interface PerfQuerySpec extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            startTime?: Date;
            endTime?: Date;
            maxSample?: number;
            metricId?: Array<vimService.vim.PerfMetricId>;
            intervalId?: number;
            format?: string;
         }
         interface ArrayOfPerfQuerySpec {
            perfQuerySpec?: Array<vimService.vim.PerfQuerySpec>;
         }
         interface PerfSampleInfo extends vimService.vim.DynamicData {
            timestamp: Date;
            interval: number;
         }
         interface ArrayOfPerfSampleInfo {
            perfSampleInfo?: Array<vimService.vim.PerfSampleInfo>;
         }
         interface PerfMetricSeries extends vimService.vim.DynamicData {
            id: vimService.vim.PerfMetricId;
         }
         interface ArrayOfPerfMetricSeries {
            perfMetricSeries?: Array<vimService.vim.PerfMetricSeries>;
         }
         interface PerfMetricIntSeries extends vimService.vim.PerfMetricSeries {
            value?: Array<number>;
         }
         interface PerfMetricSeriesCSV extends vimService.vim.PerfMetricSeries {
            value?: string;
         }
         interface ArrayOfPerfMetricSeriesCSV {
            perfMetricSeriesCSV?: Array<vimService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfEntityMetricBase extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfPerfEntityMetricBase {
            perfEntityMetricBase?: Array<vimService.vim.PerfEntityMetricBase>;
         }
         interface PerfEntityMetric extends vimService.vim.PerfEntityMetricBase {
            sampleInfo?: Array<vimService.vim.PerfSampleInfo>;
            value?: Array<vimService.vim.PerfMetricSeries>;
         }
         interface PerfEntityMetricCSV extends vimService.vim.PerfEntityMetricBase {
            sampleInfoCSV: string;
            value?: Array<vimService.vim.PerfMetricSeriesCSV>;
         }
         interface PerfCompositeMetric extends vimService.vim.DynamicData {
            entity?: vimService.vim.PerfEntityMetricBase;
            childEntity?: Array<vimService.vim.PerfEntityMetricBase>;
         }
         interface PerformanceManagerCounterLevelMapping extends vimService.vim.DynamicData {
            counterId: number;
            aggregateLevel?: number;
            perDeviceLevel?: number;
         }
         interface ArrayOfPerformanceManagerCounterLevelMapping {
            performanceManagerCounterLevelMapping?: Array<vimService.vim.PerformanceManagerCounterLevelMapping>;
         }
         interface PerfInterval extends vimService.vim.DynamicData {
            key: number;
            samplingPeriod: number;
            name: string;
            length: number;
            level?: number;
            enabled: boolean;
         }
         interface ArrayOfPerfInterval {
            perfInterval?: Array<vimService.vim.PerfInterval>;
         }
         interface PosixUserSearchResult extends vimService.vim.UserSearchResult {
            id: number;
            shellAccess?: boolean;
         }
         interface PrivilegePolicyDef extends vimService.vim.DynamicData {
            createPrivilege: string;
            readPrivilege: string;
            updatePrivilege: string;
            deletePrivilege: string;
         }
         interface ResourceAllocationInfo extends vimService.vim.DynamicData {
            reservation?: number;
            expandableReservation?: boolean;
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            overheadLimit?: number;
         }
         interface ResourceAllocationOption extends vimService.vim.DynamicData {
            sharesOption: vimService.vim.SharesOption;
         }
         interface ResourceConfigOption extends vimService.vim.DynamicData {
            cpuAllocationOption: vimService.vim.ResourceAllocationOption;
            memoryAllocationOption: vimService.vim.ResourceAllocationOption;
         }
         interface ResourceConfigSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            changeVersion?: string;
            lastModified?: Date;
            cpuAllocation: vimService.vim.ResourceAllocationInfo;
            memoryAllocation: vimService.vim.ResourceAllocationInfo;
         }
         interface ArrayOfResourceConfigSpec {
            resourceConfigSpec?: Array<vimService.vim.ResourceConfigSpec>;
         }
         interface DatabaseSizeParam extends vimService.vim.DynamicData {
            inventoryDesc: vimService.vim.InventoryDescription;
            perfStatsDesc?: vimService.vim.PerformanceStatisticsDescription;
         }
         interface InventoryDescription extends vimService.vim.DynamicData {
            numHosts: number;
            numVirtualMachines: number;
            numResourcePools?: number;
            numClusters?: number;
            numCpuDev?: number;
            numNetDev?: number;
            numDiskDev?: number;
            numvCpuDev?: number;
            numvNetDev?: number;
            numvDiskDev?: number;
         }
         interface PerformanceStatisticsDescription extends vimService.vim.DynamicData {
            intervals?: Array<vimService.vim.PerfInterval>;
         }
         interface DatabaseSizeEstimate extends vimService.vim.DynamicData {
            size: number;
         }
         interface ResourcePoolResourceUsage extends vimService.vim.DynamicData {
            reservationUsed: number;
            reservationUsedForVm: number;
            unreservedForPool: number;
            unreservedForVm: number;
            overallUsage: number;
            maxUsage: number;
         }
         interface ResourcePoolRuntimeInfo extends vimService.vim.DynamicData {
            memory: vimService.vim.ResourcePoolResourceUsage;
            cpu: vimService.vim.ResourcePoolResourceUsage;
            overallStatus: vimService.vim.ManagedEntityStatus;
         }
         interface ResourcePoolQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            overheadMemory?: number;
            consumedOverheadMemory?: number;
            compressedMemory?: number;
         }
         interface ResourcePoolSummary extends vimService.vim.DynamicData {
            name: string;
            config: vimService.vim.ResourceConfigSpec;
            runtime: vimService.vim.ResourcePoolRuntimeInfo;
            quickStats?: vimService.vim.ResourcePoolQuickStats;
            configuredMemoryMB?: number;
         }
         interface SelectionSet extends vimService.vim.DynamicData {
         }
         interface ArrayOfSelectionSet {
            selectionSet?: Array<vimService.vim.SelectionSet>;
         }
         enum ValidateMigrationTestType {
            "sourceTests",
            "compatibilityTests",
            "diskAccessibilityTests",
            "resourceTests",
         }
         enum VMotionCompatibilityType {
            "cpu",
            "software",
         }
         interface HostVMotionCompatibility extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            compatibility?: Array<string>;
         }
         interface ArrayOfHostVMotionCompatibility {
            hostVMotionCompatibility?: Array<vimService.vim.HostVMotionCompatibility>;
         }
         interface ProductComponentInfo extends vimService.vim.DynamicData {
            id: string;
            name: string;
            version: string;
            release: number;
         }
         interface ArrayOfProductComponentInfo {
            productComponentInfo?: Array<vimService.vim.ProductComponentInfo>;
         }
         interface ServiceContent extends vimService.vim.DynamicData {
            rootFolder: vimService.vim.ManagedObjectReference;
            propertyCollector: vimService.vim.ManagedObjectReference;
            viewManager?: vimService.vim.ManagedObjectReference;
            about: vimService.vim.AboutInfo;
            setting?: vimService.vim.ManagedObjectReference;
            userDirectory?: vimService.vim.ManagedObjectReference;
            sessionManager?: vimService.vim.ManagedObjectReference;
            authorizationManager?: vimService.vim.ManagedObjectReference;
            serviceManager?: vimService.vim.ManagedObjectReference;
            perfManager?: vimService.vim.ManagedObjectReference;
            scheduledTaskManager?: vimService.vim.ManagedObjectReference;
            alarmManager?: vimService.vim.ManagedObjectReference;
            eventManager?: vimService.vim.ManagedObjectReference;
            taskManager?: vimService.vim.ManagedObjectReference;
            extensionManager?: vimService.vim.ManagedObjectReference;
            customizationSpecManager?: vimService.vim.ManagedObjectReference;
            customFieldsManager?: vimService.vim.ManagedObjectReference;
            accountManager?: vimService.vim.ManagedObjectReference;
            diagnosticManager?: vimService.vim.ManagedObjectReference;
            licenseManager?: vimService.vim.ManagedObjectReference;
            searchIndex?: vimService.vim.ManagedObjectReference;
            fileManager?: vimService.vim.ManagedObjectReference;
            datastoreNamespaceManager?: vimService.vim.ManagedObjectReference;
            virtualDiskManager?: vimService.vim.ManagedObjectReference;
            virtualizationManager?: vimService.vim.ManagedObjectReference;
            snmpSystem?: vimService.vim.ManagedObjectReference;
            vmProvisioningChecker?: vimService.vim.ManagedObjectReference;
            vmCompatibilityChecker?: vimService.vim.ManagedObjectReference;
            ovfManager?: vimService.vim.ManagedObjectReference;
            ipPoolManager?: vimService.vim.ManagedObjectReference;
            dvSwitchManager?: vimService.vim.ManagedObjectReference;
            hostProfileManager?: vimService.vim.ManagedObjectReference;
            clusterProfileManager?: vimService.vim.ManagedObjectReference;
            complianceManager?: vimService.vim.ManagedObjectReference;
            localizationManager?: vimService.vim.ManagedObjectReference;
            storageResourceManager?: vimService.vim.ManagedObjectReference;
            guestOperationsManager?: vimService.vim.ManagedObjectReference;
            overheadMemoryManager?: vimService.vim.ManagedObjectReference;
            certificateManager?: vimService.vim.ManagedObjectReference;
            ioFilterManager?: vimService.vim.ManagedObjectReference;
         }
         interface ServiceLocatorCredential extends vimService.vim.DynamicData {
         }
         interface ServiceLocatorNamePassword extends vimService.vim.ServiceLocatorCredential {
            username: string;
            password: string;
         }
         interface ServiceLocatorSAMLCredential extends vimService.vim.ServiceLocatorCredential {
            token?: string;
         }
         interface ServiceLocator extends vimService.vim.DynamicData {
            instanceUuid: string;
            url: string;
            credential: vimService.vim.ServiceLocatorCredential;
            sslThumbprint?: string;
         }
         interface ArrayOfServiceLocator {
            serviceLocator?: Array<vimService.vim.ServiceLocator>;
         }
         interface ServiceManagerServiceInfo extends vimService.vim.DynamicData {
            serviceName: string;
            location?: Array<string>;
            service: vimService.vim.ManagedObjectReference;
            description: string;
         }
         interface ArrayOfServiceManagerServiceInfo {
            serviceManagerServiceInfo?: Array<vimService.vim.ServiceManagerServiceInfo>;
         }
         interface SessionManagerLocalTicket extends vimService.vim.DynamicData {
            userName: string;
            passwordFilePath: string;
         }
         interface SessionManagerGenericServiceTicket extends vimService.vim.DynamicData {
            id: string;
            hostName?: string;
            sslThumbprint?: string;
         }
         interface SessionManagerServiceRequestSpec extends vimService.vim.DynamicData {
         }
         interface SessionManagerVmomiServiceRequestSpec extends vimService.vim.SessionManagerServiceRequestSpec {
            method: string;
         }
         enum SessionManagerHttpServiceRequestSpecMethod {
            "httpOptions",
            "httpGet",
            "httpHead",
            "httpPost",
            "httpPut",
            "httpDelete",
            "httpTrace",
            "httpConnect",
         }
         interface SessionManagerHttpServiceRequestSpec extends vimService.vim.SessionManagerServiceRequestSpec {
            method?: string;
            url: string;
         }
         enum SharesLevel {
            "low",
            "normal",
            "high",
            "custom",
         }
         interface SharesInfo extends vimService.vim.DynamicData {
            shares: number;
            level: vimService.vim.SharesLevel;
         }
         interface SharesOption extends vimService.vim.DynamicData {
            sharesOption: vimService.vim.IntOption;
            defaultLevel: vimService.vim.SharesLevel;
         }
         enum SimpleCommandEncoding {
            "CSV",
            "HEX",
            "STRING",
         }
         interface SingleIp extends vimService.vim.IpAddress {
            address: string;
         }
         interface SingleMac extends vimService.vim.MacAddress {
            address: string;
         }
         interface StoragePodSummary extends vimService.vim.DynamicData {
            name: string;
            capacity: number;
            freeSpace: number;
         }
         interface StorageIOAllocationInfo extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            reservation?: number;
         }
         interface StorageIOAllocationOption extends vimService.vim.DynamicData {
            limitOption: vimService.vim.LongOption;
            sharesOption: vimService.vim.SharesOption;
         }
         enum StorageIORMThresholdMode {
            "automatic",
            "manual",
         }
         interface StorageIORMInfo extends vimService.vim.DynamicData {
            enabled: boolean;
            congestionThresholdMode?: string;
            congestionThreshold: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            reservationEnabled?: boolean;
            statsAggregationDisabled?: boolean;
            reservableIopsThreshold?: number;
         }
         interface StorageIORMConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            congestionThresholdMode?: string;
            congestionThreshold?: number;
            percentOfPeakThroughput?: number;
            statsCollectionEnabled?: boolean;
            reservationEnabled?: boolean;
            statsAggregationDisabled?: boolean;
            reservableIopsThreshold?: number;
         }
         interface StorageIORMConfigOption extends vimService.vim.DynamicData {
            enabledOption: vimService.vim.BoolOption;
            congestionThresholdOption: vimService.vim.IntOption;
            statsCollectionEnabledOption?: vimService.vim.BoolOption;
            reservationEnabledOption?: vimService.vim.BoolOption;
         }
         interface StoragePerformanceSummary extends vimService.vim.DynamicData {
            interval: number;
            percentile: Array<number>;
            datastoreReadLatency: Array<number>;
            datastoreWriteLatency: Array<number>;
            datastoreVmLatency: Array<number>;
            datastoreReadIops: Array<number>;
            datastoreWriteIops: Array<number>;
            siocActivityDuration: number;
         }
         interface ArrayOfStoragePerformanceSummary {
            storagePerformanceSummary?: Array<vimService.vim.StoragePerformanceSummary>;
         }
         interface PodStorageDrsEntry extends vimService.vim.DynamicData {
            storageDrsConfig: vimService.vim.StorageDrsConfigInfo;
            recommendation?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: Array<vimService.vim.ClusterDrsFaults>;
            actionHistory?: Array<vimService.vim.ClusterActionHistory>;
         }
         interface StorageResourceManagerStorageProfileStatistics extends vimService.vim.DynamicData {
            profileId: string;
            totalSpaceMB: number;
            usedSpaceMB: number;
         }
         interface StringExpression extends vimService.vim.NegatableExpression {
            value?: string;
         }
         interface StringPolicy extends vimService.vim.InheritablePolicy {
            value?: string;
         }
         interface Tag extends vimService.vim.DynamicData {
            key: string;
         }
         interface ArrayOfTag {
            tag?: Array<vimService.vim.Tag>;
         }
         interface TaskDescription extends vimService.vim.DynamicData {
            methodInfo: Array<vimService.vim.ElementDescription>;
            state: Array<vimService.vim.ElementDescription>;
            reason: Array<vimService.vim.TypeDescription>;
         }
         enum TaskFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         enum TaskFilterSpecTimeOption {
            "queuedTime",
            "startedTime",
            "completedTime",
         }
         interface TaskFilterSpecByEntity extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            recursion: vimService.vim.TaskFilterSpecRecursionOption;
         }
         interface TaskFilterSpecByTime extends vimService.vim.DynamicData {
            timeType: vimService.vim.TaskFilterSpecTimeOption;
            beginTime?: Date;
            endTime?: Date;
         }
         interface TaskFilterSpecByUsername extends vimService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface TaskFilterSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.TaskFilterSpecByEntity;
            time?: vimService.vim.TaskFilterSpecByTime;
            userName?: vimService.vim.TaskFilterSpecByUsername;
            activationId?: Array<string>;
            state?: Array<vimService.vim.TaskInfoState>;
            alarm?: vimService.vim.ManagedObjectReference;
            scheduledTask?: vimService.vim.ManagedObjectReference;
            eventChainId?: Array<number>;
            tag?: Array<string>;
            parentTaskKey?: Array<string>;
            rootTaskKey?: Array<string>;
         }
         enum TaskInfoState {
            "queued",
            "running",
            "success",
            "error",
         }
         interface ArrayOfTaskInfoState {
            taskInfoState?: Array<vimService.vim.TaskInfoState>;
         }
         interface TaskInfo extends vimService.vim.DynamicData {
            key: string;
            task: vimService.vim.ManagedObjectReference;
            description?: vimService.vim.LocalizableMessage;
            name?: string;
            descriptionId: string;
            entity?: vimService.vim.ManagedObjectReference;
            entityName?: string;
            locked?: Array<vimService.vim.ManagedObjectReference>;
            state: vimService.vim.TaskInfoState;
            cancelled: boolean;
            cancelable: boolean;
            error?: vimService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            reason: vimService.vim.TaskReason;
            queueTime: Date;
            startTime?: Date;
            completeTime?: Date;
            eventChainId: number;
            changeTag?: string;
            parentTaskKey?: string;
            rootTaskKey?: string;
            activationId?: string;
         }
         interface ArrayOfTaskInfo {
            taskInfo?: Array<vimService.vim.TaskInfo>;
         }
         interface TaskReason extends vimService.vim.DynamicData {
         }
         interface TaskReasonSystem extends vimService.vim.TaskReason {
         }
         interface TaskReasonUser extends vimService.vim.TaskReason {
            userName: string;
         }
         interface TaskReasonAlarm extends vimService.vim.TaskReason {
            alarmName: string;
            alarm: vimService.vim.ManagedObjectReference;
            entityName: string;
            entity: vimService.vim.ManagedObjectReference;
         }
         interface TaskReasonSchedule extends vimService.vim.TaskReason {
            name: string;
            scheduledTask: vimService.vim.ManagedObjectReference;
         }
         interface TypeDescription extends vimService.vim.Description {
            key: string;
         }
         interface ArrayOfTypeDescription {
            typeDescription?: Array<vimService.vim.TypeDescription>;
         }
         interface UpdateVirtualMachineFilesResultFailedVmFileInfo extends vimService.vim.DynamicData {
            vmFile: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfUpdateVirtualMachineFilesResultFailedVmFileInfo {
            updateVirtualMachineFilesResultFailedVmFileInfo?: Array<vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UpdateVirtualMachineFilesResult extends vimService.vim.DynamicData {
            failedVmFile?: Array<vimService.vim.UpdateVirtualMachineFilesResultFailedVmFileInfo>;
         }
         interface UserSearchResult extends vimService.vim.DynamicData {
            principal: string;
            fullName?: string;
            group: boolean;
         }
         interface ArrayOfUserSearchResult {
            userSearchResult?: Array<vimService.vim.UserSearchResult>;
         }
         interface UserSession extends vimService.vim.DynamicData {
            key: string;
            userName: string;
            fullName: string;
            loginTime: Date;
            lastActiveTime: Date;
            locale: string;
            messageLocale: string;
            extensionSession?: boolean;
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
         }
         interface ArrayOfUserSession {
            userSession?: Array<vimService.vim.UserSession>;
         }
         interface VASAStorageArray extends vimService.vim.DynamicData {
            name: string;
            uuid: string;
            vendorId: string;
            modelId: string;
         }
         interface ArrayOfVASAStorageArray {
            vASAStorageArray?: Array<vimService.vim.VASAStorageArray>;
         }
         interface VasaProviderContainerSpec extends vimService.vim.DynamicData {
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            scId: string;
            deleted: boolean;
         }
         interface VimVasaProviderStatePerArray extends vimService.vim.DynamicData {
            priority: number;
            arrayId: string;
            active: boolean;
         }
         interface ArrayOfVimVasaProviderStatePerArray {
            vimVasaProviderStatePerArray?: Array<vimService.vim.VimVasaProviderStatePerArray>;
         }
         interface VimVasaProvider extends vimService.vim.DynamicData {
            url: string;
            name?: string;
            selfSignedCertificate?: string;
         }
         interface VimVasaProviderInfo extends vimService.vim.DynamicData {
            provider: vimService.vim.VimVasaProvider;
            arrayState?: Array<vimService.vim.VimVasaProviderStatePerArray>;
         }
         interface ArrayOfVimVasaProviderInfo {
            vimVasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
         }
         enum VirtualAppVAppState {
            "started",
            "stopped",
            "starting",
            "stopping",
         }
         interface VirtualAppSummary extends vimService.vim.ResourcePoolSummary {
            product?: vimService.vim.VAppProductInfo;
            vAppState?: vimService.vim.VirtualAppVAppState;
            suspended?: boolean;
            installBootRequired?: boolean;
            instanceUuid?: string;
         }
         interface VirtualAppLinkInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVirtualAppLinkInfo {
            virtualAppLinkInfo?: Array<vimService.vim.VirtualAppLinkInfo>;
         }
         enum VirtualDiskType {
            "preallocated",
            "thin",
            "seSparse",
            "rdm",
            "rdmp",
            "raw",
            "delta",
            "sparse2Gb",
            "thick2Gb",
            "eagerZeroedThick",
            "sparseMonolithic",
            "flatMonolithic",
            "thick",
         }
         enum VirtualDiskAdapterType {
            "ide",
            "busLogic",
            "lsiLogic",
         }
         interface VirtualDiskSpec extends vimService.vim.DynamicData {
            diskType: string;
            adapterType: string;
         }
         interface FileBackedVirtualDiskSpec extends vimService.vim.VirtualDiskSpec {
            capacityKb: number;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface SeSparseVirtualDiskSpec extends vimService.vim.FileBackedVirtualDiskSpec {
            grainSizeKb?: number;
         }
         interface DeviceBackedVirtualDiskSpec extends vimService.vim.VirtualDiskSpec {
            device: string;
         }
         interface StorageRequirement extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            freeSpaceRequiredInKb: number;
         }
         interface ArrayOfStorageRequirement {
            storageRequirement?: Array<vimService.vim.StorageRequirement>;
         }
         enum VirtualMachinePowerState {
            "poweredOff",
            "poweredOn",
            "suspended",
         }
         enum VirtualMachineAppHeartbeatStatusType {
            "appStatusGray",
            "appStatusGreen",
            "appStatusRed",
         }
         enum VirtualMachineConnectionState {
            "connected",
            "disconnected",
            "orphaned",
            "inaccessible",
            "invalid",
         }
         enum VirtualMachineMovePriority {
            "lowPriority",
            "highPriority",
            "defaultPriority",
         }
         interface VirtualMachineTicket extends vimService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         interface VirtualMachineMksTicket extends vimService.vim.DynamicData {
            ticket: string;
            cfgFile: string;
            host?: string;
            port?: number;
            sslThumbprint?: string;
         }
         enum VirtualMachineFaultToleranceState {
            "notConfigured",
            "disabled",
            "enabled",
            "needSecondary",
            "starting",
            "running",
         }
         enum VirtualMachineRecordReplayState {
            "recording",
            "replaying",
            "inactive",
         }
         enum VirtualMachineNeedSecondaryReason {
            "initializing",
            "divergence",
            "lostConnection",
            "partialHardwareFailure",
            "userAction",
            "checkpointError",
            "other",
         }
         enum VirtualMachineFaultToleranceType {
            "unset",
            "recordReplay",
            "checkpointing",
         }
         enum VirtualMachineTicketType {
            "mks",
            "device",
            "guestControl",
            "webmks",
         }
         interface VirtualMachineDisplayTopology extends vimService.vim.DynamicData {
            x: number;
            y: number;
            width: number;
            height: number;
         }
         interface ArrayOfVirtualMachineDisplayTopology {
            virtualMachineDisplayTopology?: Array<vimService.vim.VirtualMachineDisplayTopology>;
         }
         interface DiskChangeExtent extends vimService.vim.DynamicData {
            start: number;
            length: number;
         }
         interface ArrayOfDiskChangeExtent {
            diskChangeExtent?: Array<vimService.vim.DiskChangeExtent>;
         }
         interface DiskChangeInfo extends vimService.vim.DynamicData {
            startOffset: number;
            length: number;
            changedArea?: Array<vimService.vim.DiskChangeExtent>;
         }
         interface VirtualMachineWipeResult extends vimService.vim.DynamicData {
            diskId: number;
            shrinkableDiskSpace: number;
         }
         interface VsanUpgradeSystemPreflightCheckIssue extends vimService.vim.DynamicData {
            msg: string;
         }
         interface ArrayOfVsanUpgradeSystemPreflightCheckIssue {
            vsanUpgradeSystemPreflightCheckIssue?: Array<vimService.vim.VsanUpgradeSystemPreflightCheckIssue>;
         }
         interface VsanUpgradeSystemHostsDisconnectedIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemMissingHostsInClusterIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemRogueHostsInClusterIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            uuids: Array<string>;
         }
         interface VsanUpgradeSystemWrongEsxVersionIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemAutoClaimEnabledOnHostsIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemAPIBrokenIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VsanUpgradeSystemV2ObjectsPresentDuringDowngradeIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            uuids: Array<string>;
         }
         interface VsanUpgradeSystemNotEnoughFreeCapacityIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            reducedRedundancyUpgradePossible: boolean;
         }
         interface VsanUpgradeSystemNetworkPartitionInfo extends vimService.vim.DynamicData {
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfVsanUpgradeSystemNetworkPartitionInfo {
            vsanUpgradeSystemNetworkPartitionInfo?: Array<vimService.vim.VsanUpgradeSystemNetworkPartitionInfo>;
         }
         interface VsanUpgradeSystemNetworkPartitionIssue extends vimService.vim.VsanUpgradeSystemPreflightCheckIssue {
            partitions: Array<vimService.vim.VsanUpgradeSystemNetworkPartitionInfo>;
         }
         interface VsanUpgradeSystemPreflightCheckResult extends vimService.vim.DynamicData {
            issues?: Array<vimService.vim.VsanUpgradeSystemPreflightCheckIssue>;
            diskMappingToRestore?: vimService.vim.VsanHostDiskMapping;
         }
         interface VsanUpgradeSystemUpgradeHistoryItem extends vimService.vim.DynamicData {
            timestamp: Date;
            host?: vimService.vim.ManagedObjectReference;
            message: string;
            task?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVsanUpgradeSystemUpgradeHistoryItem {
            vsanUpgradeSystemUpgradeHistoryItem?: Array<vimService.vim.VsanUpgradeSystemUpgradeHistoryItem>;
         }
         enum VsanUpgradeSystemUpgradeHistoryDiskGroupOpType {
            "add",
            "remove",
         }
         interface VsanUpgradeSystemUpgradeHistoryDiskGroupOp extends vimService.vim.VsanUpgradeSystemUpgradeHistoryItem {
            operation: string;
            diskMapping: vimService.vim.VsanHostDiskMapping;
         }
         interface VsanUpgradeSystemUpgradeHistoryPreflightFail extends vimService.vim.VsanUpgradeSystemUpgradeHistoryItem {
            preflightResult: vimService.vim.VsanUpgradeSystemPreflightCheckResult;
         }
         interface VsanUpgradeSystemUpgradeStatus extends vimService.vim.DynamicData {
            inProgress: boolean;
            history?: Array<vimService.vim.VsanUpgradeSystemUpgradeHistoryItem>;
            aborted?: boolean;
            completed?: boolean;
            progress?: number;
         }
         enum ActionParameter {
            "targetName",
            "alarmName",
            "oldStatus",
            "newStatus",
            "triggeringSummary",
            "declaringSummary",
            "eventDescription",
            "target",
            "alarm",
         }
         interface Action extends vimService.vim.DynamicData {
         }
         interface MethodActionArgument extends vimService.vim.DynamicData {
            value?: any;
         }
         interface ArrayOfMethodActionArgument {
            methodActionArgument?: Array<vimService.vim.MethodActionArgument>;
         }
         interface MethodAction extends vimService.vim.Action {
            name: string;
            argument?: Array<vimService.vim.MethodActionArgument>;
         }
         interface SendEmailAction extends vimService.vim.Action {
            toList: string;
            ccList: string;
            subject: string;
            body: string;
         }
         interface SendSNMPAction extends vimService.vim.Action {
         }
         interface RunScriptAction extends vimService.vim.Action {
            script: string;
         }
         interface CreateTaskAction extends vimService.vim.Action {
            taskTypeId: string;
            cancelable: boolean;
         }
         interface AlarmAction extends vimService.vim.DynamicData {
         }
         interface ArrayOfAlarmAction {
            alarmAction?: Array<vimService.vim.AlarmAction>;
         }
         interface AlarmTriggeringActionTransitionSpec extends vimService.vim.DynamicData {
            startState: vimService.vim.ManagedEntityStatus;
            finalState: vimService.vim.ManagedEntityStatus;
            repeats: boolean;
         }
         interface ArrayOfAlarmTriggeringActionTransitionSpec {
            alarmTriggeringActionTransitionSpec?: Array<vimService.vim.AlarmTriggeringActionTransitionSpec>;
         }
         interface AlarmTriggeringAction extends vimService.vim.AlarmAction {
            action: vimService.vim.Action;
            transitionSpecs?: Array<vimService.vim.AlarmTriggeringActionTransitionSpec>;
            green2yellow: boolean;
            yellow2red: boolean;
            red2yellow: boolean;
            yellow2green: boolean;
         }
         interface GroupAlarmAction extends vimService.vim.AlarmAction {
            action: Array<vimService.vim.AlarmAction>;
         }
         interface AlarmDescription extends vimService.vim.DynamicData {
            expr: Array<vimService.vim.TypeDescription>;
            stateOperator: Array<vimService.vim.ElementDescription>;
            metricOperator: Array<vimService.vim.ElementDescription>;
            hostSystemConnectionState: Array<vimService.vim.ElementDescription>;
            virtualMachinePowerState: Array<vimService.vim.ElementDescription>;
            datastoreConnectionState?: Array<vimService.vim.ElementDescription>;
            hostSystemPowerState?: Array<vimService.vim.ElementDescription>;
            virtualMachineGuestHeartbeatStatus?: Array<vimService.vim.ElementDescription>;
            entityStatus: Array<vimService.vim.ElementDescription>;
            action: Array<vimService.vim.TypeDescription>;
         }
         interface AlarmExpression extends vimService.vim.DynamicData {
         }
         interface ArrayOfAlarmExpression {
            alarmExpression?: Array<vimService.vim.AlarmExpression>;
         }
         interface AndAlarmExpression extends vimService.vim.AlarmExpression {
            expression: Array<vimService.vim.AlarmExpression>;
         }
         interface OrAlarmExpression extends vimService.vim.AlarmExpression {
            expression: Array<vimService.vim.AlarmExpression>;
         }
         enum StateAlarmOperator {
            "isEqual",
            "isUnequal",
         }
         interface StateAlarmExpression extends vimService.vim.AlarmExpression {
            operator: vimService.vim.StateAlarmOperator;
            type: string;
            statePath: string;
            yellow?: string;
            red?: string;
         }
         enum EventAlarmExpressionComparisonOperator {
            "equals",
            "notEqualTo",
            "startsWith",
            "doesNotStartWith",
            "endsWith",
            "doesNotEndWith",
         }
         interface EventAlarmExpressionComparison extends vimService.vim.DynamicData {
            attributeName: string;
            operator: string;
            value: string;
         }
         interface ArrayOfEventAlarmExpressionComparison {
            eventAlarmExpressionComparison?: Array<vimService.vim.EventAlarmExpressionComparison>;
         }
         interface EventAlarmExpression extends vimService.vim.AlarmExpression {
            comparisons?: Array<vimService.vim.EventAlarmExpressionComparison>;
            eventType: string;
            eventTypeId?: string;
            objectType?: string;
            status?: vimService.vim.ManagedEntityStatus;
         }
         enum MetricAlarmOperator {
            "isAbove",
            "isBelow",
         }
         interface MetricAlarmExpression extends vimService.vim.AlarmExpression {
            operator: vimService.vim.MetricAlarmOperator;
            type: string;
            metric: vimService.vim.PerfMetricId;
            yellow?: number;
            yellowInterval?: number;
            red?: number;
            redInterval?: number;
         }
         interface AlarmInfo extends vimService.vim.AlarmSpec {
            key: string;
            alarm: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            creationEventId: number;
         }
         interface AlarmSetting extends vimService.vim.DynamicData {
            toleranceRange: number;
            reportingFrequency: number;
         }
         interface AlarmSpec extends vimService.vim.DynamicData {
            name: string;
            systemName?: string;
            description: string;
            enabled: boolean;
            expression: vimService.vim.AlarmExpression;
            action?: vimService.vim.AlarmAction;
            actionFrequency?: number;
            setting?: vimService.vim.AlarmSetting;
         }
         interface AlarmState extends vimService.vim.DynamicData {
            key: string;
            entity: vimService.vim.ManagedObjectReference;
            alarm: vimService.vim.ManagedObjectReference;
            overallStatus: vimService.vim.ManagedEntityStatus;
            time: Date;
            acknowledged?: boolean;
            acknowledgedByUser?: string;
            acknowledgedTime?: Date;
            eventKey?: number;
         }
         interface ArrayOfAlarmState {
            alarmState?: Array<vimService.vim.AlarmState>;
         }
         enum ActionType {
            "MigrationV1",
            "VmPowerV1",
            "HostPowerV1",
            "HostMaintenanceV1",
            "StorageMigrationV1",
            "StoragePlacementV1",
            "PlacementV1",
         }
         interface ClusterAction extends vimService.vim.DynamicData {
            type: string;
            target?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAction {
            clusterAction?: Array<vimService.vim.ClusterAction>;
         }
         interface ClusterActionHistory extends vimService.vim.DynamicData {
            action: vimService.vim.ClusterAction;
            time: Date;
         }
         interface ArrayOfClusterActionHistory {
            clusterActionHistory?: Array<vimService.vim.ClusterActionHistory>;
         }
         interface ClusterAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterAntiAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterAttemptedVmInfo extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            task?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterAttemptedVmInfo {
            clusterAttemptedVmInfo?: Array<vimService.vim.ClusterAttemptedVmInfo>;
         }
         interface ClusterConfigInfo extends vimService.vim.DynamicData {
            dasConfig: vimService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<vimService.vim.ClusterDasVmConfigInfo>;
            drsConfig: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
         }
         enum DrsBehavior {
            "manual",
            "partiallyAutomated",
            "fullyAutomated",
         }
         interface ClusterDrsConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            enableVmBehaviorOverrides?: boolean;
            defaultVmBehavior?: vimService.vim.DrsBehavior;
            vmotionRate?: number;
            option?: Array<vimService.vim.OptionValue>;
         }
         interface ClusterDrsVmConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: vimService.vim.DrsBehavior;
         }
         interface ArrayOfClusterDrsVmConfigInfo {
            clusterDrsVmConfigInfo?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
         }
         interface ClusterConfigInfoEx extends vimService.vim.ComputeResourceConfigInfo {
            dasConfig: vimService.vim.ClusterDasConfigInfo;
            dasVmConfig?: Array<vimService.vim.ClusterDasVmConfigInfo>;
            drsConfig: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfig?: Array<vimService.vim.ClusterDrsVmConfigInfo>;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
            dpmConfigInfo?: vimService.vim.ClusterDpmConfigInfo;
            dpmHostConfig?: Array<vimService.vim.ClusterDpmHostConfigInfo>;
            vsanConfigInfo?: vimService.vim.VsanClusterConfigInfo;
            vsanHostConfig?: Array<vimService.vim.VsanHostConfigInfo>;
            group?: Array<vimService.vim.ClusterGroupInfo>;
         }
         enum DpmBehavior {
            "manual",
            "automated",
         }
         interface ClusterDpmConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            defaultDpmBehavior?: vimService.vim.DpmBehavior;
            hostPowerActionRate?: number;
            option?: Array<vimService.vim.OptionValue>;
         }
         interface ClusterDpmHostConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: vimService.vim.DpmBehavior;
         }
         interface ArrayOfClusterDpmHostConfigInfo {
            clusterDpmHostConfigInfo?: Array<vimService.vim.ClusterDpmHostConfigInfo>;
         }
         interface ClusterConfigSpec extends vimService.vim.DynamicData {
            dasConfig?: vimService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<vimService.vim.ClusterRuleSpec>;
         }
         interface ClusterDasVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDasVmConfigInfo;
         }
         interface ArrayOfClusterDasVmConfigSpec {
            clusterDasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
         }
         interface ClusterDrsVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDrsVmConfigInfo;
         }
         interface ArrayOfClusterDrsVmConfigSpec {
            clusterDrsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
         }
         interface ClusterConfigSpecEx extends vimService.vim.ComputeResourceConfigSpec {
            dasConfig?: vimService.vim.ClusterDasConfigInfo;
            dasVmConfigSpec?: Array<vimService.vim.ClusterDasVmConfigSpec>;
            drsConfig?: vimService.vim.ClusterDrsConfigInfo;
            drsVmConfigSpec?: Array<vimService.vim.ClusterDrsVmConfigSpec>;
            rulesSpec?: Array<vimService.vim.ClusterRuleSpec>;
            dpmConfig?: vimService.vim.ClusterDpmConfigInfo;
            dpmHostConfigSpec?: Array<vimService.vim.ClusterDpmHostConfigSpec>;
            vsanConfig?: vimService.vim.VsanClusterConfigInfo;
            vsanHostConfigSpec?: Array<vimService.vim.VsanHostConfigInfo>;
            groupSpec?: Array<vimService.vim.ClusterGroupSpec>;
         }
         interface ClusterDpmHostConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterDpmHostConfigInfo;
         }
         interface ArrayOfClusterDpmHostConfigSpec {
            clusterDpmHostConfigSpec?: Array<vimService.vim.ClusterDpmHostConfigSpec>;
         }
         interface ClusterGroupSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterGroupInfo;
         }
         interface ArrayOfClusterGroupSpec {
            clusterGroupSpec?: Array<vimService.vim.ClusterGroupSpec>;
         }
         interface ClusterDasAamHostInfo extends vimService.vim.ClusterDasHostInfo {
            hostDasState?: Array<vimService.vim.ClusterDasAamNodeState>;
            primaryHosts?: Array<string>;
         }
         enum ClusterDasAamNodeStateDasState {
            "uninitialized",
            "initialized",
            "configuring",
            "unconfiguring",
            "running",
            "error",
            "agentShutdown",
            "nodeFailed",
         }
         interface ClusterDasAamNodeState extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            name: string;
            configState: string;
            runtimeState: string;
         }
         interface ArrayOfClusterDasAamNodeState {
            clusterDasAamNodeState?: Array<vimService.vim.ClusterDasAamNodeState>;
         }
         interface ClusterDasAdmissionControlInfo extends vimService.vim.DynamicData {
         }
         interface ClusterDasAdmissionControlPolicy extends vimService.vim.DynamicData {
         }
         interface ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo extends vimService.vim.DynamicData {
            storageAPDSupported: boolean;
            storagePDLSupported: boolean;
         }
         interface DasHeartbeatDatastoreInfo extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            hosts: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfDasHeartbeatDatastoreInfo {
            dasHeartbeatDatastoreInfo?: Array<vimService.vim.DasHeartbeatDatastoreInfo>;
         }
         interface ClusterDasAdvancedRuntimeInfo extends vimService.vim.DynamicData {
            dasHostInfo?: vimService.vim.ClusterDasHostInfo;
            vmcpSupported?: vimService.vim.ClusterDasAdvancedRuntimeInfoVmcpCapabilityInfo;
            heartbeatDatastoreInfo?: Array<vimService.vim.DasHeartbeatDatastoreInfo>;
         }
         enum ClusterDasConfigInfoServiceState {
            "disabled",
            "enabled",
         }
         enum ClusterDasConfigInfoVmMonitoringState {
            "vmMonitoringDisabled",
            "vmMonitoringOnly",
            "vmAndAppMonitoring",
         }
         enum ClusterDasConfigInfoHBDatastoreCandidate {
            "userSelectedDs",
            "allFeasibleDs",
            "allFeasibleDsWithUserPreference",
         }
         interface ClusterDasConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            hostMonitoring?: string;
            vmComponentProtecting?: string;
            failoverLevel?: number;
            admissionControlPolicy?: vimService.vim.ClusterDasAdmissionControlPolicy;
            admissionControlEnabled?: boolean;
            defaultVmSettings?: vimService.vim.ClusterDasVmSettings;
            option?: Array<vimService.vim.OptionValue>;
            heartbeatDatastore?: Array<vimService.vim.ManagedObjectReference>;
            hBDatastoreCandidatePolicy?: string;
            metroHASettings?: vimService.vim.ClusterDasMetroHASettings;
         }
         interface ClusterDasData extends vimService.vim.DynamicData {
         }
         interface ClusterDasDataSummary extends vimService.vim.ClusterDasData {
            hostListVersion: number;
            clusterConfigVersion: number;
            compatListVersion: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo extends vimService.vim.DynamicData {
            numVcpus: number;
            cpuMHz: number;
            memoryMB: number;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots {
            clusterDasFailoverLevelAdvancedRuntimeInfoHostSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            slots: number;
         }
         interface ArrayOfClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots {
            clusterDasFailoverLevelAdvancedRuntimeInfoVmSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         interface ClusterDasFailoverLevelAdvancedRuntimeInfo extends vimService.vim.ClusterDasAdvancedRuntimeInfo {
            slotInfo: vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoSlotInfo;
            totalSlots: number;
            usedSlots: number;
            unreservedSlots: number;
            totalVms: number;
            totalHosts: number;
            totalGoodHosts: number;
            hostSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoHostSlots>;
            vmsRequiringMultipleSlots?: Array<vimService.vim.ClusterDasFailoverLevelAdvancedRuntimeInfoVmSlots>;
         }
         enum ClusterDasFdmAvailabilityState {
            "uninitialized",
            "election",
            "master",
            "connectedToMaster",
            "networkPartitionedFromMaster",
            "networkIsolated",
            "hostDown",
            "initializationError",
            "uninitializationError",
            "fdmUnreachable",
         }
         interface ClusterDasFdmHostState extends vimService.vim.DynamicData {
            state: string;
            stateReporter?: vimService.vim.ManagedObjectReference;
         }
         interface ClusterDasHostInfo extends vimService.vim.DynamicData {
         }
         interface ClusterDasHostRecommendation extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            drsRating?: number;
         }
         interface ClusterDasMetroHASettings extends vimService.vim.DynamicData {
            enabled?: boolean;
         }
         enum DasVmPriority {
            "disabled",
            "low",
            "medium",
            "high",
         }
         interface ClusterDasVmConfigInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            restartPriority?: vimService.vim.DasVmPriority;
            powerOffOnIsolation?: boolean;
            dasSettings?: vimService.vim.ClusterDasVmSettings;
         }
         interface ArrayOfClusterDasVmConfigInfo {
            clusterDasVmConfigInfo?: Array<vimService.vim.ClusterDasVmConfigInfo>;
         }
         enum ClusterDasVmSettingsRestartPriority {
            "disabled",
            "low",
            "medium",
            "high",
            "clusterRestartPriority",
         }
         enum ClusterDasVmSettingsIsolationResponse {
            "none",
            "powerOff",
            "shutdown",
            "clusterIsolationResponse",
         }
         interface ClusterDasVmSettings extends vimService.vim.DynamicData {
            restartPriority?: string;
            isolationResponse?: string;
            vmToolsMonitoringSettings?: vimService.vim.ClusterVmToolsMonitoringSettings;
            vmComponentProtectionSettings?: vimService.vim.ClusterVmComponentProtectionSettings;
         }
         interface ClusterDrsFaultsFaultsByVm extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            fault: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfClusterDrsFaultsFaultsByVm {
            clusterDrsFaultsFaultsByVm?: Array<vimService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ClusterDrsFaultsFaultsByVirtualDisk extends vimService.vim.ClusterDrsFaultsFaultsByVm {
            disk?: vimService.vim.VirtualDiskId;
         }
         interface ClusterDrsFaults extends vimService.vim.DynamicData {
            reason: string;
            faultsByVm: Array<vimService.vim.ClusterDrsFaultsFaultsByVm>;
         }
         interface ArrayOfClusterDrsFaults {
            clusterDrsFaults?: Array<vimService.vim.ClusterDrsFaults>;
         }
         interface ClusterDrsMigration extends vimService.vim.DynamicData {
            key: string;
            time: Date;
            vm: vimService.vim.ManagedObjectReference;
            cpuLoad?: number;
            memoryLoad?: number;
            source: vimService.vim.ManagedObjectReference;
            sourceCpuLoad?: number;
            sourceMemoryLoad?: number;
            destination: vimService.vim.ManagedObjectReference;
            destinationCpuLoad?: number;
            destinationMemoryLoad?: number;
         }
         interface ArrayOfClusterDrsMigration {
            clusterDrsMigration?: Array<vimService.vim.ClusterDrsMigration>;
         }
         enum DrsRecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
         }
         interface ClusterDrsRecommendation extends vimService.vim.DynamicData {
            key: string;
            rating: number;
            reason: string;
            reasonText: string;
            migrationList: Array<vimService.vim.ClusterDrsMigration>;
         }
         interface ArrayOfClusterDrsRecommendation {
            clusterDrsRecommendation?: Array<vimService.vim.ClusterDrsRecommendation>;
         }
         interface ClusterEVCManagerEVCState extends vimService.vim.DynamicData {
            supportedEVCMode: Array<vimService.vim.EVCMode>;
            currentEVCModeKey?: string;
            guaranteedCPUFeatures?: Array<vimService.vim.HostCpuIdInfo>;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
         }
         interface ClusterEVCManagerCheckResult extends vimService.vim.DynamicData {
            evcModeKey: string;
            error: vimService.vim.LocalizedMethodFault;
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfClusterEVCManagerCheckResult {
            clusterEVCManagerCheckResult?: Array<vimService.vim.ClusterEVCManagerCheckResult>;
         }
         interface ClusterEnterMaintenanceResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            fault?: vimService.vim.ClusterDrsFaults;
         }
         interface ClusterFailoverHostAdmissionControlInfoHostStatus extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            status: vimService.vim.ManagedEntityStatus;
         }
         interface ArrayOfClusterFailoverHostAdmissionControlInfoHostStatus {
            clusterFailoverHostAdmissionControlInfoHostStatus?: Array<vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            hostStatus?: Array<vimService.vim.ClusterFailoverHostAdmissionControlInfoHostStatus>;
         }
         interface ClusterFailoverHostAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            failoverHosts?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterFailoverLevelAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            currentFailoverLevel: number;
         }
         interface ClusterFailoverLevelAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            failoverLevel: number;
            slotPolicy?: vimService.vim.ClusterSlotPolicy;
         }
         interface ClusterFailoverResourcesAdmissionControlInfo extends vimService.vim.ClusterDasAdmissionControlInfo {
            currentCpuFailoverResourcesPercent: number;
            currentMemoryFailoverResourcesPercent: number;
         }
         interface ClusterFailoverResourcesAdmissionControlPolicy extends vimService.vim.ClusterDasAdmissionControlPolicy {
            cpuFailoverResourcesPercent: number;
            memoryFailoverResourcesPercent: number;
         }
         interface ClusterGroupInfo extends vimService.vim.DynamicData {
            name: string;
            userCreated?: boolean;
            uniqueID?: string;
         }
         interface ArrayOfClusterGroupInfo {
            clusterGroupInfo?: Array<vimService.vim.ClusterGroupInfo>;
         }
         interface ClusterHostGroup extends vimService.vim.ClusterGroupInfo {
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         enum HostPowerOperationType {
            "powerOn",
            "powerOff",
         }
         interface ClusterHostPowerAction extends vimService.vim.ClusterAction {
            operationType: vimService.vim.HostPowerOperationType;
            powerConsumptionWatt?: number;
            cpuCapacityMHz?: number;
            memCapacityMB?: number;
         }
         interface ClusterHostRecommendation extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            rating: number;
         }
         interface ArrayOfClusterHostRecommendation {
            clusterHostRecommendation?: Array<vimService.vim.ClusterHostRecommendation>;
         }
         interface ClusterInitialPlacementAction extends vimService.vim.ClusterAction {
            targetHost: vimService.vim.ManagedObjectReference;
            pool?: vimService.vim.ManagedObjectReference;
         }
         interface ClusterMigrationAction extends vimService.vim.ClusterAction {
            drsMigration?: vimService.vim.ClusterDrsMigration;
         }
         interface ClusterNotAttemptedVmInfo extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfClusterNotAttemptedVmInfo {
            clusterNotAttemptedVmInfo?: Array<vimService.vim.ClusterNotAttemptedVmInfo>;
         }
         interface PlacementAction extends vimService.vim.ClusterAction {
            vm?: vimService.vim.ManagedObjectReference;
            targetHost?: vimService.vim.ManagedObjectReference;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
         }
         interface PlacementResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: vimService.vim.ClusterDrsFaults;
         }
         enum PlacementSpecPlacementType {
            "create",
            "reconfigure",
            "relocate",
            "clone",
         }
         interface PlacementSpec extends vimService.vim.DynamicData {
            priority?: vimService.vim.VirtualMachineMovePriority;
            vm?: vimService.vim.ManagedObjectReference;
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
            hosts?: Array<vimService.vim.ManagedObjectReference>;
            datastores?: Array<vimService.vim.ManagedObjectReference>;
            storagePods?: Array<vimService.vim.ManagedObjectReference>;
            disallowPrerequisiteMoves?: boolean;
            rules?: Array<vimService.vim.ClusterRuleInfo>;
            key?: string;
            placementType?: string;
            cloneSpec?: vimService.vim.VirtualMachineCloneSpec;
            cloneName?: string;
         }
         interface ArrayOfPlacementSpec {
            placementSpec?: Array<vimService.vim.PlacementSpec>;
         }
         enum ClusterPowerOnVmOption {
            "OverrideAutomationLevel",
            "ReserveResources",
         }
         interface ClusterPowerOnVmResult extends vimService.vim.DynamicData {
            attempted?: Array<vimService.vim.ClusterAttemptedVmInfo>;
            notAttempted?: Array<vimService.vim.ClusterNotAttemptedVmInfo>;
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
         }
         enum RecommendationType {
            "V1",
         }
         enum RecommendationReasonCode {
            "fairnessCpuAvg",
            "fairnessMemAvg",
            "jointAffin",
            "antiAffin",
            "hostMaint",
            "enterStandby",
            "reservationCpu",
            "reservationMem",
            "powerOnVm",
            "powerSaving",
            "increaseCapacity",
            "checkResource",
            "unreservedCapacity",
            "vmHostHardAffinity",
            "vmHostSoftAffinity",
            "balanceDatastoreSpaceUsage",
            "balanceDatastoreIOLoad",
            "balanceDatastoreIOPSReservation",
            "datastoreMaint",
            "virtualDiskJointAffin",
            "virtualDiskAntiAffin",
            "datastoreSpaceOutage",
            "storagePlacement",
            "iolbDisabledInternal",
            "xvmotionPlacement",
            "networkBandwidthReservation",
         }
         interface ClusterRecommendation extends vimService.vim.DynamicData {
            key: string;
            type: string;
            time: Date;
            rating: number;
            reason: string;
            reasonText: string;
            warningText?: string;
            warningDetails?: vimService.vim.LocalizableMessage;
            prerequisite?: Array<string>;
            action?: Array<vimService.vim.ClusterAction>;
            target?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfClusterRecommendation {
            clusterRecommendation?: Array<vimService.vim.ClusterRecommendation>;
         }
         interface ClusterResourceUsageSummary extends vimService.vim.DynamicData {
            cpuUsedMHz: number;
            cpuCapacityMHz: number;
            memUsedMB: number;
            memCapacityMB: number;
            storageUsedMB: number;
            storageCapacityMB: number;
         }
         interface ClusterRuleInfo extends vimService.vim.DynamicData {
            key?: number;
            status?: vimService.vim.ManagedEntityStatus;
            enabled?: boolean;
            name?: string;
            mandatory?: boolean;
            userCreated?: boolean;
            inCompliance?: boolean;
            ruleUuid?: string;
         }
         interface ArrayOfClusterRuleInfo {
            clusterRuleInfo?: Array<vimService.vim.ClusterRuleInfo>;
         }
         interface ClusterRuleSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.ClusterRuleInfo;
         }
         interface ArrayOfClusterRuleSpec {
            clusterRuleSpec?: Array<vimService.vim.ClusterRuleSpec>;
         }
         interface ClusterSlotPolicy extends vimService.vim.DynamicData {
         }
         interface ClusterFixedSizeSlotPolicy extends vimService.vim.ClusterSlotPolicy {
            cpu: number;
            memory: number;
         }
         interface ClusterUsageSummary extends vimService.vim.DynamicData {
            totalCpuCapacityMhz: number;
            totalMemCapacityMB: number;
            cpuReservationMhz: number;
            memReservationMB: number;
            poweredOffCpuReservationMhz?: number;
            poweredOffMemReservationMB?: number;
            cpuDemandMhz: number;
            memDemandMB: number;
            statsGenNumber: number;
            cpuEntitledMhz: number;
            memEntitledMB: number;
            poweredOffVmCount: number;
            totalVmCount: number;
         }
         enum ClusterVmComponentProtectionSettingsStorageVmReaction {
            "disabled",
            "warning",
            "restartConservative",
            "restartAggressive",
            "clusterDefault",
         }
         enum ClusterVmComponentProtectionSettingsVmReactionOnAPDCleared {
            "none",
            "reset",
            "useClusterDefault",
         }
         interface ClusterVmComponentProtectionSettings extends vimService.vim.DynamicData {
            vmStorageProtectionForAPD?: string;
            enableAPDTimeoutForHosts?: boolean;
            vmTerminateDelayForAPDSec?: number;
            vmReactionOnAPDCleared?: string;
            vmStorageProtectionForPDL?: string;
         }
         interface ClusterVmGroup extends vimService.vim.ClusterGroupInfo {
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ClusterVmHostRuleInfo extends vimService.vim.ClusterRuleInfo {
            vmGroupName?: string;
            affineHostGroupName?: string;
            antiAffineHostGroupName?: string;
         }
         interface ClusterVmToolsMonitoringSettings extends vimService.vim.DynamicData {
            enabled?: boolean;
            vmMonitoring?: string;
            clusterSettings?: boolean;
            failureInterval?: number;
            minUpTime?: number;
            maxFailures?: number;
            maxFailureWindow?: number;
         }
         interface DVPortConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            key?: string;
            name?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            description?: string;
            setting?: vimService.vim.DVPortSetting;
            configVersion?: string;
         }
         interface ArrayOfDVPortConfigSpec {
            dVPortConfigSpec?: Array<vimService.vim.DVPortConfigSpec>;
         }
         interface DVPortConfigInfo extends vimService.vim.DynamicData {
            name?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            description?: string;
            setting?: vimService.vim.DVPortSetting;
            configVersion: string;
         }
         interface DVSTrafficShapingPolicy extends vimService.vim.InheritablePolicy {
            enabled?: vimService.vim.BoolPolicy;
            averageBandwidth?: vimService.vim.LongPolicy;
            peakBandwidth?: vimService.vim.LongPolicy;
            burstSize?: vimService.vim.LongPolicy;
         }
         interface DVSHostLocalPortInfo extends vimService.vim.DynamicData {
            switchUuid: string;
            portKey: string;
            setting: vimService.vim.DVPortSetting;
            vnic: string;
         }
         interface DVSVendorSpecificConfig extends vimService.vim.InheritablePolicy {
            keyValue?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DVSIPEntry extends vimService.vim.DynamicData {
            vlanId?: number;
            macAddress: string;
            ipAddress: string;
         }
         interface ArrayOfDVSIPEntry {
            dVSIPEntry?: Array<vimService.vim.DVSIPEntry>;
         }
         interface DVSStaticIPArray extends vimService.vim.InheritablePolicy {
            ipEntries?: Array<vimService.vim.DVSIPEntry>;
         }
         interface DVSPortDbEntry extends vimService.vim.DynamicData {
            entry: vimService.vim.DVSIPEntry;
            discoveryMethod: string;
            dhcpLeaseRemaining?: number;
         }
         interface ArrayOfDVSPortDbEntry {
            dVSPortDbEntry?: Array<vimService.vim.DVSPortDbEntry>;
         }
         interface DVSPortDbQueryResults extends vimService.vim.DynamicData {
            dbEntries?: Array<vimService.vim.DVSPortDbEntry>;
         }
         interface DVSPortDbClearSpec extends vimService.vim.DynamicData {
            entriesToRemove?: Array<vimService.vim.DVSIPEntry>;
         }
         interface DvsFilterParameter extends vimService.vim.DynamicData {
            parameters?: Array<string>;
         }
         enum DvsFilterOnFailure {
            "failOpen",
            "failClosed",
         }
         interface DvsFilterConfig extends vimService.vim.InheritablePolicy {
            key?: string;
            agentName?: string;
            slotNumber?: string;
            parameters?: vimService.vim.DvsFilterParameter;
            onFailure?: string;
         }
         interface ArrayOfDvsFilterConfig {
            dvsFilterConfig?: Array<vimService.vim.DvsFilterConfig>;
         }
         interface DvsTrafficFilterConfig extends vimService.vim.DvsFilterConfig {
            trafficRuleset?: vimService.vim.DvsTrafficRuleset;
         }
         interface DvsFilterConfigSpec extends vimService.vim.DvsFilterConfig {
            operation: string;
         }
         interface DvsTrafficFilterConfigSpec extends vimService.vim.DvsTrafficFilterConfig {
            operation: string;
         }
         interface DvsFilterPolicy extends vimService.vim.InheritablePolicy {
            filterConfig?: Array<vimService.vim.DvsFilterConfig>;
         }
         interface DVPortSetting extends vimService.vim.DynamicData {
            blocked?: vimService.vim.BoolPolicy;
            vmDirectPathGen2Allowed?: vimService.vim.BoolPolicy;
            inShapingPolicy?: vimService.vim.DVSTrafficShapingPolicy;
            outShapingPolicy?: vimService.vim.DVSTrafficShapingPolicy;
            vendorSpecificConfig?: vimService.vim.DVSVendorSpecificConfig;
            networkResourcePoolKey?: vimService.vim.StringPolicy;
            filterPolicy?: vimService.vim.DvsFilterPolicy;
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonNetwork {
            "portNptIncompatibleDvs",
            "portNptNoCompatibleNics",
            "portNptNoVirtualFunctionsAvailable",
            "portNptDisabledForPort",
         }
         enum DVPortStatusVmDirectPathGen2InactiveReasonOther {
            "portNptIncompatibleHost",
            "portNptIncompatibleConnectee",
         }
         interface DVPortStatus extends vimService.vim.DynamicData {
            linkUp: boolean;
            blocked: boolean;
            vlanIds?: Array<vimService.vim.NumericRange>;
            trunkingMode?: boolean;
            mtu?: number;
            linkPeer?: string;
            macAddress?: string;
            statusDetail?: string;
            vmDirectPathGen2Active?: boolean;
            vmDirectPathGen2InactiveReasonNetwork?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
         }
         interface DVPortState extends vimService.vim.DynamicData {
            runtimeInfo?: vimService.vim.DVPortStatus;
            stats: vimService.vim.DistributedVirtualSwitchPortStatistics;
            vendorSpecificState?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DistributedVirtualPort extends vimService.vim.DynamicData {
            key: string;
            config: vimService.vim.DVPortConfigInfo;
            dvsUuid: string;
            portgroupKey?: string;
            proxyHost?: vimService.vim.ManagedObjectReference;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
            conflict: boolean;
            conflictPortKey?: string;
            state?: vimService.vim.DVPortState;
            connectionCookie?: number;
            lastStatusChange: Date;
            hostLocalPort?: boolean;
         }
         interface ArrayOfDistributedVirtualPort {
            distributedVirtualPort?: Array<vimService.vim.DistributedVirtualPort>;
         }
         enum DistributedVirtualPortgroupPortgroupType {
            "earlyBinding",
            "lateBinding",
            "ephemeral",
         }
         interface DVPortgroupPolicy extends vimService.vim.DynamicData {
            blockOverrideAllowed: boolean;
            shapingOverrideAllowed: boolean;
            vendorConfigOverrideAllowed: boolean;
            livePortMovingAllowed: boolean;
            portConfigResetAtDisconnect: boolean;
            networkResourcePoolOverrideAllowed?: boolean;
            trafficFilterOverrideAllowed?: boolean;
         }
         enum DistributedVirtualPortgroupMetaTagName {
            "dvsName",
            "portgroupName",
            "portIndex",
         }
         interface DVPortgroupConfigSpec extends vimService.vim.DynamicData {
            configVersion?: string;
            name?: string;
            numPorts?: number;
            portNameFormat?: string;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            description?: string;
            type?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            policy?: vimService.vim.DVPortgroupPolicy;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            autoExpand?: boolean;
            vmVnicNetworkResourcePoolKey?: string;
         }
         interface ArrayOfDVPortgroupConfigSpec {
            dVPortgroupConfigSpec?: Array<vimService.vim.DVPortgroupConfigSpec>;
         }
         interface DVPortgroupConfigInfo extends vimService.vim.DynamicData {
            key: string;
            name: string;
            numPorts: number;
            distributedVirtualSwitch?: vimService.vim.ManagedObjectReference;
            defaultPortConfig?: vimService.vim.DVPortSetting;
            description?: string;
            type: string;
            policy: vimService.vim.DVPortgroupPolicy;
            portNameFormat?: string;
            scope?: Array<vimService.vim.ManagedObjectReference>;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            configVersion?: string;
            autoExpand?: boolean;
            vmVnicNetworkResourcePoolKey?: string;
         }
         interface DistributedVirtualPortgroupInfo extends vimService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            portgroupName: string;
            portgroupKey: string;
            portgroupType: string;
            uplinkPortgroup: boolean;
            portgroup: vimService.vim.ManagedObjectReference;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfDistributedVirtualPortgroupInfo {
            distributedVirtualPortgroupInfo?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
         }
         interface DVPortgroupSelection extends vimService.vim.SelectionSet {
            dvsUuid: string;
            portgroupKey: Array<string>;
         }
         interface DistributedVirtualSwitchInfo extends vimService.vim.DynamicData {
            switchName: string;
            switchUuid: string;
            distributedVirtualSwitch: vimService.vim.ManagedObjectReference;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfDistributedVirtualSwitchInfo {
            distributedVirtualSwitchInfo?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DVSManagerDvsConfigTarget extends vimService.vim.DynamicData {
            distributedVirtualPortgroup?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
         }
         interface DistributedVirtualSwitchManagerCompatibilityResult extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfDistributedVirtualSwitchManagerCompatibilityResult {
            distributedVirtualSwitchManagerCompatibilityResult?: Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>;
         }
         interface DistributedVirtualSwitchManagerHostContainer extends vimService.vim.DynamicData {
            container: vimService.vim.ManagedObjectReference;
            recursive: boolean;
         }
         interface DistributedVirtualSwitchManagerHostDvsFilterSpec extends vimService.vim.DynamicData {
            inclusive: boolean;
         }
         interface ArrayOfDistributedVirtualSwitchManagerHostDvsFilterSpec {
            distributedVirtualSwitchManagerHostDvsFilterSpec?: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>;
         }
         interface DistributedVirtualSwitchManagerHostArrayFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            host: Array<vimService.vim.ManagedObjectReference>;
         }
         interface DistributedVirtualSwitchManagerHostContainerFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer;
         }
         interface DistributedVirtualSwitchManagerHostDvsMembershipFilter extends vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec {
            distributedVirtualSwitch: vimService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerDvsProductSpec extends vimService.vim.DynamicData {
            newSwitchProductSpec?: vimService.vim.DistributedVirtualSwitchProductSpec;
            distributedVirtualSwitch?: vimService.vim.ManagedObjectReference;
         }
         interface DistributedVirtualSwitchManagerImportResult extends vimService.vim.DynamicData {
            distributedVirtualSwitch?: Array<vimService.vim.ManagedObjectReference>;
            distributedVirtualPortgroup?: Array<vimService.vim.ManagedObjectReference>;
            importFault?: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface DVSSelection extends vimService.vim.SelectionSet {
            dvsUuid: string;
         }
         interface EntityBackupConfig extends vimService.vim.DynamicData {
            entityType: string;
            configBlob: string;
            key?: string;
            name?: string;
            container?: vimService.vim.ManagedObjectReference;
            configVersion?: string;
         }
         interface ArrayOfEntityBackupConfig {
            entityBackupConfig?: Array<vimService.vim.EntityBackupConfig>;
         }
         enum EntityType {
            "distributedVirtualSwitch",
            "distributedVirtualPortgroup",
         }
         enum EntityImportType {
            "createEntityWithNewIdentifier",
            "createEntityWithOriginalIdentifier",
            "applyToEntitySpecified",
         }
         interface EntityBackup extends vimService.vim.DynamicData {
         }
         enum DistributedVirtualSwitchHostMemberHostComponentState {
            "up",
            "pending",
            "outOfSync",
            "warning",
            "disconnected",
            "down",
         }
         interface DistributedVirtualSwitchHostMemberConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            host: vimService.vim.ManagedObjectReference;
            backing?: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
            maxProxySwitchPorts?: number;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberConfigSpec {
            distributedVirtualSwitchHostMemberConfigSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberConfigSpec>;
         }
         interface DistributedVirtualSwitchHostMemberPnicSpec extends vimService.vim.DynamicData {
            pnicDevice: string;
            uplinkPortKey?: string;
            uplinkPortgroupKey?: string;
            connectionCookie?: number;
         }
         interface ArrayOfDistributedVirtualSwitchHostMemberPnicSpec {
            distributedVirtualSwitchHostMemberPnicSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberBacking extends vimService.vim.DynamicData {
         }
         interface DistributedVirtualSwitchHostMemberPnicBacking extends vimService.vim.DistributedVirtualSwitchHostMemberBacking {
            pnicSpec?: Array<vimService.vim.DistributedVirtualSwitchHostMemberPnicSpec>;
         }
         interface DistributedVirtualSwitchHostMemberRuntimeState extends vimService.vim.DynamicData {
            currentMaxProxySwitchPorts: number;
         }
         interface DistributedVirtualSwitchHostMemberConfigInfo extends vimService.vim.DynamicData {
            host?: vimService.vim.ManagedObjectReference;
            maxProxySwitchPorts: number;
            vendorSpecificConfig?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
            backing: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostMemberRuntimeInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            status?: string;
            statusDetail?: string;
            healthCheckResult?: Array<vimService.vim.HostMemberHealthCheckResult>;
         }
         interface ArrayOfHostMemberRuntimeInfo {
            hostMemberRuntimeInfo?: Array<vimService.vim.HostMemberRuntimeInfo>;
         }
         interface HostMemberHealthCheckResult extends vimService.vim.DynamicData {
            summary?: string;
         }
         interface ArrayOfHostMemberHealthCheckResult {
            hostMemberHealthCheckResult?: Array<vimService.vim.HostMemberHealthCheckResult>;
         }
         interface HostMemberUplinkHealthCheckResult extends vimService.vim.HostMemberHealthCheckResult {
            uplinkPortKey: string;
         }
         interface DistributedVirtualSwitchHostMember extends vimService.vim.DynamicData {
            runtimeState?: vimService.vim.DistributedVirtualSwitchHostMemberRuntimeState;
            config: vimService.vim.DistributedVirtualSwitchHostMemberConfigInfo;
            productInfo?: vimService.vim.DistributedVirtualSwitchProductSpec;
            uplinkPortKey?: Array<string>;
            status: string;
            statusDetail?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostMember {
            distributedVirtualSwitchHostMember?: Array<vimService.vim.DistributedVirtualSwitchHostMember>;
         }
         interface DistributedVirtualSwitchHostProductSpec extends vimService.vim.DynamicData {
            productLineId?: string;
            version?: string;
         }
         interface ArrayOfDistributedVirtualSwitchHostProductSpec {
            distributedVirtualSwitchHostProductSpec?: Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>;
         }
         interface DistributedVirtualSwitchKeyedOpaqueBlob extends vimService.vim.DynamicData {
            key: string;
            opaqueData: string;
         }
         interface ArrayOfDistributedVirtualSwitchKeyedOpaqueBlob {
            distributedVirtualSwitchKeyedOpaqueBlob?: Array<vimService.vim.DistributedVirtualSwitchKeyedOpaqueBlob>;
         }
         interface DVSNetworkResourcePoolAllocationInfo extends vimService.vim.DynamicData {
            limit?: number;
            shares?: vimService.vim.SharesInfo;
            priorityTag?: number;
         }
         interface DVSNetworkResourcePoolConfigSpec extends vimService.vim.DynamicData {
            key: string;
            configVersion?: string;
            allocationInfo?: vimService.vim.DVSNetworkResourcePoolAllocationInfo;
            name?: string;
            description?: string;
         }
         interface ArrayOfDVSNetworkResourcePoolConfigSpec {
            dVSNetworkResourcePoolConfigSpec?: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>;
         }
         interface DVSNetworkResourcePool extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            description?: string;
            configVersion: string;
            allocationInfo: vimService.vim.DVSNetworkResourcePoolAllocationInfo;
         }
         interface ArrayOfDVSNetworkResourcePool {
            dVSNetworkResourcePool?: Array<vimService.vim.DVSNetworkResourcePool>;
         }
         enum DistributedVirtualSwitchPortConnecteeConnecteeType {
            "pnic",
            "vmVnic",
            "hostConsoleVnic",
            "hostVmkVnic",
         }
         interface DistributedVirtualSwitchPortConnectee extends vimService.vim.DynamicData {
            connectedEntity?: vimService.vim.ManagedObjectReference;
            nicKey?: string;
            type?: string;
            addressHint?: string;
         }
         interface DistributedVirtualSwitchPortConnection extends vimService.vim.DynamicData {
            switchUuid: string;
            portgroupKey?: string;
            portKey?: string;
            connectionCookie?: number;
         }
         interface DistributedVirtualSwitchPortCriteria extends vimService.vim.DynamicData {
            connected?: boolean;
            active?: boolean;
            uplinkPort?: boolean;
            scope?: vimService.vim.ManagedObjectReference;
            portgroupKey?: Array<string>;
            inside?: boolean;
            portKey?: Array<string>;
         }
         interface DistributedVirtualSwitchPortStatistics extends vimService.vim.DynamicData {
            packetsInMulticast: number;
            packetsOutMulticast: number;
            bytesInMulticast: number;
            bytesOutMulticast: number;
            packetsInUnicast: number;
            packetsOutUnicast: number;
            bytesInUnicast: number;
            bytesOutUnicast: number;
            packetsInBroadcast: number;
            packetsOutBroadcast: number;
            bytesInBroadcast: number;
            bytesOutBroadcast: number;
            packetsInDropped: number;
            packetsOutDropped: number;
            packetsInException: number;
            packetsOutException: number;
         }
         interface DistributedVirtualSwitchProductSpec extends vimService.vim.DynamicData {
            name?: string;
            vendor?: string;
            version?: string;
            build?: string;
            forwardingClass?: string;
            bundleId?: string;
            bundleUrl?: string;
         }
         interface ArrayOfDistributedVirtualSwitchProductSpec {
            distributedVirtualSwitchProductSpec?: Array<vimService.vim.DistributedVirtualSwitchProductSpec>;
         }
         interface DvsNetworkRuleQualifier extends vimService.vim.DynamicData {
            key?: string;
         }
         interface ArrayOfDvsNetworkRuleQualifier {
            dvsNetworkRuleQualifier?: Array<vimService.vim.DvsNetworkRuleQualifier>;
         }
         interface DvsNetworkRuleAction extends vimService.vim.DynamicData {
         }
         enum DvsNetworkRuleDirectionType {
            "incomingPackets",
            "outgoingPackets",
            "both",
         }
         interface DvsIpNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: vimService.vim.IpAddress;
            destinationAddress?: vimService.vim.IpAddress;
            protocol?: vimService.vim.IntExpression;
            sourceIpPort?: vimService.vim.DvsIpPort;
            destinationIpPort?: vimService.vim.DvsIpPort;
            tcpFlags?: vimService.vim.IntExpression;
         }
         interface DvsIpPort extends vimService.vim.NegatableExpression {
         }
         interface DvsSingleIpPort extends vimService.vim.DvsIpPort {
            portNumber: number;
         }
         interface DvsIpPortRange extends vimService.vim.DvsIpPort {
            startPortNumber: number;
            endPortNumber: number;
         }
         interface DvsMacNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            sourceAddress?: vimService.vim.MacAddress;
            destinationAddress?: vimService.vim.MacAddress;
            protocol?: vimService.vim.IntExpression;
            vlanId?: vimService.vim.IntExpression;
         }
         interface DvsSystemTrafficNetworkRuleQualifier extends vimService.vim.DvsNetworkRuleQualifier {
            typeOfSystemTraffic?: vimService.vim.StringExpression;
         }
         interface DvsDropNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsAcceptNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsUpdateTagNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            qosTag?: number;
            dscpTag?: number;
         }
         interface DvsRateLimitNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            packetsPerSecond: number;
         }
         interface DvsLogNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsGreEncapNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            encapsulationIp: vimService.vim.SingleIp;
         }
         interface DvsMacRewriteNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
            rewriteMac: string;
         }
         interface DvsPuntNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsCopyNetworkRuleAction extends vimService.vim.DvsNetworkRuleAction {
         }
         interface DvsTrafficRule extends vimService.vim.DynamicData {
            key?: string;
            description?: string;
            sequence?: number;
            qualifier?: Array<vimService.vim.DvsNetworkRuleQualifier>;
            action?: vimService.vim.DvsNetworkRuleAction;
            direction?: string;
         }
         interface ArrayOfDvsTrafficRule {
            dvsTrafficRule?: Array<vimService.vim.DvsTrafficRule>;
         }
         interface DvsTrafficRuleset extends vimService.vim.DynamicData {
            key?: string;
            enabled?: boolean;
            precedence?: number;
            rules?: Array<vimService.vim.DvsTrafficRule>;
         }
         interface DvsVmVnicResourceAllocation extends vimService.vim.DynamicData {
            reservationQuota?: number;
         }
         interface DvsVmVnicResourcePoolConfigSpec extends vimService.vim.DynamicData {
            operation: string;
            key?: string;
            configVersion?: string;
            allocationInfo?: vimService.vim.DvsVmVnicResourceAllocation;
            name?: string;
            description?: string;
         }
         interface ArrayOfDvsVmVnicResourcePoolConfigSpec {
            dvsVmVnicResourcePoolConfigSpec?: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>;
         }
         interface DvsVnicAllocatedResource extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            vnicKey: string;
            reservation?: number;
         }
         interface ArrayOfDvsVnicAllocatedResource {
            dvsVnicAllocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
         }
         interface DvsVmVnicNetworkResourcePoolRuntimeInfo extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            capacity?: number;
            usage?: number;
            available?: number;
            status: string;
            allocatedResource?: Array<vimService.vim.DvsVnicAllocatedResource>;
         }
         interface ArrayOfDvsVmVnicNetworkResourcePoolRuntimeInfo {
            dvsVmVnicNetworkResourcePoolRuntimeInfo?: Array<vimService.vim.DvsVmVnicNetworkResourcePoolRuntimeInfo>;
         }
         interface DVSVmVnicNetworkResourcePool extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            description?: string;
            configVersion: string;
            allocationInfo?: vimService.vim.DvsVmVnicResourceAllocation;
         }
         interface ArrayOfDVSVmVnicNetworkResourcePool {
            dVSVmVnicNetworkResourcePool?: Array<vimService.vim.DVSVmVnicNetworkResourcePool>;
         }
         interface VMwareDVSFeatureCapability extends vimService.vim.DVSFeatureCapability {
            vspanSupported?: boolean;
            lldpSupported?: boolean;
            ipfixSupported?: boolean;
            ipfixCapability?: vimService.vim.VMwareDvsIpfixCapability;
            multicastSnoopingSupported?: boolean;
            vspanCapability?: vimService.vim.VMwareDVSVspanCapability;
            lacpCapability?: vimService.vim.VMwareDvsLacpCapability;
         }
         interface VMwareDvsIpfixCapability extends vimService.vim.DynamicData {
            ipfixSupported?: boolean;
            ipv6ForIpfixSupported?: boolean;
            observationDomainIdSupported?: boolean;
         }
         interface VMwareDvsLacpCapability extends vimService.vim.DynamicData {
            lacpSupported?: boolean;
            multiLacpGroupSupported?: boolean;
         }
         interface VMwareDVSHealthCheckCapability extends vimService.vim.DVSHealthCheckCapability {
            vlanMtuSupported: boolean;
            teamingSupported: boolean;
         }
         interface VMwareDVSVspanCapability extends vimService.vim.DynamicData {
            mixedDestSupported: boolean;
            dvportSupported: boolean;
            remoteSourceSupported: boolean;
            remoteDestSupported: boolean;
            encapRemoteSourceSupported: boolean;
         }
         interface VMwareVspanPort extends vimService.vim.DynamicData {
            portKey?: Array<string>;
            uplinkPortName?: Array<string>;
            wildcardPortConnecteeType?: Array<string>;
            vlans?: Array<number>;
            ipAddress?: Array<string>;
         }
         interface VMwareVspanSession extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            description?: string;
            enabled: boolean;
            sourcePortTransmitted?: vimService.vim.VMwareVspanPort;
            sourcePortReceived?: vimService.vim.VMwareVspanPort;
            destinationPort?: vimService.vim.VMwareVspanPort;
            encapsulationVlanId?: number;
            stripOriginalVlan: boolean;
            mirroredPacketLength?: number;
            normalTrafficAllowed: boolean;
            sessionType?: string;
            samplingRate?: number;
         }
         interface ArrayOfVMwareVspanSession {
            vMwareVspanSession?: Array<vimService.vim.VMwareVspanSession>;
         }
         interface VMwareIpfixConfig extends vimService.vim.DynamicData {
            collectorIpAddress?: string;
            collectorPort?: number;
            observationDomainId?: number;
            activeFlowTimeout: number;
            idleFlowTimeout: number;
            samplingRate: number;
            internalFlowsOnly: boolean;
         }
         interface VMwareDVSConfigInfo extends vimService.vim.DVSConfigInfo {
            vspanSession?: Array<vimService.vim.VMwareVspanSession>;
            pvlanConfig?: Array<vimService.vim.VMwareDVSPvlanMapEntry>;
            maxMtu: number;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: vimService.vim.VMwareIpfixConfig;
            lacpGroupConfig?: Array<vimService.vim.VMwareDvsLacpGroupConfig>;
            lacpApiVersion?: string;
            multicastFilteringMode?: string;
         }
         interface VMwareDVSConfigSpec extends vimService.vim.DVSConfigSpec {
            pvlanConfigSpec?: Array<vimService.vim.VMwareDVSPvlanConfigSpec>;
            vspanConfigSpec?: Array<vimService.vim.VMwareDVSVspanConfigSpec>;
            maxMtu?: number;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
            ipfixConfig?: vimService.vim.VMwareIpfixConfig;
            lacpApiVersion?: string;
            multicastFilteringMode?: string;
         }
         interface VMwareUplinkPortOrderPolicy extends vimService.vim.InheritablePolicy {
            activeUplinkPort?: Array<string>;
            standbyUplinkPort?: Array<string>;
         }
         interface DVSFailureCriteria extends vimService.vim.InheritablePolicy {
            checkSpeed?: vimService.vim.StringPolicy;
            speed?: vimService.vim.IntPolicy;
            checkDuplex?: vimService.vim.BoolPolicy;
            fullDuplex?: vimService.vim.BoolPolicy;
            checkErrorPercent?: vimService.vim.BoolPolicy;
            percentage?: vimService.vim.IntPolicy;
            checkBeacon?: vimService.vim.BoolPolicy;
         }
         interface VmwareUplinkPortTeamingPolicy extends vimService.vim.InheritablePolicy {
            policy?: vimService.vim.StringPolicy;
            reversePolicy?: vimService.vim.BoolPolicy;
            notifySwitches?: vimService.vim.BoolPolicy;
            rollingOrder?: vimService.vim.BoolPolicy;
            failureCriteria?: vimService.vim.DVSFailureCriteria;
            uplinkPortOrder?: vimService.vim.VMwareUplinkPortOrderPolicy;
         }
         interface VmwareDistributedVirtualSwitchVlanSpec extends vimService.vim.InheritablePolicy {
         }
         interface VmwareDistributedVirtualSwitchPvlanSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            pvlanId: number;
         }
         interface VmwareDistributedVirtualSwitchVlanIdSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: number;
         }
         interface VmwareDistributedVirtualSwitchTrunkVlanSpec extends vimService.vim.VmwareDistributedVirtualSwitchVlanSpec {
            vlanId: Array<vimService.vim.NumericRange>;
         }
         interface DVSSecurityPolicy extends vimService.vim.InheritablePolicy {
            allowPromiscuous?: vimService.vim.BoolPolicy;
            macChanges?: vimService.vim.BoolPolicy;
            forgedTransmits?: vimService.vim.BoolPolicy;
         }
         interface VMwareDVSPortSetting extends vimService.vim.DVPortSetting {
            vlan?: vimService.vim.VmwareDistributedVirtualSwitchVlanSpec;
            qosTag?: vimService.vim.IntPolicy;
            uplinkTeamingPolicy?: vimService.vim.VmwareUplinkPortTeamingPolicy;
            securityPolicy?: vimService.vim.DVSSecurityPolicy;
            ipfixEnabled?: vimService.vim.BoolPolicy;
            txUplink?: vimService.vim.BoolPolicy;
            lacpPolicy?: vimService.vim.VMwareUplinkLacpPolicy;
         }
         interface VMwareDVSPortgroupPolicy extends vimService.vim.DVPortgroupPolicy {
            vlanOverrideAllowed: boolean;
            uplinkTeamingOverrideAllowed: boolean;
            securityPolicyOverrideAllowed: boolean;
            ipfixOverrideAllowed?: boolean;
         }
         enum VmwareDistributedVirtualSwitchPvlanPortType {
            "promiscuous",
            "isolated",
            "community",
         }
         interface VMwareDVSPvlanConfigSpec extends vimService.vim.DynamicData {
            pvlanEntry: vimService.vim.VMwareDVSPvlanMapEntry;
            operation: string;
         }
         interface ArrayOfVMwareDVSPvlanConfigSpec {
            vMwareDVSPvlanConfigSpec?: Array<vimService.vim.VMwareDVSPvlanConfigSpec>;
         }
         interface VMwareDVSPvlanMapEntry extends vimService.vim.DynamicData {
            primaryVlanId: number;
            secondaryVlanId: number;
            pvlanType: string;
         }
         interface ArrayOfVMwareDVSPvlanMapEntry {
            vMwareDVSPvlanMapEntry?: Array<vimService.vim.VMwareDVSPvlanMapEntry>;
         }
         interface VMwareDVSVspanConfigSpec extends vimService.vim.DynamicData {
            vspanSession: vimService.vim.VMwareVspanSession;
            operation: string;
         }
         interface ArrayOfVMwareDVSVspanConfigSpec {
            vMwareDVSVspanConfigSpec?: Array<vimService.vim.VMwareDVSVspanConfigSpec>;
         }
         enum VMwareDVSVspanSessionType {
            "mixedDestMirror",
            "dvPortMirror",
            "remoteMirrorSource",
            "remoteMirrorDest",
            "encapsulatedRemoteMirrorSource",
         }
         interface VMwareDVSHealthCheckConfig extends vimService.vim.DVSHealthCheckConfig {
         }
         interface VMwareDVSVlanMtuHealthCheckConfig extends vimService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSTeamingHealthCheckConfig extends vimService.vim.VMwareDVSHealthCheckConfig {
         }
         interface VMwareDVSVlanHealthCheckResult extends vimService.vim.HostMemberUplinkHealthCheckResult {
            trunkedVlan?: Array<vimService.vim.NumericRange>;
            untrunkedVlan?: Array<vimService.vim.NumericRange>;
         }
         interface VMwareDVSMtuHealthCheckResult extends vimService.vim.HostMemberUplinkHealthCheckResult {
            mtuMismatch: boolean;
            vlanSupportSwitchMtu?: Array<vimService.vim.NumericRange>;
            vlanNotSupportSwitchMtu?: Array<vimService.vim.NumericRange>;
         }
         enum VMwareDVSTeamingMatchStatus {
            "iphashMatch",
            "nonIphashMatch",
            "iphashMismatch",
            "nonIphashMismatch",
         }
         interface VMwareDVSTeamingHealthCheckResult extends vimService.vim.HostMemberHealthCheckResult {
            teamingStatus: string;
         }
         interface VMwareUplinkLacpPolicy extends vimService.vim.InheritablePolicy {
            enable?: vimService.vim.BoolPolicy;
            mode?: vimService.vim.StringPolicy;
         }
         interface VMwareDvsLacpGroupConfig extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            mode?: string;
            uplinkNum?: number;
            loadbalanceAlgorithm?: string;
            vlan?: vimService.vim.VMwareDvsLagVlanConfig;
            ipfix?: vimService.vim.VMwareDvsLagIpfixConfig;
            uplinkName?: Array<string>;
            uplinkPortKey?: Array<string>;
         }
         interface ArrayOfVMwareDvsLacpGroupConfig {
            vMwareDvsLacpGroupConfig?: Array<vimService.vim.VMwareDvsLacpGroupConfig>;
         }
         interface VMwareDvsLagVlanConfig extends vimService.vim.DynamicData {
            vlanId?: Array<vimService.vim.NumericRange>;
         }
         interface VMwareDvsLagIpfixConfig extends vimService.vim.DynamicData {
            ipfixEnabled?: boolean;
         }
         enum VMwareUplinkLacpMode {
            "active",
            "passive",
         }
         interface VMwareDvsLacpGroupSpec extends vimService.vim.DynamicData {
            lacpGroupConfig: vimService.vim.VMwareDvsLacpGroupConfig;
            operation: string;
         }
         interface ArrayOfVMwareDvsLacpGroupSpec {
            vMwareDvsLacpGroupSpec?: Array<vimService.vim.VMwareDvsLacpGroupSpec>;
         }
         enum VMwareDvsLacpLoadBalanceAlgorithm {
            "srcMac",
            "destMac",
            "srcDestMac",
            "destIpVlan",
            "srcIpVlan",
            "srcDestIpVlan",
            "destTcpUdpPort",
            "srcTcpUdpPort",
            "srcDestTcpUdpPort",
            "destIpTcpUdpPort",
            "srcIpTcpUdpPort",
            "srcDestIpTcpUdpPort",
            "destIpTcpUdpPortVlan",
            "srcIpTcpUdpPortVlan",
            "srcDestIpTcpUdpPortVlan",
            "destIp",
            "srcIp",
            "srcDestIp",
            "vlan",
            "srcPortId",
         }
         enum VMwareDvsLacpApiVersion {
            "singleLag",
            "multipleLag",
         }
         enum VMwareDvsMulticastFilteringMode {
            "legacyFiltering",
            "snooping",
         }
         enum EventEventSeverity {
            "error",
            "warning",
            "info",
            "user",
         }
         interface Event extends vimService.vim.DynamicData {
            key: number;
            chainId: number;
            createdTime: Date;
            userName: string;
            datacenter?: vimService.vim.DatacenterEventArgument;
            computeResource?: vimService.vim.ComputeResourceEventArgument;
            host?: vimService.vim.HostEventArgument;
            vm?: vimService.vim.VmEventArgument;
            ds?: vimService.vim.DatastoreEventArgument;
            net?: vimService.vim.NetworkEventArgument;
            dvs?: vimService.vim.DvsEventArgument;
            fullFormattedMessage?: string;
            changeTag?: string;
         }
         interface ArrayOfEvent {
            event?: Array<vimService.vim.Event>;
         }
         interface GeneralEvent extends vimService.vim.Event {
            message: string;
         }
         interface GeneralHostInfoEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralHostWarningEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralHostErrorEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmInfoEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmWarningEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralVmErrorEvent extends vimService.vim.GeneralEvent {
         }
         interface GeneralUserEvent extends vimService.vim.GeneralEvent {
            entity?: vimService.vim.ManagedEntityEventArgument;
         }
         interface ExtendedEventPair extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfExtendedEventPair {
            extendedEventPair?: Array<vimService.vim.ExtendedEventPair>;
         }
         interface ExtendedEvent extends vimService.vim.GeneralEvent {
            eventTypeId: string;
            managedObject: vimService.vim.ManagedObjectReference;
            data?: Array<vimService.vim.ExtendedEventPair>;
         }
         interface HealthStatusChangedEvent extends vimService.vim.Event {
            componentId: string;
            oldStatus: string;
            newStatus: string;
            componentName: string;
            serviceId?: string;
         }
         interface HostInventoryUnreadableEvent extends vimService.vim.Event {
         }
         interface DatacenterEvent extends vimService.vim.Event {
         }
         interface DatacenterCreatedEvent extends vimService.vim.DatacenterEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface DatacenterRenamedEvent extends vimService.vim.DatacenterEvent {
            oldName: string;
            newName: string;
         }
         interface SessionEvent extends vimService.vim.Event {
         }
         interface ServerStartedSessionEvent extends vimService.vim.SessionEvent {
         }
         interface UserLoginSessionEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
            userAgent?: string;
            locale: string;
            sessionId: string;
         }
         interface UserLogoutSessionEvent extends vimService.vim.SessionEvent {
            ipAddress?: string;
            userAgent?: string;
            callCount?: number;
            sessionId?: string;
            loginTime?: Date;
         }
         interface BadUsernameSessionEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
         }
         interface AlreadyAuthenticatedSessionEvent extends vimService.vim.SessionEvent {
         }
         interface NoAccessUserEvent extends vimService.vim.SessionEvent {
            ipAddress: string;
         }
         interface SessionTerminatedEvent extends vimService.vim.SessionEvent {
            sessionId: string;
            terminatedUsername: string;
         }
         interface GlobalMessageChangedEvent extends vimService.vim.SessionEvent {
            message: string;
         }
         interface UpgradeEvent extends vimService.vim.Event {
            message: string;
         }
         interface InfoUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface WarningUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface ErrorUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface UserUpgradeEvent extends vimService.vim.UpgradeEvent {
         }
         interface HostEvent extends vimService.vim.Event {
         }
         interface HostDasEvent extends vimService.vim.HostEvent {
         }
         interface HostConnectedEvent extends vimService.vim.HostEvent {
         }
         enum HostDisconnectedEventReasonCode {
            "sslThumbprintVerifyFailed",
            "licenseExpired",
            "agentUpgrade",
            "userRequest",
            "insufficientLicenses",
            "agentOutOfDate",
            "passwordDecryptFailure",
            "unknown",
            "vcVRAMCapacityExceeded",
         }
         interface HostDisconnectedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface HostSyncFailedEvent extends vimService.vim.HostEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface HostConnectionLostEvent extends vimService.vim.HostEvent {
         }
         interface HostReconnectionFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNoConnectionEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadUsernameEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadVersionEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedAlreadyManagedEvent extends vimService.vim.HostEvent {
            serverName: string;
         }
         interface HostCnxFailedNoLicenseEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNetworkErrorEvent extends vimService.vim.HostEvent {
         }
         interface HostRemovedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedCcagentUpgradeEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedBadCcagentEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedAccountFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedNoAccessEvent extends vimService.vim.HostEvent {
         }
         interface HostShutdownEvent extends vimService.vim.HostEvent {
            reason: string;
         }
         interface HostCnxFailedNotFoundEvent extends vimService.vim.HostEvent {
         }
         interface HostCnxFailedTimeoutEvent extends vimService.vim.HostEvent {
         }
         interface HostUpgradeFailedEvent extends vimService.vim.HostEvent {
         }
         interface EnteringMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface EnteredMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface ExitMaintenanceModeEvent extends vimService.vim.HostEvent {
         }
         interface CanceledHostOperationEvent extends vimService.vim.HostEvent {
         }
         interface TimedOutHostOperationEvent extends vimService.vim.HostEvent {
         }
         interface HostDasEnabledEvent extends vimService.vim.HostEvent {
         }
         interface HostDasDisabledEvent extends vimService.vim.HostEvent {
         }
         interface HostDasEnablingEvent extends vimService.vim.HostEvent {
         }
         interface HostDasDisablingEvent extends vimService.vim.HostEvent {
         }
         enum HostDasErrorEventHostDasErrorReason {
            "configFailed",
            "timeout",
            "communicationInitFailed",
            "healthCheckScriptFailed",
            "agentFailed",
            "agentShutdown",
            "isolationAddressUnpingable",
            "other",
         }
         interface HostDasErrorEvent extends vimService.vim.HostEvent {
            message?: string;
            reason?: string;
         }
         interface HostDasOkEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUpgradedEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUninstalledEvent extends vimService.vim.HostEvent {
         }
         interface VcAgentUpgradeFailedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface VcAgentUninstallFailedEvent extends vimService.vim.HostEvent {
            reason?: string;
         }
         interface HostAddedEvent extends vimService.vim.HostEvent {
         }
         interface HostAddFailedEvent extends vimService.vim.HostEvent {
            hostname: string;
         }
         interface HostIpChangedEvent extends vimService.vim.HostEvent {
            oldIP: string;
            newIP: string;
         }
         interface EnteringStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsEnteringStandbyModeEvent extends vimService.vim.EnteringStandbyModeEvent {
         }
         interface EnteredStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsEnteredStandbyModeEvent extends vimService.vim.EnteredStandbyModeEvent {
         }
         interface ExitingStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitingStandbyModeEvent extends vimService.vim.ExitingStandbyModeEvent {
         }
         interface ExitedStandbyModeEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitedStandbyModeEvent extends vimService.vim.ExitedStandbyModeEvent {
         }
         interface ExitStandbyModeFailedEvent extends vimService.vim.HostEvent {
         }
         interface DrsExitStandbyModeFailedEvent extends vimService.vim.ExitStandbyModeFailedEvent {
         }
         interface UpdatedAgentBeingRestartedEvent extends vimService.vim.HostEvent {
         }
         interface AccountCreatedEvent extends vimService.vim.HostEvent {
            spec: vimService.vim.HostAccountSpec;
            group: boolean;
         }
         interface AccountRemovedEvent extends vimService.vim.HostEvent {
            account: string;
            group: boolean;
         }
         interface UserPasswordChanged extends vimService.vim.HostEvent {
            userLogin: string;
         }
         interface AccountUpdatedEvent extends vimService.vim.HostEvent {
            spec: vimService.vim.HostAccountSpec;
            group: boolean;
         }
         interface UserAssignedToGroup extends vimService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface UserUnassignedFromGroup extends vimService.vim.HostEvent {
            userLogin: string;
            group: string;
         }
         interface DatastorePrincipalConfigured extends vimService.vim.HostEvent {
            datastorePrincipal: string;
         }
         interface VMFSDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface NASDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface LocalDatastoreCreatedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface VMFSDatastoreExtendedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface VMFSDatastoreExpandedEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreRemovedOnHostEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreRenamedOnHostEvent extends vimService.vim.HostEvent {
            oldName: string;
            newName: string;
         }
         interface DuplicateIpDetectedEvent extends vimService.vim.HostEvent {
            duplicateIP: string;
            macAddress: string;
         }
         interface DatastoreDiscoveredEvent extends vimService.vim.HostEvent {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface DrsResourceConfigureFailedEvent extends vimService.vim.HostEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface DrsResourceConfigureSyncedEvent extends vimService.vim.HostEvent {
         }
         interface HostGetShortNameFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostShortNameToIpFailedEvent extends vimService.vim.HostEvent {
            shortName: string;
         }
         interface HostIpToShortNameFailedEvent extends vimService.vim.HostEvent {
         }
         interface HostPrimaryAgentNotShortNameEvent extends vimService.vim.HostDasEvent {
            primaryAgent: string;
         }
         interface HostNotInClusterEvent extends vimService.vim.HostDasEvent {
         }
         interface HostIsolationIpPingFailedEvent extends vimService.vim.HostDasEvent {
            isolationIp: string;
         }
         interface HostIpInconsistentEvent extends vimService.vim.HostEvent {
            ipAddress: string;
            ipAddress2: string;
         }
         interface HostUserWorldSwapNotEnabledEvent extends vimService.vim.HostEvent {
         }
         interface HostNonCompliantEvent extends vimService.vim.HostEvent {
         }
         interface HostCompliantEvent extends vimService.vim.HostEvent {
         }
         interface HostComplianceCheckedEvent extends vimService.vim.HostEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ClusterComplianceCheckedEvent extends vimService.vim.ClusterEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ProfileEvent extends vimService.vim.Event {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface ProfileCreatedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileRemovedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileAssociatedEvent extends vimService.vim.ProfileEvent {
         }
         interface ProfileDissociatedEvent extends vimService.vim.ProfileEvent {
         }
         interface HostConfigAppliedEvent extends vimService.vim.HostEvent {
         }
         interface ProfileReferenceHostChangedEvent extends vimService.vim.ProfileEvent {
            referenceHost?: vimService.vim.ManagedObjectReference;
         }
         interface ProfileChangedEvent extends vimService.vim.ProfileEvent {
         }
         interface HostProfileAppliedEvent extends vimService.vim.HostEvent {
            profile: vimService.vim.ProfileEventArgument;
         }
         interface HostShortNameInconsistentEvent extends vimService.vim.HostDasEvent {
            shortName: string;
            shortName2: string;
         }
         interface HostNoRedundantManagementNetworkEvent extends vimService.vim.HostDasEvent {
         }
         interface HostNoAvailableNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostExtraNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface HostNoHAEnabledPortGroupsEvent extends vimService.vim.HostDasEvent {
         }
         interface HostMissingNetworksEvent extends vimService.vim.HostDasEvent {
            ips?: string;
         }
         interface VnicPortArgument extends vimService.vim.DynamicData {
            vnic: string;
            port: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface ArrayOfVnicPortArgument {
            vnicPortArgument?: Array<vimService.vim.VnicPortArgument>;
         }
         interface HostVnicConnectedToCustomizedDVPortEvent extends vimService.vim.HostEvent {
            vnic: vimService.vim.VnicPortArgument;
         }
         interface GhostDvsProxySwitchDetectedEvent extends vimService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface GhostDvsProxySwitchRemovedEvent extends vimService.vim.HostEvent {
            switchUuid: Array<string>;
         }
         interface VmEvent extends vimService.vim.Event {
            template: boolean;
         }
         interface VmPoweredOffEvent extends vimService.vim.VmEvent {
         }
         interface VmPoweredOnEvent extends vimService.vim.VmEvent {
         }
         interface VmSuspendedEvent extends vimService.vim.VmEvent {
         }
         interface VmStartingEvent extends vimService.vim.VmEvent {
         }
         interface VmStoppingEvent extends vimService.vim.VmEvent {
         }
         interface VmSuspendingEvent extends vimService.vim.VmEvent {
         }
         interface VmResumingEvent extends vimService.vim.VmEvent {
         }
         interface VmDisconnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmRemoteConsoleConnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmRemoteConsoleDisconnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmDiscoveredEvent extends vimService.vim.VmEvent {
         }
         interface VmOrphanedEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingCreatedEvent extends vimService.vim.VmEvent {
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
         }
         interface VmCreatedEvent extends vimService.vim.VmEvent {
         }
         interface VmStartRecordingEvent extends vimService.vim.VmEvent {
         }
         interface VmEndRecordingEvent extends vimService.vim.VmEvent {
         }
         interface VmStartReplayingEvent extends vimService.vim.VmEvent {
         }
         interface VmEndReplayingEvent extends vimService.vim.VmEvent {
         }
         interface VmRegisteredEvent extends vimService.vim.VmEvent {
         }
         interface VmAutoRenameEvent extends vimService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmBeingHotMigratedEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmResettingEvent extends vimService.vim.VmEvent {
         }
         interface VmStaticMacConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            mac: string;
         }
         interface VmMacConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            mac: string;
         }
         interface VmBeingDeployedEvent extends vimService.vim.VmEvent {
            srcTemplate: vimService.vim.VmEventArgument;
         }
         interface VmDeployFailedEvent extends vimService.vim.VmEvent {
            destDatastore: vimService.vim.EntityEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmDeployedEvent extends vimService.vim.VmEvent {
            srcTemplate: vimService.vim.VmEventArgument;
         }
         interface VmMacChangedEvent extends vimService.vim.VmEvent {
            adapter: string;
            oldMac: string;
            newMac: string;
         }
         interface VmMacAssignedEvent extends vimService.vim.VmEvent {
            adapter: string;
            mac: string;
         }
         interface VmUuidConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            uuid: string;
         }
         interface VmInstanceUuidConflictEvent extends vimService.vim.VmEvent {
            conflictedVm: vimService.vim.VmEventArgument;
            instanceUuid: string;
         }
         interface VmBeingMigratedEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmFailedMigrateEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmMigratedEvent extends vimService.vim.VmEvent {
            sourceHost: vimService.vim.HostEventArgument;
            sourceDatacenter?: vimService.vim.DatacenterEventArgument;
            sourceDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmUnsupportedStartingEvent extends vimService.vim.VmStartingEvent {
            guestId: string;
         }
         interface DrsVmMigratedEvent extends vimService.vim.VmMigratedEvent {
         }
         interface DrsVmPoweredOnEvent extends vimService.vim.VmPoweredOnEvent {
         }
         interface DrsRuleViolationEvent extends vimService.vim.VmEvent {
         }
         interface DrsSoftRuleViolationEvent extends vimService.vim.VmEvent {
         }
         interface DrsRuleComplianceEvent extends vimService.vim.VmEvent {
         }
         interface VmRelocateSpecEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingRelocatedEvent extends vimService.vim.VmRelocateSpecEvent {
            destHost: vimService.vim.HostEventArgument;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmRelocatedEvent extends vimService.vim.VmRelocateSpecEvent {
            sourceHost: vimService.vim.HostEventArgument;
            sourceDatacenter?: vimService.vim.DatacenterEventArgument;
            sourceDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmRelocateFailedEvent extends vimService.vim.VmRelocateSpecEvent {
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
            destDatacenter?: vimService.vim.DatacenterEventArgument;
            destDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface VmEmigratingEvent extends vimService.vim.VmEvent {
         }
         interface VmCloneEvent extends vimService.vim.VmEvent {
         }
         interface VmBeingClonedEvent extends vimService.vim.VmCloneEvent {
            destFolder: vimService.vim.FolderEventArgument;
            destName: string;
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmBeingClonedNoFolderEvent extends vimService.vim.VmCloneEvent {
            destName: string;
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmCloneFailedEvent extends vimService.vim.VmCloneEvent {
            destFolder: vimService.vim.FolderEventArgument;
            destName: string;
            destHost: vimService.vim.HostEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmClonedEvent extends vimService.vim.VmCloneEvent {
            sourceVm: vimService.vim.VmEventArgument;
         }
         interface VmResourceReallocatedEvent extends vimService.vim.VmEvent {
         }
         interface VmRenamedEvent extends vimService.vim.VmEvent {
            oldName: string;
            newName: string;
         }
         interface VmDateRolledBackEvent extends vimService.vim.VmEvent {
         }
         interface VmNoNetworkAccessEvent extends vimService.vim.VmEvent {
            destHost: vimService.vim.HostEventArgument;
         }
         interface VmDiskFailedEvent extends vimService.vim.VmEvent {
            disk: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOnEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToPowerOffEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToSuspendEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToResetEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToShutdownGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToRebootGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmFailedToStandbyGuestEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmRemovedEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestShutdownEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestRebootEvent extends vimService.vim.VmEvent {
         }
         interface VmGuestStandbyEvent extends vimService.vim.VmEvent {
         }
         interface VmUpgradingEvent extends vimService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeCompleteEvent extends vimService.vim.VmEvent {
            version: string;
         }
         interface VmUpgradeFailedEvent extends vimService.vim.VmEvent {
         }
         interface VmRestartedOnAlternateHostEvent extends vimService.vim.VmPoweredOnEvent {
            sourceHost: vimService.vim.HostEventArgument;
         }
         interface VmReconfiguredEvent extends vimService.vim.VmEvent {
            configSpec: vimService.vim.VirtualMachineConfigSpec;
         }
         interface VmMessageEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmMessageWarningEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmMessageErrorEvent extends vimService.vim.VmEvent {
            message: string;
            messageInfo?: Array<vimService.vim.VirtualMachineMessage>;
         }
         interface VmConfigMissingEvent extends vimService.vim.VmEvent {
         }
         interface VmPowerOffOnIsolationEvent extends vimService.vim.VmPoweredOffEvent {
            isolatedHost: vimService.vim.HostEventArgument;
         }
         enum VmShutdownOnIsolationEventOperation {
            "shutdown",
            "poweredOff",
         }
         interface VmShutdownOnIsolationEvent extends vimService.vim.VmPoweredOffEvent {
            isolatedHost: vimService.vim.HostEventArgument;
            shutdownResult?: string;
         }
         interface VmFailoverFailed extends vimService.vim.VmEvent {
            reason?: vimService.vim.LocalizedMethodFault;
         }
         enum VmDasBeingResetEventReasonCode {
            "vmtoolsHeartbeatFailure",
            "appHeartbeatFailure",
            "appImmediateResetRequest",
            "vmcpResetApdCleared",
         }
         interface VmDasBeingResetEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmDasResetFailedEvent extends vimService.vim.VmEvent {
         }
         interface VmMaxRestartCountReached extends vimService.vim.VmEvent {
         }
         interface VmMaxFTRestartCountReached extends vimService.vim.VmEvent {
         }
         interface VmDasBeingResetWithScreenshotEvent extends vimService.vim.VmDasBeingResetEvent {
            screenshotFilePath: string;
         }
         interface NotEnoughResourcesToStartVmEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmUuidAssignedEvent extends vimService.vim.VmEvent {
            uuid: string;
         }
         interface VmInstanceUuidAssignedEvent extends vimService.vim.VmEvent {
            instanceUuid: string;
         }
         interface VmUuidChangedEvent extends vimService.vim.VmEvent {
            oldUuid: string;
            newUuid: string;
         }
         interface VmInstanceUuidChangedEvent extends vimService.vim.VmEvent {
            oldInstanceUuid: string;
            newInstanceUuid: string;
         }
         interface VmWwnConflictEvent extends vimService.vim.VmEvent {
            conflictedVms?: Array<vimService.vim.VmEventArgument>;
            conflictedHosts?: Array<vimService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmAcquiredMksTicketEvent extends vimService.vim.VmEvent {
         }
         interface VmAcquiredTicketEvent extends vimService.vim.VmEvent {
            ticketType: string;
         }
         interface VmGuestOSCrashedEvent extends vimService.vim.VmEvent {
         }
         interface HostWwnConflictEvent extends vimService.vim.HostEvent {
            conflictedVms?: Array<vimService.vim.VmEventArgument>;
            conflictedHosts?: Array<vimService.vim.HostEventArgument>;
            wwn: number;
         }
         interface VmWwnAssignedEvent extends vimService.vim.VmEvent {
            nodeWwns: Array<number>;
            portWwns: Array<number>;
         }
         interface VmWwnChangedEvent extends vimService.vim.VmEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface VmSecondaryAddedEvent extends vimService.vim.VmEvent {
         }
         interface VmFaultToleranceTurnedOffEvent extends vimService.vim.VmEvent {
         }
         interface VmFaultToleranceStateChangedEvent extends vimService.vim.VmEvent {
            oldState: vimService.vim.VirtualMachineFaultToleranceState;
            newState: vimService.vim.VirtualMachineFaultToleranceState;
         }
         interface VmSecondaryDisabledEvent extends vimService.vim.VmEvent {
         }
         interface VmSecondaryDisabledBySystemEvent extends vimService.vim.VmEvent {
            reason?: vimService.vim.LocalizedMethodFault;
         }
         interface VmSecondaryEnabledEvent extends vimService.vim.VmEvent {
         }
         interface VmStartingSecondaryEvent extends vimService.vim.VmEvent {
         }
         interface VmSecondaryStartedEvent extends vimService.vim.VmEvent {
         }
         interface VmFailedUpdatingSecondaryConfig extends vimService.vim.VmEvent {
         }
         enum VmFailedStartingSecondaryEventFailureReason {
            "incompatibleHost",
            "loginFailed",
            "registerVmFailed",
            "migrateFailed",
         }
         interface VmFailedStartingSecondaryEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmTimedoutStartingSecondaryEvent extends vimService.vim.VmEvent {
            timeout?: number;
         }
         interface VmNoCompatibleHostForSecondaryEvent extends vimService.vim.VmEvent {
         }
         interface VmPrimaryFailoverEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface VmFaultToleranceVmTerminatedEvent extends vimService.vim.VmEvent {
            reason?: string;
         }
         interface HostWwnChangedEvent extends vimService.vim.HostEvent {
            oldNodeWwns?: Array<number>;
            oldPortWwns?: Array<number>;
            newNodeWwns?: Array<number>;
            newPortWwns?: Array<number>;
         }
         interface HostAdminDisableEvent extends vimService.vim.HostEvent {
         }
         interface HostAdminEnableEvent extends vimService.vim.HostEvent {
         }
         interface HostEnableAdminFailedEvent extends vimService.vim.HostEvent {
            permissions: Array<vimService.vim.Permission>;
         }
         interface VmFailedRelayoutOnVmfs2DatastoreEvent extends vimService.vim.VmEvent {
         }
         interface VmFailedRelayoutEvent extends vimService.vim.VmEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface VmRelayoutSuccessfulEvent extends vimService.vim.VmEvent {
         }
         interface VmRelayoutUpToDateEvent extends vimService.vim.VmEvent {
         }
         interface VmConnectedEvent extends vimService.vim.VmEvent {
         }
         interface VmPoweringOnWithCustomizedDVPortEvent extends vimService.vim.VmEvent {
            vnic: Array<vimService.vim.VnicPortArgument>;
         }
         interface VmDasUpdateErrorEvent extends vimService.vim.VmEvent {
         }
         interface NoMaintenanceModeDrsRecommendationForVM extends vimService.vim.VmEvent {
         }
         interface VmDasUpdateOkEvent extends vimService.vim.VmEvent {
         }
         interface ScheduledTaskEvent extends vimService.vim.Event {
            scheduledTask: vimService.vim.ScheduledTaskEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface ScheduledTaskCreatedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskStartedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskRemovedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskReconfiguredEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskCompletedEvent extends vimService.vim.ScheduledTaskEvent {
         }
         interface ScheduledTaskFailedEvent extends vimService.vim.ScheduledTaskEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface ScheduledTaskEmailCompletedEvent extends vimService.vim.ScheduledTaskEvent {
            to: string;
         }
         interface ScheduledTaskEmailFailedEvent extends vimService.vim.ScheduledTaskEvent {
            to: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmEvent extends vimService.vim.Event {
            alarm: vimService.vim.AlarmEventArgument;
         }
         interface AlarmCreatedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmStatusChangedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
            from: string;
            to: string;
         }
         interface AlarmActionTriggeredEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmEmailCompletedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            to: string;
         }
         interface AlarmEmailFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            to: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmSnmpCompletedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmSnmpFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmScriptCompleteEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            script: string;
         }
         interface AlarmScriptFailedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            script: string;
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface AlarmRemovedEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmReconfiguredEvent extends vimService.vim.AlarmEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmAcknowledgedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
         }
         interface AlarmClearedEvent extends vimService.vim.AlarmEvent {
            source: vimService.vim.ManagedEntityEventArgument;
            entity: vimService.vim.ManagedEntityEventArgument;
            from: string;
         }
         interface CustomFieldEvent extends vimService.vim.Event {
         }
         interface CustomFieldDefEvent extends vimService.vim.CustomFieldEvent {
            fieldKey: number;
            name: string;
         }
         interface CustomFieldDefAddedEvent extends vimService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRemovedEvent extends vimService.vim.CustomFieldDefEvent {
         }
         interface CustomFieldDefRenamedEvent extends vimService.vim.CustomFieldDefEvent {
            newName: string;
         }
         interface CustomFieldValueChangedEvent extends vimService.vim.CustomFieldEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            fieldKey: number;
            name: string;
            value: string;
         }
         interface AuthorizationEvent extends vimService.vim.Event {
         }
         interface PermissionEvent extends vimService.vim.AuthorizationEvent {
            entity: vimService.vim.ManagedEntityEventArgument;
            principal: string;
            group: boolean;
         }
         interface PermissionAddedEvent extends vimService.vim.PermissionEvent {
            role: vimService.vim.RoleEventArgument;
            propagate: boolean;
         }
         interface PermissionUpdatedEvent extends vimService.vim.PermissionEvent {
            role: vimService.vim.RoleEventArgument;
            propagate: boolean;
         }
         interface PermissionRemovedEvent extends vimService.vim.PermissionEvent {
         }
         interface RoleEvent extends vimService.vim.AuthorizationEvent {
            role: vimService.vim.RoleEventArgument;
         }
         interface RoleAddedEvent extends vimService.vim.RoleEvent {
            privilegeList?: Array<string>;
         }
         interface RoleUpdatedEvent extends vimService.vim.RoleEvent {
            privilegeList?: Array<string>;
         }
         interface RoleRemovedEvent extends vimService.vim.RoleEvent {
         }
         interface DatastoreEvent extends vimService.vim.Event {
            datastore?: vimService.vim.DatastoreEventArgument;
         }
         interface DatastoreDestroyedEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreRenamedEvent extends vimService.vim.DatastoreEvent {
            oldName: string;
            newName: string;
         }
         interface DatastoreCapacityIncreasedEvent extends vimService.vim.DatastoreEvent {
            oldCapacity: number;
            newCapacity: number;
         }
         interface DatastoreDuplicatedEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreFileEvent extends vimService.vim.DatastoreEvent {
            targetFile: string;
         }
         interface DatastoreFileCopiedEvent extends vimService.vim.DatastoreFileEvent {
            sourceDatastore: vimService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileMovedEvent extends vimService.vim.DatastoreFileEvent {
            sourceDatastore: vimService.vim.DatastoreEventArgument;
            sourceFile: string;
         }
         interface DatastoreFileDeletedEvent extends vimService.vim.DatastoreFileEvent {
         }
         interface NonVIWorkloadDetectedOnDatastoreEvent extends vimService.vim.DatastoreEvent {
         }
         interface DatastoreIORMReconfiguredEvent extends vimService.vim.DatastoreEvent {
         }
         interface TaskEvent extends vimService.vim.Event {
            info: vimService.vim.TaskInfo;
         }
         interface TaskTimeoutEvent extends vimService.vim.TaskEvent {
         }
         interface LicenseEvent extends vimService.vim.Event {
         }
         interface ServerLicenseExpiredEvent extends vimService.vim.LicenseEvent {
            product: string;
         }
         interface HostLicenseExpiredEvent extends vimService.vim.LicenseEvent {
         }
         interface VMotionLicenseExpiredEvent extends vimService.vim.LicenseEvent {
         }
         interface NoLicenseEvent extends vimService.vim.LicenseEvent {
            feature: vimService.vim.LicenseFeatureInfo;
         }
         interface LicenseServerUnavailableEvent extends vimService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseServerAvailableEvent extends vimService.vim.LicenseEvent {
            licenseServer: string;
         }
         interface LicenseExpiredEvent extends vimService.vim.Event {
            feature: vimService.vim.LicenseFeatureInfo;
         }
         interface InvalidEditionEvent extends vimService.vim.LicenseEvent {
            feature: string;
         }
         interface HostInventoryFullEvent extends vimService.vim.LicenseEvent {
            capacity: number;
         }
         interface LicenseRestrictedEvent extends vimService.vim.LicenseEvent {
         }
         interface IncorrectHostInformationEvent extends vimService.vim.LicenseEvent {
         }
         interface UnlicensedVirtualMachinesEvent extends vimService.vim.LicenseEvent {
            unlicensed: number;
            available: number;
         }
         interface UnlicensedVirtualMachinesFoundEvent extends vimService.vim.LicenseEvent {
            available: number;
         }
         interface AllVirtualMachinesLicensedEvent extends vimService.vim.LicenseEvent {
         }
         interface LicenseNonComplianceEvent extends vimService.vim.LicenseEvent {
            url: string;
         }
         interface MigrationEvent extends vimService.vim.VmEvent {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface MigrationWarningEvent extends vimService.vim.MigrationEvent {
         }
         interface MigrationErrorEvent extends vimService.vim.MigrationEvent {
         }
         interface MigrationHostWarningEvent extends vimService.vim.MigrationEvent {
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationHostErrorEvent extends vimService.vim.MigrationEvent {
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationResourceWarningEvent extends vimService.vim.MigrationEvent {
            dstPool: vimService.vim.ResourcePoolEventArgument;
            dstHost: vimService.vim.HostEventArgument;
         }
         interface MigrationResourceErrorEvent extends vimService.vim.MigrationEvent {
            dstPool: vimService.vim.ResourcePoolEventArgument;
            dstHost: vimService.vim.HostEventArgument;
         }
         interface ClusterEvent extends vimService.vim.Event {
         }
         interface DasEnabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAdmissionControlDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAdmissionControlEnabledEvent extends vimService.vim.ClusterEvent {
         }
         interface DasHostFailedEvent extends vimService.vim.ClusterEvent {
            failedHost: vimService.vim.HostEventArgument;
         }
         interface DasHostIsolatedEvent extends vimService.vim.ClusterEvent {
            isolatedHost: vimService.vim.HostEventArgument;
         }
         interface DasClusterIsolatedEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAgentUnavailableEvent extends vimService.vim.ClusterEvent {
         }
         interface DasAgentFoundEvent extends vimService.vim.ClusterEvent {
         }
         interface InsufficientFailoverResourcesEvent extends vimService.vim.ClusterEvent {
         }
         interface FailoverLevelRestored extends vimService.vim.ClusterEvent {
         }
         interface ClusterOvercommittedEvent extends vimService.vim.ClusterEvent {
         }
         interface HostOvercommittedEvent extends vimService.vim.ClusterOvercommittedEvent {
         }
         interface ClusterStatusChangedEvent extends vimService.vim.ClusterEvent {
            oldStatus: string;
            newStatus: string;
         }
         interface HostStatusChangedEvent extends vimService.vim.ClusterStatusChangedEvent {
         }
         interface ClusterCreatedEvent extends vimService.vim.ClusterEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface ClusterDestroyedEvent extends vimService.vim.ClusterEvent {
         }
         interface DrsEnabledEvent extends vimService.vim.ClusterEvent {
            behavior: string;
         }
         interface DrsDisabledEvent extends vimService.vim.ClusterEvent {
         }
         interface ClusterReconfiguredEvent extends vimService.vim.ClusterEvent {
         }
         interface HostMonitoringStateChangedEvent extends vimService.vim.ClusterEvent {
            state: string;
         }
         interface VmHealthMonitoringStateChangedEvent extends vimService.vim.ClusterEvent {
            state: string;
         }
         interface ResourcePoolEvent extends vimService.vim.Event {
            resourcePool: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolCreatedEvent extends vimService.vim.ResourcePoolEvent {
            parent: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolDestroyedEvent extends vimService.vim.ResourcePoolEvent {
         }
         interface ResourcePoolMovedEvent extends vimService.vim.ResourcePoolEvent {
            oldParent: vimService.vim.ResourcePoolEventArgument;
            newParent: vimService.vim.ResourcePoolEventArgument;
         }
         interface ResourcePoolReconfiguredEvent extends vimService.vim.ResourcePoolEvent {
         }
         interface ResourceViolatedEvent extends vimService.vim.ResourcePoolEvent {
         }
         interface VmResourcePoolMovedEvent extends vimService.vim.VmEvent {
            oldParent: vimService.vim.ResourcePoolEventArgument;
            newParent: vimService.vim.ResourcePoolEventArgument;
         }
         interface TemplateUpgradeEvent extends vimService.vim.Event {
            legacyTemplate: string;
         }
         interface TemplateBeingUpgradedEvent extends vimService.vim.TemplateUpgradeEvent {
         }
         interface TemplateUpgradeFailedEvent extends vimService.vim.TemplateUpgradeEvent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface TemplateUpgradedEvent extends vimService.vim.TemplateUpgradeEvent {
         }
         interface CustomizationEvent extends vimService.vim.VmEvent {
            logLocation?: string;
         }
         interface CustomizationStartedEvent extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationSucceeded extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationFailed extends vimService.vim.CustomizationEvent {
         }
         interface CustomizationUnknownFailure extends vimService.vim.CustomizationFailed {
         }
         interface CustomizationSysprepFailed extends vimService.vim.CustomizationFailed {
            sysprepVersion: string;
            systemVersion: string;
         }
         interface CustomizationLinuxIdentityFailed extends vimService.vim.CustomizationFailed {
         }
         interface CustomizationNetworkSetupFailed extends vimService.vim.CustomizationFailed {
         }
         interface LockerMisconfiguredEvent extends vimService.vim.Event {
            datastore: vimService.vim.DatastoreEventArgument;
         }
         interface LockerReconfiguredEvent extends vimService.vim.Event {
            oldDatastore?: vimService.vim.DatastoreEventArgument;
            newDatastore?: vimService.vim.DatastoreEventArgument;
         }
         interface NoDatastoresConfiguredEvent extends vimService.vim.HostEvent {
         }
         interface AdminPasswordNotChangedEvent extends vimService.vim.HostEvent {
         }
         interface HostInAuditModeEvent extends vimService.vim.HostEvent {
         }
         interface LocalTSMEnabledEvent extends vimService.vim.HostEvent {
         }
         interface RemoteTSMEnabledEvent extends vimService.vim.HostEvent {
         }
         interface VimAccountPasswordChangedEvent extends vimService.vim.HostEvent {
         }
         interface IScsiBootFailureEvent extends vimService.vim.HostEvent {
         }
         interface DvsHealthStatusChangeEvent extends vimService.vim.HostEvent {
            switchUuid: string;
            healthResult?: vimService.vim.HostMemberHealthCheckResult;
         }
         interface NetworkRollbackEvent extends vimService.vim.Event {
            methodName: string;
            transactionId: string;
         }
         interface UplinkPortVlanTrunkedEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortVlanUntrunkedEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface MtuMismatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuNotSupportEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface UplinkPortMtuSupportEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface TeamingMisMatchEvent extends vimService.vim.DvsHealthStatusChangeEvent {
         }
         interface DvsEvent extends vimService.vim.Event {
         }
         interface DvsCreatedEvent extends vimService.vim.DvsEvent {
            parent: vimService.vim.FolderEventArgument;
         }
         interface DvsRenamedEvent extends vimService.vim.DvsEvent {
            oldName: string;
            newName: string;
         }
         interface DvsReconfiguredEvent extends vimService.vim.DvsEvent {
            configSpec: vimService.vim.DVSConfigSpec;
         }
         interface DvsUpgradeAvailableEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeInProgressEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradeRejectedEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsUpgradedEvent extends vimService.vim.DvsEvent {
            productInfo: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface DvsHostJoinedEvent extends vimService.vim.DvsEvent {
            hostJoined: vimService.vim.HostEventArgument;
         }
         interface DvsHostLeftEvent extends vimService.vim.DvsEvent {
            hostLeft: vimService.vim.HostEventArgument;
         }
         interface DvsOutOfSyncHostArgument extends vimService.vim.DynamicData {
            outOfSyncHost: vimService.vim.HostEventArgument;
            configParamters: Array<string>;
         }
         interface ArrayOfDvsOutOfSyncHostArgument {
            dvsOutOfSyncHostArgument?: Array<vimService.vim.DvsOutOfSyncHostArgument>;
         }
         interface OutOfSyncDvsHost extends vimService.vim.DvsEvent {
            hostOutOfSync: Array<vimService.vim.DvsOutOfSyncHostArgument>;
         }
         interface DvsHostWentOutOfSyncEvent extends vimService.vim.DvsEvent {
            hostOutOfSync: vimService.vim.DvsOutOfSyncHostArgument;
         }
         interface DvsHostBackInSyncEvent extends vimService.vim.DvsEvent {
            hostBackInSync: vimService.vim.HostEventArgument;
         }
         interface DvsHostStatusUpdated extends vimService.vim.DvsEvent {
            hostMember: vimService.vim.HostEventArgument;
            oldStatus?: string;
            newStatus?: string;
            oldStatusDetail?: string;
            newStatusDetail?: string;
         }
         interface DvsPortCreatedEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortReconfiguredEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortDeletedEvent extends vimService.vim.DvsEvent {
            portKey: Array<string>;
         }
         interface DvsPortConnectedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortDisconnectedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            connectee?: vimService.vim.DistributedVirtualSwitchPortConnectee;
         }
         interface DvsPortVendorSpecificStateChangeEvent extends vimService.vim.DvsEvent {
            portKey: string;
         }
         interface DvsPortRuntimeChangeEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo: vimService.vim.DVPortStatus;
         }
         interface DvsPortLinkUpEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortLinkDownEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortJoinPortgroupEvent extends vimService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortLeavePortgroupEvent extends vimService.vim.DvsEvent {
            portKey: string;
            portgroupKey: string;
            portgroupName: string;
         }
         interface DvsPortBlockedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            statusDetail?: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortUnblockedEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortEnteredPassthruEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsPortExitedPassthruEvent extends vimService.vim.DvsEvent {
            portKey: string;
            runtimeInfo?: vimService.vim.DVPortStatus;
         }
         interface DvsDestroyedEvent extends vimService.vim.DvsEvent {
         }
         interface DvsMergedEvent extends vimService.vim.DvsEvent {
            sourceDvs: vimService.vim.DvsEventArgument;
            destinationDvs: vimService.vim.DvsEventArgument;
         }
         interface HostLocalPortCreatedEvent extends vimService.vim.DvsEvent {
            hostLocalPort: vimService.vim.DVSHostLocalPortInfo;
         }
         interface RollbackEvent extends vimService.vim.DvsEvent {
            hostName: string;
            methodName?: string;
         }
         interface RecoveryEvent extends vimService.vim.DvsEvent {
            hostName: string;
            portKey: string;
            dvsUuid?: string;
            vnic?: string;
         }
         interface DvsImportEvent extends vimService.vim.DvsEvent {
            importType: string;
         }
         interface DvsRestoreEvent extends vimService.vim.DvsEvent {
         }
         interface VmVnicPoolReservationViolationRaiseEvent extends vimService.vim.DvsEvent {
            vmVnicResourcePoolKey: string;
            vmVnicResourcePoolName?: string;
         }
         interface VmVnicPoolReservationViolationClearEvent extends vimService.vim.DvsEvent {
            vmVnicResourcePoolKey: string;
            vmVnicResourcePoolName?: string;
         }
         interface DVPortgroupEvent extends vimService.vim.Event {
         }
         interface DVPortgroupCreatedEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DVPortgroupRenamedEvent extends vimService.vim.DVPortgroupEvent {
            oldName: string;
            newName: string;
         }
         interface DVPortgroupReconfiguredEvent extends vimService.vim.DVPortgroupEvent {
            configSpec: vimService.vim.DVPortgroupConfigSpec;
         }
         interface DVPortgroupDestroyedEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DvpgImportEvent extends vimService.vim.DVPortgroupEvent {
            importType: string;
         }
         interface DvpgRestoreEvent extends vimService.vim.DVPortgroupEvent {
         }
         interface DrsInvocationFailedEvent extends vimService.vim.ClusterEvent {
         }
         interface DrsRecoveredFromFailureEvent extends vimService.vim.ClusterEvent {
         }
         interface VmReloadFromPathEvent extends vimService.vim.VmEvent {
            configPath: string;
         }
         interface VmReloadFromPathFailedEvent extends vimService.vim.VmEvent {
            configPath: string;
         }
         interface VmRequirementsExceedCurrentEVCModeEvent extends vimService.vim.VmEvent {
         }
         interface EventArgument extends vimService.vim.DynamicData {
         }
         interface RoleEventArgument extends vimService.vim.EventArgument {
            roleId: number;
            name: string;
         }
         interface EntityEventArgument extends vimService.vim.EventArgument {
            name: string;
         }
         interface ManagedEntityEventArgument extends vimService.vim.EntityEventArgument {
            entity: vimService.vim.ManagedObjectReference;
         }
         interface FolderEventArgument extends vimService.vim.EntityEventArgument {
            folder: vimService.vim.ManagedObjectReference;
         }
         interface DatacenterEventArgument extends vimService.vim.EntityEventArgument {
            datacenter: vimService.vim.ManagedObjectReference;
         }
         interface ComputeResourceEventArgument extends vimService.vim.EntityEventArgument {
            computeResource: vimService.vim.ManagedObjectReference;
         }
         interface ResourcePoolEventArgument extends vimService.vim.EntityEventArgument {
            resourcePool: vimService.vim.ManagedObjectReference;
         }
         interface HostEventArgument extends vimService.vim.EntityEventArgument {
            host: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfHostEventArgument {
            hostEventArgument?: Array<vimService.vim.HostEventArgument>;
         }
         interface VmEventArgument extends vimService.vim.EntityEventArgument {
            vm: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVmEventArgument {
            vmEventArgument?: Array<vimService.vim.VmEventArgument>;
         }
         interface DatastoreEventArgument extends vimService.vim.EntityEventArgument {
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface NetworkEventArgument extends vimService.vim.EntityEventArgument {
            network: vimService.vim.ManagedObjectReference;
         }
         interface AlarmEventArgument extends vimService.vim.EntityEventArgument {
            alarm: vimService.vim.ManagedObjectReference;
         }
         interface ScheduledTaskEventArgument extends vimService.vim.EntityEventArgument {
            scheduledTask: vimService.vim.ManagedObjectReference;
         }
         interface ProfileEventArgument extends vimService.vim.EventArgument {
            profile: vimService.vim.ManagedObjectReference;
            name: string;
         }
         interface DvsEventArgument extends vimService.vim.EntityEventArgument {
            dvs: vimService.vim.ManagedObjectReference;
         }
         enum EventCategory {
            "info",
            "warning",
            "error",
            "user",
         }
         interface EventArgDesc extends vimService.vim.DynamicData {
            name: string;
            type: string;
            description?: vimService.vim.ElementDescription;
         }
         interface ArrayOfEventArgDesc {
            eventArgDesc?: Array<vimService.vim.EventArgDesc>;
         }
         interface EventDescriptionEventDetail extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            category: string;
            formatOnDatacenter: string;
            formatOnComputeResource: string;
            formatOnHost: string;
            formatOnVm: string;
            fullFormat: string;
            longDescription?: string;
         }
         interface ArrayOfEventDescriptionEventDetail {
            eventDescriptionEventDetail?: Array<vimService.vim.EventDescriptionEventDetail>;
         }
         interface EventDescription extends vimService.vim.DynamicData {
            category: Array<vimService.vim.ElementDescription>;
            eventInfo: Array<vimService.vim.EventDescriptionEventDetail>;
            enumeratedTypes?: Array<vimService.vim.EnumDescription>;
         }
         interface EventEx extends vimService.vim.Event {
            eventTypeId: string;
            severity?: string;
            message?: string;
            arguments?: Array<vimService.vim.KeyAnyValue>;
            objectId?: string;
            objectType?: string;
            objectName?: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         enum EventFilterSpecRecursionOption {
            "self",
            "children",
            "all",
         }
         interface EventFilterSpecByEntity extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            recursion: vimService.vim.EventFilterSpecRecursionOption;
         }
         interface EventFilterSpecByTime extends vimService.vim.DynamicData {
            beginTime?: Date;
            endTime?: Date;
         }
         interface EventFilterSpecByUsername extends vimService.vim.DynamicData {
            systemUser: boolean;
            userList?: Array<string>;
         }
         interface EventFilterSpec extends vimService.vim.DynamicData {
            entity?: vimService.vim.EventFilterSpecByEntity;
            time?: vimService.vim.EventFilterSpecByTime;
            userName?: vimService.vim.EventFilterSpecByUsername;
            eventChainId?: number;
            alarm?: vimService.vim.ManagedObjectReference;
            scheduledTask?: vimService.vim.ManagedObjectReference;
            disableFullMessage?: boolean;
            category?: Array<string>;
            type?: Array<string>;
            tag?: Array<string>;
            eventTypeId?: Array<string>;
         }
         interface ExtExtendedProductInfo extends vimService.vim.DynamicData {
            companyUrl?: string;
            productUrl?: string;
            managementUrl?: string;
            self?: vimService.vim.ManagedObjectReference;
         }
         interface ManagedByInfo extends vimService.vim.DynamicData {
            extensionKey: string;
            type: string;
         }
         interface ExtManagedEntityInfo extends vimService.vim.DynamicData {
            type: string;
            smallIconUrl?: string;
            iconUrl?: string;
            description?: string;
         }
         interface ArrayOfExtManagedEntityInfo {
            extManagedEntityInfo?: Array<vimService.vim.ExtManagedEntityInfo>;
         }
         interface ExtSolutionManagerInfoTabInfo extends vimService.vim.DynamicData {
            label: string;
            url: string;
         }
         interface ArrayOfExtSolutionManagerInfoTabInfo {
            extSolutionManagerInfoTabInfo?: Array<vimService.vim.ExtSolutionManagerInfoTabInfo>;
         }
         interface ExtSolutionManagerInfo extends vimService.vim.DynamicData {
            tab?: Array<vimService.vim.ExtSolutionManagerInfoTabInfo>;
            smallIconUrl?: string;
         }
         interface ActiveDirectoryFault extends vimService.vim.VimFault {
            errorCode?: number;
         }
         interface ActiveVMsBlockingEVC extends vimService.vim.EVCConfigFault {
            evcMode?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            hostName?: Array<string>;
         }
         interface AdminDisabled extends vimService.vim.HostConfigFault {
         }
         interface AdminNotDisabled extends vimService.vim.HostConfigFault {
         }
         enum AffinityType {
            "memory",
            "cpu",
         }
         interface AffinityConfigured extends vimService.vim.MigrationFault {
            configuredAffinity: Array<string>;
         }
         enum AgentInstallFailedReason {
            "NotEnoughSpaceOnDevice",
            "PrepareToUpgradeFailed",
            "AgentNotRunning",
            "AgentNotReachable",
            "InstallTimedout",
            "SignatureVerificationFailed",
            "AgentUploadFailed",
            "AgentUploadTimedout",
            "UnknownInstallerError",
         }
         interface AgentInstallFailed extends vimService.vim.HostConnectFault {
            reason?: string;
            statusCode?: number;
            installerOutput?: string;
         }
         interface AlreadyBeingManaged extends vimService.vim.HostConnectFault {
            ipAddress: string;
         }
         interface AlreadyConnected extends vimService.vim.HostConnectFault {
            name: string;
         }
         interface AlreadyExists extends vimService.vim.VimFault {
            name?: string;
         }
         interface AlreadyUpgraded extends vimService.vim.VimFault {
         }
         interface AnswerFileUpdateFailure extends vimService.vim.DynamicData {
            userInputPath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileUpdateFailure {
            answerFileUpdateFailure?: Array<vimService.vim.AnswerFileUpdateFailure>;
         }
         interface AnswerFileUpdateFailed extends vimService.vim.VimFault {
            failure: Array<vimService.vim.AnswerFileUpdateFailure>;
         }
         interface ApplicationQuiesceFault extends vimService.vim.SnapshotFault {
         }
         interface AuthMinimumAdminPermission extends vimService.vim.VimFault {
         }
         interface BackupBlobReadFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface BackupBlobWriteFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface BlockedByFirewall extends vimService.vim.HostConfigFault {
         }
         interface CAMServerRefusedConnection extends vimService.vim.InvalidCAMServer {
         }
         interface CannotAccessFile extends vimService.vim.FileFault {
         }
         interface CannotAccessLocalSource extends vimService.vim.VimFault {
         }
         interface CannotAccessNetwork extends vimService.vim.CannotAccessVmDevice {
            network?: vimService.vim.ManagedObjectReference;
         }
         interface CannotAccessVmComponent extends vimService.vim.VmConfigFault {
         }
         interface CannotAccessVmConfig extends vimService.vim.CannotAccessVmComponent {
            reason: vimService.vim.LocalizedMethodFault;
         }
         interface CannotAccessVmDevice extends vimService.vim.CannotAccessVmComponent {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface CannotAccessVmDisk extends vimService.vim.CannotAccessVmDevice {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface CannotAddHostWithFTVmAsStandalone extends vimService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToDifferentCluster extends vimService.vim.HostConnectFault {
         }
         interface CannotAddHostWithFTVmToNonHACluster extends vimService.vim.HostConnectFault {
         }
         interface CannotChangeDrsBehaviorForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeHaSettingsForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotChangeVsanClusterUuid extends vimService.vim.VsanFault {
         }
         interface CannotChangeVsanNodeUuid extends vimService.vim.VsanFault {
         }
         interface CannotComputeFTCompatibleHosts extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotCreateFile extends vimService.vim.FileFault {
         }
         interface CannotDecryptPasswords extends vimService.vim.CustomizationFault {
         }
         interface CannotDeleteFile extends vimService.vim.FileFault {
         }
         interface CannotDisableDrsOnClusterManagedByVDC extends vimService.vim.RuntimeFault {
         }
         interface CannotDisableDrsOnClustersWithVApps extends vimService.vim.RuntimeFault {
         }
         interface CannotDisableSnapshot extends vimService.vim.VmConfigFault {
         }
         interface CannotDisconnectHostWithFaultToleranceVm extends vimService.vim.VimFault {
            hostName: string;
         }
         enum CannotEnableVmcpForClusterReason {
            "APDTimeoutDisabled",
            "IncompatibleHostVersion",
         }
         interface CannotEnableVmcpForCluster extends vimService.vim.VimFault {
            host?: vimService.vim.ManagedObjectReference;
            hostName?: string;
            reason?: string;
         }
         interface CannotModifyConfigCpuRequirements extends vimService.vim.MigrationFault {
         }
         enum CannotMoveFaultToleranceVmMoveType {
            "resourcePool",
            "cluster",
         }
         interface CannotMoveFaultToleranceVm extends vimService.vim.VimFault {
            moveType: string;
            vmName: string;
         }
         interface CannotMoveHostWithFaultToleranceVm extends vimService.vim.VimFault {
         }
         interface CannotMoveVmWithDeltaDisk extends vimService.vim.MigrationFault {
            device: string;
         }
         interface CannotMoveVmWithNativeDeltaDisk extends vimService.vim.MigrationFault {
         }
         interface CannotMoveVsanEnabledHost extends vimService.vim.VsanFault {
         }
         interface CannotPlaceWithoutPrerequisiteMoves extends vimService.vim.VimFault {
         }
         enum CannotPowerOffVmInClusterOperation {
            "suspend",
            "powerOff",
            "guestShutdown",
            "guestSuspend",
         }
         interface CannotPowerOffVmInCluster extends vimService.vim.InvalidState {
            operation: string;
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface CannotReconfigureVsanWhenHaEnabled extends vimService.vim.VsanFault {
         }
         enum CannotUseNetworkReason {
            "NetworkReservationNotSupported",
            "MismatchedNetworkPolicies",
            "MismatchedDvsVersionOrVendor",
            "VMotionToUnsupportedNetworkType",
         }
         interface CannotUseNetwork extends vimService.vim.VmConfigFault {
            device: string;
            backing: string;
            connected: boolean;
            reason: string;
            network?: vimService.vim.ManagedObjectReference;
         }
         interface ClockSkew extends vimService.vim.HostConfigFault {
         }
         interface CloneFromSnapshotNotSupported extends vimService.vim.MigrationFault {
         }
         interface CollectorAddressUnset extends vimService.vim.DvsFault {
         }
         interface ConcurrentAccess extends vimService.vim.VimFault {
         }
         interface ConflictingConfigurationConfig extends vimService.vim.DynamicData {
            entity?: vimService.vim.ManagedObjectReference;
            propertyPath: string;
         }
         interface ArrayOfConflictingConfigurationConfig {
            conflictingConfigurationConfig?: Array<vimService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingConfiguration extends vimService.vim.DvsFault {
            configInConflict: Array<vimService.vim.ConflictingConfigurationConfig>;
         }
         interface ConflictingDatastoreFound extends vimService.vim.RuntimeFault {
            name: string;
            url: string;
         }
         interface ConnectedIso extends vimService.vim.OvfExport {
            cdrom: vimService.vim.VirtualCdrom;
            filename: string;
         }
         interface CpuCompatibilityUnknown extends vimService.vim.CpuIncompatible {
         }
         interface CpuHotPlugNotSupported extends vimService.vim.VmConfigFault {
         }
         interface CpuIncompatible extends vimService.vim.VirtualHardwareCompatibilityIssue {
            level: number;
            registerName: string;
            registerBits?: string;
            desiredBits?: string;
            host?: vimService.vim.ManagedObjectReference;
         }
         interface CpuIncompatible1ECX extends vimService.vim.CpuIncompatible {
            sse3: boolean;
            pclmulqdq?: boolean;
            ssse3: boolean;
            sse41: boolean;
            sse42: boolean;
            aes?: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CpuIncompatible81EDX extends vimService.vim.CpuIncompatible {
            nx: boolean;
            ffxsr: boolean;
            rdtscp: boolean;
            lm: boolean;
            other: boolean;
            otherOnly: boolean;
         }
         interface CustomizationFault extends vimService.vim.VimFault {
         }
         interface CustomizationPending extends vimService.vim.CustomizationFault {
         }
         interface DVPortNotSupported extends vimService.vim.DeviceBackingNotSupported {
         }
         enum DasConfigFaultDasConfigFaultReason {
            "HostNetworkMisconfiguration",
            "HostMisconfiguration",
            "InsufficientPrivileges",
            "NoPrimaryAgentAvailable",
            "Other",
            "NoDatastoresConfigured",
            "CreateConfigVvolFailed",
            "VSanNotSupportedOnHost",
            "DasNetworkMisconfiguration",
         }
         interface DasConfigFault extends vimService.vim.VimFault {
            reason?: string;
            output?: string;
            event?: Array<vimService.vim.Event>;
         }
         interface DatabaseError extends vimService.vim.RuntimeFault {
         }
         interface DatacenterMismatchArgument extends vimService.vim.DynamicData {
            entity: vimService.vim.ManagedObjectReference;
            inputDatacenter?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfDatacenterMismatchArgument {
            datacenterMismatchArgument?: Array<vimService.vim.DatacenterMismatchArgument>;
         }
         interface DatacenterMismatch extends vimService.vim.MigrationFault {
            invalidArgument: Array<vimService.vim.DatacenterMismatchArgument>;
            expectedDatacenter: vimService.vim.ManagedObjectReference;
         }
         interface DatastoreNotWritableOnHost extends vimService.vim.InvalidDatastore {
            host: vimService.vim.ManagedObjectReference;
         }
         interface DeltaDiskFormatNotSupported extends vimService.vim.VmConfigFault {
            datastore?: Array<vimService.vim.ManagedObjectReference>;
            deltaDiskFormat: string;
         }
         interface DestinationSwitchFull extends vimService.vim.CannotAccessNetwork {
         }
         interface DestinationVsanDisabled extends vimService.vim.CannotMoveVsanEnabledHost {
            destinationCluster: string;
         }
         interface DeviceBackingNotSupported extends vimService.vim.DeviceNotSupported {
            backing: string;
         }
         interface DeviceControllerNotSupported extends vimService.vim.DeviceNotSupported {
            controller: string;
         }
         interface DeviceHotPlugNotSupported extends vimService.vim.InvalidDeviceSpec {
         }
         interface DeviceNotFound extends vimService.vim.InvalidDeviceSpec {
         }
         enum DeviceNotSupportedReason {
            "host",
            "guest",
         }
         interface DeviceNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            device: string;
            reason?: string;
         }
         interface DeviceUnsupportedForVmPlatform extends vimService.vim.InvalidDeviceSpec {
         }
         interface DeviceUnsupportedForVmVersion extends vimService.vim.InvalidDeviceSpec {
            currentVersion: string;
            expectedVersion: string;
         }
         interface DigestNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface DirectoryNotEmpty extends vimService.vim.FileFault {
         }
         interface DisableAdminNotSupported extends vimService.vim.HostConfigFault {
         }
         enum DisallowedChangeByServiceDisallowedChange {
            "hotExtendDisk",
         }
         interface DisallowedChangeByService extends vimService.vim.RuntimeFault {
            serviceName: string;
            disallowedChange?: string;
         }
         interface DisallowedDiskModeChange extends vimService.vim.InvalidDeviceSpec {
         }
         interface DisallowedMigrationDeviceAttached extends vimService.vim.MigrationFault {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface DisallowedOperationOnFailoverHost extends vimService.vim.RuntimeFault {
            host: vimService.vim.ManagedObjectReference;
            hostname: string;
         }
         interface DisconnectedHostsBlockingEVC extends vimService.vim.EVCConfigFault {
         }
         interface DiskHasPartitions extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsLastRemainingNonSSD extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsNonLocal extends vimService.vim.VsanDiskFault {
         }
         interface DiskIsUSB extends vimService.vim.VsanDiskFault {
         }
         interface DiskMoveTypeNotSupported extends vimService.vim.MigrationFault {
         }
         interface DiskNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            disk: number;
         }
         interface DiskTooSmall extends vimService.vim.VsanDiskFault {
         }
         interface DomainNotFound extends vimService.vim.ActiveDirectoryFault {
            domainName: string;
         }
         interface DrsDisabledOnVm extends vimService.vim.VimFault {
         }
         interface DrsVmotionIncompatibleFault extends vimService.vim.VirtualHardwareCompatibilityIssue {
            host: vimService.vim.ManagedObjectReference;
         }
         interface DuplicateDisks extends vimService.vim.VsanDiskFault {
         }
         interface DuplicateName extends vimService.vim.VimFault {
            name: string;
            object: vimService.vim.ManagedObjectReference;
         }
         interface DuplicateVsanNetworkInterface extends vimService.vim.VsanFault {
            device: string;
         }
         interface DvsApplyOperationFaultFaultOnObject extends vimService.vim.DynamicData {
            objectId: string;
            type: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsApplyOperationFaultFaultOnObject {
            dvsApplyOperationFaultFaultOnObject?: Array<vimService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsApplyOperationFault extends vimService.vim.DvsFault {
            objectFault: Array<vimService.vim.DvsApplyOperationFaultFaultOnObject>;
         }
         interface DvsFault extends vimService.vim.VimFault {
         }
         interface DvsNotAuthorized extends vimService.vim.DvsFault {
            sessionExtensionKey?: string;
            dvsExtensionKey?: string;
         }
         interface DvsOperationBulkFaultFaultOnHost extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfDvsOperationBulkFaultFaultOnHost {
            dvsOperationBulkFaultFaultOnHost?: Array<vimService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsOperationBulkFault extends vimService.vim.DvsFault {
            hostFault: Array<vimService.vim.DvsOperationBulkFaultFaultOnHost>;
         }
         interface DvsScopeViolated extends vimService.vim.DvsFault {
            scope: Array<vimService.vim.ManagedObjectReference>;
            entity: vimService.vim.ManagedObjectReference;
         }
         interface EVCAdmissionFailed extends vimService.vim.NotSupportedHostInCluster {
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface EVCAdmissionFailedCPUFeaturesForMode extends vimService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUModel extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedCPUModelForMode extends vimService.vim.EVCAdmissionFailed {
            currentEVCModeKey: string;
         }
         interface EVCAdmissionFailedCPUVendor extends vimService.vim.EVCAdmissionFailed {
            clusterCPUVendor: string;
            hostCPUVendor: string;
         }
         interface EVCAdmissionFailedCPUVendorUnknown extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostDisconnected extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftware extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedHostSoftwareForMode extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCAdmissionFailedVmActive extends vimService.vim.EVCAdmissionFailed {
         }
         interface EVCConfigFault extends vimService.vim.VimFault {
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface EVCModeIllegalByVendor extends vimService.vim.EVCConfigFault {
            clusterCPUVendor: string;
            modeCPUVendor: string;
         }
         interface EVCModeUnsupportedByHosts extends vimService.vim.EVCConfigFault {
            evcMode?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            hostName?: Array<string>;
         }
         interface EVCUnsupportedByHostHardware extends vimService.vim.EVCConfigFault {
            host: Array<vimService.vim.ManagedObjectReference>;
            hostName: Array<string>;
         }
         interface EVCUnsupportedByHostSoftware extends vimService.vim.EVCConfigFault {
            host: Array<vimService.vim.ManagedObjectReference>;
            hostName: Array<string>;
         }
         interface EightHostLimitViolated extends vimService.vim.VmConfigFault {
         }
         interface ExpiredAddonLicense extends vimService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredEditionLicense extends vimService.vim.ExpiredFeatureLicense {
         }
         interface ExpiredFeatureLicense extends vimService.vim.NotEnoughLicenses {
            feature: string;
            count: number;
            expirationDate: Date;
         }
         interface ExtendedFault extends vimService.vim.VimFault {
            faultTypeId: string;
            data?: Array<vimService.vim.KeyValue>;
         }
         interface FailToEnableSPBM extends vimService.vim.NotEnoughLicenses {
            cs: vimService.vim.ManagedObjectReference;
            csName: string;
            hostLicenseStates: Array<vimService.vim.ComputeResourceHostSPBMLicenseInfo>;
         }
         interface FailToLockFaultToleranceVMs extends vimService.vim.RuntimeFault {
            vmName: string;
            vm: vimService.vim.ManagedObjectReference;
            alreadyLockedVm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceAntiAffinityViolated extends vimService.vim.MigrationFault {
            hostName: string;
            host: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCannotEditMem extends vimService.vim.VmConfigFault {
            vmName: string;
            vm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceCpuIncompatible extends vimService.vim.CpuIncompatible {
            model: boolean;
            family: boolean;
            stepping: boolean;
         }
         interface FaultToleranceNeedsThickDisk extends vimService.vim.MigrationFault {
            vmName: string;
         }
         interface FaultToleranceNotLicensed extends vimService.vim.VmFaultToleranceIssue {
            hostName?: string;
         }
         interface FaultToleranceNotSameBuild extends vimService.vim.MigrationFault {
            build: string;
         }
         interface FaultTolerancePrimaryPowerOnNotAttempted extends vimService.vim.VmFaultToleranceIssue {
            secondaryVm: vimService.vim.ManagedObjectReference;
            primaryVm: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceVmNotDasProtected extends vimService.vim.VimFault {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface FcoeFault extends vimService.vim.VimFault {
         }
         interface FcoeFaultPnicHasNoPortSet extends vimService.vim.FcoeFault {
            nicDevice: string;
         }
         interface FeatureRequirementsNotMet extends vimService.vim.VirtualHardwareCompatibilityIssue {
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
         }
         interface FileAlreadyExists extends vimService.vim.FileFault {
         }
         interface FileBackedPortNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface FileFault extends vimService.vim.VimFault {
            file: string;
         }
         interface FileLocked extends vimService.vim.FileFault {
         }
         interface FileNameTooLong extends vimService.vim.FileFault {
         }
         interface FileNotFound extends vimService.vim.FileFault {
         }
         interface FileNotWritable extends vimService.vim.FileFault {
         }
         interface FileTooLarge extends vimService.vim.FileFault {
            datastore: string;
            fileSize: number;
            maxFileSize?: number;
         }
         interface FilesystemQuiesceFault extends vimService.vim.SnapshotFault {
         }
         interface FilterInUse extends vimService.vim.ResourceInUse {
            disk?: Array<vimService.vim.VirtualDiskId>;
         }
         enum FtIssuesOnHostHostSelectionType {
            "user",
            "vc",
            "drs",
         }
         interface FtIssuesOnHost extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            hostName: string;
            errors?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface FullStorageVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface GatewayConnectFault extends vimService.vim.HostConnectFault {
            gatewayType: string;
            gatewayId: string;
            gatewayInfo: string;
            details?: vimService.vim.LocalizableMessage;
         }
         interface GatewayHostNotReachable extends vimService.vim.GatewayToHostConnectFault {
         }
         interface GatewayNotFound extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayNotReachable extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayOperationRefused extends vimService.vim.GatewayConnectFault {
         }
         interface GatewayToHostAuthFault extends vimService.vim.GatewayToHostConnectFault {
            invalidProperties: Array<string>;
            missingProperties: Array<string>;
         }
         interface GatewayToHostConnectFault extends vimService.vim.GatewayConnectFault {
            hostname: string;
            port?: number;
         }
         interface GatewayToHostTrustVerifyFault extends vimService.vim.GatewayToHostConnectFault {
            verificationToken: string;
            propertiesToVerify: Array<vimService.vim.KeyValue>;
         }
         interface GenericDrsFault extends vimService.vim.VimFault {
            hostFaults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface GenericVmConfigFault extends vimService.vim.VmConfigFault {
            reason: string;
         }
         interface GuestAuthenticationChallenge extends vimService.vim.GuestOperationsFault {
            serverChallenge: vimService.vim.GuestAuthentication;
            sessionID: number;
         }
         interface GuestComponentsOutOfDate extends vimService.vim.GuestOperationsFault {
         }
         interface GuestMultipleMappings extends vimService.vim.GuestOperationsFault {
         }
         interface GuestOperationsFault extends vimService.vim.VimFault {
         }
         interface GuestOperationsUnavailable extends vimService.vim.GuestOperationsFault {
         }
         interface GuestPermissionDenied extends vimService.vim.GuestOperationsFault {
         }
         interface GuestProcessNotFound extends vimService.vim.GuestOperationsFault {
            pid: number;
         }
         interface GuestRegistryFault extends vimService.vim.GuestOperationsFault {
            windowsSystemErrorCode: number;
         }
         interface GuestRegistryKeyAlreadyExists extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyFault extends vimService.vim.GuestRegistryFault {
            keyName: string;
         }
         interface GuestRegistryKeyHasSubkeys extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyInvalid extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryKeyParentVolatile extends vimService.vim.GuestRegistryKeyFault {
         }
         interface GuestRegistryValueFault extends vimService.vim.GuestRegistryFault {
            keyName: string;
            valueName: string;
         }
         interface GuestRegistryValueNotFound extends vimService.vim.GuestRegistryValueFault {
         }
         interface HAErrorsAtDest extends vimService.vim.MigrationFault {
         }
         interface HeterogenousHostsBlockingEVC extends vimService.vim.EVCConfigFault {
         }
         interface HostAccessRestrictedToManagementServer extends vimService.vim.NotSupported {
            managementServer: string;
         }
         interface HostConfigFailed extends vimService.vim.HostConfigFault {
            failure: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface HostConfigFault extends vimService.vim.VimFault {
         }
         interface HostConnectFault extends vimService.vim.VimFault {
         }
         enum HostHasComponentFailureHostComponentType {
            "Datastore",
         }
         interface HostHasComponentFailure extends vimService.vim.VimFault {
            hostName: string;
            componentType: string;
            componentName: string;
         }
         interface HostInDomain extends vimService.vim.HostConfigFault {
         }
         enum HostIncompatibleForFaultToleranceReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForFaultTolerance extends vimService.vim.VmFaultToleranceIssue {
            hostName?: string;
            reason?: string;
         }
         enum HostIncompatibleForRecordReplayReason {
            "product",
            "processor",
         }
         interface HostIncompatibleForRecordReplay extends vimService.vim.VimFault {
            hostName?: string;
            reason?: string;
         }
         interface HostInventoryFull extends vimService.vim.NotEnoughLicenses {
            capacity: number;
         }
         interface HostPowerOpFailed extends vimService.vim.VimFault {
         }
         interface HotSnapshotMoveNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface IDEDiskNotSupported extends vimService.vim.DiskNotSupported {
         }
         interface IORMNotSupportedHostOnDatastore extends vimService.vim.VimFault {
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ImportHostAddFailure extends vimService.vim.DvsFault {
            hostIp: Array<string>;
         }
         interface ImportOperationBulkFaultFaultOnImport extends vimService.vim.DynamicData {
            entityType?: string;
            key?: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfImportOperationBulkFaultFaultOnImport {
            importOperationBulkFaultFaultOnImport?: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface ImportOperationBulkFault extends vimService.vim.DvsFault {
            importFaults: Array<vimService.vim.ImportOperationBulkFaultFaultOnImport>;
         }
         interface InUseFeatureManipulationDisallowed extends vimService.vim.NotEnoughLicenses {
         }
         interface InaccessibleDatastore extends vimService.vim.InvalidDatastore {
            detail?: string;
         }
         interface InaccessibleFTMetadataDatastore extends vimService.vim.InaccessibleDatastore {
         }
         interface InaccessibleVFlashSource extends vimService.vim.VimFault {
            hostName: string;
         }
         interface IncompatibleDefaultDevice extends vimService.vim.MigrationFault {
            device: string;
         }
         interface IncompatibleHostForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         enum IncompatibleHostForVmReplicationIncompatibleReason {
            "rpo",
            "netCompression",
         }
         interface IncompatibleHostForVmReplication extends vimService.vim.ReplicationFault {
            vmName: string;
            hostName: string;
            reason: string;
         }
         interface IncompatibleSetting extends vimService.vim.InvalidArgument {
            conflictingProperty: string;
         }
         interface IncorrectFileType extends vimService.vim.FileFault {
         }
         interface IncorrectHostInformation extends vimService.vim.NotEnoughLicenses {
         }
         interface IndependentDiskVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface InsufficientAgentVmsDeployed extends vimService.vim.InsufficientResourcesFault {
            hostName: string;
            requiredNumAgentVms: number;
            currentNumAgentVms: number;
         }
         interface InsufficientCpuResourcesFault extends vimService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientDisks extends vimService.vim.VsanDiskFault {
         }
         interface InsufficientFailoverResourcesFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientGraphicsResourcesFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientHostCapacityFault extends vimService.vim.InsufficientResourcesFault {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface InsufficientHostCpuCapacityFault extends vimService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientHostMemoryCapacityFault extends vimService.vim.InsufficientHostCapacityFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientMemoryResourcesFault extends vimService.vim.InsufficientResourcesFault {
            unreserved: number;
            requested: number;
         }
         interface InsufficientNetworkCapacity extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientNetworkResourcePoolCapacity extends vimService.vim.InsufficientResourcesFault {
            dvsName: string;
            dvsUuid: string;
            resourcePoolKey: string;
            available: number;
            requested: number;
            device: Array<string>;
         }
         interface InsufficientPerCpuCapacity extends vimService.vim.InsufficientHostCapacityFault {
         }
         interface InsufficientResourcesFault extends vimService.vim.VimFault {
         }
         interface InsufficientStandbyCpuResource extends vimService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyMemoryResource extends vimService.vim.InsufficientStandbyResource {
            available: number;
            requested: number;
         }
         interface InsufficientStandbyResource extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientStorageIops extends vimService.vim.VimFault {
            unreservedIops: number;
            requestedIops: number;
            datastoreName: string;
         }
         interface InsufficientStorageSpace extends vimService.vim.InsufficientResourcesFault {
         }
         interface InsufficientVFlashResourcesFault extends vimService.vim.InsufficientResourcesFault {
            freeSpaceInMB?: number;
            freeSpace: number;
            requestedSpaceInMB?: number;
            requestedSpace: number;
         }
         interface InvalidAffinitySettingFault extends vimService.vim.VimFault {
         }
         interface InvalidBmcRole extends vimService.vim.VimFault {
         }
         interface InvalidBundle extends vimService.vim.PlatformConfigFault {
         }
         interface InvalidCAMCertificate extends vimService.vim.InvalidCAMServer {
         }
         interface InvalidCAMServer extends vimService.vim.ActiveDirectoryFault {
            camServer: string;
         }
         interface InvalidClientCertificate extends vimService.vim.InvalidLogin {
         }
         interface InvalidController extends vimService.vim.InvalidDeviceSpec {
            controllerKey: number;
         }
         enum InvalidDasConfigArgumentEntryForInvalidArgument {
            "admissionControl",
            "userHeartbeatDs",
            "vmConfig",
         }
         interface InvalidDasConfigArgument extends vimService.vim.InvalidArgument {
            entry?: string;
            clusterName?: string;
         }
         interface InvalidDasRestartPriorityForFtVm extends vimService.vim.InvalidArgument {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidDatastore extends vimService.vim.VimFault {
            datastore?: vimService.vim.ManagedObjectReference;
            name?: string;
         }
         interface InvalidDatastorePath extends vimService.vim.InvalidDatastore {
            datastorePath: string;
         }
         interface InvalidDatastoreState extends vimService.vim.InvalidState {
            datastoreName?: string;
         }
         interface InvalidDeviceBacking extends vimService.vim.InvalidDeviceSpec {
         }
         interface InvalidDeviceOperation extends vimService.vim.InvalidDeviceSpec {
            badOp?: vimService.vim.VirtualDeviceConfigSpecOperation;
            badFileOp?: vimService.vim.VirtualDeviceConfigSpecFileOperation;
         }
         interface InvalidDeviceSpec extends vimService.vim.InvalidVmConfig {
            deviceIndex: number;
         }
         interface InvalidDiskFormat extends vimService.vim.InvalidFormat {
         }
         interface InvalidDrsBehaviorForFtVm extends vimService.vim.InvalidArgument {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface InvalidEditionLicense extends vimService.vim.NotEnoughLicenses {
            feature: string;
         }
         interface InvalidEvent extends vimService.vim.VimFault {
         }
         interface InvalidFolder extends vimService.vim.VimFault {
            target: vimService.vim.ManagedObjectReference;
         }
         interface InvalidFormat extends vimService.vim.VmConfigFault {
         }
         interface InvalidGuestLogin extends vimService.vim.GuestOperationsFault {
         }
         interface InvalidHostConnectionState extends vimService.vim.InvalidHostState {
         }
         interface InvalidHostName extends vimService.vim.HostConfigFault {
         }
         interface InvalidHostState extends vimService.vim.InvalidState {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface InvalidIndexArgument extends vimService.vim.InvalidArgument {
            key: string;
         }
         interface InvalidIpfixConfig extends vimService.vim.DvsFault {
            property?: string;
         }
         interface InvalidIpmiLoginInfo extends vimService.vim.VimFault {
         }
         interface InvalidIpmiMacAddress extends vimService.vim.VimFault {
            userProvidedMacAddress: string;
            observedMacAddress: string;
         }
         interface InvalidLicense extends vimService.vim.VimFault {
            licenseContent: string;
         }
         interface InvalidLocale extends vimService.vim.VimFault {
         }
         interface InvalidLogin extends vimService.vim.VimFault {
         }
         interface InvalidName extends vimService.vim.VimFault {
            name: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface InvalidNasCredentials extends vimService.vim.NasConfigFault {
            userName: string;
         }
         interface InvalidNetworkInType extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidNetworkResource extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface InvalidOperationOnSecondaryVm extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface InvalidPowerState extends vimService.vim.InvalidState {
            requestedState?: vimService.vim.VirtualMachinePowerState;
            existingState: vimService.vim.VirtualMachinePowerState;
         }
         interface InvalidPrivilege extends vimService.vim.VimFault {
            privilege: string;
         }
         enum InvalidProfileReferenceHostReason {
            "incompatibleVersion",
            "missingReferenceHost",
         }
         interface InvalidProfileReferenceHost extends vimService.vim.RuntimeFault {
            reason?: string;
            host?: vimService.vim.ManagedObjectReference;
            profile?: vimService.vim.ManagedObjectReference;
         }
         interface InvalidPropertyType extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidPropertyValue extends vimService.vim.VAppPropertyFault {
         }
         interface InvalidResourcePoolStructureFault extends vimService.vim.InsufficientResourcesFault {
         }
         interface InvalidSnapshotFormat extends vimService.vim.InvalidFormat {
         }
         interface InvalidState extends vimService.vim.VimFault {
         }
         interface InvalidVmConfig extends vimService.vim.VmConfigFault {
            property?: string;
         }
         interface InventoryHasStandardAloneHosts extends vimService.vim.NotEnoughLicenses {
            hosts: Array<string>;
         }
         interface IpHostnameGeneratorError extends vimService.vim.CustomizationFault {
         }
         interface IscsiFault extends vimService.vim.VimFault {
         }
         interface IscsiFaultInvalidVnic extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultPnicInUse extends vimService.vim.IscsiFault {
            pnicDevice: string;
         }
         interface IscsiFaultVnicAlreadyBound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasActivePaths extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasMultipleUplinks extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasNoUplinks extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicHasWrongUplink extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicInUse extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicIsLastPath extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotBound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface IscsiFaultVnicNotFound extends vimService.vim.IscsiFault {
            vnicDevice: string;
         }
         interface LargeRDMConversionNotSupported extends vimService.vim.MigrationFault {
            device: string;
         }
         interface LargeRDMNotSupportedOnDatastore extends vimService.vim.VmConfigFault {
            device: string;
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface LegacyNetworkInterfaceInUse extends vimService.vim.CannotAccessNetwork {
         }
         enum LicenseAssignmentFailedReason {
            "keyEntityMismatch",
            "downgradeDisallowed",
            "inventoryNotManageableByVirtualCenter",
            "hostsUnmanageableByVirtualCenterWithoutLicenseServer",
         }
         interface LicenseAssignmentFailed extends vimService.vim.RuntimeFault {
            reason?: string;
         }
         interface LicenseDowngradeDisallowed extends vimService.vim.NotEnoughLicenses {
            edition: string;
            entityId: string;
            features: Array<vimService.vim.KeyAnyValue>;
         }
         interface LicenseEntityNotFound extends vimService.vim.VimFault {
            entityId: string;
         }
         interface LicenseExpired extends vimService.vim.NotEnoughLicenses {
            licenseKey: string;
         }
         interface LicenseKeyEntityMismatch extends vimService.vim.NotEnoughLicenses {
         }
         interface LicenseRestricted extends vimService.vim.NotEnoughLicenses {
         }
         interface LicenseServerUnavailable extends vimService.vim.VimFault {
            licenseServer: string;
         }
         interface LicenseSourceUnavailable extends vimService.vim.NotEnoughLicenses {
            licenseSource: vimService.vim.LicenseSource;
         }
         interface LimitExceeded extends vimService.vim.VimFault {
            property?: string;
            limit?: number;
         }
         interface LinuxVolumeNotClean extends vimService.vim.CustomizationFault {
         }
         interface LogBundlingFailed extends vimService.vim.VimFault {
         }
         interface MaintenanceModeFileMove extends vimService.vim.MigrationFault {
         }
         interface MemoryFileFormatNotSupportedByDatastore extends vimService.vim.UnsupportedDatastore {
            datastoreName: string;
            type: string;
         }
         interface MemoryHotPlugNotSupported extends vimService.vim.VmConfigFault {
         }
         interface MemorySizeNotRecommended extends vimService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            memorySizeMB: number;
            minMemorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySizeNotSupportedByDatastore extends vimService.vim.VirtualHardwareCompatibilityIssue {
            datastore: vimService.vim.ManagedObjectReference;
            memorySizeMB: number;
            maxMemorySizeMB: number;
         }
         interface MemorySnapshotOnIndependentDisk extends vimService.vim.SnapshotFault {
         }
         interface MethodAlreadyDisabledFault extends vimService.vim.RuntimeFault {
            sourceId: string;
         }
         interface MethodDisabled extends vimService.vim.RuntimeFault {
            source?: string;
         }
         interface MigrationDisabled extends vimService.vim.MigrationFault {
         }
         interface MigrationFault extends vimService.vim.VimFault {
         }
         interface MigrationFeatureNotSupported extends vimService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHostName: string;
            failedHost: vimService.vim.ManagedObjectReference;
         }
         interface MigrationNotReady extends vimService.vim.MigrationFault {
            reason: string;
         }
         interface MismatchedBundle extends vimService.vim.VimFault {
            bundleUuid: string;
            hostUuid: string;
            bundleBuildNumber: number;
            hostBuildNumber: number;
         }
         interface MismatchedNetworkPolicies extends vimService.vim.MigrationFault {
            device: string;
            backing: string;
            connected: boolean;
         }
         interface MismatchedVMotionNetworkNames extends vimService.vim.MigrationFault {
            sourceNetwork: string;
            destNetwork: string;
         }
         interface MissingBmcSupport extends vimService.vim.VimFault {
         }
         interface MissingController extends vimService.vim.InvalidDeviceSpec {
         }
         interface MissingIpPool extends vimService.vim.VAppPropertyFault {
         }
         interface MissingLinuxCustResources extends vimService.vim.CustomizationFault {
         }
         interface MissingNetworkIpConfig extends vimService.vim.VAppPropertyFault {
         }
         interface MissingPowerOffConfiguration extends vimService.vim.VAppConfigFault {
         }
         interface MissingPowerOnConfiguration extends vimService.vim.VAppConfigFault {
         }
         interface MissingWindowsCustResources extends vimService.vim.CustomizationFault {
         }
         interface MksConnectionLimitReached extends vimService.vim.InvalidState {
            connectionLimit: number;
         }
         interface MountError extends vimService.vim.CustomizationFault {
            vm: vimService.vim.ManagedObjectReference;
            diskIndex: number;
         }
         interface MultiWriterNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface MultipleCertificatesVerifyFaultThumbprintData extends vimService.vim.DynamicData {
            port: number;
            thumbprint: string;
         }
         interface ArrayOfMultipleCertificatesVerifyFaultThumbprintData {
            multipleCertificatesVerifyFaultThumbprintData?: Array<vimService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleCertificatesVerifyFault extends vimService.vim.HostConnectFault {
            thumbprintData: Array<vimService.vim.MultipleCertificatesVerifyFaultThumbprintData>;
         }
         interface MultipleSnapshotsNotSupported extends vimService.vim.SnapshotFault {
         }
         interface NamespaceFull extends vimService.vim.VimFault {
            name: string;
            currentMaxSize: number;
            requiredSize?: number;
         }
         interface NamespaceLimitReached extends vimService.vim.VimFault {
            limit?: number;
         }
         interface NamespaceWriteProtected extends vimService.vim.VimFault {
            name: string;
         }
         interface NasConfigFault extends vimService.vim.HostConfigFault {
            name: string;
         }
         interface NasConnectionLimitReached extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NasSessionCredentialConflict extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
            userName: string;
         }
         interface NasVolumeNotMounted extends vimService.vim.NasConfigFault {
            remoteHost: string;
            remotePath: string;
         }
         interface NetworkCopyFault extends vimService.vim.FileFault {
         }
         interface NetworkDisruptedAndConfigRolledBack extends vimService.vim.VimFault {
            host: string;
         }
         interface NetworkInaccessible extends vimService.vim.NasConfigFault {
         }
         interface NetworksMayNotBeTheSame extends vimService.vim.MigrationFault {
            name?: string;
         }
         interface NicSettingMismatch extends vimService.vim.CustomizationFault {
            numberOfNicsInSpec: number;
            numberOfNicsInVM: number;
         }
         interface NoActiveHostInCluster extends vimService.vim.InvalidState {
            computeResource: vimService.vim.ManagedObjectReference;
         }
         interface NoAvailableIp extends vimService.vim.VAppPropertyFault {
            network: vimService.vim.ManagedObjectReference;
         }
         interface NoClientCertificate extends vimService.vim.VimFault {
         }
         interface NoCompatibleDatastore extends vimService.vim.VimFault {
         }
         interface NoCompatibleHardAffinityHost extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoCompatibleHost extends vimService.vim.VimFault {
            host?: Array<vimService.vim.ManagedObjectReference>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface NoCompatibleHostWithAccessToDevice extends vimService.vim.NoCompatibleHost {
         }
         interface NoCompatibleSoftAffinityHost extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface NoConnectedDatastore extends vimService.vim.VimFault {
         }
         interface NoDiskFound extends vimService.vim.VimFault {
         }
         interface NoDiskSpace extends vimService.vim.FileFault {
            datastore: string;
         }
         interface NoDisksToCustomize extends vimService.vim.CustomizationFault {
         }
         interface NoGateway extends vimService.vim.HostConfigFault {
         }
         interface NoGuestHeartbeat extends vimService.vim.MigrationFault {
         }
         interface NoHost extends vimService.vim.HostConnectFault {
            name?: string;
         }
         interface NoHostSuitableForFtSecondary extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
         }
         interface NoLicenseServerConfigured extends vimService.vim.NotEnoughLicenses {
         }
         interface NoPeerHostFound extends vimService.vim.HostPowerOpFailed {
         }
         interface NoPermission extends vimService.vim.SecurityError {
            object: vimService.vim.ManagedObjectReference;
            privilegeId: string;
         }
         interface NoPermissionOnAD extends vimService.vim.ActiveDirectoryFault {
         }
         interface NoPermissionOnHost extends vimService.vim.HostConnectFault {
         }
         interface NoPermissionOnNasVolume extends vimService.vim.NasConfigFault {
            userName?: string;
         }
         interface NoSubjectName extends vimService.vim.VimFault {
         }
         interface NoVcManagedIpConfigured extends vimService.vim.VAppPropertyFault {
         }
         interface NoVirtualNic extends vimService.vim.HostConfigFault {
         }
         interface NoVmInVApp extends vimService.vim.VAppConfigFault {
         }
         interface NonADUserRequired extends vimService.vim.ActiveDirectoryFault {
         }
         interface NonHomeRDMVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
            device: string;
         }
         interface NonPersistentDisksNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface NonVmwareOuiMacNotSupportedHost extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotADirectory extends vimService.vim.FileFault {
         }
         interface NotAFile extends vimService.vim.FileFault {
         }
         interface NotAuthenticated extends vimService.vim.NoPermission {
         }
         interface NotEnoughCpus extends vimService.vim.VirtualHardwareCompatibilityIssue {
            numCpuDest: number;
            numCpuVm: number;
         }
         interface NotEnoughLogicalCpus extends vimService.vim.NotEnoughCpus {
            host?: vimService.vim.ManagedObjectReference;
         }
         interface NotFound extends vimService.vim.VimFault {
         }
         enum NotSupportedDeviceForFTDeviceType {
            "virtualVmxnet3",
            "paraVirtualSCSIController",
         }
         interface NotSupportedDeviceForFT extends vimService.vim.VmFaultToleranceIssue {
            host: vimService.vim.ManagedObjectReference;
            hostName?: string;
            vm: vimService.vim.ManagedObjectReference;
            vmName?: string;
            deviceType: string;
            deviceLabel?: string;
         }
         interface NotSupportedHost extends vimService.vim.HostConnectFault {
            productName?: string;
            productVersion?: string;
         }
         interface NotSupportedHostForChecksum extends vimService.vim.VimFault {
         }
         interface NotSupportedHostForVFlash extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVmcp extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVmemFile extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostForVsan extends vimService.vim.NotSupportedHost {
            hostName: string;
         }
         interface NotSupportedHostInCluster extends vimService.vim.NotSupportedHost {
         }
         interface NotSupportedHostInDvs extends vimService.vim.NotSupportedHost {
            switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec;
         }
         interface NotSupportedHostInHACluster extends vimService.vim.NotSupportedHost {
            hostName: string;
            build: string;
         }
         interface NotUserConfigurableProperty extends vimService.vim.VAppPropertyFault {
         }
         interface NumVirtualCoresPerSocketNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedCoresPerSocketDest: number;
            numCoresPerSocketVm: number;
         }
         interface NumVirtualCpusExceedsLimit extends vimService.vim.InsufficientResourcesFault {
            maxSupportedVcpus: number;
         }
         enum NumVirtualCpusIncompatibleReason {
            "recordReplay",
            "faultTolerance",
         }
         interface NumVirtualCpusIncompatible extends vimService.vim.VmConfigFault {
            reason: string;
            numCpu: number;
         }
         interface NumVirtualCpusNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            maxSupportedVcpusDest: number;
            numCpuVm: number;
         }
         interface OperationDisabledByGuest extends vimService.vim.GuestOperationsFault {
         }
         interface OperationDisallowedOnHost extends vimService.vim.RuntimeFault {
         }
         interface OperationNotSupportedByGuest extends vimService.vim.GuestOperationsFault {
         }
         interface OutOfBounds extends vimService.vim.VimFault {
            argumentName: string;
         }
         interface OvfAttribute extends vimService.vim.OvfInvalidPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfConnectedDevice extends vimService.vim.OvfHardwareExport {
         }
         interface OvfConnectedDeviceFloppy extends vimService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConnectedDeviceIso extends vimService.vim.OvfConnectedDevice {
            filename: string;
         }
         interface OvfConstraint extends vimService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfConsumerCallbackFault extends vimService.vim.OvfFault {
            extensionKey: string;
            extensionName: string;
         }
         interface OvfConsumerCommunicationError extends vimService.vim.OvfConsumerCallbackFault {
            description: string;
         }
         interface OvfConsumerFault extends vimService.vim.OvfConsumerCallbackFault {
            errorKey: string;
            message: string;
            params?: Array<vimService.vim.KeyValue>;
         }
         interface OvfConsumerInvalidSection extends vimService.vim.OvfConsumerCallbackFault {
            lineNumber: number;
            description: string;
         }
         interface OvfConsumerPowerOnFault extends vimService.vim.InvalidState {
            extensionKey: string;
            extensionName: string;
            description: string;
         }
         interface OvfConsumerUndeclaredSection extends vimService.vim.OvfConsumerCallbackFault {
            qualifiedSectionType: string;
         }
         interface OvfConsumerUndefinedPrefix extends vimService.vim.OvfConsumerCallbackFault {
            prefix: string;
         }
         interface OvfConsumerValidationFault extends vimService.vim.VmConfigFault {
            extensionKey: string;
            extensionName: string;
            message: string;
         }
         interface OvfCpuCompatibility extends vimService.vim.OvfImport {
            registerName: string;
            level: number;
            registerValue: string;
            desiredRegisterValue: string;
         }
         interface OvfCpuCompatibilityCheckNotSupported extends vimService.vim.OvfImport {
         }
         interface OvfDiskMappingNotFound extends vimService.vim.OvfSystemFault {
            diskName: string;
            vmName: string;
         }
         interface OvfDiskOrderConstraint extends vimService.vim.OvfConstraint {
         }
         interface OvfDuplicateElement extends vimService.vim.OvfElement {
         }
         interface OvfDuplicatedElementBoundary extends vimService.vim.OvfElement {
            boundary: string;
         }
         interface OvfDuplicatedPropertyIdExport extends vimService.vim.OvfExport {
            fqid: string;
         }
         interface OvfDuplicatedPropertyIdImport extends vimService.vim.OvfExport {
         }
         interface OvfElement extends vimService.vim.OvfInvalidPackage {
            name: string;
         }
         interface OvfElementInvalidValue extends vimService.vim.OvfElement {
            value: string;
         }
         interface OvfExport extends vimService.vim.OvfFault {
         }
         interface OvfExportFailed extends vimService.vim.OvfExport {
         }
         interface OvfFault extends vimService.vim.VimFault {
         }
         interface OvfHardwareCheck extends vimService.vim.OvfImport {
         }
         interface OvfHardwareExport extends vimService.vim.OvfExport {
            device?: vimService.vim.VirtualDevice;
            vmPath: string;
         }
         interface OvfHostResourceConstraint extends vimService.vim.OvfConstraint {
            value: string;
         }
         interface OvfHostValueNotParsed extends vimService.vim.OvfSystemFault {
            property: string;
            value: string;
         }
         interface OvfImport extends vimService.vim.OvfFault {
         }
         interface OvfImportFailed extends vimService.vim.OvfImport {
         }
         interface OvfInternalError extends vimService.vim.OvfSystemFault {
         }
         interface OvfInvalidPackage extends vimService.vim.OvfFault {
            lineNumber: number;
         }
         interface OvfInvalidValue extends vimService.vim.OvfAttribute {
            value: string;
         }
         interface OvfInvalidValueConfiguration extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueEmpty extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueFormatMalformed extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidValueReference extends vimService.vim.OvfInvalidValue {
         }
         interface OvfInvalidVmName extends vimService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfMappedOsId extends vimService.vim.OvfImport {
            ovfId: number;
            ovfDescription: string;
            targetDescription: string;
         }
         interface OvfMissingAttribute extends vimService.vim.OvfAttribute {
         }
         interface OvfMissingElement extends vimService.vim.OvfElement {
         }
         interface OvfMissingElementNormalBoundary extends vimService.vim.OvfMissingElement {
            boundary: string;
         }
         interface OvfMissingHardware extends vimService.vim.OvfImport {
            name: string;
            resourceType: number;
         }
         interface OvfNetworkMappingNotSupported extends vimService.vim.OvfImport {
         }
         interface OvfNoHostNic extends vimService.vim.OvfUnsupportedPackage {
         }
         interface OvfNoSpaceOnController extends vimService.vim.OvfUnsupportedElement {
            parent: string;
         }
         interface OvfNoSupportedHardwareFamily extends vimService.vim.OvfUnsupportedPackage {
            version: string;
         }
         interface OvfProperty extends vimService.vim.OvfInvalidPackage {
            type: string;
            value: string;
         }
         interface OvfPropertyExport extends vimService.vim.OvfExport {
            type: string;
            value: string;
         }
         interface OvfPropertyNetwork extends vimService.vim.OvfProperty {
         }
         interface OvfPropertyNetworkExport extends vimService.vim.OvfExport {
            network: string;
         }
         interface OvfPropertyQualifier extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierDuplicate extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyQualifierIgnored extends vimService.vim.OvfProperty {
            qualifier: string;
         }
         interface OvfPropertyType extends vimService.vim.OvfProperty {
         }
         interface OvfPropertyValue extends vimService.vim.OvfProperty {
         }
         interface OvfSystemFault extends vimService.vim.OvfFault {
         }
         interface OvfToXmlUnsupportedElement extends vimService.vim.OvfSystemFault {
            name?: string;
         }
         interface OvfUnableToExportDisk extends vimService.vim.OvfHardwareExport {
            diskName: string;
         }
         interface OvfUnexpectedElement extends vimService.vim.OvfElement {
         }
         interface OvfUnknownDevice extends vimService.vim.OvfSystemFault {
            device?: vimService.vim.VirtualDevice;
            vmName: string;
         }
         interface OvfUnknownDeviceBacking extends vimService.vim.OvfHardwareExport {
            backing: vimService.vim.VirtualDeviceBackingInfo;
         }
         interface OvfUnknownEntity extends vimService.vim.OvfSystemFault {
            lineNumber: number;
         }
         interface OvfUnsupportedAttribute extends vimService.vim.OvfUnsupportedPackage {
            elementName: string;
            attributeName: string;
         }
         interface OvfUnsupportedAttributeValue extends vimService.vim.OvfUnsupportedAttribute {
            value: string;
         }
         interface OvfUnsupportedDeviceBackingInfo extends vimService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceBackingOption extends vimService.vim.OvfSystemFault {
            elementName?: string;
            instanceId?: string;
            deviceName: string;
            backingName?: string;
         }
         interface OvfUnsupportedDeviceExport extends vimService.vim.OvfHardwareExport {
         }
         interface OvfUnsupportedDiskProvisioning extends vimService.vim.OvfImport {
            diskProvisioning: string;
            supportedDiskProvisioning: string;
         }
         interface OvfUnsupportedElement extends vimService.vim.OvfUnsupportedPackage {
            name: string;
         }
         interface OvfUnsupportedElementValue extends vimService.vim.OvfUnsupportedElement {
            value: string;
         }
         interface OvfUnsupportedPackage extends vimService.vim.OvfFault {
            lineNumber?: number;
         }
         interface OvfUnsupportedSection extends vimService.vim.OvfUnsupportedElement {
            info: string;
         }
         interface OvfUnsupportedSubType extends vimService.vim.OvfUnsupportedPackage {
            elementName: string;
            instanceId: string;
            deviceType: number;
            deviceSubType: string;
         }
         interface OvfUnsupportedType extends vimService.vim.OvfUnsupportedPackage {
            name: string;
            instanceId: string;
            deviceType: number;
         }
         interface OvfWrongElement extends vimService.vim.OvfElement {
         }
         interface OvfWrongNamespace extends vimService.vim.OvfInvalidPackage {
            namespaceName: string;
         }
         interface OvfXmlFormat extends vimService.vim.OvfInvalidPackage {
            description: string;
         }
         interface PatchAlreadyInstalled extends vimService.vim.PatchNotApplicable {
         }
         interface PatchBinariesNotFound extends vimService.vim.VimFault {
            patchID: string;
            binary?: Array<string>;
         }
         interface PatchInstallFailed extends vimService.vim.PlatformConfigFault {
            rolledBack: boolean;
         }
         interface PatchIntegrityError extends vimService.vim.PlatformConfigFault {
         }
         interface PatchMetadataCorrupted extends vimService.vim.PatchMetadataInvalid {
         }
         interface PatchMetadataInvalid extends vimService.vim.VimFault {
            patchID: string;
            metaData?: Array<string>;
         }
         interface PatchMetadataNotFound extends vimService.vim.PatchMetadataInvalid {
         }
         interface PatchMissingDependencies extends vimService.vim.PatchNotApplicable {
            prerequisitePatch?: Array<string>;
            prerequisiteLib?: Array<string>;
         }
         interface PatchNotApplicable extends vimService.vim.VimFault {
            patchID: string;
         }
         interface PatchSuperseded extends vimService.vim.PatchNotApplicable {
            supersede?: Array<string>;
         }
         interface PhysCompatRDMNotSupported extends vimService.vim.RDMNotSupported {
         }
         interface PlatformConfigFault extends vimService.vim.HostConfigFault {
            text: string;
         }
         interface PowerOnFtSecondaryFailed extends vimService.vim.VmFaultToleranceIssue {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
            hostSelectionBy: vimService.vim.FtIssuesOnHostHostSelectionType;
            hostErrors?: Array<vimService.vim.LocalizedMethodFault>;
            rootCause: vimService.vim.LocalizedMethodFault;
         }
         interface PowerOnFtSecondaryTimedout extends vimService.vim.Timedout {
            vm: vimService.vim.ManagedObjectReference;
            vmName: string;
            timeout: number;
         }
         interface ProfileUpdateFailedUpdateFailure extends vimService.vim.DynamicData {
            profilePath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileUpdateFailedUpdateFailure {
            profileUpdateFailedUpdateFailure?: Array<vimService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         interface ProfileUpdateFailed extends vimService.vim.VimFault {
            failure: Array<vimService.vim.ProfileUpdateFailedUpdateFailure>;
         }
         interface QuestionPending extends vimService.vim.InvalidState {
            text: string;
         }
         interface QuiesceDatastoreIOForHAFailed extends vimService.vim.ResourceInUse {
            host: vimService.vim.ManagedObjectReference;
            hostName: string;
            ds: vimService.vim.ManagedObjectReference;
            dsName: string;
         }
         interface RDMConversionNotSupported extends vimService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotPreserved extends vimService.vim.MigrationFault {
            device: string;
         }
         interface RDMNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface RDMNotSupportedOnDatastore extends vimService.vim.VmConfigFault {
            device: string;
            datastore: vimService.vim.ManagedObjectReference;
            datastoreName: string;
         }
         interface RDMPointsToInaccessibleDisk extends vimService.vim.CannotAccessVmDisk {
         }
         interface RawDiskNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface ReadHostResourcePoolTreeFailed extends vimService.vim.HostConnectFault {
         }
         interface ReadOnlyDisksWithLegacyDestination extends vimService.vim.MigrationFault {
            roDiskCount: number;
            timeoutDanger: boolean;
         }
         interface RebootRequired extends vimService.vim.VimFault {
            patch?: string;
         }
         interface RecordReplayDisabled extends vimService.vim.VimFault {
         }
         interface RemoteDeviceNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface RemoveFailed extends vimService.vim.VimFault {
         }
         interface ReplicationConfigFault extends vimService.vim.ReplicationFault {
         }
         enum ReplicationDiskConfigFaultReasonForFault {
            "diskNotFound",
            "diskTypeNotSupported",
            "invalidDiskKey",
            "invalidDiskReplicationId",
            "duplicateDiskReplicationId",
            "invalidPersistentFilePath",
            "reconfigureDiskReplicationIdNotAllowed",
         }
         interface ReplicationDiskConfigFault extends vimService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: vimService.vim.ManagedObjectReference;
            key?: number;
         }
         interface ReplicationFault extends vimService.vim.VimFault {
         }
         interface ReplicationIncompatibleWithFT extends vimService.vim.ReplicationFault {
         }
         interface ReplicationInvalidOptions extends vimService.vim.ReplicationFault {
            options: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface ReplicationNotSupportedOnHost extends vimService.vim.ReplicationFault {
         }
         enum ReplicationVmConfigFaultReasonForFault {
            "incompatibleHwVersion",
            "invalidVmReplicationId",
            "invalidGenerationNumber",
            "outOfBoundsRpoValue",
            "invalidDestinationIpAddress",
            "invalidDestinationPort",
            "invalidExtraVmOptions",
            "staleGenerationNumber",
            "reconfigureVmReplicationIdNotAllowed",
            "cannotRetrieveVmReplicationConfiguration",
            "replicationAlreadyEnabled",
            "invalidPriorConfiguration",
            "replicationNotEnabled",
            "replicationConfigurationFailed",
         }
         interface ReplicationVmConfigFault extends vimService.vim.ReplicationConfigFault {
            reason?: string;
            vmRef?: vimService.vim.ManagedObjectReference;
         }
         enum ReplicationVmFaultReasonForFault {
            "notConfigured",
            "poweredOff",
            "suspended",
            "poweredOn",
            "offlineReplicating",
            "invalidState",
            "invalidInstanceId",
            "closeDiskError",
         }
         interface ReplicationVmFault extends vimService.vim.ReplicationFault {
            reason?: string;
            state?: string;
            instanceId?: string;
            vm?: vimService.vim.ManagedObjectReference;
         }
         enum ReplicationVmInProgressFaultActivity {
            "fullSync",
            "delta",
         }
         interface ReplicationVmInProgressFault extends vimService.vim.ReplicationVmFault {
            requestedActivity: string;
            inProgressActivity: string;
         }
         interface ResourceInUse extends vimService.vim.VimFault {
            type?: string;
            name?: string;
         }
         interface ResourceNotAvailable extends vimService.vim.VimFault {
            containerType?: string;
            containerName?: string;
            type?: string;
         }
         interface RestrictedByAdministrator extends vimService.vim.RuntimeFault {
            details: string;
         }
         interface RestrictedVersion extends vimService.vim.SecurityError {
         }
         interface RollbackFailure extends vimService.vim.DvsFault {
            entityName: string;
            entityType: string;
         }
         interface RuleViolation extends vimService.vim.VmConfigFault {
            host?: vimService.vim.ManagedObjectReference;
            rule?: vimService.vim.ClusterRuleInfo;
         }
         interface SSLDisabledFault extends vimService.vim.HostConnectFault {
         }
         interface SSLVerifyFault extends vimService.vim.HostConnectFault {
            selfSigned: boolean;
            thumbprint: string;
         }
         interface SSPIChallenge extends vimService.vim.VimFault {
            base64Token: string;
         }
         interface SecondaryVmAlreadyDisabled extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyEnabled extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid: string;
         }
         interface SecondaryVmAlreadyRegistered extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SecondaryVmNotRegistered extends vimService.vim.VmFaultToleranceIssue {
            instanceUuid?: string;
         }
         interface SharedBusControllerNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface ShrinkDiskFault extends vimService.vim.VimFault {
            diskId?: number;
         }
         interface SnapshotCloneNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotCopyNotSupported extends vimService.vim.MigrationFault {
         }
         interface SnapshotDisabled extends vimService.vim.SnapshotFault {
         }
         interface SnapshotFault extends vimService.vim.VimFault {
         }
         interface SnapshotIncompatibleDeviceInVm extends vimService.vim.SnapshotFault {
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface SnapshotLocked extends vimService.vim.SnapshotFault {
         }
         interface SnapshotMoveFromNonHomeNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotMoveToNonHomeNotSupported extends vimService.vim.SnapshotCopyNotSupported {
         }
         interface SnapshotNoChange extends vimService.vim.SnapshotFault {
         }
         interface SnapshotRevertIssue extends vimService.vim.MigrationFault {
            snapshotName?: string;
            event?: Array<vimService.vim.Event>;
            errors: boolean;
         }
         interface SoftRuleVioCorrectionDisallowed extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface SoftRuleVioCorrectionImpact extends vimService.vim.VmConfigFault {
            vmName: string;
         }
         interface SsdDiskNotAvailable extends vimService.vim.VimFault {
            devicePath: string;
         }
         interface StorageDrsCannotMoveDiskInMultiWriterMode extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveFTVm extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveIndependentDisk extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedSwapFile extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveManuallyPlacedVm extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveSharedDisk extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveTemplate extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmInUserFolder extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithMountedCDROM extends vimService.vim.VimFault {
         }
         interface StorageDrsCannotMoveVmWithNoFilesInLayout extends vimService.vim.VimFault {
         }
         interface StorageDrsDatacentersCannotShareDatastore extends vimService.vim.VimFault {
         }
         interface StorageDrsDisabledOnVm extends vimService.vim.VimFault {
         }
         interface StorageDrsHbrDiskNotMovable extends vimService.vim.VimFault {
            nonMovableDiskIds: string;
         }
         interface StorageDrsHmsMoveInProgress extends vimService.vim.VimFault {
         }
         interface StorageDrsHmsUnreachable extends vimService.vim.VimFault {
         }
         interface StorageDrsIolbDisabledInternally extends vimService.vim.VimFault {
         }
         interface StorageDrsRelocateDisabled extends vimService.vim.VimFault {
         }
         interface StorageDrsStaleHmsCollection extends vimService.vim.VimFault {
         }
         interface StorageDrsUnableToMoveFiles extends vimService.vim.VimFault {
         }
         interface StorageVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface StorageVmotionIncompatible extends vimService.vim.VirtualHardwareCompatibilityIssue {
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface SuspendedRelocateNotSupported extends vimService.vim.MigrationFault {
         }
         interface SwapDatastoreNotWritableOnHost extends vimService.vim.DatastoreNotWritableOnHost {
         }
         interface SwapDatastoreUnset extends vimService.vim.VimFault {
         }
         interface SwapPlacementOverrideNotSupported extends vimService.vim.InvalidVmConfig {
         }
         interface SwitchIpUnset extends vimService.vim.DvsFault {
         }
         interface SwitchNotInUpgradeMode extends vimService.vim.DvsFault {
         }
         interface TaskInProgress extends vimService.vim.VimFault {
            task: vimService.vim.ManagedObjectReference;
         }
         enum ThirdPartyLicenseAssignmentFailedReason {
            "licenseAssignmentFailed",
            "moduleNotInstalled",
         }
         interface ThirdPartyLicenseAssignmentFailed extends vimService.vim.RuntimeFault {
            host: vimService.vim.ManagedObjectReference;
            module: string;
            reason?: string;
         }
         interface Timedout extends vimService.vim.VimFault {
         }
         interface TooManyConcurrentNativeClones extends vimService.vim.FileFault {
         }
         interface TooManyConsecutiveOverrides extends vimService.vim.VimFault {
         }
         interface TooManyDevices extends vimService.vim.InvalidVmConfig {
         }
         interface TooManyDisksOnLegacyHost extends vimService.vim.MigrationFault {
            diskCount: number;
            timeoutDanger: boolean;
         }
         interface TooManyGuestLogons extends vimService.vim.GuestOperationsFault {
         }
         interface TooManyHosts extends vimService.vim.HostConnectFault {
         }
         interface TooManyNativeCloneLevels extends vimService.vim.FileFault {
         }
         interface TooManyNativeClonesOnFile extends vimService.vim.FileFault {
         }
         interface TooManySnapshotLevels extends vimService.vim.SnapshotFault {
         }
         interface ToolsAlreadyUpgraded extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsAutoUpgradeNotSupported extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageCopyFailed extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageNotAvailable extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsImageSignatureCheckFailed extends vimService.vim.VmToolsUpgradeFault {
         }
         interface ToolsInstallationInProgress extends vimService.vim.MigrationFault {
         }
         interface ToolsUnavailable extends vimService.vim.VimFault {
         }
         interface ToolsUpgradeCancelled extends vimService.vim.VmToolsUpgradeFault {
         }
         interface UnSupportedDatastoreForVFlash extends vimService.vim.UnsupportedDatastore {
            datastoreName: string;
            type: string;
         }
         interface UncommittedUndoableDisk extends vimService.vim.MigrationFault {
         }
         interface UnconfiguredPropertyValue extends vimService.vim.InvalidPropertyValue {
         }
         interface UncustomizableGuest extends vimService.vim.CustomizationFault {
            uncustomizableGuestOS: string;
         }
         interface UnexpectedCustomizationFault extends vimService.vim.CustomizationFault {
         }
         interface UnrecognizedHost extends vimService.vim.VimFault {
            hostName: string;
         }
         interface UnsharedSwapVMotionNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface UnsupportedDatastore extends vimService.vim.VmConfigFault {
            datastore?: vimService.vim.ManagedObjectReference;
         }
         interface UnsupportedGuest extends vimService.vim.InvalidVmConfig {
            unsupportedGuestOS: string;
         }
         interface UnsupportedVimApiVersion extends vimService.vim.VimFault {
            version?: string;
         }
         interface UnsupportedVmxLocation extends vimService.vim.VmConfigFault {
         }
         interface UnusedVirtualDiskBlocksNotScrubbed extends vimService.vim.DeviceBackingNotSupported {
         }
         interface UserNotFound extends vimService.vim.VimFault {
            principal: string;
            unresolved: boolean;
         }
         interface VAppConfigFault extends vimService.vim.VimFault {
         }
         interface VAppNotRunning extends vimService.vim.VmConfigFault {
         }
         interface VAppOperationInProgress extends vimService.vim.RuntimeFault {
         }
         interface VAppPropertyFault extends vimService.vim.VmConfigFault {
            id: string;
            category: string;
            label: string;
            type: string;
            value: string;
         }
         interface VAppTaskInProgress extends vimService.vim.TaskInProgress {
         }
         interface VFlashCacheHotConfigNotSupported extends vimService.vim.VmConfigFault {
         }
         enum VFlashModuleNotSupportedReason {
            "CacheModeNotSupported",
            "CacheConsistencyTypeNotSupported",
            "CacheBlockSizeNotSupported",
            "CacheReservationNotSupported",
            "DiskSizeNotSupported",
         }
         interface VFlashModuleNotSupported extends vimService.vim.VmConfigFault {
            vmName: string;
            moduleName: string;
            reason: string;
            hostName: string;
         }
         interface VFlashModuleVersionIncompatible extends vimService.vim.VimFault {
            moduleName: string;
            vmRequestModuleVersion: string;
            hostMinSupportedVerson: string;
            hostModuleVersion: string;
         }
         interface VMINotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface VMOnConflictDVPort extends vimService.vim.CannotAccessNetwork {
         }
         interface VMOnVirtualIntranet extends vimService.vim.CannotAccessNetwork {
         }
         interface VMotionAcrossNetworkNotSupported extends vimService.vim.MigrationFeatureNotSupported {
         }
         interface VMotionInterfaceIssue extends vimService.vim.MigrationFault {
            atSourceHost: boolean;
            failedHost: string;
            failedHostEntity?: vimService.vim.ManagedObjectReference;
         }
         interface VMotionLinkCapacityLow extends vimService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionLinkDown extends vimService.vim.VMotionInterfaceIssue {
            network: string;
         }
         interface VMotionNotConfigured extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotLicensed extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionNotSupported extends vimService.vim.VMotionInterfaceIssue {
         }
         interface VMotionProtocolIncompatible extends vimService.vim.MigrationFault {
         }
         interface VimFault extends vimService.vim.MethodFault {
         }
         interface VirtualDiskBlocksNotFullyProvisioned extends vimService.vim.DeviceBackingNotSupported {
         }
         interface VirtualDiskModeNotSupported extends vimService.vim.DeviceNotSupported {
            mode: string;
         }
         interface VirtualEthernetCardNotSupported extends vimService.vim.DeviceNotSupported {
         }
         interface VirtualHardwareCompatibilityIssue extends vimService.vim.VmConfigFault {
         }
         interface VirtualHardwareVersionNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
            hostName: string;
            host: vimService.vim.ManagedObjectReference;
         }
         interface VmAlreadyExistsInDatacenter extends vimService.vim.InvalidFolder {
            host: vimService.vim.ManagedObjectReference;
            hostname: string;
            vm: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VmConfigFault extends vimService.vim.VimFault {
         }
         interface VmConfigIncompatibleForFaultTolerance extends vimService.vim.VmConfigFault {
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface VmConfigIncompatibleForRecordReplay extends vimService.vim.VmConfigFault {
            fault?: vimService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceConfigIssueReasonForIssue {
            "haNotEnabled",
            "moreThanOneSecondary",
            "recordReplayNotSupported",
            "replayNotSupported",
            "templateVm",
            "multipleVCPU",
            "hostInactive",
            "ftUnsupportedHardware",
            "ftUnsupportedProduct",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "thinDisk",
            "verifySSLCertificateFlagNotSet",
            "hasSnapshots",
            "noConfig",
            "ftSecondaryVm",
            "hasLocalDisk",
            "esxAgentVm",
            "video3dEnabled",
            "hasUnsupportedDisk",
            "insufficientBandwidth",
            "hasNestedHVConfiguration",
            "hasVFlashConfiguration",
            "unsupportedProduct",
            "cpuHvUnsupported",
            "cpuHwmmuUnsupported",
            "cpuHvDisabled",
            "hasEFIFirmware",
         }
         interface VmFaultToleranceConfigIssue extends vimService.vim.VmFaultToleranceIssue {
            reason?: string;
            entityName?: string;
            entity?: vimService.vim.ManagedObjectReference;
         }
         interface VmFaultToleranceConfigIssueWrapper extends vimService.vim.VmFaultToleranceIssue {
            entityName?: string;
            entity?: vimService.vim.ManagedObjectReference;
            error?: vimService.vim.LocalizedMethodFault;
         }
         enum VmFaultToleranceInvalidFileBackingDeviceType {
            "virtualFloppy",
            "virtualCdrom",
            "virtualSerialPort",
            "virtualParallelPort",
            "virtualDisk",
         }
         interface VmFaultToleranceInvalidFileBacking extends vimService.vim.VmFaultToleranceIssue {
            backingType?: string;
            backingFilename?: string;
         }
         interface VmFaultToleranceIssue extends vimService.vim.VimFault {
         }
         interface VmFaultToleranceOpIssuesList extends vimService.vim.VmFaultToleranceIssue {
            errors?: Array<vimService.vim.LocalizedMethodFault>;
            warnings?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface VmFaultToleranceTooManyFtVcpusOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumFtVcpus: number;
         }
         interface VmFaultToleranceTooManyVMsOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumFtVms: number;
         }
         interface VmHostAffinityRuleViolation extends vimService.vim.VmConfigFault {
            vmName: string;
            hostName: string;
         }
         interface VmLimitLicense extends vimService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VmMetadataManagerFault extends vimService.vim.VimFault {
         }
         interface VmMonitorIncompatibleForFaultTolerance extends vimService.vim.VimFault {
         }
         interface VmPowerOnDisabled extends vimService.vim.InvalidState {
         }
         interface VmSmpFaultToleranceTooManyVMsOnHost extends vimService.vim.InsufficientResourcesFault {
            hostName?: string;
            maxNumSmpFtVms: number;
         }
         interface VmToolsUpgradeFault extends vimService.vim.VimFault {
         }
         interface VmValidateMaxDevice extends vimService.vim.VimFault {
            device: string;
            max: number;
            count: number;
         }
         interface VmWwnConflict extends vimService.vim.InvalidVmConfig {
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            name?: string;
            wwn?: number;
         }
         interface VmfsAlreadyMounted extends vimService.vim.VmfsMountFault {
         }
         interface VmfsAmbiguousMount extends vimService.vim.VmfsMountFault {
         }
         interface VmfsMountFault extends vimService.vim.HostConfigFault {
            uuid: string;
         }
         interface VmotionInterfaceNotEnabled extends vimService.vim.HostPowerOpFailed {
         }
         interface VolumeEditorError extends vimService.vim.CustomizationFault {
         }
         interface VramLimitLicense extends vimService.vim.NotEnoughLicenses {
            limit: number;
         }
         interface VsanClusterUuidMismatch extends vimService.vim.CannotMoveVsanEnabledHost {
            hostClusterUuid: string;
            destinationClusterUuid: string;
         }
         interface VsanDiskFault extends vimService.vim.VsanFault {
            device?: string;
         }
         interface VsanFault extends vimService.vim.VimFault {
         }
         interface VsanIncompatibleDiskMapping extends vimService.vim.VsanDiskFault {
         }
         interface VspanDestPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey1: string;
            vspanSessionKey2: string;
            portKey: string;
         }
         interface VspanPortMoveFault extends vimService.vim.DvsFault {
            srcPortgroupName: string;
            destPortgroupName: string;
            portKey: string;
         }
         interface VspanPortPromiscChangeFault extends vimService.vim.DvsFault {
            portKey: string;
         }
         interface VspanPortgroupPromiscChangeFault extends vimService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPortgroupTypeChangeFault extends vimService.vim.DvsFault {
            portgroupName: string;
         }
         interface VspanPromiscuousPortNotSupported extends vimService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface VspanSameSessionPortConflict extends vimService.vim.DvsFault {
            vspanSessionKey: string;
            portKey: string;
         }
         interface WakeOnLanNotSupported extends vimService.vim.VirtualHardwareCompatibilityIssue {
         }
         interface WakeOnLanNotSupportedByVmotionNIC extends vimService.vim.HostPowerOpFailed {
         }
         enum WillLoseHAProtectionResolution {
            "svmotion",
            "relocate",
         }
         interface WillLoseHAProtection extends vimService.vim.MigrationFault {
            resolution: string;
         }
         interface WillModifyConfigCpuRequirements extends vimService.vim.MigrationFault {
         }
         interface WillResetSnapshotDirectory extends vimService.vim.MigrationFault {
         }
         interface WipeDiskFault extends vimService.vim.VimFault {
         }
         enum HostActiveDirectoryAuthenticationCertificateDigest {
            "SHA1",
         }
         enum HostActiveDirectoryInfoDomainMembershipStatus {
            "unknown",
            "ok",
            "noServers",
            "clientTrustBroken",
            "serverTrustBroken",
            "inconsistentTrust",
            "otherProblem",
         }
         interface HostActiveDirectoryInfo extends vimService.vim.HostDirectoryStoreInfo {
            joinedDomain?: string;
            trustedDomain?: Array<string>;
            domainMembershipStatus?: string;
            smartCardAuthenticationEnabled?: boolean;
         }
         interface HostActiveDirectorySpec extends vimService.vim.DynamicData {
            domainName?: string;
            userName?: string;
            password?: string;
            camServer?: string;
            thumbprint?: string;
            smartCardAuthenticationEnabled?: boolean;
            smartCardTrustAnchors?: Array<string>;
         }
         interface HostActiveDirectory extends vimService.vim.DynamicData {
            changeOperation: string;
            spec?: vimService.vim.HostActiveDirectorySpec;
         }
         interface ArrayOfHostActiveDirectory {
            hostActiveDirectory?: Array<vimService.vim.HostActiveDirectory>;
         }
         interface HostAuthenticationManagerInfo extends vimService.vim.DynamicData {
            authConfig: Array<vimService.vim.HostAuthenticationStoreInfo>;
         }
         interface HostAuthenticationStoreInfo extends vimService.vim.DynamicData {
            enabled: boolean;
         }
         interface ArrayOfHostAuthenticationStoreInfo {
            hostAuthenticationStoreInfo?: Array<vimService.vim.HostAuthenticationStoreInfo>;
         }
         enum AutoStartAction {
            "none",
            "systemDefault",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface AutoStartDefaults extends vimService.vim.DynamicData {
            enabled?: boolean;
            startDelay?: number;
            stopDelay?: number;
            waitForHeartbeat?: boolean;
            stopAction?: string;
         }
         enum AutoStartWaitHeartbeatSetting {
            "yes",
            "no",
            "systemDefault",
         }
         interface AutoStartPowerInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            startOrder: number;
            startDelay: number;
            waitForHeartbeat: vimService.vim.AutoStartWaitHeartbeatSetting;
            startAction: string;
            stopDelay: number;
            stopAction: string;
         }
         interface ArrayOfAutoStartPowerInfo {
            autoStartPowerInfo?: Array<vimService.vim.AutoStartPowerInfo>;
         }
         interface HostAutoStartManagerConfig extends vimService.vim.DynamicData {
            defaults?: vimService.vim.AutoStartDefaults;
            powerInfo?: Array<vimService.vim.AutoStartPowerInfo>;
         }
         interface HostBootDeviceInfo extends vimService.vim.DynamicData {
            bootDevices?: Array<vimService.vim.HostBootDevice>;
            currentBootDeviceKey?: string;
         }
         interface HostBootDevice extends vimService.vim.DynamicData {
            key: string;
            description: string;
         }
         interface ArrayOfHostBootDevice {
            hostBootDevice?: Array<vimService.vim.HostBootDevice>;
         }
         interface HostCacheConfigurationSpec extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface HostCacheConfigurationInfo extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            swapSize: number;
         }
         interface ArrayOfHostCacheConfigurationInfo {
            hostCacheConfigurationInfo?: Array<vimService.vim.HostCacheConfigurationInfo>;
         }
         enum HostReplayUnsupportedReason {
            "incompatibleProduct",
            "incompatibleCpu",
            "hvDisabled",
            "cpuidLimitSet",
            "oldBIOS",
            "unknown",
         }
         enum HostCapabilityFtUnsupportedReason {
            "vMotionNotLicensed",
            "missingVMotionNic",
            "missingFTLoggingNic",
            "ftNotLicensed",
            "haAgentIssue",
            "unsupportedProduct",
            "cpuHvUnsupported",
            "cpuHwmmuUnsupported",
            "cpuHvDisabled",
         }
         enum HostCapabilityVmDirectPathGen2UnsupportedReason {
            "hostNptIncompatibleProduct",
            "hostNptIncompatibleHardware",
            "hostNptDisabled",
         }
         interface HostCapability extends vimService.vim.DynamicData {
            recursiveResourcePoolsSupported: boolean;
            cpuMemoryResourceConfigurationSupported: boolean;
            rebootSupported: boolean;
            shutdownSupported: boolean;
            vmotionSupported: boolean;
            standbySupported: boolean;
            ipmiSupported?: boolean;
            maxSupportedVMs?: number;
            maxRunningVMs?: number;
            maxSupportedVcpus?: number;
            maxRegisteredVMs?: number;
            datastorePrincipalSupported: boolean;
            sanSupported: boolean;
            nfsSupported: boolean;
            iscsiSupported: boolean;
            vlanTaggingSupported: boolean;
            nicTeamingSupported: boolean;
            highGuestMemSupported: boolean;
            maintenanceModeSupported: boolean;
            suspendedRelocateSupported: boolean;
            restrictedSnapshotRelocateSupported: boolean;
            perVmSwapFiles: boolean;
            localSwapDatastoreSupported: boolean;
            unsharedSwapVMotionSupported: boolean;
            backgroundSnapshotsSupported: boolean;
            preAssignedPCIUnitNumbersSupported: boolean;
            screenshotSupported: boolean;
            scaledScreenshotSupported: boolean;
            storageVMotionSupported?: boolean;
            vmotionWithStorageVMotionSupported?: boolean;
            vmotionAcrossNetworkSupported?: boolean;
            maxNumDisksSVMotion?: number;
            hbrNicSelectionSupported?: boolean;
            vrNfcNicSelectionSupported?: boolean;
            recordReplaySupported?: boolean;
            ftSupported?: boolean;
            replayUnsupportedReason?: string;
            replayCompatibilityIssues?: Array<string>;
            smpFtSupported?: boolean;
            ftCompatibilityIssues?: Array<string>;
            smpFtCompatibilityIssues?: Array<string>;
            maxVcpusPerFtVm?: number;
            loginBySSLThumbprintSupported?: boolean;
            cloneFromSnapshotSupported?: boolean;
            deltaDiskBackingsSupported?: boolean;
            perVMNetworkTrafficShapingSupported?: boolean;
            tpmSupported?: boolean;
            supportedCpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
            virtualExecUsageSupported?: boolean;
            storageIORMSupported?: boolean;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2UnsupportedReason?: Array<string>;
            vmDirectPathGen2UnsupportedReasonExtended?: string;
            supportedVmfsMajorVersion?: Array<number>;
            vStorageCapable?: boolean;
            snapshotRelayoutSupported?: boolean;
            firewallIpRulesSupported?: boolean;
            servicePackageInfoSupported?: boolean;
            maxHostRunningVms?: number;
            maxHostSupportedVcpus?: number;
            vmfsDatastoreMountCapable?: boolean;
            eightPlusHostVmfsSharedAccessSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
            interVMCommunicationThroughVMCISupported?: boolean;
            scheduledHardwareUpgradeSupported?: boolean;
            featureCapabilitiesSupported?: boolean;
            latencySensitivitySupported?: boolean;
            storagePolicySupported?: boolean;
            accel3dSupported?: boolean;
            reliableMemoryAware?: boolean;
            multipleNetworkStackInstanceSupported?: boolean;
            messageBusProxySupported?: boolean;
            vsanSupported?: boolean;
            vFlashSupported?: boolean;
            hostAccessManagerSupported?: boolean;
            provisioningNicSelectionSupported?: boolean;
            nfs41Supported?: boolean;
            turnDiskLocatorLedSupported?: boolean;
            virtualVolumeDatastoreSupported?: boolean;
            markAsSsdSupported?: boolean;
            markAsLocalSupported?: boolean;
            smartCardAuthenticationSupported?: boolean;
         }
         enum HostCertificateManagerCertificateInfoCertificateStatus {
            "unknown",
            "expired",
            "expiring",
            "expiringShortly",
            "expirationImminent",
            "good",
            "revoked",
         }
         interface HostCertificateManagerCertificateInfo extends vimService.vim.DynamicData {
            issuer?: string;
            notBefore?: Date;
            notAfter?: Date;
            subject?: string;
            status: string;
         }
         enum HostConfigChangeMode {
            "modify",
            "replace",
         }
         enum HostConfigChangeOperation {
            "add",
            "remove",
            "edit",
            "ignore",
         }
         interface HostConfigChange extends vimService.vim.DynamicData {
         }
         interface HostConfigInfo extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            product: vimService.vim.AboutInfo;
            hyperThread?: vimService.vim.HostHyperThreadScheduleInfo;
            consoleReservation?: vimService.vim.ServiceConsoleReservationInfo;
            virtualMachineReservation?: vimService.vim.VirtualMachineMemoryReservationInfo;
            storageDevice?: vimService.vim.HostStorageDeviceInfo;
            multipathState?: vimService.vim.HostMultipathStateInfo;
            fileSystemVolume?: vimService.vim.HostFileSystemVolumeInfo;
            systemFile?: Array<string>;
            network?: vimService.vim.HostNetworkInfo;
            vmotion?: vimService.vim.HostVMotionInfo;
            virtualNicManagerInfo?: vimService.vim.HostVirtualNicManagerInfo;
            capabilities?: vimService.vim.HostNetCapabilities;
            datastoreCapabilities?: vimService.vim.HostDatastoreSystemCapabilities;
            offloadCapabilities?: vimService.vim.HostNetOffloadCapabilities;
            service?: vimService.vim.HostServiceInfo;
            firewall?: vimService.vim.HostFirewallInfo;
            autoStart?: vimService.vim.HostAutoStartManagerConfig;
            activeDiagnosticPartition?: vimService.vim.HostDiagnosticPartition;
            option?: Array<vimService.vim.OptionValue>;
            optionDef?: Array<vimService.vim.OptionDef>;
            datastorePrincipal?: string;
            localSwapDatastore?: vimService.vim.ManagedObjectReference;
            systemSwapConfiguration?: vimService.vim.HostSystemSwapConfiguration;
            systemResources?: vimService.vim.HostSystemResourceInfo;
            dateTimeInfo?: vimService.vim.HostDateTimeInfo;
            flags?: vimService.vim.HostFlagInfo;
            adminDisabled?: boolean;
            lockdownMode?: vimService.vim.HostLockdownMode;
            ipmi?: vimService.vim.HostIpmiInfo;
            sslThumbprintInfo?: vimService.vim.HostSslThumbprintInfo;
            sslThumbprintData?: Array<vimService.vim.HostSslThumbprintInfo>;
            certificate?: Array<number>;
            pciPassthruInfo?: Array<vimService.vim.HostPciPassthruInfo>;
            authenticationManagerInfo?: vimService.vim.HostAuthenticationManagerInfo;
            featureVersion?: Array<vimService.vim.HostFeatureVersionInfo>;
            powerSystemCapability?: vimService.vim.PowerSystemCapability;
            powerSystemInfo?: vimService.vim.PowerSystemInfo;
            cacheConfigurationInfo?: Array<vimService.vim.HostCacheConfigurationInfo>;
            wakeOnLanCapable?: boolean;
            featureCapability?: Array<vimService.vim.HostFeatureCapability>;
            maskedFeatureCapability?: Array<vimService.vim.HostFeatureCapability>;
            vFlashConfigInfo?: vimService.vim.HostVFlashManagerVFlashConfigInfo;
            vsanHostConfig?: vimService.vim.VsanHostConfigInfo;
            domainList?: Array<string>;
            scriptCheckSum?: string;
            hostConfigCheckSum?: string;
            graphicsInfo?: Array<vimService.vim.HostGraphicsInfo>;
            sharedPassthruGpuTypes?: Array<string>;
            ioFilterInfo?: Array<vimService.vim.HostIoFilterInfo>;
         }
         interface HostConfigManager extends vimService.vim.DynamicData {
            cpuScheduler?: vimService.vim.ManagedObjectReference;
            datastoreSystem?: vimService.vim.ManagedObjectReference;
            memoryManager?: vimService.vim.ManagedObjectReference;
            storageSystem?: vimService.vim.ManagedObjectReference;
            networkSystem?: vimService.vim.ManagedObjectReference;
            vmotionSystem?: vimService.vim.ManagedObjectReference;
            virtualNicManager?: vimService.vim.ManagedObjectReference;
            serviceSystem?: vimService.vim.ManagedObjectReference;
            firewallSystem?: vimService.vim.ManagedObjectReference;
            advancedOption?: vimService.vim.ManagedObjectReference;
            diagnosticSystem?: vimService.vim.ManagedObjectReference;
            autoStartManager?: vimService.vim.ManagedObjectReference;
            snmpSystem?: vimService.vim.ManagedObjectReference;
            dateTimeSystem?: vimService.vim.ManagedObjectReference;
            patchManager?: vimService.vim.ManagedObjectReference;
            imageConfigManager?: vimService.vim.ManagedObjectReference;
            bootDeviceSystem?: vimService.vim.ManagedObjectReference;
            firmwareSystem?: vimService.vim.ManagedObjectReference;
            healthStatusSystem?: vimService.vim.ManagedObjectReference;
            pciPassthruSystem?: vimService.vim.ManagedObjectReference;
            licenseManager?: vimService.vim.ManagedObjectReference;
            kernelModuleSystem?: vimService.vim.ManagedObjectReference;
            authenticationManager?: vimService.vim.ManagedObjectReference;
            powerSystem?: vimService.vim.ManagedObjectReference;
            cacheConfigurationManager?: vimService.vim.ManagedObjectReference;
            esxAgentHostManager?: vimService.vim.ManagedObjectReference;
            iscsiManager?: vimService.vim.ManagedObjectReference;
            vFlashManager?: vimService.vim.ManagedObjectReference;
            vsanSystem?: vimService.vim.ManagedObjectReference;
            messageBusProxy?: vimService.vim.ManagedObjectReference;
            userDirectory?: vimService.vim.ManagedObjectReference;
            accountManager?: vimService.vim.ManagedObjectReference;
            hostAccessManager?: vimService.vim.ManagedObjectReference;
            graphicsManager?: vimService.vim.ManagedObjectReference;
            vsanInternalSystem?: vimService.vim.ManagedObjectReference;
            certificateManager?: vimService.vim.ManagedObjectReference;
         }
         interface HostConfigSpec extends vimService.vim.DynamicData {
            nasDatastore?: Array<vimService.vim.HostNasVolumeConfig>;
            network?: vimService.vim.HostNetworkConfig;
            nicTypeSelection?: Array<vimService.vim.HostVirtualNicManagerNicTypeSelection>;
            service?: Array<vimService.vim.HostServiceConfig>;
            firewall?: vimService.vim.HostFirewallConfig;
            option?: Array<vimService.vim.OptionValue>;
            datastorePrincipal?: string;
            datastorePrincipalPasswd?: string;
            datetime?: vimService.vim.HostDateTimeConfig;
            storageDevice?: vimService.vim.HostStorageDeviceInfo;
            license?: vimService.vim.HostLicenseSpec;
            security?: vimService.vim.HostSecuritySpec;
            userAccount?: Array<vimService.vim.HostAccountSpec>;
            usergroupAccount?: Array<vimService.vim.HostAccountSpec>;
            memory?: vimService.vim.HostMemorySpec;
            activeDirectory?: Array<vimService.vim.HostActiveDirectory>;
            genericConfig?: Array<vimService.vim.KeyAnyValue>;
         }
         interface HostConnectInfoNetworkInfo extends vimService.vim.DynamicData {
            summary: vimService.vim.NetworkSummary;
         }
         interface ArrayOfHostConnectInfoNetworkInfo {
            hostConnectInfoNetworkInfo?: Array<vimService.vim.HostConnectInfoNetworkInfo>;
         }
         interface HostNewNetworkConnectInfo extends vimService.vim.HostConnectInfoNetworkInfo {
         }
         interface HostDatastoreConnectInfo extends vimService.vim.DynamicData {
            summary: vimService.vim.DatastoreSummary;
         }
         interface ArrayOfHostDatastoreConnectInfo {
            hostDatastoreConnectInfo?: Array<vimService.vim.HostDatastoreConnectInfo>;
         }
         interface HostDatastoreExistsConnectInfo extends vimService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostDatastoreNameConflictConnectInfo extends vimService.vim.HostDatastoreConnectInfo {
            newDatastoreName: string;
         }
         interface HostLicenseConnectInfo extends vimService.vim.DynamicData {
            license: vimService.vim.LicenseManagerLicenseInfo;
            evaluation: vimService.vim.LicenseManagerEvaluationInfo;
            resource?: vimService.vim.HostLicensableResourceInfo;
         }
         interface HostConnectInfo extends vimService.vim.DynamicData {
            serverIp?: string;
            inDasCluster?: boolean;
            host: vimService.vim.HostListSummary;
            vm?: Array<vimService.vim.VirtualMachineSummary>;
            vimAccountNameRequired?: boolean;
            clusterSupported?: boolean;
            network?: Array<vimService.vim.HostConnectInfoNetworkInfo>;
            datastore?: Array<vimService.vim.HostDatastoreConnectInfo>;
            license?: vimService.vim.HostLicenseConnectInfo;
            capability?: vimService.vim.HostCapability;
         }
         interface HostConnectSpec extends vimService.vim.DynamicData {
            hostName?: string;
            port?: number;
            sslThumbprint?: string;
            userName?: string;
            password?: string;
            vmFolder?: vimService.vim.ManagedObjectReference;
            force: boolean;
            vimAccountName?: string;
            vimAccountPassword?: string;
            managementIp?: string;
            lockdownMode?: vimService.vim.HostLockdownMode;
            hostGateway?: vimService.vim.HostGatewaySpec;
         }
         interface HostCpuIdInfo extends vimService.vim.DynamicData {
            level: number;
            vendor?: string;
            eax?: string;
            ebx?: string;
            ecx?: string;
            edx?: string;
         }
         interface ArrayOfHostCpuIdInfo {
            hostCpuIdInfo?: Array<vimService.vim.HostCpuIdInfo>;
         }
         interface HostHyperThreadScheduleInfo extends vimService.vim.DynamicData {
            available: boolean;
            active: boolean;
            config: boolean;
         }
         interface FileQueryFlags extends vimService.vim.DynamicData {
            fileType: boolean;
            fileSize: boolean;
            modification: boolean;
            fileOwner?: boolean;
         }
         interface FileInfo extends vimService.vim.DynamicData {
            path: string;
            fileSize?: number;
            modification?: Date;
            owner?: string;
         }
         interface ArrayOfFileInfo {
            fileInfo?: Array<vimService.vim.FileInfo>;
         }
         interface FileQuery extends vimService.vim.DynamicData {
         }
         interface ArrayOfFileQuery {
            fileQuery?: Array<vimService.vim.FileQuery>;
         }
         interface VmConfigFileQueryFilter extends vimService.vim.DynamicData {
            matchConfigVersion?: Array<number>;
         }
         interface VmConfigFileQueryFlags extends vimService.vim.DynamicData {
            configVersion: boolean;
         }
         interface VmConfigFileQuery extends vimService.vim.FileQuery {
            filter?: vimService.vim.VmConfigFileQueryFilter;
            details?: vimService.vim.VmConfigFileQueryFlags;
         }
         interface TemplateConfigFileQuery extends vimService.vim.VmConfigFileQuery {
         }
         interface VmDiskFileQueryFilter extends vimService.vim.DynamicData {
            diskType?: Array<string>;
            matchHardwareVersion?: Array<number>;
            controllerType?: Array<string>;
            thin?: boolean;
         }
         interface VmDiskFileQueryFlags extends vimService.vim.DynamicData {
            diskType: boolean;
            capacityKb: boolean;
            hardwareVersion: boolean;
            controllerType?: boolean;
            diskExtents?: boolean;
            thin?: boolean;
         }
         interface VmDiskFileQuery extends vimService.vim.FileQuery {
            filter?: vimService.vim.VmDiskFileQueryFilter;
            details?: vimService.vim.VmDiskFileQueryFlags;
         }
         interface FolderFileQuery extends vimService.vim.FileQuery {
         }
         interface VmSnapshotFileQuery extends vimService.vim.FileQuery {
         }
         interface IsoImageFileQuery extends vimService.vim.FileQuery {
         }
         interface FloppyImageFileQuery extends vimService.vim.FileQuery {
         }
         interface VmNvramFileQuery extends vimService.vim.FileQuery {
         }
         interface VmLogFileQuery extends vimService.vim.FileQuery {
         }
         interface VmConfigFileInfo extends vimService.vim.FileInfo {
            configVersion?: number;
         }
         interface TemplateConfigFileInfo extends vimService.vim.VmConfigFileInfo {
         }
         interface VmDiskFileInfo extends vimService.vim.FileInfo {
            diskType?: string;
            capacityKb?: number;
            hardwareVersion?: number;
            controllerType?: string;
            diskExtents?: Array<string>;
            thin?: boolean;
         }
         interface FolderFileInfo extends vimService.vim.FileInfo {
         }
         interface VmSnapshotFileInfo extends vimService.vim.FileInfo {
         }
         interface IsoImageFileInfo extends vimService.vim.FileInfo {
         }
         interface FloppyImageFileInfo extends vimService.vim.FileInfo {
         }
         interface VmNvramFileInfo extends vimService.vim.FileInfo {
         }
         interface VmLogFileInfo extends vimService.vim.FileInfo {
         }
         interface HostDatastoreBrowserSearchSpec extends vimService.vim.DynamicData {
            query?: Array<vimService.vim.FileQuery>;
            details?: vimService.vim.FileQueryFlags;
            searchCaseInsensitive?: boolean;
            matchPattern?: Array<string>;
            sortFoldersFirst?: boolean;
         }
         interface HostDatastoreBrowserSearchResults extends vimService.vim.DynamicData {
            datastore?: vimService.vim.ManagedObjectReference;
            folderPath?: string;
            file?: Array<vimService.vim.FileInfo>;
         }
         interface ArrayOfHostDatastoreBrowserSearchResults {
            hostDatastoreBrowserSearchResults?: Array<vimService.vim.HostDatastoreBrowserSearchResults>;
         }
         interface HostDatastoreSystemCapabilities extends vimService.vim.DynamicData {
            nfsMountCreationRequired: boolean;
            nfsMountCreationSupported: boolean;
            localDatastoreSupported: boolean;
            vmfsExtentExpansionSupported?: boolean;
         }
         interface HostDatastoreSystemVvolDatastoreSpec extends vimService.vim.DynamicData {
            name: string;
            scId: string;
         }
         interface HostDatastoreSystemDatastoreResult extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostDatastoreSystemDatastoreResult {
            hostDatastoreSystemDatastoreResult?: Array<vimService.vim.HostDatastoreSystemDatastoreResult>;
         }
         interface VmfsDatastoreInfo extends vimService.vim.DatastoreInfo {
            maxPhysicalRDMFileSize?: number;
            maxVirtualRDMFileSize?: number;
            vmfs?: vimService.vim.HostVmfsVolume;
         }
         interface NasDatastoreInfo extends vimService.vim.DatastoreInfo {
            nas?: vimService.vim.HostNasVolume;
         }
         interface LocalDatastoreInfo extends vimService.vim.DatastoreInfo {
            path?: string;
         }
         interface VmfsDatastoreSpec extends vimService.vim.DynamicData {
            diskUuid: string;
         }
         interface VmfsDatastoreCreateSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            vmfs: vimService.vim.HostVmfsSpec;
            extent?: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExtendSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface VmfsDatastoreExpandSpec extends vimService.vim.VmfsDatastoreSpec {
            partition: vimService.vim.HostDiskPartitionSpec;
            extent: vimService.vim.HostScsiDiskPartition;
         }
         interface VmfsDatastoreBaseOption extends vimService.vim.DynamicData {
            layout: vimService.vim.HostDiskPartitionLayout;
            partitionFormatChange?: boolean;
         }
         interface VmfsDatastoreSingleExtentOption extends vimService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: vimService.vim.HostDiskPartitionBlockRange;
         }
         interface VmfsDatastoreAllExtentOption extends vimService.vim.VmfsDatastoreSingleExtentOption {
         }
         interface VmfsDatastoreMultipleExtentOption extends vimService.vim.VmfsDatastoreBaseOption {
            vmfsExtent: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface VmfsDatastoreOption extends vimService.vim.DynamicData {
            info: vimService.vim.VmfsDatastoreBaseOption;
            spec: vimService.vim.VmfsDatastoreSpec;
         }
         interface ArrayOfVmfsDatastoreOption {
            vmfsDatastoreOption?: Array<vimService.vim.VmfsDatastoreOption>;
         }
         interface VvolDatastoreInfo extends vimService.vim.DatastoreInfo {
            vvolDS?: vimService.vim.HostVvolVolume;
         }
         interface HostDateTimeConfig extends vimService.vim.DynamicData {
            timeZone?: string;
            ntpConfig?: vimService.vim.HostNtpConfig;
         }
         interface HostDateTimeInfo extends vimService.vim.DynamicData {
            timeZone: vimService.vim.HostDateTimeSystemTimeZone;
            ntpConfig?: vimService.vim.HostNtpConfig;
         }
         interface HostDateTimeSystemTimeZone extends vimService.vim.DynamicData {
            key: string;
            name: string;
            description: string;
            gmtOffset: number;
         }
         interface ArrayOfHostDateTimeSystemTimeZone {
            hostDateTimeSystemTimeZone?: Array<vimService.vim.HostDateTimeSystemTimeZone>;
         }
         interface HostDevice extends vimService.vim.DynamicData {
            deviceName: string;
            deviceType: string;
         }
         interface HostDhcpServiceSpec extends vimService.vim.DynamicData {
            virtualSwitch: string;
            defaultLeaseDuration: number;
            leaseBeginIp: string;
            leaseEndIp: string;
            maxLeaseDuration: number;
            unlimitedLease: boolean;
            ipSubnetAddr: string;
            ipSubnetMask: string;
         }
         interface HostDhcpServiceConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: vimService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpServiceConfig {
            hostDhcpServiceConfig?: Array<vimService.vim.HostDhcpServiceConfig>;
         }
         interface HostDhcpService extends vimService.vim.DynamicData {
            key: string;
            spec: vimService.vim.HostDhcpServiceSpec;
         }
         interface ArrayOfHostDhcpService {
            hostDhcpService?: Array<vimService.vim.HostDhcpService>;
         }
         enum DiagnosticPartitionStorageType {
            "directAttached",
            "networkAttached",
         }
         enum DiagnosticPartitionType {
            "singleHost",
            "multiHost",
         }
         interface HostDiagnosticPartitionCreateOption extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            disk: vimService.vim.HostScsiDisk;
         }
         interface ArrayOfHostDiagnosticPartitionCreateOption {
            hostDiagnosticPartitionCreateOption?: Array<vimService.vim.HostDiagnosticPartitionCreateOption>;
         }
         interface HostDiagnosticPartitionCreateSpec extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            id: vimService.vim.HostScsiDiskPartition;
            partition: vimService.vim.HostDiskPartitionSpec;
            active?: boolean;
         }
         interface HostDiagnosticPartitionCreateDescription extends vimService.vim.DynamicData {
            layout: vimService.vim.HostDiskPartitionLayout;
            diskUuid: string;
            spec: vimService.vim.HostDiagnosticPartitionCreateSpec;
         }
         interface HostDiagnosticPartition extends vimService.vim.DynamicData {
            storageType: string;
            diagnosticType: string;
            slots: number;
            id: vimService.vim.HostScsiDiskPartition;
         }
         interface ArrayOfHostDiagnosticPartition {
            hostDiagnosticPartition?: Array<vimService.vim.HostDiagnosticPartition>;
         }
         interface HostDirectoryStoreInfo extends vimService.vim.HostAuthenticationStoreInfo {
         }
         interface HostDiskConfigurationResult extends vimService.vim.DynamicData {
            devicePath?: string;
            success?: boolean;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostDiskConfigurationResult {
            hostDiskConfigurationResult?: Array<vimService.vim.HostDiskConfigurationResult>;
         }
         interface HostDiskDimensionsChs extends vimService.vim.DynamicData {
            cylinder: number;
            head: number;
            sector: number;
         }
         interface HostDiskDimensionsLba extends vimService.vim.DynamicData {
            blockSize: number;
            block: number;
         }
         interface HostDiskDimensions extends vimService.vim.DynamicData {
         }
         enum HostDiskPartitionInfoPartitionFormat {
            "gpt",
            "mbr",
            "unknown",
         }
         enum HostDiskPartitionInfoType {
            "none",
            "vmfs",
            "linuxNative",
            "linuxSwap",
            "extended",
            "ntfs",
            "vmkDiagnostic",
            "vffs",
         }
         interface HostDiskPartitionAttributes extends vimService.vim.DynamicData {
            partition: number;
            startSector: number;
            endSector: number;
            type: string;
            guid?: string;
            logical: boolean;
            attributes: number;
            partitionAlignment?: number;
         }
         interface ArrayOfHostDiskPartitionAttributes {
            hostDiskPartitionAttributes?: Array<vimService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionBlockRange extends vimService.vim.DynamicData {
            partition?: number;
            type: string;
            start: vimService.vim.HostDiskDimensionsLba;
            end: vimService.vim.HostDiskDimensionsLba;
         }
         interface ArrayOfHostDiskPartitionBlockRange {
            hostDiskPartitionBlockRange?: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionSpec extends vimService.vim.DynamicData {
            partitionFormat?: string;
            chs?: vimService.vim.HostDiskDimensionsChs;
            totalSectors?: number;
            partition?: Array<vimService.vim.HostDiskPartitionAttributes>;
         }
         interface HostDiskPartitionLayout extends vimService.vim.DynamicData {
            total?: vimService.vim.HostDiskDimensionsLba;
            partition: Array<vimService.vim.HostDiskPartitionBlockRange>;
         }
         interface HostDiskPartitionInfo extends vimService.vim.DynamicData {
            deviceName: string;
            spec: vimService.vim.HostDiskPartitionSpec;
            layout: vimService.vim.HostDiskPartitionLayout;
         }
         interface ArrayOfHostDiskPartitionInfo {
            hostDiskPartitionInfo?: Array<vimService.vim.HostDiskPartitionInfo>;
         }
         interface HostDnsConfig extends vimService.vim.DynamicData {
            dhcp: boolean;
            virtualNicDevice?: string;
            hostName: string;
            domainName: string;
            address?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface HostDnsConfigSpec extends vimService.vim.HostDnsConfig {
            virtualNicConnection?: vimService.vim.HostVirtualNicConnection;
         }
         interface HostEsxAgentHostManagerConfigInfo extends vimService.vim.DynamicData {
            agentVmDatastore?: vimService.vim.ManagedObjectReference;
            agentVmNetwork?: vimService.vim.ManagedObjectReference;
         }
         interface HostFaultToleranceManagerComponentHealthInfo extends vimService.vim.DynamicData {
            isStorageHealthy: boolean;
            isNetworkHealthy: boolean;
         }
         interface FcoeConfigVlanRange extends vimService.vim.DynamicData {
            vlanLow: number;
            vlanHigh: number;
         }
         interface ArrayOfFcoeConfigVlanRange {
            fcoeConfigVlanRange?: Array<vimService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfigFcoeCapabilities extends vimService.vim.DynamicData {
            priorityClass: boolean;
            sourceMacAddress: boolean;
            vlanRange: boolean;
         }
         interface FcoeConfigFcoeSpecification extends vimService.vim.DynamicData {
            underlyingPnic: string;
            priorityClass?: number;
            sourceMac?: string;
            vlanRange?: Array<vimService.vim.FcoeConfigVlanRange>;
         }
         interface FcoeConfig extends vimService.vim.DynamicData {
            priorityClass: number;
            sourceMac: string;
            vlanRange: Array<vimService.vim.FcoeConfigVlanRange>;
            capabilities: vimService.vim.FcoeConfigFcoeCapabilities;
            fcoeActive: boolean;
         }
         interface HostFeatureCapability extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureCapability {
            hostFeatureCapability?: Array<vimService.vim.HostFeatureCapability>;
         }
         interface HostFeatureMask extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfHostFeatureMask {
            hostFeatureMask?: Array<vimService.vim.HostFeatureMask>;
         }
         enum HostFeatureVersionKey {
            "faultTolerance",
         }
         interface HostFeatureVersionInfo extends vimService.vim.DynamicData {
            key: string;
            value: string;
         }
         interface ArrayOfHostFeatureVersionInfo {
            hostFeatureVersionInfo?: Array<vimService.vim.HostFeatureVersionInfo>;
         }
         interface ModeInfo extends vimService.vim.DynamicData {
            browse?: string;
            read: string;
            modify: string;
            use: string;
            admin?: string;
            full: string;
         }
         interface HostFileAccess extends vimService.vim.DynamicData {
            who: string;
            what: string;
         }
         interface HostFileSystemVolumeInfo extends vimService.vim.DynamicData {
            volumeTypeList?: Array<string>;
            mountInfo?: Array<vimService.vim.HostFileSystemMountInfo>;
         }
         enum FileSystemMountInfoVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface HostFileSystemMountInfo extends vimService.vim.DynamicData {
            mountInfo: vimService.vim.HostMountInfo;
            volume: vimService.vim.HostFileSystemVolume;
            vStorageSupport?: string;
         }
         interface ArrayOfHostFileSystemMountInfo {
            hostFileSystemMountInfo?: Array<vimService.vim.HostFileSystemMountInfo>;
         }
         enum HostFileSystemVolumeFileSystemType {
            "VMFS",
            "NFS",
            "NFS41",
            "CIFS",
            "vsan",
            "VFFS",
            "VVOL",
            "OTHER",
         }
         interface HostFileSystemVolume extends vimService.vim.DynamicData {
            type: string;
            name: string;
            capacity: number;
         }
         interface HostNasVolumeUserInfo extends vimService.vim.DynamicData {
            user: string;
         }
         enum HostNasVolumeSecurityType {
            "AUTH_SYS",
            "SEC_KRB5",
         }
         interface HostNasVolumeSpec extends vimService.vim.DynamicData {
            remoteHost: string;
            remotePath: string;
            localPath: string;
            accessMode: string;
            type?: string;
            userName?: string;
            password?: string;
            remoteHostNames?: Array<string>;
            securityType?: string;
         }
         interface HostNasVolumeConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            spec?: vimService.vim.HostNasVolumeSpec;
         }
         interface ArrayOfHostNasVolumeConfig {
            hostNasVolumeConfig?: Array<vimService.vim.HostNasVolumeConfig>;
         }
         interface HostNasVolume extends vimService.vim.HostFileSystemVolume {
            remoteHost: string;
            remotePath: string;
            userName?: string;
            remoteHostNames?: Array<string>;
            securityType?: string;
            protocolEndpoint?: boolean;
         }
         interface HostLocalFileSystemVolumeSpec extends vimService.vim.DynamicData {
            device: string;
            localPath: string;
         }
         interface HostLocalFileSystemVolume extends vimService.vim.HostFileSystemVolume {
            device: string;
         }
         interface HostVfatVolume extends vimService.vim.HostFileSystemVolume {
         }
         interface HostFirewallConfigRuleSetConfig extends vimService.vim.DynamicData {
            rulesetId: string;
            enabled: boolean;
            allowedHosts?: vimService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallConfigRuleSetConfig {
            hostFirewallConfigRuleSetConfig?: Array<vimService.vim.HostFirewallConfigRuleSetConfig>;
         }
         interface HostFirewallConfig extends vimService.vim.DynamicData {
            rule?: Array<vimService.vim.HostFirewallConfigRuleSetConfig>;
            defaultBlockingPolicy: vimService.vim.HostFirewallDefaultPolicy;
         }
         interface HostFirewallDefaultPolicy extends vimService.vim.DynamicData {
            incomingBlocked?: boolean;
            outgoingBlocked?: boolean;
         }
         interface HostFirewallInfo extends vimService.vim.DynamicData {
            defaultPolicy: vimService.vim.HostFirewallDefaultPolicy;
            ruleset?: Array<vimService.vim.HostFirewallRuleset>;
         }
         interface HostFlagInfo extends vimService.vim.DynamicData {
            backgroundSnapshotsEnabled?: boolean;
         }
         interface HostForceMountedInfo extends vimService.vim.DynamicData {
            persist: boolean;
            mounted: boolean;
         }
         interface HostGatewaySpec extends vimService.vim.DynamicData {
            gatewayType: string;
            gatewayId?: string;
            trustVerificationToken?: string;
            hostAuthParams?: Array<vimService.vim.KeyValue>;
         }
         enum HostGraphicsInfoGraphicsType {
            "basic",
            "shared",
            "direct",
         }
         interface HostGraphicsInfo extends vimService.vim.DynamicData {
            deviceName: string;
            vendorName: string;
            pciId: string;
            graphicsType: string;
            memorySizeInKB: number;
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfHostGraphicsInfo {
            hostGraphicsInfo?: Array<vimService.vim.HostGraphicsInfo>;
         }
         interface HostHardwareInfo extends vimService.vim.DynamicData {
            systemInfo: vimService.vim.HostSystemInfo;
            cpuPowerManagementInfo?: vimService.vim.HostCpuPowerManagementInfo;
            cpuInfo: vimService.vim.HostCpuInfo;
            cpuPkg: Array<vimService.vim.HostCpuPackage>;
            memorySize: number;
            numaInfo?: vimService.vim.HostNumaInfo;
            smcPresent?: boolean;
            pciDevice?: Array<vimService.vim.HostPciDevice>;
            cpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
            biosInfo?: vimService.vim.HostBIOSInfo;
            reliableMemoryInfo?: vimService.vim.HostReliableMemoryInfo;
         }
         interface HostSystemInfo extends vimService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
         }
         enum HostCpuPowerManagementInfoPolicyType {
            "off",
            "staticPolicy",
            "dynamicPolicy",
         }
         interface HostCpuPowerManagementInfo extends vimService.vim.DynamicData {
            currentPolicy?: string;
            hardwareSupport?: string;
         }
         interface HostCpuInfo extends vimService.vim.DynamicData {
            numCpuPackages: number;
            numCpuCores: number;
            numCpuThreads: number;
            hz: number;
         }
         enum HostCpuPackageVendor {
            "unknown",
            "intel",
            "amd",
         }
         interface HostCpuPackage extends vimService.vim.DynamicData {
            index: number;
            vendor: string;
            hz: number;
            busHz: number;
            description: string;
            threadId: Array<number>;
            cpuFeature?: Array<vimService.vim.HostCpuIdInfo>;
         }
         interface ArrayOfHostCpuPackage {
            hostCpuPackage?: Array<vimService.vim.HostCpuPackage>;
         }
         interface HostNumaInfo extends vimService.vim.DynamicData {
            type: string;
            numNodes: number;
            numaNode?: Array<vimService.vim.HostNumaNode>;
         }
         interface HostNumaNode extends vimService.vim.DynamicData {
            typeId: number;
            cpuID: Array<number>;
            memoryRangeBegin: number;
            memoryRangeLength: number;
         }
         interface ArrayOfHostNumaNode {
            hostNumaNode?: Array<vimService.vim.HostNumaNode>;
         }
         interface HostBIOSInfo extends vimService.vim.DynamicData {
            biosVersion?: string;
            releaseDate?: Date;
         }
         interface HostReliableMemoryInfo extends vimService.vim.DynamicData {
            memorySize: number;
         }
         enum HostHardwareElementStatus {
            "Unknown",
            "Green",
            "Yellow",
            "Red",
         }
         interface HostHardwareElementInfo extends vimService.vim.DynamicData {
            name: string;
            status: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostHardwareElementInfo {
            hostHardwareElementInfo?: Array<vimService.vim.HostHardwareElementInfo>;
         }
         interface HostStorageOperationalInfo extends vimService.vim.DynamicData {
            property: string;
            value: string;
         }
         interface ArrayOfHostStorageOperationalInfo {
            hostStorageOperationalInfo?: Array<vimService.vim.HostStorageOperationalInfo>;
         }
         interface HostStorageElementInfo extends vimService.vim.HostHardwareElementInfo {
            operationalInfo?: Array<vimService.vim.HostStorageOperationalInfo>;
         }
         interface ArrayOfHostStorageElementInfo {
            hostStorageElementInfo?: Array<vimService.vim.HostStorageElementInfo>;
         }
         interface HostHardwareStatusInfo extends vimService.vim.DynamicData {
            memoryStatusInfo?: Array<vimService.vim.HostHardwareElementInfo>;
            cpuStatusInfo?: Array<vimService.vim.HostHardwareElementInfo>;
            storageStatusInfo?: Array<vimService.vim.HostStorageElementInfo>;
         }
         interface HealthSystemRuntime extends vimService.vim.DynamicData {
            systemHealthInfo?: vimService.vim.HostSystemHealthInfo;
            hardwareStatusInfo?: vimService.vim.HostHardwareStatusInfo;
         }
         enum HostAccessMode {
            "accessNone",
            "accessAdmin",
            "accessNoAccess",
            "accessReadOnly",
            "accessOther",
         }
         interface HostAccessControlEntry extends vimService.vim.DynamicData {
            principal: string;
            group: boolean;
            accessMode: vimService.vim.HostAccessMode;
         }
         interface ArrayOfHostAccessControlEntry {
            hostAccessControlEntry?: Array<vimService.vim.HostAccessControlEntry>;
         }
         enum HostLockdownMode {
            "lockdownDisabled",
            "lockdownNormal",
            "lockdownStrict",
         }
         interface HostHostBusAdapter extends vimService.vim.DynamicData {
            key?: string;
            device: string;
            bus: number;
            status: string;
            model: string;
            driver?: string;
            pci?: string;
         }
         interface ArrayOfHostHostBusAdapter {
            hostHostBusAdapter?: Array<vimService.vim.HostHostBusAdapter>;
         }
         interface HostParallelScsiHba extends vimService.vim.HostHostBusAdapter {
         }
         interface HostBlockHba extends vimService.vim.HostHostBusAdapter {
         }
         enum FibreChannelPortType {
            "fabric",
            "loop",
            "pointToPoint",
            "unknown",
         }
         interface HostFibreChannelHba extends vimService.vim.HostHostBusAdapter {
            portWorldWideName: number;
            nodeWorldWideName: number;
            portType: vimService.vim.FibreChannelPortType;
            speed: number;
         }
         interface HostInternetScsiHbaParamValue extends vimService.vim.OptionValue {
            isInherited?: boolean;
         }
         interface ArrayOfHostInternetScsiHbaParamValue {
            hostInternetScsiHbaParamValue?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
         }
         interface HostInternetScsiHbaDiscoveryCapabilities extends vimService.vim.DynamicData {
            iSnsDiscoverySettable: boolean;
            slpDiscoverySettable: boolean;
            staticTargetDiscoverySettable: boolean;
            sendTargetsDiscoverySettable: boolean;
         }
         enum InternetScsiSnsDiscoveryMethod {
            "isnsStatic",
            "isnsDhcp",
            "isnsSlp",
         }
         enum SlpDiscoveryMethod {
            "slpDhcp",
            "slpAutoUnicast",
            "slpAutoMulticast",
            "slpManual",
         }
         interface HostInternetScsiHbaDiscoveryProperties extends vimService.vim.DynamicData {
            iSnsDiscoveryEnabled: boolean;
            iSnsDiscoveryMethod?: string;
            iSnsHost?: string;
            slpDiscoveryEnabled: boolean;
            slpDiscoveryMethod?: string;
            slpHost?: string;
            staticTargetDiscoveryEnabled: boolean;
            sendTargetsDiscoveryEnabled: boolean;
         }
         enum HostInternetScsiHbaChapAuthenticationType {
            "chapProhibited",
            "chapDiscouraged",
            "chapPreferred",
            "chapRequired",
         }
         interface HostInternetScsiHbaAuthenticationCapabilities extends vimService.vim.DynamicData {
            chapAuthSettable: boolean;
            krb5AuthSettable: boolean;
            srpAuthSettable: boolean;
            spkmAuthSettable: boolean;
            mutualChapSettable?: boolean;
            targetChapSettable?: boolean;
            targetMutualChapSettable?: boolean;
         }
         interface HostInternetScsiHbaAuthenticationProperties extends vimService.vim.DynamicData {
            chapAuthEnabled: boolean;
            chapName?: string;
            chapSecret?: string;
            chapAuthenticationType?: string;
            chapInherited?: boolean;
            mutualChapName?: string;
            mutualChapSecret?: string;
            mutualChapAuthenticationType?: string;
            mutualChapInherited?: boolean;
         }
         enum HostInternetScsiHbaDigestType {
            "digestProhibited",
            "digestDiscouraged",
            "digestPreferred",
            "digestRequired",
         }
         interface HostInternetScsiHbaDigestCapabilities extends vimService.vim.DynamicData {
            headerDigestSettable?: boolean;
            dataDigestSettable?: boolean;
            targetHeaderDigestSettable?: boolean;
            targetDataDigestSettable?: boolean;
         }
         interface HostInternetScsiHbaDigestProperties extends vimService.vim.DynamicData {
            headerDigestType?: string;
            headerDigestInherited?: boolean;
            dataDigestType?: string;
            dataDigestInherited?: boolean;
         }
         interface HostInternetScsiHbaIPCapabilities extends vimService.vim.DynamicData {
            addressSettable: boolean;
            ipConfigurationMethodSettable: boolean;
            subnetMaskSettable: boolean;
            defaultGatewaySettable: boolean;
            primaryDnsServerAddressSettable: boolean;
            alternateDnsServerAddressSettable: boolean;
            ipv6Supported?: boolean;
            arpRedirectSettable?: boolean;
            mtuSettable?: boolean;
            hostNameAsTargetAddress?: boolean;
            nameAliasSettable?: boolean;
            ipv4EnableSettable?: boolean;
            ipv6EnableSettable?: boolean;
            ipv6PrefixLengthSettable?: boolean;
            ipv6PrefixLength?: number;
            ipv6DhcpConfigurationSettable?: boolean;
            ipv6LinkLocalAutoConfigurationSettable?: boolean;
            ipv6RouterAdvertisementConfigurationSettable?: boolean;
            ipv6DefaultGatewaySettable?: boolean;
            ipv6MaxStaticAddressesSupported?: number;
         }
         enum HostInternetScsiHbaIscsiIpv6AddressAddressConfigurationType {
            "DHCP",
            "AutoConfigured",
            "Static",
            "Other",
         }
         enum HostInternetScsiHbaIscsiIpv6AddressIPv6AddressOperation {
            "add",
            "remove",
         }
         interface HostInternetScsiHbaIscsiIpv6Address extends vimService.vim.DynamicData {
            address: string;
            prefixLength: number;
            origin: string;
            operation?: string;
         }
         interface ArrayOfHostInternetScsiHbaIscsiIpv6Address {
            hostInternetScsiHbaIscsiIpv6Address?: Array<vimService.vim.HostInternetScsiHbaIscsiIpv6Address>;
         }
         interface HostInternetScsiHbaIPv6Properties extends vimService.vim.DynamicData {
            iscsiIpv6Address?: Array<vimService.vim.HostInternetScsiHbaIscsiIpv6Address>;
            ipv6DhcpConfigurationEnabled?: boolean;
            ipv6LinkLocalAutoConfigurationEnabled?: boolean;
            ipv6RouterAdvertisementConfigurationEnabled?: boolean;
            ipv6DefaultGateway?: string;
         }
         interface HostInternetScsiHbaIPProperties extends vimService.vim.DynamicData {
            mac?: string;
            address?: string;
            dhcpConfigurationEnabled: boolean;
            subnetMask?: string;
            defaultGateway?: string;
            primaryDnsServerAddress?: string;
            alternateDnsServerAddress?: string;
            ipv6Address?: string;
            ipv6SubnetMask?: string;
            ipv6DefaultGateway?: string;
            arpRedirectEnabled?: boolean;
            mtu?: number;
            jumboFramesEnabled?: boolean;
            ipv4Enabled?: boolean;
            ipv6Enabled?: boolean;
            ipv6properties?: vimService.vim.HostInternetScsiHbaIPv6Properties;
         }
         interface HostInternetScsiHbaSendTarget extends vimService.vim.DynamicData {
            address: string;
            port?: number;
            authenticationProperties?: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaSendTarget {
            hostInternetScsiHbaSendTarget?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaStaticTargetTargetDiscoveryMethod {
            "staticMethod",
            "sendTargetMethod",
            "slpMethod",
            "isnsMethod",
            "unknownMethod",
         }
         interface HostInternetScsiHbaStaticTarget extends vimService.vim.DynamicData {
            address: string;
            port?: number;
            iScsiName: string;
            discoveryMethod?: string;
            authenticationProperties?: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            parent?: string;
         }
         interface ArrayOfHostInternetScsiHbaStaticTarget {
            hostInternetScsiHbaStaticTarget?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
         }
         interface HostInternetScsiHbaTargetSet extends vimService.vim.DynamicData {
            staticTargets?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
            sendTargets?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
         }
         enum HostInternetScsiHbaNetworkBindingSupportType {
            "notsupported",
            "optional",
            "required",
         }
         interface HostInternetScsiHba extends vimService.vim.HostHostBusAdapter {
            isSoftwareBased: boolean;
            canBeDisabled?: boolean;
            networkBindingSupport?: vimService.vim.HostInternetScsiHbaNetworkBindingSupportType;
            discoveryCapabilities: vimService.vim.HostInternetScsiHbaDiscoveryCapabilities;
            discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties;
            authenticationCapabilities: vimService.vim.HostInternetScsiHbaAuthenticationCapabilities;
            authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties;
            digestCapabilities?: vimService.vim.HostInternetScsiHbaDigestCapabilities;
            digestProperties?: vimService.vim.HostInternetScsiHbaDigestProperties;
            ipCapabilities: vimService.vim.HostInternetScsiHbaIPCapabilities;
            ipProperties: vimService.vim.HostInternetScsiHbaIPProperties;
            supportedAdvancedOptions?: Array<vimService.vim.OptionDef>;
            advancedOptions?: Array<vimService.vim.HostInternetScsiHbaParamValue>;
            iScsiName: string;
            iScsiAlias?: string;
            configuredSendTarget?: Array<vimService.vim.HostInternetScsiHbaSendTarget>;
            configuredStaticTarget?: Array<vimService.vim.HostInternetScsiHbaStaticTarget>;
            maxSpeedMb?: number;
            currentSpeedMb?: number;
         }
         interface HostFibreChannelOverEthernetHbaLinkInfo extends vimService.vim.DynamicData {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostFibreChannelOverEthernetHba extends vimService.vim.HostFibreChannelHba {
            underlyingNic: string;
            linkInfo: vimService.vim.HostFibreChannelOverEthernetHbaLinkInfo;
            isSoftwareFcoe: boolean;
            markedForRemoval: boolean;
         }
         interface HostProxySwitchSpec extends vimService.vim.DynamicData {
            backing?: vimService.vim.DistributedVirtualSwitchHostMemberBacking;
         }
         interface HostProxySwitchConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            uuid: string;
            spec?: vimService.vim.HostProxySwitchSpec;
         }
         interface ArrayOfHostProxySwitchConfig {
            hostProxySwitchConfig?: Array<vimService.vim.HostProxySwitchConfig>;
         }
         interface HostProxySwitchHostLagConfig extends vimService.vim.DynamicData {
            lagKey: string;
            lagName?: string;
            uplinkPort?: Array<vimService.vim.KeyValue>;
         }
         interface ArrayOfHostProxySwitchHostLagConfig {
            hostProxySwitchHostLagConfig?: Array<vimService.vim.HostProxySwitchHostLagConfig>;
         }
         interface HostProxySwitch extends vimService.vim.DynamicData {
            dvsUuid: string;
            dvsName: string;
            key: string;
            numPorts: number;
            configNumPorts?: number;
            numPortsAvailable: number;
            uplinkPort?: Array<vimService.vim.KeyValue>;
            mtu?: number;
            pnic?: Array<string>;
            spec: vimService.vim.HostProxySwitchSpec;
            hostLag?: Array<vimService.vim.HostProxySwitchHostLagConfig>;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfHostProxySwitch {
            hostProxySwitch?: Array<vimService.vim.HostProxySwitch>;
         }
         enum HostImageAcceptanceLevel {
            "vmware_certified",
            "vmware_accepted",
            "partner",
            "community",
         }
         interface HostImageProfileSummary extends vimService.vim.DynamicData {
            name: string;
            vendor: string;
         }
         enum HostIpConfigIpV6AddressConfigType {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum HostIpConfigIpV6AddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface HostIpConfigIpV6Address extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            dadState?: string;
            lifetime?: Date;
            operation?: string;
         }
         interface ArrayOfHostIpConfigIpV6Address {
            hostIpConfigIpV6Address?: Array<vimService.vim.HostIpConfigIpV6Address>;
         }
         interface HostIpConfigIpV6AddressConfiguration extends vimService.vim.DynamicData {
            ipV6Address?: Array<vimService.vim.HostIpConfigIpV6Address>;
            autoConfigurationEnabled?: boolean;
            dhcpV6Enabled?: boolean;
         }
         interface HostIpConfig extends vimService.vim.DynamicData {
            dhcp: boolean;
            ipAddress?: string;
            subnetMask?: string;
            ipV6Config?: vimService.vim.HostIpConfigIpV6AddressConfiguration;
         }
         interface HostIpRouteConfig extends vimService.vim.DynamicData {
            defaultGateway?: string;
            gatewayDevice?: string;
            ipV6DefaultGateway?: string;
            ipV6GatewayDevice?: string;
         }
         interface HostIpRouteConfigSpec extends vimService.vim.HostIpRouteConfig {
            gatewayDeviceConnection?: vimService.vim.HostVirtualNicConnection;
            ipV6GatewayDeviceConnection?: vimService.vim.HostVirtualNicConnection;
         }
         interface HostIpRouteEntry extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: string;
            deviceName?: string;
         }
         interface ArrayOfHostIpRouteEntry {
            hostIpRouteEntry?: Array<vimService.vim.HostIpRouteEntry>;
         }
         interface HostIpRouteOp extends vimService.vim.DynamicData {
            changeOperation: string;
            route: vimService.vim.HostIpRouteEntry;
         }
         interface ArrayOfHostIpRouteOp {
            hostIpRouteOp?: Array<vimService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableConfig extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.HostIpRouteOp>;
            ipv6Route?: Array<vimService.vim.HostIpRouteOp>;
         }
         interface HostIpRouteTableInfo extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.HostIpRouteEntry>;
            ipv6Route?: Array<vimService.vim.HostIpRouteEntry>;
         }
         interface HostIpmiInfo extends vimService.vim.DynamicData {
            bmcIpAddress?: string;
            bmcMacAddress?: string;
            login?: string;
            password?: string;
         }
         interface IscsiStatus extends vimService.vim.DynamicData {
            reason?: Array<vimService.vim.LocalizedMethodFault>;
         }
         enum IscsiPortInfoPathStatus {
            "notUsed",
            "active",
            "standBy",
            "lastActive",
         }
         interface IscsiPortInfo extends vimService.vim.DynamicData {
            vnicDevice?: string;
            vnic?: vimService.vim.HostVirtualNic;
            pnicDevice?: string;
            pnic?: vimService.vim.PhysicalNic;
            switchName?: string;
            switchUuid?: string;
            portgroupName?: string;
            portgroupKey?: string;
            portKey?: string;
            complianceStatus?: vimService.vim.IscsiStatus;
            pathStatus?: string;
         }
         interface ArrayOfIscsiPortInfo {
            iscsiPortInfo?: Array<vimService.vim.IscsiPortInfo>;
         }
         interface IscsiDependencyEntity extends vimService.vim.DynamicData {
            pnicDevice: string;
            vnicDevice: string;
            vmhbaName: string;
         }
         interface ArrayOfIscsiDependencyEntity {
            iscsiDependencyEntity?: Array<vimService.vim.IscsiDependencyEntity>;
         }
         interface IscsiMigrationDependency extends vimService.vim.DynamicData {
            migrationAllowed: boolean;
            disallowReason?: vimService.vim.IscsiStatus;
            dependency?: Array<vimService.vim.IscsiDependencyEntity>;
         }
         interface KernelModuleSectionInfo extends vimService.vim.DynamicData {
            address: number;
            length?: number;
         }
         interface KernelModuleInfo extends vimService.vim.DynamicData {
            id: number;
            name: string;
            version: string;
            filename: string;
            optionString: string;
            loaded: boolean;
            enabled: boolean;
            useCount: number;
            readOnlySection: vimService.vim.KernelModuleSectionInfo;
            writableSection: vimService.vim.KernelModuleSectionInfo;
            textSection: vimService.vim.KernelModuleSectionInfo;
            dataSection: vimService.vim.KernelModuleSectionInfo;
            bssSection: vimService.vim.KernelModuleSectionInfo;
         }
         interface ArrayOfKernelModuleInfo {
            kernelModuleInfo?: Array<vimService.vim.KernelModuleInfo>;
         }
         interface HostLicenseSpec extends vimService.vim.DynamicData {
            source?: vimService.vim.LicenseSource;
            editionKey?: string;
            disabledFeatureKey?: Array<string>;
            enabledFeatureKey?: Array<string>;
         }
         enum LinkDiscoveryProtocolConfigProtocolType {
            "cdp",
            "lldp",
         }
         enum LinkDiscoveryProtocolConfigOperationType {
            "none",
            "listen",
            "advertise",
            "both",
         }
         interface LinkDiscoveryProtocolConfig extends vimService.vim.DynamicData {
            protocol: string;
            operation: string;
         }
         interface HostAccountSpec extends vimService.vim.DynamicData {
            id: string;
            password?: string;
            description?: string;
         }
         interface ArrayOfHostAccountSpec {
            hostAccountSpec?: Array<vimService.vim.HostAccountSpec>;
         }
         interface HostPosixAccountSpec extends vimService.vim.HostAccountSpec {
            posixId?: number;
            shellAccess?: boolean;
         }
         interface HostLocalAuthenticationInfo extends vimService.vim.HostAuthenticationStoreInfo {
         }
         interface HostLowLevelProvisioningManagerVmRecoveryInfo extends vimService.vim.DynamicData {
            version: string;
            biosUUID: string;
            instanceUUID: string;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
         }
         interface HostLowLevelProvisioningManagerVmMigrationStatus extends vimService.vim.DynamicData {
            migrationId: number;
            type: string;
            source: boolean;
            consideredSuccessful: boolean;
         }
         enum HostLowLevelProvisioningManagerReloadTarget {
            "currentConfig",
            "snapshotConfig",
         }
         interface HostLowLevelProvisioningManagerDiskLayoutSpec extends vimService.vim.DynamicData {
            controllerType: string;
            busNumber: number;
            unitNumber: number;
            srcFilename: string;
            dstFilename: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerDiskLayoutSpec {
            hostLowLevelProvisioningManagerDiskLayoutSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface HostLowLevelProvisioningManagerSnapshotLayoutSpec extends vimService.vim.DynamicData {
            id: number;
            srcFilename: string;
            dstFilename: string;
            disk?: Array<vimService.vim.HostLowLevelProvisioningManagerDiskLayoutSpec>;
         }
         interface ArrayOfHostLowLevelProvisioningManagerSnapshotLayoutSpec {
            hostLowLevelProvisioningManagerSnapshotLayoutSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerSnapshotLayoutSpec>;
         }
         enum HostLowLevelProvisioningManagerFileType {
            "File",
            "VirtualDisk",
            "Directory",
         }
         interface HostLowLevelProvisioningManagerFileReserveSpec extends vimService.vim.DynamicData {
            baseName: string;
            parentDir: string;
            fileType: string;
            storageProfile: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileReserveSpec {
            hostLowLevelProvisioningManagerFileReserveSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerFileReserveSpec>;
         }
         interface HostLowLevelProvisioningManagerFileReserveResult extends vimService.vim.DynamicData {
            baseName: string;
            parentDir: string;
            reservedName: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileReserveResult {
            hostLowLevelProvisioningManagerFileReserveResult?: Array<vimService.vim.HostLowLevelProvisioningManagerFileReserveResult>;
         }
         interface HostLowLevelProvisioningManagerFileDeleteSpec extends vimService.vim.DynamicData {
            fileName: string;
            fileType: string;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileDeleteSpec {
            hostLowLevelProvisioningManagerFileDeleteSpec?: Array<vimService.vim.HostLowLevelProvisioningManagerFileDeleteSpec>;
         }
         interface HostLowLevelProvisioningManagerFileDeleteResult extends vimService.vim.DynamicData {
            fileName: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostLowLevelProvisioningManagerFileDeleteResult {
            hostLowLevelProvisioningManagerFileDeleteResult?: Array<vimService.vim.HostLowLevelProvisioningManagerFileDeleteResult>;
         }
         interface HostMaintenanceSpec extends vimService.vim.DynamicData {
            vsanMode?: vimService.vim.VsanHostDecommissionMode;
         }
         interface ServiceConsoleReservationInfo extends vimService.vim.DynamicData {
            serviceConsoleReservedCfg: number;
            serviceConsoleReserved: number;
            unreserved: number;
         }
         enum VirtualMachineMemoryAllocationPolicy {
            "swapNone",
            "swapSome",
            "swapMost",
         }
         interface VirtualMachineMemoryReservationInfo extends vimService.vim.DynamicData {
            virtualMachineMin: number;
            virtualMachineMax: number;
            virtualMachineReserved: number;
            allocationPolicy: string;
         }
         interface VirtualMachineMemoryReservationSpec extends vimService.vim.DynamicData {
            virtualMachineReserved?: number;
            allocationPolicy?: string;
         }
         interface HostMemorySpec extends vimService.vim.DynamicData {
            serviceConsoleReservation?: number;
         }
         enum HostMountMode {
            "readWrite",
            "readOnly",
         }
         enum HostMountInfoInaccessibleReason {
            "AllPathsDown_Start",
            "AllPathsDown_Timeout",
            "PermanentDeviceLoss",
         }
         interface HostMountInfo extends vimService.vim.DynamicData {
            path?: string;
            accessMode: string;
            mounted?: boolean;
            accessible?: boolean;
            inaccessibleReason?: string;
         }
         enum MultipathState {
            "standby",
            "active",
            "disabled",
            "dead",
            "unknown",
         }
         interface HostMultipathInfoLogicalUnitPolicy extends vimService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoLogicalUnitStorageArrayTypePolicy extends vimService.vim.DynamicData {
            policy: string;
         }
         interface HostMultipathInfoFixedLogicalUnitPolicy extends vimService.vim.HostMultipathInfoLogicalUnitPolicy {
            prefer: string;
         }
         interface HostMultipathInfoLogicalUnit extends vimService.vim.DynamicData {
            key: string;
            id: string;
            lun: string;
            path: Array<vimService.vim.HostMultipathInfoPath>;
            policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy;
            storageArrayTypePolicy?: vimService.vim.HostMultipathInfoLogicalUnitStorageArrayTypePolicy;
         }
         interface ArrayOfHostMultipathInfoLogicalUnit {
            hostMultipathInfoLogicalUnit?: Array<vimService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathInfoPath extends vimService.vim.DynamicData {
            key: string;
            name: string;
            pathState: string;
            state?: string;
            isWorkingPath?: boolean;
            adapter: string;
            lun: string;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostMultipathInfoPath {
            hostMultipathInfoPath?: Array<vimService.vim.HostMultipathInfoPath>;
         }
         interface HostMultipathInfo extends vimService.vim.DynamicData {
            lun?: Array<vimService.vim.HostMultipathInfoLogicalUnit>;
         }
         interface HostMultipathStateInfoPath extends vimService.vim.DynamicData {
            name: string;
            pathState: string;
         }
         interface ArrayOfHostMultipathStateInfoPath {
            hostMultipathStateInfoPath?: Array<vimService.vim.HostMultipathStateInfoPath>;
         }
         interface HostMultipathStateInfo extends vimService.vim.DynamicData {
            path?: Array<vimService.vim.HostMultipathStateInfoPath>;
         }
         interface HostNatServicePortForwardSpec extends vimService.vim.DynamicData {
            type: string;
            name: string;
            hostPort: number;
            guestPort: number;
            guestIpAddress: string;
         }
         interface ArrayOfHostNatServicePortForwardSpec {
            hostNatServicePortForwardSpec?: Array<vimService.vim.HostNatServicePortForwardSpec>;
         }
         interface HostNatServiceNameServiceSpec extends vimService.vim.DynamicData {
            dnsAutoDetect: boolean;
            dnsPolicy: string;
            dnsRetries: number;
            dnsTimeout: number;
            dnsNameServer?: Array<string>;
            nbdsTimeout: number;
            nbnsRetries: number;
            nbnsTimeout: number;
         }
         interface HostNatServiceSpec extends vimService.vim.DynamicData {
            virtualSwitch: string;
            activeFtp: boolean;
            allowAnyOui: boolean;
            configPort: boolean;
            ipGatewayAddress: string;
            udpTimeout: number;
            portForward?: Array<vimService.vim.HostNatServicePortForwardSpec>;
            nameService?: vimService.vim.HostNatServiceNameServiceSpec;
         }
         interface HostNatServiceConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            key: string;
            spec: vimService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatServiceConfig {
            hostNatServiceConfig?: Array<vimService.vim.HostNatServiceConfig>;
         }
         interface HostNatService extends vimService.vim.DynamicData {
            key: string;
            spec: vimService.vim.HostNatServiceSpec;
         }
         interface ArrayOfHostNatService {
            hostNatService?: Array<vimService.vim.HostNatService>;
         }
         interface HostNetCapabilities extends vimService.vim.DynamicData {
            canSetPhysicalNicLinkSpeed: boolean;
            supportsNicTeaming: boolean;
            nicTeamingPolicy?: Array<string>;
            supportsVlan: boolean;
            usesServiceConsoleNic: boolean;
            supportsNetworkHints: boolean;
            maxPortGroupsPerVswitch?: number;
            vswitchConfigSupported: boolean;
            vnicConfigSupported: boolean;
            ipRouteConfigSupported: boolean;
            dnsConfigSupported: boolean;
            dhcpOnVnicSupported: boolean;
            ipV6Supported?: boolean;
         }
         interface HostNetOffloadCapabilities extends vimService.vim.DynamicData {
            csumOffload?: boolean;
            tcpSegmentation?: boolean;
            zeroCopyXmit?: boolean;
         }
         enum HostNetStackInstanceSystemStackKey {
            "defaultTcpipStack",
            "vmotion",
            "vSphereProvisioning",
         }
         enum HostNetStackInstanceCongestionControlAlgorithmType {
            "newreno",
            "cubic",
         }
         interface HostNetStackInstance extends vimService.vim.DynamicData {
            key?: string;
            name?: string;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            requestedMaxNumberOfConnections?: number;
            congestionControlAlgorithm?: string;
            ipV6Enabled?: boolean;
            routeTableConfig?: vimService.vim.HostIpRouteTableConfig;
         }
         interface ArrayOfHostNetStackInstance {
            hostNetStackInstance?: Array<vimService.vim.HostNetStackInstance>;
         }
         interface HostNetworkConfigResult extends vimService.vim.DynamicData {
            vnicDevice?: Array<string>;
            consoleVnicDevice?: Array<string>;
         }
         interface HostNetworkConfigNetStackSpec extends vimService.vim.DynamicData {
            netStackInstance: vimService.vim.HostNetStackInstance;
            operation?: string;
         }
         interface ArrayOfHostNetworkConfigNetStackSpec {
            hostNetworkConfigNetStackSpec?: Array<vimService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkConfig extends vimService.vim.DynamicData {
            vswitch?: Array<vimService.vim.HostVirtualSwitchConfig>;
            proxySwitch?: Array<vimService.vim.HostProxySwitchConfig>;
            portgroup?: Array<vimService.vim.HostPortGroupConfig>;
            pnic?: Array<vimService.vim.PhysicalNicConfig>;
            vnic?: Array<vimService.vim.HostVirtualNicConfig>;
            consoleVnic?: Array<vimService.vim.HostVirtualNicConfig>;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: vimService.vim.HostIpRouteConfig;
            routeTableConfig?: vimService.vim.HostIpRouteTableConfig;
            dhcp?: Array<vimService.vim.HostDhcpServiceConfig>;
            nat?: Array<vimService.vim.HostNatServiceConfig>;
            ipV6Enabled?: boolean;
            netStackSpec?: Array<vimService.vim.HostNetworkConfigNetStackSpec>;
         }
         interface HostNetworkInfo extends vimService.vim.DynamicData {
            vswitch?: Array<vimService.vim.HostVirtualSwitch>;
            proxySwitch?: Array<vimService.vim.HostProxySwitch>;
            portgroup?: Array<vimService.vim.HostPortGroup>;
            pnic?: Array<vimService.vim.PhysicalNic>;
            vnic?: Array<vimService.vim.HostVirtualNic>;
            consoleVnic?: Array<vimService.vim.HostVirtualNic>;
            dnsConfig?: vimService.vim.HostDnsConfig;
            ipRouteConfig?: vimService.vim.HostIpRouteConfig;
            consoleIpRouteConfig?: vimService.vim.HostIpRouteConfig;
            routeTableInfo?: vimService.vim.HostIpRouteTableInfo;
            dhcp?: Array<vimService.vim.HostDhcpService>;
            nat?: Array<vimService.vim.HostNatService>;
            ipV6Enabled?: boolean;
            atBootIpV6Enabled?: boolean;
            netStackInstance?: Array<vimService.vim.HostNetStackInstance>;
            opaqueSwitch?: Array<vimService.vim.HostOpaqueSwitch>;
            opaqueNetwork?: Array<vimService.vim.HostOpaqueNetworkInfo>;
         }
         interface HostNetworkSecurityPolicy extends vimService.vim.DynamicData {
            allowPromiscuous?: boolean;
            macChanges?: boolean;
            forgedTransmits?: boolean;
         }
         interface HostNetworkTrafficShapingPolicy extends vimService.vim.DynamicData {
            enabled?: boolean;
            averageBandwidth?: number;
            peakBandwidth?: number;
            burstSize?: number;
         }
         interface HostNicFailureCriteria extends vimService.vim.DynamicData {
            checkSpeed?: string;
            speed?: number;
            checkDuplex?: boolean;
            fullDuplex?: boolean;
            checkErrorPercent?: boolean;
            percentage?: number;
            checkBeacon?: boolean;
         }
         interface HostNicOrderPolicy extends vimService.vim.DynamicData {
            activeNic?: Array<string>;
            standbyNic?: Array<string>;
         }
         interface HostNicTeamingPolicy extends vimService.vim.DynamicData {
            policy?: string;
            reversePolicy?: boolean;
            notifySwitches?: boolean;
            rollingOrder?: boolean;
            failureCriteria?: vimService.vim.HostNicFailureCriteria;
            nicOrder?: vimService.vim.HostNicOrderPolicy;
         }
         interface HostNetworkPolicy extends vimService.vim.DynamicData {
            security?: vimService.vim.HostNetworkSecurityPolicy;
            nicTeaming?: vimService.vim.HostNicTeamingPolicy;
            offloadPolicy?: vimService.vim.HostNetOffloadCapabilities;
            shapingPolicy?: vimService.vim.HostNetworkTrafficShapingPolicy;
         }
         interface HostNtpConfig extends vimService.vim.DynamicData {
            server?: Array<string>;
            configFile?: Array<string>;
         }
         enum HostNumericSensorHealthState {
            "unknown",
            "green",
            "yellow",
            "red",
         }
         enum HostNumericSensorType {
            "fan",
            "power",
            "temperature",
            "voltage",
            "other",
         }
         interface HostNumericSensorInfo extends vimService.vim.DynamicData {
            name: string;
            healthState?: vimService.vim.ElementDescription;
            currentReading: number;
            unitModifier: number;
            baseUnits: string;
            rateUnits?: string;
            sensorType: string;
         }
         interface ArrayOfHostNumericSensorInfo {
            hostNumericSensorInfo?: Array<vimService.vim.HostNumericSensorInfo>;
         }
         interface HostOpaqueNetworkInfo extends vimService.vim.DynamicData {
            opaqueNetworkId: string;
            opaqueNetworkName: string;
            opaqueNetworkType: string;
            pnicZone?: Array<string>;
         }
         interface ArrayOfHostOpaqueNetworkInfo {
            hostOpaqueNetworkInfo?: Array<vimService.vim.HostOpaqueNetworkInfo>;
         }
         enum HostOpaqueSwitchOpaqueSwitchState {
            "up",
            "warning",
            "down",
         }
         interface HostOpaqueSwitchPhysicalNicZone extends vimService.vim.DynamicData {
            key: string;
            pnicDevice?: Array<string>;
         }
         interface ArrayOfHostOpaqueSwitchPhysicalNicZone {
            hostOpaqueSwitchPhysicalNicZone?: Array<vimService.vim.HostOpaqueSwitchPhysicalNicZone>;
         }
         interface HostOpaqueSwitch extends vimService.vim.DynamicData {
            key: string;
            name?: string;
            pnic?: Array<string>;
            pnicZone?: Array<vimService.vim.HostOpaqueSwitchPhysicalNicZone>;
            status?: string;
            vtep?: Array<vimService.vim.HostVirtualNic>;
         }
         interface ArrayOfHostOpaqueSwitch {
            hostOpaqueSwitch?: Array<vimService.vim.HostOpaqueSwitch>;
         }
         interface HostPatchManagerResult extends vimService.vim.DynamicData {
            version: string;
            status?: Array<vimService.vim.HostPatchManagerStatus>;
            xmlResult?: string;
         }
         enum HostPatchManagerReason {
            "obsoleted",
            "missingPatch",
            "missingLib",
            "hasDependentPatch",
            "conflictPatch",
            "conflictLib",
         }
         enum HostPatchManagerIntegrityStatus {
            "validated",
            "keyNotFound",
            "keyRevoked",
            "keyExpired",
            "digestMismatch",
            "notEnoughSignatures",
            "validationError",
         }
         enum HostPatchManagerInstallState {
            "hostRestarted",
            "imageActive",
         }
         interface HostPatchManagerStatusPrerequisitePatch extends vimService.vim.DynamicData {
            id: string;
            installState?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatusPrerequisitePatch {
            hostPatchManagerStatusPrerequisitePatch?: Array<vimService.vim.HostPatchManagerStatusPrerequisitePatch>;
         }
         interface HostPatchManagerStatus extends vimService.vim.DynamicData {
            id: string;
            applicable: boolean;
            reason?: Array<string>;
            integrity?: string;
            installed: boolean;
            installState?: Array<string>;
            prerequisitePatch?: Array<vimService.vim.HostPatchManagerStatusPrerequisitePatch>;
            restartRequired: boolean;
            reconnectRequired: boolean;
            vmOffRequired: boolean;
            supersededPatchIds?: Array<string>;
         }
         interface ArrayOfHostPatchManagerStatus {
            hostPatchManagerStatus?: Array<vimService.vim.HostPatchManagerStatus>;
         }
         interface HostPatchManagerLocator extends vimService.vim.DynamicData {
            url: string;
            proxy?: string;
         }
         interface HostPatchManagerPatchManagerOperationSpec extends vimService.vim.DynamicData {
            proxy?: string;
            port?: number;
            userName?: string;
            password?: string;
            cmdOption?: string;
         }
         interface HostPathSelectionPolicyOption extends vimService.vim.DynamicData {
            policy: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostPathSelectionPolicyOption {
            hostPathSelectionPolicyOption?: Array<vimService.vim.HostPathSelectionPolicyOption>;
         }
         interface HostPciDevice extends vimService.vim.DynamicData {
            id: string;
            classId: number;
            bus: number;
            slot: number;
            function: number;
            vendorId: number;
            subVendorId: number;
            vendorName: string;
            deviceId: number;
            subDeviceId: number;
            parentBridge?: string;
            deviceName: string;
         }
         interface ArrayOfHostPciDevice {
            hostPciDevice?: Array<vimService.vim.HostPciDevice>;
         }
         interface HostPciPassthruConfig extends vimService.vim.DynamicData {
            id: string;
            passthruEnabled: boolean;
         }
         interface ArrayOfHostPciPassthruConfig {
            hostPciPassthruConfig?: Array<vimService.vim.HostPciPassthruConfig>;
         }
         interface HostPciPassthruInfo extends vimService.vim.DynamicData {
            id: string;
            dependentDevice: string;
            passthruEnabled: boolean;
            passthruCapable: boolean;
            passthruActive: boolean;
         }
         interface ArrayOfHostPciPassthruInfo {
            hostPciPassthruInfo?: Array<vimService.vim.HostPciPassthruInfo>;
         }
         interface PhysicalNicSpec extends vimService.vim.DynamicData {
            ip?: vimService.vim.HostIpConfig;
            linkSpeed?: vimService.vim.PhysicalNicLinkInfo;
         }
         interface PhysicalNicConfig extends vimService.vim.DynamicData {
            device: string;
            spec: vimService.vim.PhysicalNicSpec;
         }
         interface ArrayOfPhysicalNicConfig {
            physicalNicConfig?: Array<vimService.vim.PhysicalNicConfig>;
         }
         interface PhysicalNicLinkInfo extends vimService.vim.DynamicData {
            speedMb: number;
            duplex: boolean;
         }
         interface ArrayOfPhysicalNicLinkInfo {
            physicalNicLinkInfo?: Array<vimService.vim.PhysicalNicLinkInfo>;
         }
         interface PhysicalNicHint extends vimService.vim.DynamicData {
            vlanId?: number;
         }
         interface PhysicalNicIpHint extends vimService.vim.PhysicalNicHint {
            ipSubnet: string;
         }
         interface ArrayOfPhysicalNicIpHint {
            physicalNicIpHint?: Array<vimService.vim.PhysicalNicIpHint>;
         }
         interface PhysicalNicNameHint extends vimService.vim.PhysicalNicHint {
            network: string;
         }
         interface ArrayOfPhysicalNicNameHint {
            physicalNicNameHint?: Array<vimService.vim.PhysicalNicNameHint>;
         }
         interface PhysicalNicHintInfo extends vimService.vim.DynamicData {
            device: string;
            subnet?: Array<vimService.vim.PhysicalNicIpHint>;
            network?: Array<vimService.vim.PhysicalNicNameHint>;
            connectedSwitchPort?: vimService.vim.PhysicalNicCdpInfo;
            lldpInfo?: vimService.vim.LinkLayerDiscoveryProtocolInfo;
         }
         interface ArrayOfPhysicalNicHintInfo {
            physicalNicHintInfo?: Array<vimService.vim.PhysicalNicHintInfo>;
         }
         interface PhysicalNicCdpDeviceCapability extends vimService.vim.DynamicData {
            router: boolean;
            transparentBridge: boolean;
            sourceRouteBridge: boolean;
            networkSwitch: boolean;
            host: boolean;
            igmpEnabled: boolean;
            repeater: boolean;
         }
         interface PhysicalNicCdpInfo extends vimService.vim.DynamicData {
            cdpVersion?: number;
            timeout?: number;
            ttl?: number;
            samples?: number;
            devId?: string;
            address?: string;
            portId?: string;
            deviceCapability?: vimService.vim.PhysicalNicCdpDeviceCapability;
            softwareVersion?: string;
            hardwarePlatform?: string;
            ipPrefix?: string;
            ipPrefixLen?: number;
            vlan?: number;
            fullDuplex?: boolean;
            mtu?: number;
            systemName?: string;
            systemOID?: string;
            mgmtAddr?: string;
            location?: string;
         }
         interface LinkLayerDiscoveryProtocolInfo extends vimService.vim.DynamicData {
            chassisId: string;
            portId: string;
            timeToLive: number;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         enum PhysicalNicVmDirectPathGen2SupportedMode {
            "upt",
         }
         enum PhysicalNicResourcePoolSchedulerDisallowedReason {
            "userOptOut",
            "hardwareUnsupported",
         }
         interface PhysicalNic extends vimService.vim.DynamicData {
            key?: string;
            device: string;
            pci: string;
            driver?: string;
            linkSpeed?: vimService.vim.PhysicalNicLinkInfo;
            validLinkSpecification?: Array<vimService.vim.PhysicalNicLinkInfo>;
            spec: vimService.vim.PhysicalNicSpec;
            wakeOnLanSupported: boolean;
            mac: string;
            fcoeConfiguration?: vimService.vim.FcoeConfig;
            vmDirectPathGen2Supported?: boolean;
            vmDirectPathGen2SupportedMode?: string;
            resourcePoolSchedulerAllowed?: boolean;
            resourcePoolSchedulerDisallowedReason?: Array<string>;
            autoNegotiateSupported?: boolean;
         }
         interface ArrayOfPhysicalNic {
            physicalNic?: Array<vimService.vim.PhysicalNic>;
         }
         interface HostPlugStoreTopologyAdapter extends vimService.vim.DynamicData {
            key: string;
            adapter: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyAdapter {
            hostPlugStoreTopologyAdapter?: Array<vimService.vim.HostPlugStoreTopologyAdapter>;
         }
         interface HostPlugStoreTopologyPath extends vimService.vim.DynamicData {
            key: string;
            name: string;
            channelNumber?: number;
            targetNumber?: number;
            lunNumber?: number;
            adapter?: string;
            target?: string;
            device?: string;
         }
         interface ArrayOfHostPlugStoreTopologyPath {
            hostPlugStoreTopologyPath?: Array<vimService.vim.HostPlugStoreTopologyPath>;
         }
         interface HostPlugStoreTopologyDevice extends vimService.vim.DynamicData {
            key: string;
            lun: string;
            path?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyDevice {
            hostPlugStoreTopologyDevice?: Array<vimService.vim.HostPlugStoreTopologyDevice>;
         }
         interface HostPlugStoreTopologyPlugin extends vimService.vim.DynamicData {
            key: string;
            name: string;
            device?: Array<string>;
            claimedPath?: Array<string>;
         }
         interface ArrayOfHostPlugStoreTopologyPlugin {
            hostPlugStoreTopologyPlugin?: Array<vimService.vim.HostPlugStoreTopologyPlugin>;
         }
         interface HostPlugStoreTopologyTarget extends vimService.vim.DynamicData {
            key: string;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostPlugStoreTopologyTarget {
            hostPlugStoreTopologyTarget?: Array<vimService.vim.HostPlugStoreTopologyTarget>;
         }
         interface HostPlugStoreTopology extends vimService.vim.DynamicData {
            adapter?: Array<vimService.vim.HostPlugStoreTopologyAdapter>;
            path?: Array<vimService.vim.HostPlugStoreTopologyPath>;
            target?: Array<vimService.vim.HostPlugStoreTopologyTarget>;
            device?: Array<vimService.vim.HostPlugStoreTopologyDevice>;
            plugin?: Array<vimService.vim.HostPlugStoreTopologyPlugin>;
         }
         enum PortGroupConnecteeType {
            "virtualMachine",
            "systemManagement",
            "host",
            "unknown",
         }
         interface HostPortGroupSpec extends vimService.vim.DynamicData {
            name: string;
            vlanId: number;
            vswitchName: string;
            policy: vimService.vim.HostNetworkPolicy;
         }
         interface HostPortGroupConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            spec?: vimService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroupConfig {
            hostPortGroupConfig?: Array<vimService.vim.HostPortGroupConfig>;
         }
         interface HostPortGroupPort extends vimService.vim.DynamicData {
            key?: string;
            mac?: Array<string>;
            type: string;
         }
         interface ArrayOfHostPortGroupPort {
            hostPortGroupPort?: Array<vimService.vim.HostPortGroupPort>;
         }
         interface HostPortGroup extends vimService.vim.DynamicData {
            key?: string;
            port?: Array<vimService.vim.HostPortGroupPort>;
            vswitch?: string;
            computedPolicy: vimService.vim.HostNetworkPolicy;
            spec: vimService.vim.HostPortGroupSpec;
         }
         interface ArrayOfHostPortGroup {
            hostPortGroup?: Array<vimService.vim.HostPortGroup>;
         }
         interface HostPowerPolicy extends vimService.vim.DynamicData {
            key: number;
            name: string;
            shortName: string;
            description: string;
         }
         interface ArrayOfHostPowerPolicy {
            hostPowerPolicy?: Array<vimService.vim.HostPowerPolicy>;
         }
         interface PowerSystemCapability extends vimService.vim.DynamicData {
            availablePolicy: Array<vimService.vim.HostPowerPolicy>;
         }
         interface PowerSystemInfo extends vimService.vim.DynamicData {
            currentPolicy: vimService.vim.HostPowerPolicy;
         }
         enum HostProtocolEndpointPEType {
            "block",
            "nas",
         }
         interface HostProtocolEndpoint extends vimService.vim.DynamicData {
            peType: string;
            uuid: string;
            hostKey?: Array<vimService.vim.ManagedObjectReference>;
            storageArray?: string;
            nfsServer?: string;
            nfsDir?: string;
            deviceId?: string;
         }
         interface ArrayOfHostProtocolEndpoint {
            hostProtocolEndpoint?: Array<vimService.vim.HostProtocolEndpoint>;
         }
         interface HostResignatureRescanResult extends vimService.vim.DynamicData {
            rescan?: Array<vimService.vim.HostVmfsRescanResult>;
            result: vimService.vim.ManagedObjectReference;
         }
         interface HostFirewallRulesetIpNetwork extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
         }
         interface ArrayOfHostFirewallRulesetIpNetwork {
            hostFirewallRulesetIpNetwork?: Array<vimService.vim.HostFirewallRulesetIpNetwork>;
         }
         interface HostFirewallRulesetIpList extends vimService.vim.DynamicData {
            ipAddress?: Array<string>;
            ipNetwork?: Array<vimService.vim.HostFirewallRulesetIpNetwork>;
            allIp: boolean;
         }
         interface HostFirewallRulesetRulesetSpec extends vimService.vim.DynamicData {
            allowedHosts: vimService.vim.HostFirewallRulesetIpList;
         }
         enum HostFirewallRuleDirection {
            "inbound",
            "outbound",
         }
         enum HostFirewallRulePortType {
            "src",
            "dst",
         }
         enum HostFirewallRuleProtocol {
            "tcp",
            "udp",
         }
         interface HostFirewallRule extends vimService.vim.DynamicData {
            port: number;
            endPort?: number;
            direction: vimService.vim.HostFirewallRuleDirection;
            portType?: vimService.vim.HostFirewallRulePortType;
            protocol: string;
         }
         interface ArrayOfHostFirewallRule {
            hostFirewallRule?: Array<vimService.vim.HostFirewallRule>;
         }
         interface HostFirewallRuleset extends vimService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            rule: Array<vimService.vim.HostFirewallRule>;
            service?: string;
            enabled: boolean;
            allowedHosts?: vimService.vim.HostFirewallRulesetIpList;
         }
         interface ArrayOfHostFirewallRuleset {
            hostFirewallRuleset?: Array<vimService.vim.HostFirewallRuleset>;
         }
         enum HostRuntimeInfoNetStackInstanceRuntimeInfoState {
            "inactive",
            "active",
            "deactivating",
            "activating",
         }
         interface HostRuntimeInfoNetStackInstanceRuntimeInfo extends vimService.vim.DynamicData {
            netStackInstanceKey: string;
            state?: string;
            vmknicKeys?: Array<string>;
            maxNumberOfConnections?: number;
            currentIpV6Enabled?: boolean;
         }
         interface ArrayOfHostRuntimeInfoNetStackInstanceRuntimeInfo {
            hostRuntimeInfoNetStackInstanceRuntimeInfo?: Array<vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
         }
         interface HostPlacedVirtualNicIdentifier extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            vnicKey: string;
            reservation?: number;
         }
         interface ArrayOfHostPlacedVirtualNicIdentifier {
            hostPlacedVirtualNicIdentifier?: Array<vimService.vim.HostPlacedVirtualNicIdentifier>;
         }
         interface HostPnicNetworkResourceInfo extends vimService.vim.DynamicData {
            pnicDevice: string;
            availableBandwidthForVMTraffic?: number;
            unusedBandwidthForVMTraffic?: number;
            placedVirtualNics?: Array<vimService.vim.HostPlacedVirtualNicIdentifier>;
         }
         interface ArrayOfHostPnicNetworkResourceInfo {
            hostPnicNetworkResourceInfo?: Array<vimService.vim.HostPnicNetworkResourceInfo>;
         }
         interface HostNetworkResourceRuntime extends vimService.vim.DynamicData {
            pnicResourceInfo: Array<vimService.vim.HostPnicNetworkResourceInfo>;
         }
         interface HostRuntimeInfoNetworkRuntimeInfo extends vimService.vim.DynamicData {
            netStackInstanceRuntimeInfo?: Array<vimService.vim.HostRuntimeInfoNetStackInstanceRuntimeInfo>;
            networkResourceRuntime?: vimService.vim.HostNetworkResourceRuntime;
         }
         interface HostRuntimeInfo extends vimService.vim.DynamicData {
            connectionState: vimService.vim.HostSystemConnectionState;
            powerState: vimService.vim.HostSystemPowerState;
            standbyMode?: string;
            inMaintenanceMode: boolean;
            bootTime?: Date;
            healthSystemRuntime?: vimService.vim.HealthSystemRuntime;
            dasHostState?: vimService.vim.ClusterDasFdmHostState;
            tpmPcrValues?: Array<vimService.vim.HostTpmDigestInfo>;
            vsanRuntimeInfo?: vimService.vim.VsanHostRuntimeInfo;
            networkRuntimeInfo?: vimService.vim.HostRuntimeInfoNetworkRuntimeInfo;
            vFlashResourceRuntimeInfo?: vimService.vim.HostVFlashManagerVFlashResourceRunTimeInfo;
            hostMaxVirtualDiskCapacity?: number;
         }
         interface HostScsiDiskPartition extends vimService.vim.DynamicData {
            diskName: string;
            partition: number;
         }
         interface ArrayOfHostScsiDiskPartition {
            hostScsiDiskPartition?: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface HostScsiDisk extends vimService.vim.ScsiLun {
            capacity: vimService.vim.HostDiskDimensionsLba;
            devicePath: string;
            ssd?: boolean;
            localDisk?: boolean;
            physicalLocation?: Array<string>;
            emulatedDIXDIFEnabled?: boolean;
            vsanDiskInfo?: vimService.vim.VsanHostVsanDiskInfo;
         }
         interface ArrayOfHostScsiDisk {
            hostScsiDisk?: Array<vimService.vim.HostScsiDisk>;
         }
         enum ScsiLunType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "opticalDevice",
            "mediaChanger",
            "communications",
            "storageArrayController",
            "enclosure",
            "unknown",
         }
         interface ScsiLunCapabilities extends vimService.vim.DynamicData {
            updateDisplayNameSupported: boolean;
         }
         interface ScsiLunDurableName extends vimService.vim.DynamicData {
            namespace: string;
            namespaceId: number;
            data?: Array<number>;
         }
         interface ArrayOfScsiLunDurableName {
            scsiLunDurableName?: Array<vimService.vim.ScsiLunDurableName>;
         }
         enum ScsiLunState {
            "unknownState",
            "ok",
            "error",
            "off",
            "quiesced",
            "degraded",
            "lostCommunication",
            "timeout",
         }
         enum ScsiLunDescriptorQuality {
            "highQuality",
            "mediumQuality",
            "lowQuality",
            "unknownQuality",
         }
         interface ScsiLunDescriptor extends vimService.vim.DynamicData {
            quality: string;
            id: string;
         }
         interface ArrayOfScsiLunDescriptor {
            scsiLunDescriptor?: Array<vimService.vim.ScsiLunDescriptor>;
         }
         enum ScsiLunVStorageSupportStatus {
            "vStorageSupported",
            "vStorageUnsupported",
            "vStorageUnknown",
         }
         interface ScsiLun extends vimService.vim.HostDevice {
            key?: string;
            uuid: string;
            descriptor?: Array<vimService.vim.ScsiLunDescriptor>;
            canonicalName?: string;
            displayName?: string;
            lunType: string;
            vendor?: string;
            model?: string;
            revision?: string;
            scsiLevel?: number;
            serialNumber?: string;
            durableName?: vimService.vim.ScsiLunDurableName;
            alternateName?: Array<vimService.vim.ScsiLunDurableName>;
            standardInquiry?: Array<number>;
            queueDepth?: number;
            operationalState: Array<string>;
            capabilities?: vimService.vim.ScsiLunCapabilities;
            vStorageSupport?: string;
            protocolEndpoint?: boolean;
         }
         interface ArrayOfScsiLun {
            scsiLun?: Array<vimService.vim.ScsiLun>;
         }
         interface HostScsiTopologyInterface extends vimService.vim.DynamicData {
            key: string;
            adapter: string;
            target?: Array<vimService.vim.HostScsiTopologyTarget>;
         }
         interface ArrayOfHostScsiTopologyInterface {
            hostScsiTopologyInterface?: Array<vimService.vim.HostScsiTopologyInterface>;
         }
         interface HostScsiTopologyTarget extends vimService.vim.DynamicData {
            key: string;
            target: number;
            lun?: Array<vimService.vim.HostScsiTopologyLun>;
            transport?: vimService.vim.HostTargetTransport;
         }
         interface ArrayOfHostScsiTopologyTarget {
            hostScsiTopologyTarget?: Array<vimService.vim.HostScsiTopologyTarget>;
         }
         interface HostScsiTopologyLun extends vimService.vim.DynamicData {
            key: string;
            lun: number;
            scsiLun: string;
         }
         interface ArrayOfHostScsiTopologyLun {
            hostScsiTopologyLun?: Array<vimService.vim.HostScsiTopologyLun>;
         }
         interface HostScsiTopology extends vimService.vim.DynamicData {
            adapter?: Array<vimService.vim.HostScsiTopologyInterface>;
         }
         interface HostSecuritySpec extends vimService.vim.DynamicData {
            adminPassword?: string;
            removePermission?: Array<vimService.vim.Permission>;
            addPermission?: Array<vimService.vim.Permission>;
         }
         enum HostServicePolicy {
            "on",
            "automatic",
            "off",
         }
         interface HostServiceSourcePackage extends vimService.vim.DynamicData {
            sourcePackageName: string;
            description: string;
         }
         interface HostService extends vimService.vim.DynamicData {
            key: string;
            label: string;
            required: boolean;
            uninstallable: boolean;
            running: boolean;
            ruleset?: Array<string>;
            policy: string;
            sourcePackage?: vimService.vim.HostServiceSourcePackage;
         }
         interface ArrayOfHostService {
            hostService?: Array<vimService.vim.HostService>;
         }
         interface HostServiceConfig extends vimService.vim.DynamicData {
            serviceId: string;
            startupPolicy: string;
         }
         interface ArrayOfHostServiceConfig {
            hostServiceConfig?: Array<vimService.vim.HostServiceConfig>;
         }
         interface HostServiceInfo extends vimService.vim.DynamicData {
            service?: Array<vimService.vim.HostService>;
         }
         interface HostSnmpDestination extends vimService.vim.DynamicData {
            hostName: string;
            port: number;
            community: string;
         }
         interface ArrayOfHostSnmpDestination {
            hostSnmpDestination?: Array<vimService.vim.HostSnmpDestination>;
         }
         interface HostSnmpConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            port?: number;
            readOnlyCommunities?: Array<string>;
            trapTargets?: Array<vimService.vim.HostSnmpDestination>;
            option?: Array<vimService.vim.KeyValue>;
         }
         enum HostSnmpAgentCapability {
            "COMPLETE",
            "DIAGNOSTICS",
            "CONFIGURATION",
         }
         interface HostSnmpSystemAgentLimits extends vimService.vim.DynamicData {
            maxReadOnlyCommunities: number;
            maxTrapDestinations: number;
            maxCommunityLength: number;
            maxBufferSize: number;
            capability?: vimService.vim.HostSnmpAgentCapability;
         }
         interface HostSriovConfig extends vimService.vim.HostPciPassthruConfig {
            sriovEnabled: boolean;
            numVirtualFunction: number;
         }
         interface HostSriovInfo extends vimService.vim.HostPciPassthruInfo {
            sriovEnabled: boolean;
            sriovCapable: boolean;
            sriovActive: boolean;
            numVirtualFunctionRequested: number;
            numVirtualFunction: number;
            maxVirtualFunctionSupported: number;
         }
         interface HostSslThumbprintInfo extends vimService.vim.DynamicData {
            principal: string;
            ownerTag?: string;
            sslThumbprints?: Array<string>;
         }
         interface ArrayOfHostSslThumbprintInfo {
            hostSslThumbprintInfo?: Array<vimService.vim.HostSslThumbprintInfo>;
         }
         interface HostStorageArrayTypePolicyOption extends vimService.vim.DynamicData {
            policy: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostStorageArrayTypePolicyOption {
            hostStorageArrayTypePolicyOption?: Array<vimService.vim.HostStorageArrayTypePolicyOption>;
         }
         interface HostStorageDeviceInfo extends vimService.vim.DynamicData {
            hostBusAdapter?: Array<vimService.vim.HostHostBusAdapter>;
            scsiLun?: Array<vimService.vim.ScsiLun>;
            scsiTopology?: vimService.vim.HostScsiTopology;
            multipathInfo?: vimService.vim.HostMultipathInfo;
            plugStoreTopology?: vimService.vim.HostPlugStoreTopology;
            softwareInternetScsiEnabled: boolean;
         }
         interface HostStorageSystemVmfsVolumeResult extends vimService.vim.DynamicData {
            key: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemVmfsVolumeResult {
            hostStorageSystemVmfsVolumeResult?: Array<vimService.vim.HostStorageSystemVmfsVolumeResult>;
         }
         interface HostStorageSystemScsiLunResult extends vimService.vim.DynamicData {
            key: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemScsiLunResult {
            hostStorageSystemScsiLunResult?: Array<vimService.vim.HostStorageSystemScsiLunResult>;
         }
         interface HostStorageSystemDiskLocatorLedResult extends vimService.vim.DynamicData {
            key: string;
            fault: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostStorageSystemDiskLocatorLedResult {
            hostStorageSystemDiskLocatorLedResult?: Array<vimService.vim.HostStorageSystemDiskLocatorLedResult>;
         }
         interface HostHardwareSummary extends vimService.vim.DynamicData {
            vendor: string;
            model: string;
            uuid: string;
            otherIdentifyingInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
            memorySize: number;
            cpuModel: string;
            cpuMhz: number;
            numCpuPkgs: number;
            numCpuCores: number;
            numCpuThreads: number;
            numNics: number;
            numHBAs: number;
         }
         interface HostListSummaryQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallMemoryUsage?: number;
            distributedCpuFairness?: number;
            distributedMemoryFairness?: number;
            uptime?: number;
         }
         interface HostConfigSummary extends vimService.vim.DynamicData {
            name: string;
            port: number;
            sslThumbprint?: string;
            product?: vimService.vim.AboutInfo;
            vmotionEnabled: boolean;
            faultToleranceEnabled?: boolean;
            featureVersion?: Array<vimService.vim.HostFeatureVersionInfo>;
            agentVmDatastore?: vimService.vim.ManagedObjectReference;
            agentVmNetwork?: vimService.vim.ManagedObjectReference;
         }
         interface HostListSummaryGatewaySummary extends vimService.vim.DynamicData {
            gatewayType: string;
            gatewayId: string;
         }
         interface HostListSummary extends vimService.vim.DynamicData {
            host?: vimService.vim.ManagedObjectReference;
            hardware?: vimService.vim.HostHardwareSummary;
            runtime?: vimService.vim.HostRuntimeInfo;
            config: vimService.vim.HostConfigSummary;
            quickStats: vimService.vim.HostListSummaryQuickStats;
            overallStatus: vimService.vim.ManagedEntityStatus;
            rebootRequired: boolean;
            customValue?: Array<vimService.vim.CustomFieldValue>;
            managementServerIp?: string;
            maxEVCModeKey?: string;
            currentEVCModeKey?: string;
            gateway?: vimService.vim.HostListSummaryGatewaySummary;
         }
         interface HostSystemHealthInfo extends vimService.vim.DynamicData {
            numericSensorInfo?: Array<vimService.vim.HostNumericSensorInfo>;
         }
         enum HostSystemIdentificationInfoIdentifier {
            "AssetTag",
            "ServiceTag",
            "OemSpecificString",
         }
         interface HostSystemIdentificationInfo extends vimService.vim.DynamicData {
            identifierValue: string;
            identifierType: vimService.vim.ElementDescription;
         }
         interface ArrayOfHostSystemIdentificationInfo {
            hostSystemIdentificationInfo?: Array<vimService.vim.HostSystemIdentificationInfo>;
         }
         interface HostSystemResourceInfo extends vimService.vim.DynamicData {
            key: string;
            config?: vimService.vim.ResourceConfigSpec;
            child?: Array<vimService.vim.HostSystemResourceInfo>;
         }
         interface ArrayOfHostSystemResourceInfo {
            hostSystemResourceInfo?: Array<vimService.vim.HostSystemResourceInfo>;
         }
         interface HostSystemSwapConfigurationSystemSwapOption extends vimService.vim.DynamicData {
            key: number;
         }
         interface ArrayOfHostSystemSwapConfigurationSystemSwapOption {
            hostSystemSwapConfigurationSystemSwapOption?: Array<vimService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostSystemSwapConfigurationDisabledOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostCacheOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationHostLocalSwapOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
         }
         interface HostSystemSwapConfigurationDatastoreOption extends vimService.vim.HostSystemSwapConfigurationSystemSwapOption {
            datastore: string;
         }
         interface HostSystemSwapConfiguration extends vimService.vim.DynamicData {
            option?: Array<vimService.vim.HostSystemSwapConfigurationSystemSwapOption>;
         }
         interface HostTargetTransport extends vimService.vim.DynamicData {
         }
         interface HostParallelScsiTargetTransport extends vimService.vim.HostTargetTransport {
         }
         interface HostBlockAdapterTargetTransport extends vimService.vim.HostTargetTransport {
         }
         interface HostFibreChannelTargetTransport extends vimService.vim.HostTargetTransport {
            portWorldWideName: number;
            nodeWorldWideName: number;
         }
         interface HostInternetScsiTargetTransport extends vimService.vim.HostTargetTransport {
            iScsiName: string;
            iScsiAlias: string;
            address?: Array<string>;
         }
         interface HostFibreChannelOverEthernetTargetTransport extends vimService.vim.HostFibreChannelTargetTransport {
            vnportMac: string;
            fcfMac: string;
            vlanId: number;
         }
         interface HostTpmAttestationReport extends vimService.vim.DynamicData {
            tpmPcrValues: Array<vimService.vim.HostTpmDigestInfo>;
            tpmEvents: Array<vimService.vim.HostTpmEventLogEntry>;
            tpmLogReliable: boolean;
         }
         interface HostTpmBootSecurityOptionEventDetails extends vimService.vim.HostTpmEventDetails {
            bootSecurityOption: string;
         }
         interface HostTpmCommandEventDetails extends vimService.vim.HostTpmEventDetails {
            commandLine: string;
         }
         enum HostDigestInfoDigestMethodType {
            "SHA1",
            "MD5",
         }
         interface HostDigestInfo extends vimService.vim.DynamicData {
            digestMethod: string;
            digestValue: Array<number>;
            objectName?: string;
         }
         interface HostTpmDigestInfo extends vimService.vim.HostDigestInfo {
            pcrNumber: number;
         }
         interface ArrayOfHostTpmDigestInfo {
            hostTpmDigestInfo?: Array<vimService.vim.HostTpmDigestInfo>;
         }
         interface HostTpmEventDetails extends vimService.vim.DynamicData {
            dataHash: Array<number>;
         }
         interface HostTpmEventLogEntry extends vimService.vim.DynamicData {
            pcrIndex: number;
            eventDetails: vimService.vim.HostTpmEventDetails;
         }
         interface ArrayOfHostTpmEventLogEntry {
            hostTpmEventLogEntry?: Array<vimService.vim.HostTpmEventLogEntry>;
         }
         interface HostTpmOptionEventDetails extends vimService.vim.HostTpmEventDetails {
            optionsFileName: string;
            bootOptions?: Array<number>;
         }
         interface HostTpmSoftwareComponentEventDetails extends vimService.vim.HostTpmEventDetails {
            componentName: string;
            vibName: string;
            vibVersion: string;
            vibVendor: string;
         }
         enum HostUnresolvedVmfsExtentUnresolvedReason {
            "diskIdMismatch",
            "uuidConflict",
         }
         interface HostUnresolvedVmfsExtent extends vimService.vim.DynamicData {
            device: vimService.vim.HostScsiDiskPartition;
            devicePath: string;
            vmfsUuid: string;
            isHeadExtent: boolean;
            ordinal: number;
            startBlock: number;
            endBlock: number;
            reason: string;
         }
         interface ArrayOfHostUnresolvedVmfsExtent {
            hostUnresolvedVmfsExtent?: Array<vimService.vim.HostUnresolvedVmfsExtent>;
         }
         interface HostUnresolvedVmfsResignatureSpec extends vimService.vim.DynamicData {
            extentDevicePath: Array<string>;
         }
         interface HostUnresolvedVmfsResolutionResult extends vimService.vim.DynamicData {
            spec: vimService.vim.HostUnresolvedVmfsResolutionSpec;
            vmfs?: vimService.vim.HostVmfsVolume;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionResult {
            hostUnresolvedVmfsResolutionResult?: Array<vimService.vim.HostUnresolvedVmfsResolutionResult>;
         }
         enum HostUnresolvedVmfsResolutionSpecVmfsUuidResolution {
            "resignature",
            "forceMount",
         }
         interface HostUnresolvedVmfsResolutionSpec extends vimService.vim.DynamicData {
            extentDevicePath: Array<string>;
            uuidResolution: string;
         }
         interface ArrayOfHostUnresolvedVmfsResolutionSpec {
            hostUnresolvedVmfsResolutionSpec?: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>;
         }
         interface HostUnresolvedVmfsVolumeResolveStatus extends vimService.vim.DynamicData {
            resolvable: boolean;
            incompleteExtents?: boolean;
            multipleCopies?: boolean;
         }
         interface HostUnresolvedVmfsVolume extends vimService.vim.DynamicData {
            extent: Array<vimService.vim.HostUnresolvedVmfsExtent>;
            vmfsLabel: string;
            vmfsUuid: string;
            totalBlocks: number;
            resolveStatus: vimService.vim.HostUnresolvedVmfsVolumeResolveStatus;
         }
         interface ArrayOfHostUnresolvedVmfsVolume {
            hostUnresolvedVmfsVolume?: Array<vimService.vim.HostUnresolvedVmfsVolume>;
         }
         interface HostVFlashManagerVFlashResourceConfigSpec extends vimService.vim.DynamicData {
            vffsUuid: string;
         }
         interface HostVFlashManagerVFlashResourceConfigInfo extends vimService.vim.DynamicData {
            vffs?: vimService.vim.HostVffsVolume;
            capacity: number;
         }
         interface HostVFlashManagerVFlashResourceRunTimeInfo extends vimService.vim.DynamicData {
            usage: number;
            capacity: number;
            accessible: boolean;
            capacityForVmCache: number;
            freeForVmCache: number;
         }
         interface HostVFlashManagerVFlashCacheConfigSpec extends vimService.vim.DynamicData {
            defaultVFlashModule: string;
            swapCacheReservationInGB: number;
         }
         interface HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption extends vimService.vim.DynamicData {
            vFlashModule: string;
            vFlashModuleVersion: string;
            minSupportedModuleVersion: string;
            cacheConsistencyType: vimService.vim.ChoiceOption;
            cacheMode: vimService.vim.ChoiceOption;
            blockSizeInKBOption: vimService.vim.LongOption;
            reservationInMBOption: vimService.vim.LongOption;
            maxDiskSizeInKB: number;
         }
         interface ArrayOfHostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption {
            hostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption?: Array<vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
         }
         interface HostVFlashManagerVFlashCacheConfigInfo extends vimService.vim.DynamicData {
            vFlashModuleConfigOption?: Array<vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption>;
            defaultVFlashModule?: string;
            swapCacheReservationInGB?: number;
         }
         interface HostVFlashManagerVFlashConfigInfo extends vimService.vim.DynamicData {
            vFlashResourceConfigInfo?: vimService.vim.HostVFlashManagerVFlashResourceConfigInfo;
            vFlashCacheConfigInfo?: vimService.vim.HostVFlashManagerVFlashCacheConfigInfo;
         }
         interface HostVFlashResourceConfigurationResult extends vimService.vim.DynamicData {
            devicePath?: Array<string>;
            vffs?: vimService.vim.HostVffsVolume;
            diskConfigurationResult?: Array<vimService.vim.HostDiskConfigurationResult>;
         }
         interface HostVMotionConfig extends vimService.vim.DynamicData {
            vmotionNicKey?: string;
            enabled: boolean;
         }
         interface HostVMotionInfo extends vimService.vim.DynamicData {
            netConfig?: vimService.vim.HostVMotionNetConfig;
            ipConfig?: vimService.vim.HostIpConfig;
         }
         interface HostVMotionNetConfig extends vimService.vim.DynamicData {
            candidateVnic?: Array<vimService.vim.HostVirtualNic>;
            selectedVnic?: string;
         }
         interface HostVffsSpec extends vimService.vim.DynamicData {
            devicePath: string;
            partition?: vimService.vim.HostDiskPartitionSpec;
            majorVersion: number;
            volumeName: string;
         }
         interface HostVffsVolume extends vimService.vim.HostFileSystemVolume {
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
         }
         interface HostVirtualNicSpec extends vimService.vim.DynamicData {
            ip?: vimService.vim.HostIpConfig;
            mac?: string;
            distributedVirtualPort?: vimService.vim.DistributedVirtualSwitchPortConnection;
            portgroup?: string;
            mtu?: number;
            tsoEnabled?: boolean;
            netStackInstanceKey?: string;
            opaqueNetwork?: vimService.vim.HostVirtualNicOpaqueNetworkSpec;
            externalId?: string;
            pinnedPnic?: string;
         }
         interface HostVirtualNicConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            device?: string;
            portgroup: string;
            spec?: vimService.vim.HostVirtualNicSpec;
         }
         interface ArrayOfHostVirtualNicConfig {
            hostVirtualNicConfig?: Array<vimService.vim.HostVirtualNicConfig>;
         }
         interface HostVirtualNicOpaqueNetworkSpec extends vimService.vim.DynamicData {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface HostVirtualNic extends vimService.vim.DynamicData {
            device: string;
            key: string;
            portgroup: string;
            spec: vimService.vim.HostVirtualNicSpec;
            port?: string;
         }
         interface ArrayOfHostVirtualNic {
            hostVirtualNic?: Array<vimService.vim.HostVirtualNic>;
         }
         interface HostVirtualNicConnection extends vimService.vim.DynamicData {
            portgroup?: string;
            dvPort?: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         enum HostVirtualNicManagerNicType {
            "vmotion",
            "faultToleranceLogging",
            "vSphereReplication",
            "vSphereReplicationNFC",
            "management",
            "vsan",
            "vSphereProvisioning",
         }
         interface HostVirtualNicManagerNicTypeSelection extends vimService.vim.DynamicData {
            vnic: vimService.vim.HostVirtualNicConnection;
            nicType?: Array<string>;
         }
         interface ArrayOfHostVirtualNicManagerNicTypeSelection {
            hostVirtualNicManagerNicTypeSelection?: Array<vimService.vim.HostVirtualNicManagerNicTypeSelection>;
         }
         interface VirtualNicManagerNetConfig extends vimService.vim.DynamicData {
            nicType: string;
            multiSelectAllowed: boolean;
            candidateVnic?: Array<vimService.vim.HostVirtualNic>;
            selectedVnic?: Array<string>;
         }
         interface ArrayOfVirtualNicManagerNetConfig {
            virtualNicManagerNetConfig?: Array<vimService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualNicManagerInfo extends vimService.vim.DynamicData {
            netConfig?: Array<vimService.vim.VirtualNicManagerNetConfig>;
         }
         interface HostVirtualSwitchBridge extends vimService.vim.DynamicData {
         }
         interface HostVirtualSwitchAutoBridge extends vimService.vim.HostVirtualSwitchBridge {
            excludedNicDevice?: Array<string>;
         }
         interface HostVirtualSwitchSimpleBridge extends vimService.vim.HostVirtualSwitchBridge {
            nicDevice: string;
         }
         interface HostVirtualSwitchBondBridge extends vimService.vim.HostVirtualSwitchBridge {
            nicDevice: Array<string>;
            beacon?: vimService.vim.HostVirtualSwitchBeaconConfig;
            linkDiscoveryProtocolConfig?: vimService.vim.LinkDiscoveryProtocolConfig;
         }
         interface HostVirtualSwitchBeaconConfig extends vimService.vim.DynamicData {
            interval: number;
         }
         interface HostVirtualSwitchSpec extends vimService.vim.DynamicData {
            numPorts: number;
            bridge?: vimService.vim.HostVirtualSwitchBridge;
            policy?: vimService.vim.HostNetworkPolicy;
            mtu?: number;
         }
         interface HostVirtualSwitchConfig extends vimService.vim.DynamicData {
            changeOperation?: string;
            name: string;
            spec?: vimService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitchConfig {
            hostVirtualSwitchConfig?: Array<vimService.vim.HostVirtualSwitchConfig>;
         }
         interface HostVirtualSwitch extends vimService.vim.DynamicData {
            name: string;
            key: string;
            numPorts: number;
            numPortsAvailable: number;
            mtu?: number;
            portgroup?: Array<string>;
            pnic?: Array<string>;
            spec: vimService.vim.HostVirtualSwitchSpec;
         }
         interface ArrayOfHostVirtualSwitch {
            hostVirtualSwitch?: Array<vimService.vim.HostVirtualSwitch>;
         }
         enum HostVmciAccessManagerMode {
            "grant",
            "replace",
            "revoke",
         }
         interface HostVmciAccessManagerAccessSpec extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            services?: Array<string>;
            mode: string;
         }
         interface ArrayOfHostVmciAccessManagerAccessSpec {
            hostVmciAccessManagerAccessSpec?: Array<vimService.vim.HostVmciAccessManagerAccessSpec>;
         }
         interface HostVmfsRescanResult extends vimService.vim.DynamicData {
            host: vimService.vim.ManagedObjectReference;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfHostVmfsRescanResult {
            hostVmfsRescanResult?: Array<vimService.vim.HostVmfsRescanResult>;
         }
         interface HostVmfsSpec extends vimService.vim.DynamicData {
            extent: vimService.vim.HostScsiDiskPartition;
            blockSizeMb?: number;
            majorVersion: number;
            volumeName: string;
         }
         interface HostVmfsVolume extends vimService.vim.HostFileSystemVolume {
            blockSizeMb: number;
            maxBlocks: number;
            majorVersion: number;
            version: string;
            uuid: string;
            extent: Array<vimService.vim.HostScsiDiskPartition>;
            vmfsUpgradable: boolean;
            forceMountedInfo?: vimService.vim.HostForceMountedInfo;
            ssd?: boolean;
            local?: boolean;
         }
         interface HostVsanInternalSystemCmmdsQuery extends vimService.vim.DynamicData {
            type?: string;
            uuid?: string;
            owner?: string;
         }
         interface ArrayOfHostVsanInternalSystemCmmdsQuery {
            hostVsanInternalSystemCmmdsQuery?: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>;
         }
         interface VsanPolicyCost extends vimService.vim.DynamicData {
            changeDataSize?: number;
            currentDataSize?: number;
            tempDataSize?: number;
            copyDataSize?: number;
            changeFlashReadCacheSize?: number;
            currentFlashReadCacheSize?: number;
            currentDiskSpaceToAddressSpaceRatio?: number;
            diskSpaceToAddressSpaceRatio?: number;
         }
         interface VsanPolicySatisfiability extends vimService.vim.DynamicData {
            uuid?: string;
            isSatisfiable: boolean;
            reason?: vimService.vim.LocalizableMessage;
            cost?: vimService.vim.VsanPolicyCost;
         }
         interface ArrayOfVsanPolicySatisfiability {
            vsanPolicySatisfiability?: Array<vimService.vim.VsanPolicySatisfiability>;
         }
         interface VsanPolicyChangeBatch extends vimService.vim.DynamicData {
            uuid?: Array<string>;
            policy?: string;
         }
         interface ArrayOfVsanPolicyChangeBatch {
            vsanPolicyChangeBatch?: Array<vimService.vim.VsanPolicyChangeBatch>;
         }
         interface VsanNewPolicyBatch extends vimService.vim.DynamicData {
            size?: Array<number>;
            policy?: string;
         }
         interface ArrayOfVsanNewPolicyBatch {
            vsanNewPolicyBatch?: Array<vimService.vim.VsanNewPolicyBatch>;
         }
         interface HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult extends vimService.vim.DynamicData {
            diskUuid: string;
            success: boolean;
            failureReason?: string;
         }
         interface ArrayOfHostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult {
            hostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult?: Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>;
         }
         interface HostVsanInternalSystemDeleteVsanObjectsResult extends vimService.vim.DynamicData {
            uuid: string;
            success: boolean;
            failureReason?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfHostVsanInternalSystemDeleteVsanObjectsResult {
            hostVsanInternalSystemDeleteVsanObjectsResult?: Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>;
         }
         interface HostVsanInternalSystemVsanObjectOperationResult extends vimService.vim.DynamicData {
            uuid: string;
            failureReason?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfHostVsanInternalSystemVsanObjectOperationResult {
            hostVsanInternalSystemVsanObjectOperationResult?: Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>;
         }
         interface HostVvolVolumeSpecification extends vimService.vim.DynamicData {
            maxSizeInMB: number;
            volumeName: string;
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            storageArray?: Array<vimService.vim.VASAStorageArray>;
            uuid: string;
         }
         interface VVolHostPE extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            protocolEndpoint: Array<vimService.vim.HostProtocolEndpoint>;
         }
         interface ArrayOfVVolHostPE {
            vVolHostPE?: Array<vimService.vim.VVolHostPE>;
         }
         interface HostVvolVolume extends vimService.vim.HostFileSystemVolume {
            scId: string;
            hostPE?: Array<vimService.vim.VVolHostPE>;
            vasaProviderInfo?: Array<vimService.vim.VimVasaProviderInfo>;
            storageArray?: Array<vimService.vim.VASAStorageArray>;
         }
         interface NetDhcpConfigInfoDhcpOptions extends vimService.vim.DynamicData {
            enable: boolean;
            config?: Array<vimService.vim.KeyValue>;
         }
         interface NetDhcpConfigInfo extends vimService.vim.DynamicData {
            ipv6?: vimService.vim.NetDhcpConfigInfoDhcpOptions;
            ipv4?: vimService.vim.NetDhcpConfigInfoDhcpOptions;
         }
         interface NetDhcpConfigSpecDhcpOptionsSpec extends vimService.vim.DynamicData {
            enable?: boolean;
            config: Array<vimService.vim.KeyValue>;
            operation: string;
         }
         interface NetDhcpConfigSpec extends vimService.vim.DynamicData {
            ipv6?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
            ipv4?: vimService.vim.NetDhcpConfigSpecDhcpOptionsSpec;
         }
         interface NetDnsConfigInfo extends vimService.vim.DynamicData {
            dhcp: boolean;
            hostName: string;
            domainName: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         interface NetDnsConfigSpec extends vimService.vim.DynamicData {
            dhcp?: boolean;
            hostName?: string;
            domainName?: string;
            ipAddress?: Array<string>;
            searchDomain?: Array<string>;
         }
         enum NetIpConfigInfoIpAddressOrigin {
            "other",
            "manual",
            "dhcp",
            "linklayer",
            "random",
         }
         enum NetIpConfigInfoIpAddressStatus {
            "preferred",
            "deprecated",
            "invalid",
            "inaccessible",
            "unknown",
            "tentative",
            "duplicate",
         }
         interface NetIpConfigInfoIpAddress extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            origin?: string;
            state?: string;
            lifetime?: Date;
         }
         interface ArrayOfNetIpConfigInfoIpAddress {
            netIpConfigInfoIpAddress?: Array<vimService.vim.NetIpConfigInfoIpAddress>;
         }
         interface NetIpConfigInfo extends vimService.vim.DynamicData {
            ipAddress?: Array<vimService.vim.NetIpConfigInfoIpAddress>;
            dhcp?: vimService.vim.NetDhcpConfigInfo;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpConfigSpecIpAddressSpec extends vimService.vim.DynamicData {
            ipAddress: string;
            prefixLength: number;
            operation: string;
         }
         interface ArrayOfNetIpConfigSpecIpAddressSpec {
            netIpConfigSpecIpAddressSpec?: Array<vimService.vim.NetIpConfigSpecIpAddressSpec>;
         }
         interface NetIpConfigSpec extends vimService.vim.DynamicData {
            ipAddress?: Array<vimService.vim.NetIpConfigSpecIpAddressSpec>;
            dhcp?: vimService.vim.NetDhcpConfigSpec;
            autoConfigurationEnabled?: boolean;
         }
         interface NetIpRouteConfigInfoGateway extends vimService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigInfoIpRoute extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: vimService.vim.NetIpRouteConfigInfoGateway;
         }
         interface ArrayOfNetIpRouteConfigInfoIpRoute {
            netIpRouteConfigInfoIpRoute?: Array<vimService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigInfo extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.NetIpRouteConfigInfoIpRoute>;
         }
         interface NetIpRouteConfigSpecGatewaySpec extends vimService.vim.DynamicData {
            ipAddress?: string;
            device?: string;
         }
         interface NetIpRouteConfigSpecIpRouteSpec extends vimService.vim.DynamicData {
            network: string;
            prefixLength: number;
            gateway: vimService.vim.NetIpRouteConfigSpecGatewaySpec;
            operation: string;
         }
         interface ArrayOfNetIpRouteConfigSpecIpRouteSpec {
            netIpRouteConfigSpecIpRouteSpec?: Array<vimService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         interface NetIpRouteConfigSpec extends vimService.vim.DynamicData {
            ipRoute?: Array<vimService.vim.NetIpRouteConfigSpecIpRouteSpec>;
         }
         enum NetIpStackInfoEntryType {
            "other",
            "invalid",
            "dynamic",
            "manual",
         }
         enum NetIpStackInfoPreference {
            "reserved",
            "low",
            "medium",
            "high",
         }
         interface NetIpStackInfoNetToMedia extends vimService.vim.DynamicData {
            ipAddress: string;
            physicalAddress: string;
            device: string;
            type: string;
         }
         interface ArrayOfNetIpStackInfoNetToMedia {
            netIpStackInfoNetToMedia?: Array<vimService.vim.NetIpStackInfoNetToMedia>;
         }
         interface NetIpStackInfoDefaultRouter extends vimService.vim.DynamicData {
            ipAddress: string;
            device: string;
            lifetime: Date;
            preference: string;
         }
         interface ArrayOfNetIpStackInfoDefaultRouter {
            netIpStackInfoDefaultRouter?: Array<vimService.vim.NetIpStackInfoDefaultRouter>;
         }
         interface NetIpStackInfo extends vimService.vim.DynamicData {
            neighbor?: Array<vimService.vim.NetIpStackInfoNetToMedia>;
            defaultRouter?: Array<vimService.vim.NetIpStackInfoDefaultRouter>;
         }
         enum NetBIOSConfigInfoMode {
            "unknown",
            "enabled",
            "disabled",
            "enabledViaDHCP",
         }
         interface NetBIOSConfigInfo extends vimService.vim.DynamicData {
            mode: string;
         }
         interface WinNetBIOSConfigInfo extends vimService.vim.NetBIOSConfigInfo {
            primaryWINS: string;
            secondaryWINS?: string;
         }
         enum ArrayUpdateOperation {
            "add",
            "remove",
            "edit",
         }
         interface ArrayUpdateSpec extends vimService.vim.DynamicData {
            operation: vimService.vim.ArrayUpdateOperation;
            removeKey?: any;
         }
         interface BoolOption extends vimService.vim.OptionType {
            supported: boolean;
            defaultValue: boolean;
         }
         interface ChoiceOption extends vimService.vim.OptionType {
            choiceInfo: Array<vimService.vim.ElementDescription>;
            defaultIndex?: number;
         }
         interface FloatOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface IntOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface LongOption extends vimService.vim.OptionType {
            min: number;
            max: number;
            defaultValue: number;
         }
         interface OptionDef extends vimService.vim.ElementDescription {
            optionType: vimService.vim.OptionType;
         }
         interface ArrayOfOptionDef {
            optionDef?: Array<vimService.vim.OptionDef>;
         }
         interface OptionType extends vimService.vim.DynamicData {
            valueIsReadonly?: boolean;
         }
         interface OptionValue extends vimService.vim.DynamicData {
            key: string;
            value?: any;
         }
         interface ArrayOfOptionValue {
            optionValue?: Array<vimService.vim.OptionValue>;
         }
         interface StringOption extends vimService.vim.OptionType {
            defaultValue: string;
            validCharacters?: string;
         }
         interface ApplyProfile extends vimService.vim.DynamicData {
            enabled: boolean;
            policy?: Array<vimService.vim.ProfilePolicy>;
            profileTypeName?: string;
            profileVersion?: string;
            property?: Array<vimService.vim.ProfileApplyProfileProperty>;
         }
         interface ArrayOfApplyProfile {
            applyProfile?: Array<vimService.vim.ApplyProfile>;
         }
         interface ProfileApplyProfileElement extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ProfileApplyProfileProperty extends vimService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            profile?: Array<vimService.vim.ApplyProfile>;
         }
         interface ArrayOfProfileApplyProfileProperty {
            profileApplyProfileProperty?: Array<vimService.vim.ProfileApplyProfileProperty>;
         }
         interface ComplianceLocator extends vimService.vim.DynamicData {
            expressionName: string;
            applyPath: vimService.vim.ProfilePropertyPath;
         }
         interface ArrayOfComplianceLocator {
            complianceLocator?: Array<vimService.vim.ComplianceLocator>;
         }
         interface ComplianceProfile extends vimService.vim.DynamicData {
            expression: Array<vimService.vim.ProfileExpression>;
            rootExpression: string;
         }
         enum ComplianceResultStatus {
            "compliant",
            "nonCompliant",
            "unknown",
         }
         interface ComplianceFailure extends vimService.vim.DynamicData {
            failureType: string;
            message: vimService.vim.LocalizableMessage;
            expressionName?: string;
         }
         interface ArrayOfComplianceFailure {
            complianceFailure?: Array<vimService.vim.ComplianceFailure>;
         }
         interface ComplianceResult extends vimService.vim.DynamicData {
            profile?: vimService.vim.ManagedObjectReference;
            complianceStatus: string;
            entity?: vimService.vim.ManagedObjectReference;
            checkTime?: Date;
            failure?: Array<vimService.vim.ComplianceFailure>;
         }
         interface ArrayOfComplianceResult {
            complianceResult?: Array<vimService.vim.ComplianceResult>;
         }
         interface ProfileDeferredPolicyOptionParameter extends vimService.vim.DynamicData {
            inputPath: vimService.vim.ProfilePropertyPath;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfProfileDeferredPolicyOptionParameter {
            profileDeferredPolicyOptionParameter?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface ProfileExpression extends vimService.vim.DynamicData {
            id: string;
            displayName: string;
            negated: boolean;
         }
         interface ArrayOfProfileExpression {
            profileExpression?: Array<vimService.vim.ProfileExpression>;
         }
         interface ProfileSimpleExpression extends vimService.vim.ProfileExpression {
            expressionType: string;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ProfileCompositeExpression extends vimService.vim.ProfileExpression {
            operator: string;
            expressionName: Array<string>;
         }
         interface ProfileExpressionMetadata extends vimService.vim.DynamicData {
            expressionId: vimService.vim.ExtendedElementDescription;
            parameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfileExpressionMetadata {
            profileExpressionMetadata?: Array<vimService.vim.ProfileExpressionMetadata>;
         }
         enum ProfileNumericComparator {
            "lessThan",
            "lessThanEqual",
            "equal",
            "notEqual",
            "greaterThanEqual",
            "greaterThan",
         }
         interface ProfileParameterMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            type: string;
            optional: boolean;
            defaultValue?: any;
         }
         interface ArrayOfProfileParameterMetadata {
            profileParameterMetadata?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicy extends vimService.vim.DynamicData {
            id: string;
            policyOption: vimService.vim.PolicyOption;
         }
         interface ArrayOfProfilePolicy {
            profilePolicy?: Array<vimService.vim.ProfilePolicy>;
         }
         interface ProfilePolicyOptionMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            parameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ArrayOfProfilePolicyOptionMetadata {
            profilePolicyOptionMetadata?: Array<vimService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ProfileCompositePolicyOptionMetadata extends vimService.vim.ProfilePolicyOptionMetadata {
            option: Array<string>;
         }
         interface UserInputRequiredParameterMetadata extends vimService.vim.ProfilePolicyOptionMetadata {
            userInputParameter?: Array<vimService.vim.ProfileParameterMetadata>;
         }
         interface ProfilePolicyMetadata extends vimService.vim.DynamicData {
            id: vimService.vim.ExtendedElementDescription;
            possibleOption: Array<vimService.vim.ProfilePolicyOptionMetadata>;
         }
         interface ArrayOfProfilePolicyMetadata {
            profilePolicyMetadata?: Array<vimService.vim.ProfilePolicyMetadata>;
         }
         interface PolicyOption extends vimService.vim.DynamicData {
            id: string;
            parameter?: Array<vimService.vim.KeyAnyValue>;
         }
         interface ArrayOfPolicyOption {
            policyOption?: Array<vimService.vim.PolicyOption>;
         }
         interface CompositePolicyOption extends vimService.vim.PolicyOption {
            option?: Array<vimService.vim.PolicyOption>;
         }
         interface ProfileCreateSpec extends vimService.vim.DynamicData {
            name?: string;
            annotation?: string;
            enabled?: boolean;
         }
         interface ProfileSerializedCreateSpec extends vimService.vim.ProfileCreateSpec {
            profileConfigString: string;
         }
         interface ProfileConfigInfo extends vimService.vim.DynamicData {
            name: string;
            annotation?: string;
            enabled: boolean;
         }
         interface ProfileDescriptionSection extends vimService.vim.DynamicData {
            description: vimService.vim.ExtendedElementDescription;
            message?: Array<vimService.vim.LocalizableMessage>;
         }
         interface ArrayOfProfileDescriptionSection {
            profileDescriptionSection?: Array<vimService.vim.ProfileDescriptionSection>;
         }
         interface ProfileDescription extends vimService.vim.DynamicData {
            section: Array<vimService.vim.ProfileDescriptionSection>;
         }
         interface ProfileMetadataProfileSortSpec extends vimService.vim.DynamicData {
            policyId: string;
            parameter: string;
         }
         interface ArrayOfProfileMetadataProfileSortSpec {
            profileMetadataProfileSortSpec?: Array<vimService.vim.ProfileMetadataProfileSortSpec>;
         }
         interface ProfileMetadata extends vimService.vim.DynamicData {
            key: string;
            profileTypeName?: string;
            description?: vimService.vim.ExtendedDescription;
            sortSpec?: Array<vimService.vim.ProfileMetadataProfileSortSpec>;
            profileCategory?: string;
            profileComponent?: string;
         }
         interface ArrayOfProfileMetadata {
            profileMetadata?: Array<vimService.vim.ProfileMetadata>;
         }
         interface ProfilePropertyPath extends vimService.vim.DynamicData {
            profilePath: string;
            policyId?: string;
            parameterId?: string;
         }
         interface ArrayOfProfilePropertyPath {
            profilePropertyPath?: Array<vimService.vim.ProfilePropertyPath>;
         }
         interface ProfileProfileStructure extends vimService.vim.DynamicData {
            profileTypeName: string;
            child?: Array<vimService.vim.ProfileProfileStructureProperty>;
         }
         interface ProfileProfileStructureProperty extends vimService.vim.DynamicData {
            propertyName: string;
            array: boolean;
            element: vimService.vim.ProfileProfileStructure;
         }
         interface ArrayOfProfileProfileStructureProperty {
            profileProfileStructureProperty?: Array<vimService.vim.ProfileProfileStructureProperty>;
         }
         interface ClusterProfileConfigInfo extends vimService.vim.ProfileConfigInfo {
            complyProfile?: vimService.vim.ComplianceProfile;
         }
         interface ClusterProfileCreateSpec extends vimService.vim.ProfileCreateSpec {
         }
         interface ClusterProfileConfigSpec extends vimService.vim.ClusterProfileCreateSpec {
         }
         interface ClusterProfileCompleteConfigSpec extends vimService.vim.ClusterProfileConfigSpec {
            complyProfile?: vimService.vim.ComplianceProfile;
         }
         enum ClusterProfileServiceType {
            "DRS",
            "HA",
            "DPM",
            "FT",
         }
         interface ClusterProfileConfigServiceCreateSpec extends vimService.vim.ClusterProfileConfigSpec {
            serviceType?: Array<string>;
         }
         interface AnswerFile extends vimService.vim.DynamicData {
            userInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
            createdTime: Date;
            modifiedTime: Date;
         }
         interface AnswerFileStatusError extends vimService.vim.DynamicData {
            userInputPath: vimService.vim.ProfilePropertyPath;
            errMsg: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfAnswerFileStatusError {
            answerFileStatusError?: Array<vimService.vim.AnswerFileStatusError>;
         }
         interface AnswerFileStatusResult extends vimService.vim.DynamicData {
            checkedTime: Date;
            host: vimService.vim.ManagedObjectReference;
            status: string;
            error?: Array<vimService.vim.AnswerFileStatusError>;
         }
         interface ArrayOfAnswerFileStatusResult {
            answerFileStatusResult?: Array<vimService.vim.AnswerFileStatusResult>;
         }
         enum ProfileExecuteResultStatus {
            "success",
            "needInput",
            "error",
         }
         interface ProfileExecuteError extends vimService.vim.DynamicData {
            path?: vimService.vim.ProfilePropertyPath;
            message: vimService.vim.LocalizableMessage;
         }
         interface ArrayOfProfileExecuteError {
            profileExecuteError?: Array<vimService.vim.ProfileExecuteError>;
         }
         interface ProfileExecuteResult extends vimService.vim.DynamicData {
            status: string;
            configSpec?: vimService.vim.HostConfigSpec;
            inapplicablePath?: Array<string>;
            requireInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
            error?: Array<vimService.vim.ProfileExecuteError>;
         }
         interface HostApplyProfile extends vimService.vim.ApplyProfile {
            memory?: vimService.vim.HostMemoryProfile;
            storage?: vimService.vim.StorageProfile;
            network?: vimService.vim.NetworkProfile;
            datetime?: vimService.vim.DateTimeProfile;
            firewall?: vimService.vim.FirewallProfile;
            security?: vimService.vim.SecurityProfile;
            service?: Array<vimService.vim.ServiceProfile>;
            option?: Array<vimService.vim.OptionProfile>;
            userAccount?: Array<vimService.vim.UserProfile>;
            usergroupAccount?: Array<vimService.vim.UserGroupProfile>;
            authentication?: vimService.vim.AuthenticationProfile;
         }
         interface PhysicalNicProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPhysicalNicProfile {
            physicalNicProfile?: Array<vimService.vim.PhysicalNicProfile>;
         }
         interface HostMemoryProfile extends vimService.vim.ApplyProfile {
         }
         interface UserProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserProfile {
            userProfile?: Array<vimService.vim.UserProfile>;
         }
         interface UserGroupProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfUserGroupProfile {
            userGroupProfile?: Array<vimService.vim.UserGroupProfile>;
         }
         interface SecurityProfile extends vimService.vim.ApplyProfile {
            permission?: Array<vimService.vim.PermissionProfile>;
         }
         interface OptionProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfOptionProfile {
            optionProfile?: Array<vimService.vim.OptionProfile>;
         }
         interface DateTimeProfile extends vimService.vim.ApplyProfile {
         }
         interface ServiceProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfServiceProfile {
            serviceProfile?: Array<vimService.vim.ServiceProfile>;
         }
         interface FirewallProfileRulesetProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfFirewallProfileRulesetProfile {
            firewallProfileRulesetProfile?: Array<vimService.vim.FirewallProfileRulesetProfile>;
         }
         interface FirewallProfile extends vimService.vim.ApplyProfile {
            ruleset?: Array<vimService.vim.FirewallProfileRulesetProfile>;
         }
         interface NasStorageProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfNasStorageProfile {
            nasStorageProfile?: Array<vimService.vim.NasStorageProfile>;
         }
         interface StorageProfile extends vimService.vim.ApplyProfile {
            nasStorage?: Array<vimService.vim.NasStorageProfile>;
         }
         interface NetworkProfileDnsConfigProfile extends vimService.vim.ApplyProfile {
         }
         interface NetworkProfile extends vimService.vim.ApplyProfile {
            vswitch?: Array<vimService.vim.VirtualSwitchProfile>;
            vmPortGroup?: Array<vimService.vim.VmPortGroupProfile>;
            hostPortGroup?: Array<vimService.vim.HostPortGroupProfile>;
            serviceConsolePortGroup?: Array<vimService.vim.ServiceConsolePortGroupProfile>;
            dnsConfig?: vimService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig?: vimService.vim.IpRouteProfile;
            consoleIpRouteConfig?: vimService.vim.IpRouteProfile;
            pnic?: Array<vimService.vim.PhysicalNicProfile>;
            dvswitch?: Array<vimService.vim.DvsProfile>;
            dvsServiceConsoleNic?: Array<vimService.vim.DvsServiceConsoleVNicProfile>;
            dvsHostNic?: Array<vimService.vim.DvsHostVNicProfile>;
            netStackInstance?: Array<vimService.vim.NetStackInstanceProfile>;
         }
         interface DvsVNicProfile extends vimService.vim.ApplyProfile {
            key: string;
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface DvsServiceConsoleVNicProfile extends vimService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsServiceConsoleVNicProfile {
            dvsServiceConsoleVNicProfile?: Array<vimService.vim.DvsServiceConsoleVNicProfile>;
         }
         interface DvsHostVNicProfile extends vimService.vim.DvsVNicProfile {
         }
         interface ArrayOfDvsHostVNicProfile {
            dvsHostVNicProfile?: Array<vimService.vim.DvsHostVNicProfile>;
         }
         interface DvsProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            uplink?: Array<vimService.vim.PnicUplinkProfile>;
         }
         interface ArrayOfDvsProfile {
            dvsProfile?: Array<vimService.vim.DvsProfile>;
         }
         interface PnicUplinkProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPnicUplinkProfile {
            pnicUplinkProfile?: Array<vimService.vim.PnicUplinkProfile>;
         }
         interface IpRouteProfile extends vimService.vim.ApplyProfile {
            staticRoute?: Array<vimService.vim.StaticRouteProfile>;
         }
         interface StaticRouteProfile extends vimService.vim.ApplyProfile {
            key?: string;
         }
         interface ArrayOfStaticRouteProfile {
            staticRouteProfile?: Array<vimService.vim.StaticRouteProfile>;
         }
         interface LinkProfile extends vimService.vim.ApplyProfile {
         }
         interface NumPortsProfile extends vimService.vim.ApplyProfile {
         }
         interface VirtualSwitchProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            link: vimService.vim.LinkProfile;
            numPorts: vimService.vim.NumPortsProfile;
            networkPolicy: vimService.vim.NetworkPolicyProfile;
         }
         interface ArrayOfVirtualSwitchProfile {
            virtualSwitchProfile?: Array<vimService.vim.VirtualSwitchProfile>;
         }
         interface NetStackInstanceProfile extends vimService.vim.ApplyProfile {
            key: string;
            dnsConfig: vimService.vim.NetworkProfileDnsConfigProfile;
            ipRouteConfig: vimService.vim.IpRouteProfile;
         }
         interface ArrayOfNetStackInstanceProfile {
            netStackInstanceProfile?: Array<vimService.vim.NetStackInstanceProfile>;
         }
         interface VlanProfile extends vimService.vim.ApplyProfile {
         }
         interface VirtualSwitchSelectionProfile extends vimService.vim.ApplyProfile {
         }
         interface PortGroupProfile extends vimService.vim.ApplyProfile {
            key: string;
            name: string;
            vlan: vimService.vim.VlanProfile;
            vswitch: vimService.vim.VirtualSwitchSelectionProfile;
            networkPolicy: vimService.vim.NetworkPolicyProfile;
         }
         interface VmPortGroupProfile extends vimService.vim.PortGroupProfile {
         }
         interface ArrayOfVmPortGroupProfile {
            vmPortGroupProfile?: Array<vimService.vim.VmPortGroupProfile>;
         }
         interface HostPortGroupProfile extends vimService.vim.PortGroupProfile {
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface ArrayOfHostPortGroupProfile {
            hostPortGroupProfile?: Array<vimService.vim.HostPortGroupProfile>;
         }
         interface ServiceConsolePortGroupProfile extends vimService.vim.PortGroupProfile {
            ipConfig: vimService.vim.IpAddressProfile;
         }
         interface ArrayOfServiceConsolePortGroupProfile {
            serviceConsolePortGroupProfile?: Array<vimService.vim.ServiceConsolePortGroupProfile>;
         }
         interface NetworkPolicyProfile extends vimService.vim.ApplyProfile {
         }
         interface IpAddressProfile extends vimService.vim.ApplyProfile {
         }
         interface AuthenticationProfile extends vimService.vim.ApplyProfile {
            activeDirectory?: vimService.vim.ActiveDirectoryProfile;
         }
         interface ActiveDirectoryProfile extends vimService.vim.ApplyProfile {
         }
         interface PermissionProfile extends vimService.vim.ApplyProfile {
            key: string;
         }
         interface ArrayOfPermissionProfile {
            permissionProfile?: Array<vimService.vim.PermissionProfile>;
         }
         interface HostProfileConfigInfo extends vimService.vim.ProfileConfigInfo {
            applyProfile?: vimService.vim.HostApplyProfile;
            defaultComplyProfile?: vimService.vim.ComplianceProfile;
            defaultComplyLocator?: Array<vimService.vim.ComplianceLocator>;
            customComplyProfile?: vimService.vim.ComplianceProfile;
            disabledExpressionList?: Array<string>;
         }
         interface HostProfileConfigSpec extends vimService.vim.ProfileCreateSpec {
         }
         interface HostProfileSerializedHostProfileSpec extends vimService.vim.ProfileSerializedCreateSpec {
            validatorHost?: vimService.vim.ManagedObjectReference;
            validating?: boolean;
         }
         interface HostProfileCompleteConfigSpec extends vimService.vim.HostProfileConfigSpec {
            applyProfile?: vimService.vim.HostApplyProfile;
            customComplyProfile?: vimService.vim.ComplianceProfile;
            disabledExpressionListChanged: boolean;
            disabledExpressionList?: Array<string>;
            validatorHost?: vimService.vim.ManagedObjectReference;
            validating?: boolean;
         }
         interface HostProfileHostBasedConfigSpec extends vimService.vim.HostProfileConfigSpec {
            host: vimService.vim.ManagedObjectReference;
            useHostProfileEngine?: boolean;
         }
         enum HostProfileManagerTaskListRequirement {
            "maintenanceModeRequired",
            "rebootRequired",
         }
         interface HostProfileManagerConfigTaskList extends vimService.vim.DynamicData {
            configSpec?: vimService.vim.HostConfigSpec;
            taskDescription?: Array<vimService.vim.LocalizableMessage>;
            taskListRequirement?: Array<string>;
         }
         interface AnswerFileCreateSpec extends vimService.vim.DynamicData {
            validating?: boolean;
         }
         interface AnswerFileOptionsCreateSpec extends vimService.vim.AnswerFileCreateSpec {
            userInput?: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>;
         }
         interface AnswerFileSerializedCreateSpec extends vimService.vim.AnswerFileCreateSpec {
            answerFileConfigString: string;
         }
         enum HostProfileManagerAnswerFileStatus {
            "valid",
            "invalid",
            "unknown",
         }
         interface ScheduledTaskDetail extends vimService.vim.TypeDescription {
            frequency: string;
         }
         interface ArrayOfScheduledTaskDetail {
            scheduledTaskDetail?: Array<vimService.vim.ScheduledTaskDetail>;
         }
         interface ScheduledTaskDescription extends vimService.vim.DynamicData {
            action: Array<vimService.vim.TypeDescription>;
            schedulerInfo: Array<vimService.vim.ScheduledTaskDetail>;
            state: Array<vimService.vim.ElementDescription>;
            dayOfWeek: Array<vimService.vim.ElementDescription>;
            weekOfMonth: Array<vimService.vim.ElementDescription>;
         }
         interface ScheduledTaskInfo extends vimService.vim.ScheduledTaskSpec {
            scheduledTask: vimService.vim.ManagedObjectReference;
            entity: vimService.vim.ManagedObjectReference;
            lastModifiedTime: Date;
            lastModifiedUser: string;
            nextRunTime?: Date;
            prevRunTime?: Date;
            state: vimService.vim.TaskInfoState;
            error?: vimService.vim.LocalizedMethodFault;
            result?: any;
            progress?: number;
            activeTask?: vimService.vim.ManagedObjectReference;
            taskObject?: vimService.vim.ManagedObjectReference;
         }
         interface TaskScheduler extends vimService.vim.DynamicData {
            activeTime?: Date;
            expireTime?: Date;
         }
         interface AfterStartupTaskScheduler extends vimService.vim.TaskScheduler {
            minute: number;
         }
         interface OnceTaskScheduler extends vimService.vim.TaskScheduler {
            runAt?: Date;
         }
         interface RecurrentTaskScheduler extends vimService.vim.TaskScheduler {
            interval: number;
         }
         interface HourlyTaskScheduler extends vimService.vim.RecurrentTaskScheduler {
            minute: number;
         }
         interface DailyTaskScheduler extends vimService.vim.HourlyTaskScheduler {
            hour: number;
         }
         interface WeeklyTaskScheduler extends vimService.vim.DailyTaskScheduler {
            sunday: boolean;
            monday: boolean;
            tuesday: boolean;
            wednesday: boolean;
            thursday: boolean;
            friday: boolean;
            saturday: boolean;
         }
         interface MonthlyTaskScheduler extends vimService.vim.DailyTaskScheduler {
         }
         interface MonthlyByDayTaskScheduler extends vimService.vim.MonthlyTaskScheduler {
            day: number;
         }
         enum DayOfWeek {
            "sunday",
            "monday",
            "tuesday",
            "wednesday",
            "thursday",
            "friday",
            "saturday",
         }
         enum WeekOfMonth {
            "first",
            "second",
            "third",
            "fourth",
            "last",
         }
         interface MonthlyByWeekdayTaskScheduler extends vimService.vim.MonthlyTaskScheduler {
            offset: vimService.vim.WeekOfMonth;
            weekday: vimService.vim.DayOfWeek;
         }
         interface ScheduledTaskSpec extends vimService.vim.DynamicData {
            name: string;
            description: string;
            enabled: boolean;
            scheduler: vimService.vim.TaskScheduler;
            action: vimService.vim.Action;
            notification?: string;
         }
         interface ApplyStorageRecommendationResult extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
         }
         interface StorageDrsConfigInfo extends vimService.vim.DynamicData {
            podConfig: vimService.vim.StorageDrsPodConfigInfo;
            vmConfig?: Array<vimService.vim.StorageDrsVmConfigInfo>;
         }
         interface StorageDrsConfigSpec extends vimService.vim.DynamicData {
            podConfigSpec?: vimService.vim.StorageDrsPodConfigSpec;
            vmConfigSpec?: Array<vimService.vim.StorageDrsVmConfigSpec>;
         }
         interface StorageDrsVmConfigSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.StorageDrsVmConfigInfo;
         }
         interface ArrayOfStorageDrsVmConfigSpec {
            storageDrsVmConfigSpec?: Array<vimService.vim.StorageDrsVmConfigSpec>;
         }
         interface HbrDiskMigrationAction extends vimService.vim.ClusterAction {
            collectionId: string;
            collectionName: string;
            diskIds: Array<string>;
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
            sizeTransferred: number;
            spaceUtilSrcBefore?: number;
            spaceUtilDstBefore?: number;
            spaceUtilSrcAfter?: number;
            spaceUtilDstAfter?: number;
            ioLatencySrcBefore?: number;
            ioLatencyDstBefore?: number;
         }
         enum PlacementAffinityRuleRuleType {
            "affinity",
            "antiAffinity",
            "softAffinity",
            "softAntiAffinity",
         }
         enum PlacementAffinityRuleRuleScope {
            "cluster",
            "host",
            "storagePod",
            "datastore",
         }
         interface PlacementAffinityRule extends vimService.vim.DynamicData {
            ruleType: string;
            ruleScope: string;
            vms?: Array<vimService.vim.ManagedObjectReference>;
            keys?: Array<string>;
         }
         interface ArrayOfPlacementAffinityRule {
            placementAffinityRule?: Array<vimService.vim.PlacementAffinityRule>;
         }
         interface PlacementRankResult extends vimService.vim.DynamicData {
            key: string;
            candidate: vimService.vim.ManagedObjectReference;
            reservedSpaceMB: number;
            usedSpaceMB: number;
            totalSpaceMB: number;
            utilization: number;
            faults?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface PlacementRankSpec extends vimService.vim.DynamicData {
            specs: Array<vimService.vim.PlacementSpec>;
            clusters: Array<vimService.vim.ManagedObjectReference>;
            rules?: Array<vimService.vim.PlacementAffinityRule>;
            placementRankByVm?: Array<vimService.vim.StorageDrsPlacementRankVmSpec>;
         }
         interface StorageDrsPlacementRankVmSpec extends vimService.vim.DynamicData {
            vmPlacementSpec: vimService.vim.PlacementSpec;
            vmClusters: Array<vimService.vim.ManagedObjectReference>;
         }
         interface ArrayOfStorageDrsPlacementRankVmSpec {
            storageDrsPlacementRankVmSpec?: Array<vimService.vim.StorageDrsPlacementRankVmSpec>;
         }
         enum StorageDrsPodConfigInfoBehavior {
            "manual",
            "automated",
         }
         interface StorageDrsPodConfigInfo extends vimService.vim.DynamicData {
            enabled: boolean;
            ioLoadBalanceEnabled: boolean;
            defaultVmBehavior: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: vimService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: vimService.vim.StorageDrsIoLoadBalanceConfig;
            automationOverrides?: vimService.vim.StorageDrsAutomationConfig;
            rule?: Array<vimService.vim.ClusterRuleInfo>;
            option?: Array<vimService.vim.OptionValue>;
         }
         enum StorageDrsSpaceLoadBalanceConfigSpaceThresholdMode {
            "utilization",
            "freeSpace",
         }
         interface StorageDrsSpaceLoadBalanceConfig extends vimService.vim.DynamicData {
            spaceThresholdMode?: string;
            spaceUtilizationThreshold?: number;
            freeSpaceThresholdGB?: number;
            minSpaceUtilizationDifference?: number;
         }
         interface StorageDrsIoLoadBalanceConfig extends vimService.vim.DynamicData {
            reservablePercentThreshold?: number;
            reservableIopsThreshold?: number;
            reservableThresholdMode?: string;
            ioLatencyThreshold?: number;
            ioLoadImbalanceThreshold?: number;
         }
         interface StorageDrsAutomationConfig extends vimService.vim.DynamicData {
            spaceLoadBalanceAutomationMode?: string;
            ioLoadBalanceAutomationMode?: string;
            ruleEnforcementAutomationMode?: string;
            policyEnforcementAutomationMode?: string;
            vmEvacuationAutomationMode?: string;
         }
         interface StorageDrsPodConfigSpec extends vimService.vim.DynamicData {
            enabled?: boolean;
            ioLoadBalanceEnabled?: boolean;
            defaultVmBehavior?: string;
            loadBalanceInterval?: number;
            defaultIntraVmAffinity?: boolean;
            spaceLoadBalanceConfig?: vimService.vim.StorageDrsSpaceLoadBalanceConfig;
            ioLoadBalanceConfig?: vimService.vim.StorageDrsIoLoadBalanceConfig;
            automationOverrides?: vimService.vim.StorageDrsAutomationConfig;
            rule?: Array<vimService.vim.ClusterRuleSpec>;
            option?: Array<vimService.vim.StorageDrsOptionSpec>;
         }
         interface StorageDrsOptionSpec extends vimService.vim.ArrayUpdateSpec {
            option?: vimService.vim.OptionValue;
         }
         interface ArrayOfStorageDrsOptionSpec {
            storageDrsOptionSpec?: Array<vimService.vim.StorageDrsOptionSpec>;
         }
         interface VmPodConfigForPlacement extends vimService.vim.DynamicData {
            storagePod: vimService.vim.ManagedObjectReference;
            disk?: Array<vimService.vim.PodDiskLocator>;
            vmConfig?: vimService.vim.StorageDrsVmConfigInfo;
            interVmRule?: Array<vimService.vim.ClusterRuleInfo>;
         }
         interface ArrayOfVmPodConfigForPlacement {
            vmPodConfigForPlacement?: Array<vimService.vim.VmPodConfigForPlacement>;
         }
         interface PodDiskLocator extends vimService.vim.DynamicData {
            diskId: number;
            diskMoveType?: string;
            diskBackingInfo?: vimService.vim.VirtualDeviceBackingInfo;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfPodDiskLocator {
            podDiskLocator?: Array<vimService.vim.PodDiskLocator>;
         }
         interface StorageDrsPodSelectionSpec extends vimService.vim.DynamicData {
            initialVmConfig?: Array<vimService.vim.VmPodConfigForPlacement>;
            storagePod?: vimService.vim.ManagedObjectReference;
         }
         interface StorageMigrationAction extends vimService.vim.ClusterAction {
            vm: vimService.vim.ManagedObjectReference;
            relocateSpec: vimService.vim.VirtualMachineRelocateSpec;
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
            sizeTransferred: number;
            spaceUtilSrcBefore?: number;
            spaceUtilDstBefore?: number;
            spaceUtilSrcAfter?: number;
            spaceUtilDstAfter?: number;
            ioLatencySrcBefore?: number;
            ioLatencyDstBefore?: number;
         }
         interface StoragePlacementAction extends vimService.vim.ClusterAction {
            vm?: vimService.vim.ManagedObjectReference;
            relocateSpec: vimService.vim.VirtualMachineRelocateSpec;
            destination: vimService.vim.ManagedObjectReference;
            spaceUtilBefore?: number;
            spaceDemandBefore?: number;
            spaceUtilAfter?: number;
            spaceDemandAfter?: number;
            ioLatencyBefore?: number;
         }
         interface StoragePlacementResult extends vimService.vim.DynamicData {
            recommendations?: Array<vimService.vim.ClusterRecommendation>;
            drsFault?: vimService.vim.ClusterDrsFaults;
            task?: vimService.vim.ManagedObjectReference;
         }
         enum StoragePlacementSpecPlacementType {
            "create",
            "reconfigure",
            "relocate",
            "clone",
         }
         interface StoragePlacementSpec extends vimService.vim.DynamicData {
            type: string;
            priority?: vimService.vim.VirtualMachineMovePriority;
            vm?: vimService.vim.ManagedObjectReference;
            podSelectionSpec: vimService.vim.StorageDrsPodSelectionSpec;
            cloneSpec?: vimService.vim.VirtualMachineCloneSpec;
            cloneName?: string;
            configSpec?: vimService.vim.VirtualMachineConfigSpec;
            relocateSpec?: vimService.vim.VirtualMachineRelocateSpec;
            resourcePool?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            folder?: vimService.vim.ManagedObjectReference;
            disallowPrerequisiteMoves?: boolean;
            resourceLeaseDurationSec?: number;
         }
         interface VirtualDiskAntiAffinityRuleSpec extends vimService.vim.ClusterRuleInfo {
            diskId: Array<number>;
         }
         interface StorageDrsVmConfigInfo extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            enabled?: boolean;
            behavior?: string;
            intraVmAffinity?: boolean;
            intraVmAntiAffinity?: vimService.vim.VirtualDiskAntiAffinityRuleSpec;
         }
         interface ArrayOfStorageDrsVmConfigInfo {
            storageDrsVmConfigInfo?: Array<vimService.vim.StorageDrsVmConfigInfo>;
         }
         interface VAppCloneSpecNetworkMappingPair extends vimService.vim.DynamicData {
            source: vimService.vim.ManagedObjectReference;
            destination: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecNetworkMappingPair {
            vAppCloneSpecNetworkMappingPair?: Array<vimService.vim.VAppCloneSpecNetworkMappingPair>;
         }
         interface VAppCloneSpecResourceMap extends vimService.vim.DynamicData {
            source: vimService.vim.ManagedObjectReference;
            parent?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            location?: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfVAppCloneSpecResourceMap {
            vAppCloneSpecResourceMap?: Array<vimService.vim.VAppCloneSpecResourceMap>;
         }
         enum VAppCloneSpecProvisioningType {
            "sameAsSource",
            "thin",
            "thick",
         }
         interface VAppCloneSpec extends vimService.vim.DynamicData {
            location: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            resourceSpec?: vimService.vim.ResourceConfigSpec;
            vmFolder?: vimService.vim.ManagedObjectReference;
            networkMapping?: Array<vimService.vim.VAppCloneSpecNetworkMappingPair>;
            property?: Array<vimService.vim.KeyValue>;
            resourceMapping?: Array<vimService.vim.VAppCloneSpecResourceMap>;
            provisioning?: string;
         }
         enum VAppAutoStartAction {
            "none",
            "powerOn",
            "powerOff",
            "guestShutdown",
            "suspend",
         }
         interface VAppEntityConfigInfo extends vimService.vim.DynamicData {
            key?: vimService.vim.ManagedObjectReference;
            tag?: string;
            startOrder?: number;
            startDelay?: number;
            waitingForGuest?: boolean;
            startAction?: string;
            stopDelay?: number;
            stopAction?: string;
            destroyWithParent?: boolean;
         }
         interface ArrayOfVAppEntityConfigInfo {
            vAppEntityConfigInfo?: Array<vimService.vim.VAppEntityConfigInfo>;
         }
         enum VAppIPAssignmentInfoIpAllocationPolicy {
            "dhcpPolicy",
            "transientPolicy",
            "fixedPolicy",
            "fixedAllocatedPolicy",
         }
         enum VAppIPAssignmentInfoAllocationSchemes {
            "dhcp",
            "ovfenv",
         }
         enum VAppIPAssignmentInfoProtocols {
            "IPv4",
            "IPv6",
         }
         interface VAppIPAssignmentInfo extends vimService.vim.DynamicData {
            supportedAllocationScheme?: Array<string>;
            ipAllocationPolicy?: string;
            supportedIpProtocol?: Array<string>;
            ipProtocol?: string;
         }
         interface IpPoolIpPoolConfigInfo extends vimService.vim.DynamicData {
            subnetAddress?: string;
            netmask?: string;
            gateway?: string;
            range?: string;
            dns?: Array<string>;
            dhcpServerAvailable?: boolean;
            ipPoolEnabled?: boolean;
         }
         interface IpPoolAssociation extends vimService.vim.DynamicData {
            network?: vimService.vim.ManagedObjectReference;
            networkName: string;
         }
         interface ArrayOfIpPoolAssociation {
            ipPoolAssociation?: Array<vimService.vim.IpPoolAssociation>;
         }
         interface IpPool extends vimService.vim.DynamicData {
            id?: number;
            name?: string;
            ipv4Config?: vimService.vim.IpPoolIpPoolConfigInfo;
            ipv6Config?: vimService.vim.IpPoolIpPoolConfigInfo;
            dnsDomain?: string;
            dnsSearchPath?: string;
            hostPrefix?: string;
            httpProxy?: string;
            networkAssociation?: Array<vimService.vim.IpPoolAssociation>;
            availableIpv4Addresses?: number;
            availableIpv6Addresses?: number;
            allocatedIpv4Addresses?: number;
            allocatedIpv6Addresses?: number;
         }
         interface ArrayOfIpPool {
            ipPool?: Array<vimService.vim.IpPool>;
         }
         interface VAppOvfSectionInfo extends vimService.vim.DynamicData {
            key?: number;
            namespace?: string;
            type?: string;
            atEnvelopeLevel?: boolean;
            contents?: string;
         }
         interface ArrayOfVAppOvfSectionInfo {
            vAppOvfSectionInfo?: Array<vimService.vim.VAppOvfSectionInfo>;
         }
         interface VAppProductInfo extends vimService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            name?: string;
            vendor?: string;
            version?: string;
            fullVersion?: string;
            vendorUrl?: string;
            productUrl?: string;
            appUrl?: string;
         }
         interface ArrayOfVAppProductInfo {
            vAppProductInfo?: Array<vimService.vim.VAppProductInfo>;
         }
         interface VAppPropertyInfo extends vimService.vim.DynamicData {
            key: number;
            classId?: string;
            instanceId?: string;
            id?: string;
            category?: string;
            label?: string;
            type?: string;
            typeReference?: string;
            userConfigurable?: boolean;
            defaultValue?: string;
            value?: string;
            description?: string;
         }
         interface ArrayOfVAppPropertyInfo {
            vAppPropertyInfo?: Array<vimService.vim.VAppPropertyInfo>;
         }
         interface VAppConfigInfo extends vimService.vim.VmConfigInfo {
            entityConfig?: Array<vimService.vim.VAppEntityConfigInfo>;
            annotation: string;
            instanceUuid?: string;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VAppConfigSpec extends vimService.vim.VmConfigSpec {
            entityConfig?: Array<vimService.vim.VAppEntityConfigInfo>;
            annotation?: string;
            instanceUuid?: string;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VirtualAppImportSpec extends vimService.vim.ImportSpec {
            name: string;
            vAppConfigSpec: vimService.vim.VAppConfigSpec;
            resourcePoolSpec: vimService.vim.ResourceConfigSpec;
            child?: Array<vimService.vim.ImportSpec>;
         }
         interface VmConfigInfo extends vimService.vim.DynamicData {
            product?: Array<vimService.vim.VAppProductInfo>;
            property?: Array<vimService.vim.VAppPropertyInfo>;
            ipAssignment: vimService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<vimService.vim.VAppOvfSectionInfo>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired: boolean;
            installBootStopDelay: number;
         }
         interface VmConfigSpec extends vimService.vim.DynamicData {
            product?: Array<vimService.vim.VAppProductSpec>;
            property?: Array<vimService.vim.VAppPropertySpec>;
            ipAssignment?: vimService.vim.VAppIPAssignmentInfo;
            eula?: Array<string>;
            ovfSection?: Array<vimService.vim.VAppOvfSectionSpec>;
            ovfEnvironmentTransport?: Array<string>;
            installBootRequired?: boolean;
            installBootStopDelay?: number;
         }
         interface VAppProductSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppProductInfo;
         }
         interface ArrayOfVAppProductSpec {
            vAppProductSpec?: Array<vimService.vim.VAppProductSpec>;
         }
         interface VAppPropertySpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppPropertyInfo;
         }
         interface ArrayOfVAppPropertySpec {
            vAppPropertySpec?: Array<vimService.vim.VAppPropertySpec>;
         }
         interface VAppOvfSectionSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.VAppOvfSectionInfo;
         }
         interface ArrayOfVAppOvfSectionSpec {
            vAppOvfSectionSpec?: Array<vimService.vim.VAppOvfSectionSpec>;
         }
         interface VirtualMachineAffinityInfo extends vimService.vim.DynamicData {
            affinitySet?: Array<number>;
         }
         enum VirtualMachineBootOptionsNetworkBootProtocolType {
            "ipv4",
            "ipv6",
         }
         interface VirtualMachineBootOptionsBootableDevice extends vimService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineBootOptionsBootableDevice {
            virtualMachineBootOptionsBootableDevice?: Array<vimService.vim.VirtualMachineBootOptionsBootableDevice>;
         }
         interface VirtualMachineBootOptionsBootableDiskDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableEthernetDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
            deviceKey: number;
         }
         interface VirtualMachineBootOptionsBootableFloppyDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptionsBootableCdromDevice extends vimService.vim.VirtualMachineBootOptionsBootableDevice {
         }
         interface VirtualMachineBootOptions extends vimService.vim.DynamicData {
            bootDelay?: number;
            enterBIOSSetup?: boolean;
            bootRetryEnabled?: boolean;
            bootRetryDelay?: number;
            bootOrder?: Array<vimService.vim.VirtualMachineBootOptionsBootableDevice>;
            networkBootProtocol?: string;
         }
         interface VirtualMachineCapability extends vimService.vim.DynamicData {
            snapshotOperationsSupported: boolean;
            multipleSnapshotsSupported: boolean;
            snapshotConfigSupported: boolean;
            poweredOffSnapshotsSupported: boolean;
            memorySnapshotsSupported: boolean;
            revertToSnapshotSupported: boolean;
            quiescedSnapshotsSupported: boolean;
            disableSnapshotsSupported: boolean;
            lockSnapshotsSupported: boolean;
            consolePreferencesSupported: boolean;
            cpuFeatureMaskSupported: boolean;
            s1AcpiManagementSupported: boolean;
            settingScreenResolutionSupported: boolean;
            toolsAutoUpdateSupported: boolean;
            vmNpivWwnSupported: boolean;
            npivWwnOnNonRdmVmSupported: boolean;
            vmNpivWwnDisableSupported?: boolean;
            vmNpivWwnUpdateSupported?: boolean;
            swapPlacementSupported: boolean;
            toolsSyncTimeSupported: boolean;
            virtualMmuUsageSupported: boolean;
            diskSharesSupported: boolean;
            bootOptionsSupported: boolean;
            bootRetryOptionsSupported?: boolean;
            settingVideoRamSizeSupported: boolean;
            settingDisplayTopologySupported?: boolean;
            recordReplaySupported?: boolean;
            changeTrackingSupported?: boolean;
            multipleCoresPerSocketSupported?: boolean;
            hostBasedReplicationSupported?: boolean;
            guestAutoLockSupported?: boolean;
            memoryReservationLockSupported?: boolean;
            featureRequirementSupported?: boolean;
            poweredOnMonitorTypeChangeSupported?: boolean;
            seSparseDiskSupported?: boolean;
            nestedHVSupported?: boolean;
            vPMCSupported?: boolean;
         }
         interface VirtualMachineCdromInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineCdromInfo {
            virtualMachineCdromInfo?: Array<vimService.vim.VirtualMachineCdromInfo>;
         }
         interface VirtualMachineCloneSpec extends vimService.vim.DynamicData {
            location: vimService.vim.VirtualMachineRelocateSpec;
            template: boolean;
            config?: vimService.vim.VirtualMachineConfigSpec;
            customization?: vimService.vim.CustomizationSpec;
            powerOn: boolean;
            snapshot?: vimService.vim.ManagedObjectReference;
            memory?: boolean;
         }
         enum VirtualMachineConfigInfoNpivWwnType {
            "vc",
            "host",
            "external",
         }
         enum VirtualMachineConfigInfoSwapPlacementType {
            "inherit",
            "vmDirectory",
            "hostLocal",
         }
         interface VirtualMachineConfigInfoDatastoreUrlPair extends vimService.vim.DynamicData {
            name: string;
            url: string;
         }
         interface ArrayOfVirtualMachineConfigInfoDatastoreUrlPair {
            virtualMachineConfigInfoDatastoreUrlPair?: Array<vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
         }
         interface VirtualMachineConfigInfoOverheadInfo extends vimService.vim.DynamicData {
            initialMemoryReservation?: number;
            initialSwapReservation?: number;
         }
         interface VirtualMachineConfigInfo extends vimService.vim.DynamicData {
            changeVersion: string;
            modified: Date;
            name: string;
            guestFullName: string;
            version: string;
            uuid: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            locationId?: string;
            template: boolean;
            guestId: string;
            alternateGuestName: string;
            annotation?: string;
            files: vimService.vim.VirtualMachineFileInfo;
            tools?: vimService.vim.ToolsConfigInfo;
            flags: vimService.vim.VirtualMachineFlagInfo;
            consolePreferences?: vimService.vim.VirtualMachineConsolePreferences;
            defaultPowerOps: vimService.vim.VirtualMachineDefaultPowerOpInfo;
            hardware: vimService.vim.VirtualHardware;
            cpuAllocation?: vimService.vim.ResourceAllocationInfo;
            memoryAllocation?: vimService.vim.ResourceAllocationInfo;
            latencySensitivity?: vimService.vim.LatencySensitivity;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            hotPlugMemoryLimit?: number;
            hotPlugMemoryIncrementSize?: number;
            cpuAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            networkShaper?: vimService.vim.VirtualMachineNetworkShaperInfo;
            extraConfig?: Array<vimService.vim.OptionValue>;
            cpuFeatureMask?: Array<vimService.vim.HostCpuIdInfo>;
            datastoreUrl?: Array<vimService.vim.VirtualMachineConfigInfoDatastoreUrlPair>;
            swapPlacement?: string;
            bootOptions?: vimService.vim.VirtualMachineBootOptions;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            repConfig?: vimService.vim.ReplicationConfigSpec;
            vAppConfig?: vimService.vim.VmConfigInfo;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: vimService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            initialOverhead?: vimService.vim.VirtualMachineConfigInfoOverheadInfo;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: vimService.vim.ScheduledHardwareUpgradeInfo;
            forkConfigInfo?: vimService.vim.VirtualMachineForkConfigInfo;
            vFlashCacheReservation?: number;
            vmxConfigChecksum?: string;
            messageBusTunnelEnabled?: boolean;
            vmStorageObjectId?: string;
            swapStorageObjectId?: string;
         }
         interface VirtualMachineConfigOption extends vimService.vim.DynamicData {
            version: string;
            description: string;
            guestOSDescriptor: Array<vimService.vim.GuestOsDescriptor>;
            guestOSDefaultIndex: number;
            hardwareOptions: vimService.vim.VirtualHardwareOption;
            capabilities: vimService.vim.VirtualMachineCapability;
            datastore: vimService.vim.DatastoreOption;
            defaultDevice?: Array<vimService.vim.VirtualDevice>;
            supportedMonitorType: Array<string>;
            supportedOvfEnvironmentTransport?: Array<string>;
            supportedOvfInstallTransport?: Array<string>;
         }
         interface VirtualMachineConfigOptionDescriptor extends vimService.vim.DynamicData {
            key: string;
            description?: string;
            host?: Array<vimService.vim.ManagedObjectReference>;
            createSupported?: boolean;
            defaultConfigOption?: boolean;
            runSupported?: boolean;
            upgradeSupported?: boolean;
         }
         interface ArrayOfVirtualMachineConfigOptionDescriptor {
            virtualMachineConfigOptionDescriptor?: Array<vimService.vim.VirtualMachineConfigOptionDescriptor>;
         }
         enum VirtualMachineConfigSpecNpivWwnOp {
            "generate",
            "set",
            "remove",
            "extend",
         }
         interface VirtualMachineCpuIdInfoSpec extends vimService.vim.ArrayUpdateSpec {
            info?: vimService.vim.HostCpuIdInfo;
         }
         interface ArrayOfVirtualMachineCpuIdInfoSpec {
            virtualMachineCpuIdInfoSpec?: Array<vimService.vim.VirtualMachineCpuIdInfoSpec>;
         }
         interface VirtualMachineConfigSpec extends vimService.vim.DynamicData {
            changeVersion?: string;
            name?: string;
            version?: string;
            uuid?: string;
            instanceUuid?: string;
            npivNodeWorldWideName?: Array<number>;
            npivPortWorldWideName?: Array<number>;
            npivWorldWideNameType?: string;
            npivDesiredNodeWwns?: number;
            npivDesiredPortWwns?: number;
            npivTemporaryDisabled?: boolean;
            npivOnNonRdmDisks?: boolean;
            npivWorldWideNameOp?: string;
            locationId?: string;
            guestId?: string;
            alternateGuestName?: string;
            annotation?: string;
            files?: vimService.vim.VirtualMachineFileInfo;
            tools?: vimService.vim.ToolsConfigInfo;
            flags?: vimService.vim.VirtualMachineFlagInfo;
            consolePreferences?: vimService.vim.VirtualMachineConsolePreferences;
            powerOpInfo?: vimService.vim.VirtualMachineDefaultPowerOpInfo;
            numCPUs?: number;
            numCoresPerSocket?: number;
            memoryMB?: number;
            memoryHotAddEnabled?: boolean;
            cpuHotAddEnabled?: boolean;
            cpuHotRemoveEnabled?: boolean;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            deviceChange?: Array<vimService.vim.VirtualDeviceConfigSpec>;
            cpuAllocation?: vimService.vim.ResourceAllocationInfo;
            memoryAllocation?: vimService.vim.ResourceAllocationInfo;
            latencySensitivity?: vimService.vim.LatencySensitivity;
            cpuAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            memoryAffinity?: vimService.vim.VirtualMachineAffinityInfo;
            networkShaper?: vimService.vim.VirtualMachineNetworkShaperInfo;
            cpuFeatureMask?: Array<vimService.vim.VirtualMachineCpuIdInfoSpec>;
            extraConfig?: Array<vimService.vim.OptionValue>;
            swapPlacement?: string;
            bootOptions?: vimService.vim.VirtualMachineBootOptions;
            vAppConfig?: vimService.vim.VmConfigSpec;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            repConfig?: vimService.vim.ReplicationConfigSpec;
            vAppConfigRemoved?: boolean;
            vAssertsEnabled?: boolean;
            changeTrackingEnabled?: boolean;
            firmware?: string;
            maxMksConnections?: number;
            guestAutoLockEnabled?: boolean;
            managedBy?: vimService.vim.ManagedByInfo;
            memoryReservationLockedToMax?: boolean;
            nestedHVEnabled?: boolean;
            vPMCEnabled?: boolean;
            scheduledHardwareUpgradeInfo?: vimService.vim.ScheduledHardwareUpgradeInfo;
            vmProfile?: Array<vimService.vim.VirtualMachineProfileSpec>;
            messageBusTunnelEnabled?: boolean;
         }
         interface ConfigTarget extends vimService.vim.DynamicData {
            numCpus: number;
            numCpuCores: number;
            numNumaNodes: number;
            smcPresent?: boolean;
            datastore?: Array<vimService.vim.VirtualMachineDatastoreInfo>;
            network?: Array<vimService.vim.VirtualMachineNetworkInfo>;
            opaqueNetwork?: Array<vimService.vim.OpaqueNetworkTargetInfo>;
            distributedVirtualPortgroup?: Array<vimService.vim.DistributedVirtualPortgroupInfo>;
            distributedVirtualSwitch?: Array<vimService.vim.DistributedVirtualSwitchInfo>;
            cdRom?: Array<vimService.vim.VirtualMachineCdromInfo>;
            serial?: Array<vimService.vim.VirtualMachineSerialInfo>;
            parallel?: Array<vimService.vim.VirtualMachineParallelInfo>;
            sound?: Array<vimService.vim.VirtualMachineSoundInfo>;
            usb?: Array<vimService.vim.VirtualMachineUsbInfo>;
            floppy?: Array<vimService.vim.VirtualMachineFloppyInfo>;
            legacyNetworkInfo?: Array<vimService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
            scsiPassthrough?: Array<vimService.vim.VirtualMachineScsiPassthroughInfo>;
            scsiDisk?: Array<vimService.vim.VirtualMachineScsiDiskDeviceInfo>;
            ideDisk?: Array<vimService.vim.VirtualMachineIdeDiskDeviceInfo>;
            maxMemMBOptimalPerf: number;
            resourcePool?: vimService.vim.ResourcePoolRuntimeInfo;
            autoVmotion?: boolean;
            pciPassthrough?: Array<vimService.vim.VirtualMachinePciPassthroughInfo>;
            sriov?: Array<vimService.vim.VirtualMachineSriovInfo>;
            vFlashModule?: Array<vimService.vim.VirtualMachineVFlashModuleInfo>;
            sharedGpuPassthroughTypes?: Array<vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo>;
         }
         interface VirtualMachineConsolePreferences extends vimService.vim.DynamicData {
            powerOnWhenOpened?: boolean;
            enterFullScreenOnPowerOn?: boolean;
            closeOnPowerOffOrSuspend?: boolean;
         }
         interface VirtualMachineCreateChildSpec extends vimService.vim.DynamicData {
            location?: vimService.vim.VirtualMachineRelocateSpec;
            persistent: boolean;
            configParams?: Array<vimService.vim.OptionValue>;
         }
         interface VirtualMachineDatastoreInfo extends vimService.vim.VirtualMachineTargetInfo {
            datastore: vimService.vim.DatastoreSummary;
            capability: vimService.vim.DatastoreCapability;
            maxFileSize: number;
            maxVirtualDiskCapacity?: number;
            maxPhysicalRDMFileSize?: number;
            maxVirtualRDMFileSize?: number;
            mode: string;
            vStorageSupport?: string;
         }
         interface ArrayOfVirtualMachineDatastoreInfo {
            virtualMachineDatastoreInfo?: Array<vimService.vim.VirtualMachineDatastoreInfo>;
         }
         interface VirtualMachineDatastoreVolumeOption extends vimService.vim.DynamicData {
            fileSystemType: string;
            majorVersion?: number;
         }
         interface ArrayOfVirtualMachineDatastoreVolumeOption {
            virtualMachineDatastoreVolumeOption?: Array<vimService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         interface DatastoreOption extends vimService.vim.DynamicData {
            unsupportedVolumes?: Array<vimService.vim.VirtualMachineDatastoreVolumeOption>;
         }
         enum VirtualMachinePowerOpType {
            "soft",
            "hard",
            "preset",
         }
         enum VirtualMachineStandbyActionType {
            "checkpoint",
            "powerOnSuspend",
         }
         interface VirtualMachineDefaultPowerOpInfo extends vimService.vim.DynamicData {
            powerOffType?: string;
            suspendType?: string;
            resetType?: string;
            defaultPowerOffType?: string;
            defaultSuspendType?: string;
            defaultResetType?: string;
            standbyAction?: string;
         }
         interface VirtualMachineDefaultProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
         }
         interface VirtualMachineDefinedProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
            profileId: string;
            profileData?: vimService.vim.VirtualMachineProfileRawData;
         }
         interface VirtualMachineDeviceRuntimeInfoDeviceRuntimeState extends vimService.vim.DynamicData {
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonVm {
            "vmNptIncompatibleGuest",
            "vmNptIncompatibleGuestDriver",
            "vmNptIncompatibleAdapterType",
            "vmNptDisabledOrDisconnectedAdapter",
            "vmNptIncompatibleAdapterFeatures",
            "vmNptIncompatibleBackingType",
            "vmNptInsufficientMemoryReservation",
            "vmNptFaultToleranceOrRecordReplayConfigured",
            "vmNptConflictingIOChainConfigured",
            "vmNptMonitorBlocks",
            "vmNptConflictingOperationInProgress",
            "vmNptRuntimeError",
            "vmNptOutOfIntrVector",
            "vmNptVMCIActive",
         }
         enum VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther {
            "vmNptIncompatibleHost",
            "vmNptIncompatibleNetwork",
         }
         interface VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeState extends vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState {
            vmDirectPathGen2Active: boolean;
            vmDirectPathGen2InactiveReasonVm?: Array<string>;
            vmDirectPathGen2InactiveReasonOther?: Array<string>;
            vmDirectPathGen2InactiveReasonExtended?: string;
            reservationStatus?: string;
         }
         interface VirtualMachineDeviceRuntimeInfo extends vimService.vim.DynamicData {
            runtimeState: vimService.vim.VirtualMachineDeviceRuntimeInfoDeviceRuntimeState;
            key: number;
         }
         interface ArrayOfVirtualMachineDeviceRuntimeInfo {
            virtualMachineDeviceRuntimeInfo?: Array<vimService.vim.VirtualMachineDeviceRuntimeInfo>;
         }
         interface VirtualMachineDiskDeviceInfo extends vimService.vim.VirtualMachineTargetInfo {
            capacity?: number;
            vm?: Array<vimService.vim.ManagedObjectReference>;
         }
         interface VirtualMachineEmptyProfileSpec extends vimService.vim.VirtualMachineProfileSpec {
         }
         interface FaultToleranceConfigInfo extends vimService.vim.DynamicData {
            role: number;
            instanceUuids: Array<string>;
            configPaths: Array<string>;
            orphaned?: boolean;
         }
         interface FaultTolerancePrimaryConfigInfo extends vimService.vim.FaultToleranceConfigInfo {
            secondaries: Array<vimService.vim.ManagedObjectReference>;
         }
         interface FaultToleranceSecondaryConfigInfo extends vimService.vim.FaultToleranceConfigInfo {
            primaryVM: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceConfigSpec extends vimService.vim.DynamicData {
            metaDataPath?: vimService.vim.FaultToleranceMetaSpec;
            secondaryVmSpec?: vimService.vim.FaultToleranceVMConfigSpec;
         }
         interface FaultToleranceMetaSpec extends vimService.vim.DynamicData {
            metaDataDatastore: vimService.vim.ManagedObjectReference;
         }
         interface FaultToleranceSecondaryOpResult extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            powerOnAttempted: boolean;
            powerOnResult?: vimService.vim.ClusterPowerOnVmResult;
         }
         interface FaultToleranceDiskSpec extends vimService.vim.DynamicData {
            disk: vimService.vim.VirtualDevice;
            datastore: vimService.vim.ManagedObjectReference;
         }
         interface ArrayOfFaultToleranceDiskSpec {
            faultToleranceDiskSpec?: Array<vimService.vim.FaultToleranceDiskSpec>;
         }
         interface FaultToleranceVMConfigSpec extends vimService.vim.DynamicData {
            vmConfig?: vimService.vim.ManagedObjectReference;
            disks?: Array<vimService.vim.FaultToleranceDiskSpec>;
         }
         interface VirtualMachineFeatureRequirement extends vimService.vim.DynamicData {
            key: string;
            featureName: string;
            value: string;
         }
         interface ArrayOfVirtualMachineFeatureRequirement {
            virtualMachineFeatureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
         }
         interface VirtualMachineFileInfo extends vimService.vim.DynamicData {
            vmPathName?: string;
            snapshotDirectory?: string;
            suspendDirectory?: string;
            logDirectory?: string;
            ftMetadataDirectory?: string;
         }
         interface VirtualMachineFileLayoutDiskLayout extends vimService.vim.DynamicData {
            key: number;
            diskFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutDiskLayout {
            virtualMachineFileLayoutDiskLayout?: Array<vimService.vim.VirtualMachineFileLayoutDiskLayout>;
         }
         interface VirtualMachineFileLayoutSnapshotLayout extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            snapshotFile: Array<string>;
         }
         interface ArrayOfVirtualMachineFileLayoutSnapshotLayout {
            virtualMachineFileLayoutSnapshotLayout?: Array<vimService.vim.VirtualMachineFileLayoutSnapshotLayout>;
         }
         interface VirtualMachineFileLayout extends vimService.vim.DynamicData {
            configFile?: Array<string>;
            logFile?: Array<string>;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutDiskLayout>;
            snapshot?: Array<vimService.vim.VirtualMachineFileLayoutSnapshotLayout>;
            swapFile?: string;
         }
         enum VirtualMachineFileLayoutExFileType {
            "config",
            "extendedConfig",
            "diskDescriptor",
            "diskExtent",
            "digestDescriptor",
            "digestExtent",
            "diskReplicationState",
            "log",
            "stat",
            "namespaceData",
            "nvram",
            "snapshotData",
            "snapshotMemory",
            "snapshotList",
            "snapshotManifestList",
            "suspend",
            "suspendMemory",
            "swap",
            "uwswap",
            "core",
            "screenshot",
            "ftMetadata",
            "guestCustomization",
         }
         interface VirtualMachineFileLayoutExFileInfo extends vimService.vim.DynamicData {
            key: number;
            name: string;
            type: string;
            size: number;
            uniqueSize?: number;
            backingObjectId?: string;
            accessible?: boolean;
         }
         interface ArrayOfVirtualMachineFileLayoutExFileInfo {
            virtualMachineFileLayoutExFileInfo?: Array<vimService.vim.VirtualMachineFileLayoutExFileInfo>;
         }
         interface VirtualMachineFileLayoutExDiskUnit extends vimService.vim.DynamicData {
            fileKey: Array<number>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskUnit {
            virtualMachineFileLayoutExDiskUnit?: Array<vimService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface VirtualMachineFileLayoutExDiskLayout extends vimService.vim.DynamicData {
            key: number;
            chain?: Array<vimService.vim.VirtualMachineFileLayoutExDiskUnit>;
         }
         interface ArrayOfVirtualMachineFileLayoutExDiskLayout {
            virtualMachineFileLayoutExDiskLayout?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface VirtualMachineFileLayoutExSnapshotLayout extends vimService.vim.DynamicData {
            key: vimService.vim.ManagedObjectReference;
            dataKey: number;
            memoryKey?: number;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
         }
         interface ArrayOfVirtualMachineFileLayoutExSnapshotLayout {
            virtualMachineFileLayoutExSnapshotLayout?: Array<vimService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
         }
         interface VirtualMachineFileLayoutEx extends vimService.vim.DynamicData {
            file?: Array<vimService.vim.VirtualMachineFileLayoutExFileInfo>;
            disk?: Array<vimService.vim.VirtualMachineFileLayoutExDiskLayout>;
            snapshot?: Array<vimService.vim.VirtualMachineFileLayoutExSnapshotLayout>;
            timestamp: Date;
         }
         enum VirtualMachineHtSharing {
            "any",
            "none",
            "internal",
         }
         enum VirtualMachinePowerOffBehavior {
            "powerOff",
            "revert",
            "prompt",
            "take",
         }
         enum VirtualMachineFlagInfoMonitorType {
            "release",
            "debug",
            "stats",
         }
         enum VirtualMachineFlagInfoVirtualMmuUsage {
            "automatic",
            "on",
            "off",
         }
         enum VirtualMachineFlagInfoVirtualExecUsage {
            "hvAuto",
            "hvOn",
            "hvOff",
         }
         interface VirtualMachineFlagInfo extends vimService.vim.DynamicData {
            disableAcceleration?: boolean;
            enableLogging?: boolean;
            useToe?: boolean;
            runWithDebugInfo?: boolean;
            monitorType?: string;
            htSharing?: string;
            snapshotDisabled?: boolean;
            snapshotLocked?: boolean;
            diskUuidEnabled?: boolean;
            virtualMmuUsage?: string;
            virtualExecUsage?: string;
            snapshotPowerOffBehavior?: string;
            recordReplayEnabled?: boolean;
            faultToleranceType?: string;
         }
         interface VirtualMachineFloppyInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineFloppyInfo {
            virtualMachineFloppyInfo?: Array<vimService.vim.VirtualMachineFloppyInfo>;
         }
         enum VirtualMachineForkConfigInfoChildType {
            "none",
            "persistent",
            "nonpersistent",
         }
         interface VirtualMachineForkConfigInfo extends vimService.vim.DynamicData {
            parentEnabled?: boolean;
            childForkGroupId?: string;
            childType?: string;
         }
         enum VirtualMachineToolsStatus {
            "toolsNotInstalled",
            "toolsNotRunning",
            "toolsOld",
            "toolsOk",
         }
         enum VirtualMachineToolsVersionStatus {
            "guestToolsNotInstalled",
            "guestToolsNeedUpgrade",
            "guestToolsCurrent",
            "guestToolsUnmanaged",
            "guestToolsTooOld",
            "guestToolsSupportedOld",
            "guestToolsSupportedNew",
            "guestToolsTooNew",
            "guestToolsBlacklisted",
         }
         enum VirtualMachineToolsRunningStatus {
            "guestToolsNotRunning",
            "guestToolsRunning",
            "guestToolsExecutingScripts",
         }
         interface GuestDiskInfo extends vimService.vim.DynamicData {
            diskPath?: string;
            capacity?: number;
            freeSpace?: number;
         }
         interface ArrayOfGuestDiskInfo {
            guestDiskInfo?: Array<vimService.vim.GuestDiskInfo>;
         }
         interface GuestNicInfo extends vimService.vim.DynamicData {
            network?: string;
            ipAddress?: Array<string>;
            macAddress?: string;
            connected: boolean;
            deviceConfigId: number;
            dnsConfig?: vimService.vim.NetDnsConfigInfo;
            ipConfig?: vimService.vim.NetIpConfigInfo;
            netBIOSConfig?: vimService.vim.NetBIOSConfigInfo;
         }
         interface ArrayOfGuestNicInfo {
            guestNicInfo?: Array<vimService.vim.GuestNicInfo>;
         }
         interface GuestStackInfo extends vimService.vim.DynamicData {
            dnsConfig?: vimService.vim.NetDnsConfigInfo;
            ipRouteConfig?: vimService.vim.NetIpRouteConfigInfo;
            ipStackConfig?: Array<vimService.vim.KeyValue>;
            dhcpConfig?: vimService.vim.NetDhcpConfigInfo;
         }
         interface ArrayOfGuestStackInfo {
            guestStackInfo?: Array<vimService.vim.GuestStackInfo>;
         }
         interface GuestScreenInfo extends vimService.vim.DynamicData {
            width: number;
            height: number;
         }
         enum VirtualMachineGuestState {
            "running",
            "shuttingDown",
            "resetting",
            "standby",
            "notRunning",
            "unknown",
         }
         enum GuestInfoAppStateType {
            "none",
            "appStateOk",
            "appStateNeedReset",
         }
         interface GuestInfoNamespaceGenerationInfo extends vimService.vim.DynamicData {
            key: string;
            generationNo: number;
         }
         interface ArrayOfGuestInfoNamespaceGenerationInfo {
            guestInfoNamespaceGenerationInfo?: Array<vimService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         interface GuestInfo extends vimService.vim.DynamicData {
            toolsStatus?: vimService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            toolsVersion?: string;
            guestId?: string;
            guestFamily?: string;
            guestFullName?: string;
            hostName?: string;
            ipAddress?: string;
            net?: Array<vimService.vim.GuestNicInfo>;
            ipStack?: Array<vimService.vim.GuestStackInfo>;
            disk?: Array<vimService.vim.GuestDiskInfo>;
            screen?: vimService.vim.GuestScreenInfo;
            guestState: string;
            appHeartbeatStatus?: string;
            guestKernelCrashed?: boolean;
            appState?: string;
            guestOperationsReady?: boolean;
            interactiveGuestOperationsReady?: boolean;
            guestStateChangeSupported?: boolean;
            generationInfo?: Array<vimService.vim.GuestInfoNamespaceGenerationInfo>;
         }
         enum VirtualMachineGuestOsFamily {
            "windowsGuest",
            "linuxGuest",
            "netwareGuest",
            "solarisGuest",
            "darwinGuestFamily",
            "otherGuestFamily",
         }
         enum VirtualMachineGuestOsIdentifier {
            "dosGuest",
            "win31Guest",
            "win95Guest",
            "win98Guest",
            "winMeGuest",
            "winNTGuest",
            "win2000ProGuest",
            "win2000ServGuest",
            "win2000AdvServGuest",
            "winXPHomeGuest",
            "winXPProGuest",
            "winXPPro64Guest",
            "winNetWebGuest",
            "winNetStandardGuest",
            "winNetEnterpriseGuest",
            "winNetDatacenterGuest",
            "winNetBusinessGuest",
            "winNetStandard64Guest",
            "winNetEnterprise64Guest",
            "winLonghornGuest",
            "winLonghorn64Guest",
            "winNetDatacenter64Guest",
            "winVistaGuest",
            "winVista64Guest",
            "windows7Guest",
            "windows7_64Guest",
            "windows7Server64Guest",
            "windows8Guest",
            "windows8_64Guest",
            "windows8Server64Guest",
            "windows9Guest",
            "windows9_64Guest",
            "windows9Server64Guest",
            "windowsHyperVGuest",
            "freebsdGuest",
            "freebsd64Guest",
            "redhatGuest",
            "rhel2Guest",
            "rhel3Guest",
            "rhel3_64Guest",
            "rhel4Guest",
            "rhel4_64Guest",
            "rhel5Guest",
            "rhel5_64Guest",
            "rhel6Guest",
            "rhel6_64Guest",
            "rhel7Guest",
            "rhel7_64Guest",
            "centosGuest",
            "centos64Guest",
            "oracleLinuxGuest",
            "oracleLinux64Guest",
            "suseGuest",
            "suse64Guest",
            "slesGuest",
            "sles64Guest",
            "sles10Guest",
            "sles10_64Guest",
            "sles11Guest",
            "sles11_64Guest",
            "sles12Guest",
            "sles12_64Guest",
            "nld9Guest",
            "oesGuest",
            "sjdsGuest",
            "mandrakeGuest",
            "mandrivaGuest",
            "mandriva64Guest",
            "turboLinuxGuest",
            "turboLinux64Guest",
            "ubuntuGuest",
            "ubuntu64Guest",
            "debian4Guest",
            "debian4_64Guest",
            "debian5Guest",
            "debian5_64Guest",
            "debian6Guest",
            "debian6_64Guest",
            "debian7Guest",
            "debian7_64Guest",
            "debian8Guest",
            "debian8_64Guest",
            "asianux3Guest",
            "asianux3_64Guest",
            "asianux4Guest",
            "asianux4_64Guest",
            "asianux5_64Guest",
            "opensuseGuest",
            "opensuse64Guest",
            "fedoraGuest",
            "fedora64Guest",
            "coreos64Guest",
            "other24xLinuxGuest",
            "other26xLinuxGuest",
            "otherLinuxGuest",
            "other3xLinuxGuest",
            "genericLinuxGuest",
            "other24xLinux64Guest",
            "other26xLinux64Guest",
            "other3xLinux64Guest",
            "otherLinux64Guest",
            "solaris6Guest",
            "solaris7Guest",
            "solaris8Guest",
            "solaris9Guest",
            "solaris10Guest",
            "solaris10_64Guest",
            "solaris11_64Guest",
            "os2Guest",
            "eComStationGuest",
            "eComStation2Guest",
            "netware4Guest",
            "netware5Guest",
            "netware6Guest",
            "openServer5Guest",
            "openServer6Guest",
            "unixWare7Guest",
            "darwinGuest",
            "darwin64Guest",
            "darwin10Guest",
            "darwin10_64Guest",
            "darwin11Guest",
            "darwin11_64Guest",
            "darwin12_64Guest",
            "darwin13_64Guest",
            "darwin14_64Guest",
            "vmkernelGuest",
            "vmkernel5Guest",
            "vmkernel6Guest",
            "otherGuest",
            "otherGuest64",
         }
         enum GuestOsDescriptorFirmwareType {
            "bios",
            "efi",
         }
         enum GuestOsDescriptorSupportLevel {
            "experimental",
            "legacy",
            "terminated",
            "supported",
            "unsupported",
            "deprecated",
            "techPreview",
         }
         interface GuestOsDescriptor extends vimService.vim.DynamicData {
            id: string;
            family: string;
            fullName: string;
            supportedMaxCPUs: number;
            numSupportedPhysicalSockets?: number;
            numSupportedCoresPerSocket?: number;
            supportedMinMemMB: number;
            supportedMaxMemMB: number;
            recommendedMemMB: number;
            recommendedColorDepth: number;
            supportedDiskControllerList: Array<string>;
            recommendedSCSIController?: string;
            recommendedDiskController: string;
            supportedNumDisks: number;
            recommendedDiskSizeMB: number;
            recommendedCdromController?: string;
            supportedEthernetCard: Array<string>;
            recommendedEthernetCard?: string;
            supportsSlaveDisk?: boolean;
            cpuFeatureMask?: Array<vimService.vim.HostCpuIdInfo>;
            smcRequired?: boolean;
            supportsWakeOnLan: boolean;
            supportsVMI?: boolean;
            supportsMemoryHotAdd?: boolean;
            supportsCpuHotAdd?: boolean;
            supportsCpuHotRemove?: boolean;
            supportedFirmware?: Array<string>;
            recommendedFirmware?: string;
            supportedUSBControllerList?: Array<string>;
            recommendedUSBController?: string;
            supports3D?: boolean;
            recommended3D?: boolean;
            smcRecommended?: boolean;
            ich7mRecommended?: boolean;
            usbRecommended?: boolean;
            supportLevel?: string;
            supportedForCreate?: boolean;
            vRAMSizeInKB?: vimService.vim.IntOption;
            numSupportedFloppyDevices?: number;
            wakeOnLanEthernetCard?: Array<string>;
            supportsPvscsiControllerForBoot?: boolean;
            diskUuidEnabled?: boolean;
            supportsHotPlugPCI?: boolean;
         }
         interface ArrayOfGuestOsDescriptor {
            guestOsDescriptor?: Array<vimService.vim.GuestOsDescriptor>;
         }
         interface VirtualMachineIdeDiskDevicePartitionInfo extends vimService.vim.DynamicData {
            id: number;
            capacity: number;
         }
         interface ArrayOfVirtualMachineIdeDiskDevicePartitionInfo {
            virtualMachineIdeDiskDevicePartitionInfo?: Array<vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface VirtualMachineIdeDiskDeviceInfo extends vimService.vim.VirtualMachineDiskDeviceInfo {
            partitionTable?: Array<vimService.vim.VirtualMachineIdeDiskDevicePartitionInfo>;
         }
         interface ArrayOfVirtualMachineIdeDiskDeviceInfo {
            virtualMachineIdeDiskDeviceInfo?: Array<vimService.vim.VirtualMachineIdeDiskDeviceInfo>;
         }
         interface VirtualMachineLegacyNetworkSwitchInfo extends vimService.vim.DynamicData {
            name: string;
         }
         interface ArrayOfVirtualMachineLegacyNetworkSwitchInfo {
            virtualMachineLegacyNetworkSwitchInfo?: Array<vimService.vim.VirtualMachineLegacyNetworkSwitchInfo>;
         }
         interface VirtualMachineMessage extends vimService.vim.DynamicData {
            id: string;
            argument?: Array<any>;
            text?: string;
         }
         interface ArrayOfVirtualMachineMessage {
            virtualMachineMessage?: Array<vimService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineMetadataManagerVmMetadataOwnerOwner {
            "ComVmwareVsphereHA",
         }
         interface VirtualMachineMetadataManagerVmMetadataOwner extends vimService.vim.DynamicData {
            name: string;
         }
         enum VirtualMachineMetadataManagerVmMetadataOp {
            "Update",
            "Remove",
         }
         interface VirtualMachineMetadataManagerVmMetadata extends vimService.vim.DynamicData {
            vmId: string;
            metadata?: string;
         }
         interface VirtualMachineMetadataManagerVmMetadataInput extends vimService.vim.DynamicData {
            operation: string;
            vmMetadata: vimService.vim.VirtualMachineMetadataManagerVmMetadata;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataInput {
            virtualMachineMetadataManagerVmMetadataInput?: Array<vimService.vim.VirtualMachineMetadataManagerVmMetadataInput>;
         }
         interface VirtualMachineMetadataManagerVmMetadataResult extends vimService.vim.DynamicData {
            vmMetadata: vimService.vim.VirtualMachineMetadataManagerVmMetadata;
            error?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVirtualMachineMetadataManagerVmMetadataResult {
            virtualMachineMetadataManagerVmMetadataResult?: Array<vimService.vim.VirtualMachineMetadataManagerVmMetadataResult>;
         }
         interface VirtualMachineNetworkInfo extends vimService.vim.VirtualMachineTargetInfo {
            network: vimService.vim.NetworkSummary;
         }
         interface ArrayOfVirtualMachineNetworkInfo {
            virtualMachineNetworkInfo?: Array<vimService.vim.VirtualMachineNetworkInfo>;
         }
         interface VirtualMachineNetworkShaperInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            peakBps?: number;
            averageBps?: number;
            burstSize?: number;
         }
         interface OpaqueNetworkTargetInfo extends vimService.vim.VirtualMachineTargetInfo {
            network: vimService.vim.OpaqueNetworkSummary;
            networkReservationSupported?: boolean;
         }
         interface ArrayOfOpaqueNetworkTargetInfo {
            opaqueNetworkTargetInfo?: Array<vimService.vim.OpaqueNetworkTargetInfo>;
         }
         interface VirtualMachineParallelInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineParallelInfo {
            virtualMachineParallelInfo?: Array<vimService.vim.VirtualMachineParallelInfo>;
         }
         interface VirtualMachinePciPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            pciDevice: vimService.vim.HostPciDevice;
            systemId: string;
         }
         interface ArrayOfVirtualMachinePciPassthroughInfo {
            virtualMachinePciPassthroughInfo?: Array<vimService.vim.VirtualMachinePciPassthroughInfo>;
         }
         interface VirtualMachinePciSharedGpuPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            vgpu: string;
         }
         interface ArrayOfVirtualMachinePciSharedGpuPassthroughInfo {
            virtualMachinePciSharedGpuPassthroughInfo?: Array<vimService.vim.VirtualMachinePciSharedGpuPassthroughInfo>;
         }
         interface VirtualMachineProfileRawData extends vimService.vim.DynamicData {
            extensionKey: string;
            objectData?: string;
         }
         interface VirtualMachineProfileSpec extends vimService.vim.DynamicData {
         }
         interface ArrayOfVirtualMachineProfileSpec {
            virtualMachineProfileSpec?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface VirtualMachineQuestionInfo extends vimService.vim.DynamicData {
            id: string;
            text: string;
            choice: vimService.vim.ChoiceOption;
            message?: Array<vimService.vim.VirtualMachineMessage>;
         }
         enum VirtualMachineRelocateTransformation {
            "flat",
            "sparse",
         }
         interface VirtualMachineRelocateSpecDiskLocator extends vimService.vim.DynamicData {
            diskId: number;
            datastore: vimService.vim.ManagedObjectReference;
            diskMoveType?: string;
            diskBackingInfo?: vimService.vim.VirtualDeviceBackingInfo;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfVirtualMachineRelocateSpecDiskLocator {
            virtualMachineRelocateSpecDiskLocator?: Array<vimService.vim.VirtualMachineRelocateSpecDiskLocator>;
         }
         enum VirtualMachineRelocateDiskMoveOptions {
            "moveAllDiskBackingsAndAllowSharing",
            "moveAllDiskBackingsAndDisallowSharing",
            "moveChildMostDiskBacking",
            "createNewChildDiskBacking",
            "moveAllDiskBackingsAndConsolidate",
         }
         interface VirtualMachineRelocateSpec extends vimService.vim.DynamicData {
            service?: vimService.vim.ServiceLocator;
            folder?: vimService.vim.ManagedObjectReference;
            datastore?: vimService.vim.ManagedObjectReference;
            diskMoveType?: string;
            pool?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            disk?: Array<vimService.vim.VirtualMachineRelocateSpecDiskLocator>;
            transform?: vimService.vim.VirtualMachineRelocateTransformation;
            deviceChange?: Array<vimService.vim.VirtualDeviceConfigSpec>;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ReplicationInfoDiskSettings extends vimService.vim.DynamicData {
            key: number;
            diskReplicationId: string;
         }
         interface ArrayOfReplicationInfoDiskSettings {
            replicationInfoDiskSettings?: Array<vimService.vim.ReplicationInfoDiskSettings>;
         }
         interface ReplicationConfigSpec extends vimService.vim.DynamicData {
            generation: number;
            vmReplicationId: string;
            destination: string;
            port: number;
            rpo: number;
            quiesceGuestEnabled: boolean;
            paused: boolean;
            oppUpdatesEnabled: boolean;
            netCompressionEnabled?: boolean;
            disk?: Array<vimService.vim.ReplicationInfoDiskSettings>;
         }
         interface VirtualMachineRuntimeInfoDasProtectionState extends vimService.vim.DynamicData {
            dasProtected: boolean;
         }
         interface VirtualMachineRuntimeInfo extends vimService.vim.DynamicData {
            device?: Array<vimService.vim.VirtualMachineDeviceRuntimeInfo>;
            host?: vimService.vim.ManagedObjectReference;
            connectionState: vimService.vim.VirtualMachineConnectionState;
            powerState: vimService.vim.VirtualMachinePowerState;
            faultToleranceState?: vimService.vim.VirtualMachineFaultToleranceState;
            dasVmProtection?: vimService.vim.VirtualMachineRuntimeInfoDasProtectionState;
            toolsInstallerMounted: boolean;
            suspendTime?: Date;
            bootTime?: Date;
            suspendInterval?: number;
            question?: vimService.vim.VirtualMachineQuestionInfo;
            memoryOverhead?: number;
            maxCpuUsage?: number;
            maxMemoryUsage?: number;
            numMksConnections: number;
            recordReplayState?: vimService.vim.VirtualMachineRecordReplayState;
            cleanPowerOff?: boolean;
            needSecondaryReason?: string;
            onlineStandby?: boolean;
            minRequiredEVCModeKey?: string;
            consolidationNeeded?: boolean;
            offlineFeatureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            featureRequirement?: Array<vimService.vim.VirtualMachineFeatureRequirement>;
            featureMask?: Array<vimService.vim.HostFeatureMask>;
            vFlashCacheAllocation?: number;
            paused?: boolean;
            snapshotInBackground?: boolean;
            quiescedForkParent?: boolean;
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradePolicy {
            "never",
            "onSoftPowerOff",
            "always",
         }
         enum ScheduledHardwareUpgradeInfoHardwareUpgradeStatus {
            "none",
            "pending",
            "success",
            "failed",
         }
         interface ScheduledHardwareUpgradeInfo extends vimService.vim.DynamicData {
            upgradePolicy?: string;
            versionKey?: string;
            scheduledHardwareUpgradeStatus?: string;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface VirtualMachineScsiDiskDeviceInfo extends vimService.vim.VirtualMachineDiskDeviceInfo {
            disk?: vimService.vim.HostScsiDisk;
            transportHint?: string;
            lunNumber?: number;
         }
         interface ArrayOfVirtualMachineScsiDiskDeviceInfo {
            virtualMachineScsiDiskDeviceInfo?: Array<vimService.vim.VirtualMachineScsiDiskDeviceInfo>;
         }
         enum VirtualMachineScsiPassthroughType {
            "disk",
            "tape",
            "printer",
            "processor",
            "worm",
            "cdrom",
            "scanner",
            "optical",
            "media",
            "com",
            "raid",
            "unknown",
         }
         interface VirtualMachineScsiPassthroughInfo extends vimService.vim.VirtualMachineTargetInfo {
            scsiClass: string;
            vendor: string;
            physicalUnitNumber: number;
         }
         interface ArrayOfVirtualMachineScsiPassthroughInfo {
            virtualMachineScsiPassthroughInfo?: Array<vimService.vim.VirtualMachineScsiPassthroughInfo>;
         }
         interface VirtualMachineSerialInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSerialInfo {
            virtualMachineSerialInfo?: Array<vimService.vim.VirtualMachineSerialInfo>;
         }
         interface VirtualMachineSnapshotInfo extends vimService.vim.DynamicData {
            currentSnapshot?: vimService.vim.ManagedObjectReference;
            rootSnapshotList: Array<vimService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSnapshotTree extends vimService.vim.DynamicData {
            snapshot: vimService.vim.ManagedObjectReference;
            vm: vimService.vim.ManagedObjectReference;
            name: string;
            description: string;
            id?: number;
            createTime: Date;
            state: vimService.vim.VirtualMachinePowerState;
            quiesced: boolean;
            backupManifest?: string;
            childSnapshotList?: Array<vimService.vim.VirtualMachineSnapshotTree>;
            replaySupported?: boolean;
         }
         interface ArrayOfVirtualMachineSnapshotTree {
            virtualMachineSnapshotTree?: Array<vimService.vim.VirtualMachineSnapshotTree>;
         }
         interface VirtualMachineSoundInfo extends vimService.vim.VirtualMachineTargetInfo {
         }
         interface ArrayOfVirtualMachineSoundInfo {
            virtualMachineSoundInfo?: Array<vimService.vim.VirtualMachineSoundInfo>;
         }
         interface VirtualMachineSriovInfo extends vimService.vim.VirtualMachinePciPassthroughInfo {
            virtualFunction: boolean;
            pnic?: string;
         }
         interface ArrayOfVirtualMachineSriovInfo {
            virtualMachineSriovInfo?: Array<vimService.vim.VirtualMachineSriovInfo>;
         }
         interface VirtualMachineUsageOnDatastore extends vimService.vim.DynamicData {
            datastore: vimService.vim.ManagedObjectReference;
            committed: number;
            uncommitted: number;
            unshared: number;
         }
         interface ArrayOfVirtualMachineUsageOnDatastore {
            virtualMachineUsageOnDatastore?: Array<vimService.vim.VirtualMachineUsageOnDatastore>;
         }
         interface VirtualMachineStorageInfo extends vimService.vim.DynamicData {
            perDatastoreUsage?: Array<vimService.vim.VirtualMachineUsageOnDatastore>;
            timestamp: Date;
         }
         interface VirtualMachineConfigSummary extends vimService.vim.DynamicData {
            name: string;
            template: boolean;
            vmPathName: string;
            memorySizeMB?: number;
            cpuReservation?: number;
            memoryReservation?: number;
            numCpu?: number;
            numEthernetCards?: number;
            numVirtualDisks?: number;
            uuid?: string;
            instanceUuid?: string;
            guestId?: string;
            guestFullName?: string;
            annotation?: string;
            product?: vimService.vim.VAppProductInfo;
            installBootRequired?: boolean;
            ftInfo?: vimService.vim.FaultToleranceConfigInfo;
            managedBy?: vimService.vim.ManagedByInfo;
         }
         interface VirtualMachineQuickStats extends vimService.vim.DynamicData {
            overallCpuUsage?: number;
            overallCpuDemand?: number;
            guestMemoryUsage?: number;
            hostMemoryUsage?: number;
            guestHeartbeatStatus: vimService.vim.ManagedEntityStatus;
            distributedCpuEntitlement?: number;
            distributedMemoryEntitlement?: number;
            staticCpuEntitlement?: number;
            staticMemoryEntitlement?: number;
            privateMemory?: number;
            sharedMemory?: number;
            swappedMemory?: number;
            balloonedMemory?: number;
            consumedOverheadMemory?: number;
            ftLogBandwidth?: number;
            ftSecondaryLatency?: number;
            ftLatencyStatus?: vimService.vim.ManagedEntityStatus;
            compressedMemory?: number;
            uptimeSeconds?: number;
            ssdSwappedMemory?: number;
         }
         interface VirtualMachineGuestSummary extends vimService.vim.DynamicData {
            guestId?: string;
            guestFullName?: string;
            toolsStatus?: vimService.vim.VirtualMachineToolsStatus;
            toolsVersionStatus?: string;
            toolsVersionStatus2?: string;
            toolsRunningStatus?: string;
            hostName?: string;
            ipAddress?: string;
         }
         interface VirtualMachineStorageSummary extends vimService.vim.DynamicData {
            committed: number;
            uncommitted: number;
            unshared: number;
            timestamp: Date;
         }
         interface VirtualMachineSummary extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            runtime: vimService.vim.VirtualMachineRuntimeInfo;
            guest?: vimService.vim.VirtualMachineGuestSummary;
            config: vimService.vim.VirtualMachineConfigSummary;
            storage?: vimService.vim.VirtualMachineStorageSummary;
            quickStats: vimService.vim.VirtualMachineQuickStats;
            overallStatus: vimService.vim.ManagedEntityStatus;
            customValue?: Array<vimService.vim.CustomFieldValue>;
         }
         interface ArrayOfVirtualMachineSummary {
            virtualMachineSummary?: Array<vimService.vim.VirtualMachineSummary>;
         }
         enum VirtualMachineTargetInfoConfigurationTag {
            "compliant",
            "clusterWide",
         }
         interface VirtualMachineTargetInfo extends vimService.vim.DynamicData {
            name: string;
            configurationTag?: Array<string>;
         }
         enum UpgradePolicy {
            "manual",
            "upgradeAtPowerCycle",
         }
         interface ToolsConfigInfoToolsLastInstallInfo extends vimService.vim.DynamicData {
            counter: number;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ToolsConfigInfo extends vimService.vim.DynamicData {
            toolsVersion?: number;
            afterPowerOn?: boolean;
            afterResume?: boolean;
            beforeGuestStandby?: boolean;
            beforeGuestShutdown?: boolean;
            beforeGuestReboot?: boolean;
            toolsUpgradePolicy?: string;
            pendingCustomization?: string;
            syncTimeWithHost?: boolean;
            lastInstallInfo?: vimService.vim.ToolsConfigInfoToolsLastInstallInfo;
         }
         enum VirtualMachineUsbInfoSpeed {
            "low",
            "full",
            "high",
            "superSpeed",
            "unknownSpeed",
         }
         enum VirtualMachineUsbInfoFamily {
            "audio",
            "hid",
            "hid_bootable",
            "physical",
            "communication",
            "imaging",
            "printer",
            "storage",
            "hub",
            "smart_card",
            "security",
            "video",
            "wireless",
            "bluetooth",
            "wusb",
            "pda",
            "vendor_specific",
            "other",
            "unknownFamily",
         }
         interface VirtualMachineUsbInfo extends vimService.vim.VirtualMachineTargetInfo {
            description: string;
            vendor: number;
            product: number;
            physicalPath: string;
            family?: Array<string>;
            speed?: Array<string>;
            summary?: vimService.vim.VirtualMachineSummary;
         }
         interface ArrayOfVirtualMachineUsbInfo {
            virtualMachineUsbInfo?: Array<vimService.vim.VirtualMachineUsbInfo>;
         }
         interface VirtualMachineVFlashModuleInfo extends vimService.vim.VirtualMachineTargetInfo {
            vFlashModule: vimService.vim.HostVFlashManagerVFlashCacheConfigInfoVFlashModuleConfigOption;
         }
         interface ArrayOfVirtualMachineVFlashModuleInfo {
            virtualMachineVFlashModuleInfo?: Array<vimService.vim.VirtualMachineVFlashModuleInfo>;
         }
         interface VirtualHardware extends vimService.vim.DynamicData {
            numCPU: number;
            numCoresPerSocket?: number;
            memoryMB: number;
            virtualICH7MPresent?: boolean;
            virtualSMCPresent?: boolean;
            device?: Array<vimService.vim.VirtualDevice>;
         }
         interface VirtualHardwareOption extends vimService.vim.DynamicData {
            hwVersion: number;
            virtualDeviceOption: Array<vimService.vim.VirtualDeviceOption>;
            deviceListReadonly: boolean;
            numCPU: Array<number>;
            numCoresPerSocket?: vimService.vim.IntOption;
            numCpuReadonly: boolean;
            memoryMB: vimService.vim.LongOption;
            numPCIControllers: vimService.vim.IntOption;
            numIDEControllers: vimService.vim.IntOption;
            numUSBControllers: vimService.vim.IntOption;
            numUSBXHCIControllers?: vimService.vim.IntOption;
            numSIOControllers: vimService.vim.IntOption;
            numPS2Controllers: vimService.vim.IntOption;
            licensingLimit?: Array<string>;
            numSupportedWwnPorts?: vimService.vim.IntOption;
            numSupportedWwnNodes?: vimService.vim.IntOption;
            resourceConfigOption?: vimService.vim.ResourceConfigOption;
         }
         interface VirtualMachineImportSpec extends vimService.vim.ImportSpec {
            configSpec: vimService.vim.VirtualMachineConfigSpec;
            resPoolEntity?: vimService.vim.ManagedObjectReference;
         }
         interface CheckResult extends vimService.vim.DynamicData {
            vm?: vimService.vim.ManagedObjectReference;
            host?: vimService.vim.ManagedObjectReference;
            warning?: Array<vimService.vim.LocalizedMethodFault>;
            error?: Array<vimService.vim.LocalizedMethodFault>;
         }
         interface ArrayOfCheckResult {
            checkResult?: Array<vimService.vim.CheckResult>;
         }
         enum CheckTestType {
            "sourceTests",
            "hostTests",
            "resourcePoolTests",
            "datastoreTests",
            "networkTests",
         }
         interface CustomizationIPSettingsIpV6AddressSpec extends vimService.vim.DynamicData {
            ip: Array<vimService.vim.CustomizationIpV6Generator>;
            gateway?: Array<string>;
         }
         enum CustomizationNetBIOSMode {
            "enableNetBIOSViaDhcp",
            "enableNetBIOS",
            "disableNetBIOS",
         }
         interface CustomizationIPSettings extends vimService.vim.DynamicData {
            ip: vimService.vim.CustomizationIpGenerator;
            subnetMask?: string;
            gateway?: Array<string>;
            ipV6Spec?: vimService.vim.CustomizationIPSettingsIpV6AddressSpec;
            dnsServerList?: Array<string>;
            dnsDomain?: string;
            primaryWINS?: string;
            secondaryWINS?: string;
            netBIOS?: vimService.vim.CustomizationNetBIOSMode;
         }
         interface CustomizationSpec extends vimService.vim.DynamicData {
            options?: vimService.vim.CustomizationOptions;
            identity: vimService.vim.CustomizationIdentitySettings;
            globalIPSettings: vimService.vim.CustomizationGlobalIPSettings;
            nicSettingMap?: Array<vimService.vim.CustomizationAdapterMapping>;
            encryptionKey?: Array<number>;
         }
         interface CustomizationName extends vimService.vim.DynamicData {
         }
         interface CustomizationFixedName extends vimService.vim.CustomizationName {
            name: string;
         }
         interface CustomizationPrefixName extends vimService.vim.CustomizationName {
            base: string;
         }
         interface CustomizationVirtualMachineName extends vimService.vim.CustomizationName {
         }
         interface CustomizationUnknownName extends vimService.vim.CustomizationName {
         }
         interface CustomizationCustomName extends vimService.vim.CustomizationName {
            argument?: string;
         }
         interface CustomizationPassword extends vimService.vim.DynamicData {
            value: string;
            plainText: boolean;
         }
         interface CustomizationOptions extends vimService.vim.DynamicData {
         }
         enum CustomizationSysprepRebootOption {
            "reboot",
            "noreboot",
            "shutdown",
         }
         interface CustomizationWinOptions extends vimService.vim.CustomizationOptions {
            changeSID: boolean;
            deleteAccounts: boolean;
            reboot?: vimService.vim.CustomizationSysprepRebootOption;
         }
         interface CustomizationLinuxOptions extends vimService.vim.CustomizationOptions {
         }
         interface CustomizationGuiUnattended extends vimService.vim.DynamicData {
            password?: vimService.vim.CustomizationPassword;
            timeZone: number;
            autoLogon: boolean;
            autoLogonCount: number;
         }
         interface CustomizationUserData extends vimService.vim.DynamicData {
            fullName: string;
            orgName: string;
            computerName: vimService.vim.CustomizationName;
            productId: string;
         }
         interface CustomizationGuiRunOnce extends vimService.vim.DynamicData {
            commandList: Array<string>;
         }
         interface CustomizationIdentification extends vimService.vim.DynamicData {
            joinWorkgroup?: string;
            joinDomain?: string;
            domainAdmin?: string;
            domainAdminPassword?: vimService.vim.CustomizationPassword;
         }
         enum CustomizationLicenseDataMode {
            "perServer",
            "perSeat",
         }
         interface CustomizationLicenseFilePrintData extends vimService.vim.DynamicData {
            autoMode: vimService.vim.CustomizationLicenseDataMode;
            autoUsers?: number;
         }
         interface CustomizationIdentitySettings extends vimService.vim.DynamicData {
         }
         interface CustomizationSysprepText extends vimService.vim.CustomizationIdentitySettings {
            value: string;
         }
         interface CustomizationSysprep extends vimService.vim.CustomizationIdentitySettings {
            guiUnattended: vimService.vim.CustomizationGuiUnattended;
            userData: vimService.vim.CustomizationUserData;
            guiRunOnce?: vimService.vim.CustomizationGuiRunOnce;
            identification: vimService.vim.CustomizationIdentification;
            licenseFilePrintData?: vimService.vim.CustomizationLicenseFilePrintData;
         }
         interface CustomizationLinuxPrep extends vimService.vim.CustomizationIdentitySettings {
            hostName: vimService.vim.CustomizationName;
            domain: string;
            timeZone?: string;
            hwClockUTC?: boolean;
         }
         interface CustomizationGlobalIPSettings extends vimService.vim.DynamicData {
            dnsSuffixList?: Array<string>;
            dnsServerList?: Array<string>;
         }
         interface CustomizationIpGenerator extends vimService.vim.DynamicData {
         }
         interface CustomizationDhcpIpGenerator extends vimService.vim.CustomizationIpGenerator {
         }
         interface CustomizationFixedIp extends vimService.vim.CustomizationIpGenerator {
            ipAddress: string;
         }
         interface CustomizationUnknownIpGenerator extends vimService.vim.CustomizationIpGenerator {
         }
         interface CustomizationCustomIpGenerator extends vimService.vim.CustomizationIpGenerator {
            argument?: string;
         }
         interface CustomizationIpV6Generator extends vimService.vim.DynamicData {
         }
         interface ArrayOfCustomizationIpV6Generator {
            customizationIpV6Generator?: Array<vimService.vim.CustomizationIpV6Generator>;
         }
         interface CustomizationDhcpIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationStatelessIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationFixedIpV6 extends vimService.vim.CustomizationIpV6Generator {
            ipAddress: string;
            subnetMask: number;
         }
         interface CustomizationAutoIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationUnknownIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
         }
         interface CustomizationCustomIpV6Generator extends vimService.vim.CustomizationIpV6Generator {
            argument?: string;
         }
         interface CustomizationAdapterMapping extends vimService.vim.DynamicData {
            macAddress?: string;
            adapter: vimService.vim.CustomizationIPSettings;
         }
         interface ArrayOfCustomizationAdapterMapping {
            customizationAdapterMapping?: Array<vimService.vim.CustomizationAdapterMapping>;
         }
         interface HostDiskMappingPartitionInfo extends vimService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface HostDiskMappingInfo extends vimService.vim.DynamicData {
            physicalPartition?: vimService.vim.HostDiskMappingPartitionInfo;
            name: string;
            exclusive?: boolean;
         }
         interface HostDiskMappingPartitionOption extends vimService.vim.DynamicData {
            name: string;
            fileSystem: string;
            capacityInKb: number;
         }
         interface ArrayOfHostDiskMappingPartitionOption {
            hostDiskMappingPartitionOption?: Array<vimService.vim.HostDiskMappingPartitionOption>;
         }
         interface HostDiskMappingOption extends vimService.vim.DynamicData {
            physicalPartition?: Array<vimService.vim.HostDiskMappingPartitionOption>;
            name: string;
         }
         interface ParaVirtualSCSIController extends vimService.vim.VirtualSCSIController {
         }
         interface ParaVirtualSCSIControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualAHCIController extends vimService.vim.VirtualSATAController {
         }
         interface VirtualAHCIControllerOption extends vimService.vim.VirtualSATAControllerOption {
         }
         interface VirtualBusLogicController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualBusLogicControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualCdromIsoBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualCdromPassthroughBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromRemotePassthroughBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            exclusive: boolean;
         }
         interface VirtualCdromAtapiBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualCdromRemoteAtapiBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualCdrom extends vimService.vim.VirtualDevice {
         }
         interface VirtualCdromIsoBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualCdromPassthroughBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            exclusive: vimService.vim.BoolOption;
         }
         interface VirtualCdromRemotePassthroughBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
            exclusive: vimService.vim.BoolOption;
         }
         interface VirtualCdromAtapiBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromRemoteAtapiBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualCdromOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualController extends vimService.vim.VirtualDevice {
            busNumber: number;
            device?: Array<number>;
         }
         interface VirtualControllerOption extends vimService.vim.VirtualDeviceOption {
            devices: vimService.vim.IntOption;
            supportedDevice?: Array<string>;
         }
         interface VirtualDeviceBackingInfo extends vimService.vim.DynamicData {
         }
         interface VirtualDeviceFileBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            fileName: string;
            datastore?: vimService.vim.ManagedObjectReference;
            backingObjectId?: string;
         }
         interface VirtualDeviceDeviceBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDeviceRemoteDeviceBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            deviceName: string;
            useAutoDetect?: boolean;
         }
         interface VirtualDevicePipeBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            pipeName: string;
         }
         interface VirtualDeviceURIBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            serviceURI: string;
            direction: string;
            proxyURI?: string;
         }
         enum VirtualDeviceConnectInfoStatus {
            "ok",
            "recoverableError",
            "unrecoverableError",
            "untried",
         }
         interface VirtualDeviceConnectInfo extends vimService.vim.DynamicData {
            startConnected: boolean;
            allowGuestControl: boolean;
            connected: boolean;
            status?: string;
         }
         interface VirtualDeviceBusSlotInfo extends vimService.vim.DynamicData {
         }
         interface VirtualDevicePciBusSlotInfo extends vimService.vim.VirtualDeviceBusSlotInfo {
            pciSlotNumber: number;
         }
         interface VirtualDevice extends vimService.vim.DynamicData {
            key: number;
            deviceInfo?: vimService.vim.Description;
            backing?: vimService.vim.VirtualDeviceBackingInfo;
            connectable?: vimService.vim.VirtualDeviceConnectInfo;
            slotInfo?: vimService.vim.VirtualDeviceBusSlotInfo;
            controllerKey?: number;
            unitNumber?: number;
         }
         interface ArrayOfVirtualDevice {
            virtualDevice?: Array<vimService.vim.VirtualDevice>;
         }
         interface VirtualDeviceBackingOption extends vimService.vim.DynamicData {
            type: string;
         }
         interface ArrayOfVirtualDeviceBackingOption {
            virtualDeviceBackingOption?: Array<vimService.vim.VirtualDeviceBackingOption>;
         }
         enum VirtualDeviceFileExtension {
            "iso",
            "flp",
            "vmdk",
            "dsk",
            "rdm",
         }
         interface VirtualDeviceFileBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            fileNameExtensions?: vimService.vim.ChoiceOption;
         }
         interface VirtualDeviceDeviceBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: vimService.vim.BoolOption;
         }
         interface VirtualDeviceRemoteDeviceBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            autoDetectAvailable: vimService.vim.BoolOption;
         }
         interface VirtualDevicePipeBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualDeviceURIBackingOptionDirection {
            "server",
            "client",
         }
         interface VirtualDeviceURIBackingOption extends vimService.vim.VirtualDeviceBackingOption {
            directions: vimService.vim.ChoiceOption;
         }
         interface VirtualDeviceConnectOption extends vimService.vim.DynamicData {
            startConnected: vimService.vim.BoolOption;
            allowGuestControl: vimService.vim.BoolOption;
         }
         interface VirtualDeviceBusSlotOption extends vimService.vim.DynamicData {
            type: string;
         }
         interface VirtualDeviceOption extends vimService.vim.DynamicData {
            type: string;
            connectOption?: vimService.vim.VirtualDeviceConnectOption;
            busSlotOption?: vimService.vim.VirtualDeviceBusSlotOption;
            controllerType?: string;
            autoAssignController?: vimService.vim.BoolOption;
            backingOption?: Array<vimService.vim.VirtualDeviceBackingOption>;
            defaultBackingOptionIndex?: number;
            licensingLimit?: Array<string>;
            deprecated: boolean;
            plugAndPlay: boolean;
            hotRemoveSupported?: boolean;
         }
         interface ArrayOfVirtualDeviceOption {
            virtualDeviceOption?: Array<vimService.vim.VirtualDeviceOption>;
         }
         enum VirtualDeviceConfigSpecOperation {
            "add",
            "remove",
            "edit",
         }
         enum VirtualDeviceConfigSpecFileOperation {
            "create",
            "destroy",
            "replace",
         }
         interface VirtualDeviceConfigSpec extends vimService.vim.DynamicData {
            operation?: vimService.vim.VirtualDeviceConfigSpecOperation;
            fileOperation?: vimService.vim.VirtualDeviceConfigSpecFileOperation;
            device: vimService.vim.VirtualDevice;
            profile?: Array<vimService.vim.VirtualMachineProfileSpec>;
         }
         interface ArrayOfVirtualDeviceConfigSpec {
            virtualDeviceConfigSpec?: Array<vimService.vim.VirtualDeviceConfigSpec>;
         }
         enum VirtualDiskDeltaDiskFormat {
            "redoLogFormat",
            "nativeFormat",
            "seSparseFormat",
         }
         enum VirtualDiskDeltaDiskFormatVariant {
            "vmfsSparseVariant",
            "vsanSparseVariant",
         }
         enum VirtualDiskSharing {
            "sharingNone",
            "sharingMultiWriter",
         }
         interface VirtualDiskSparseVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            contentId?: string;
            parent?: vimService.vim.VirtualDiskSparseVer1BackingInfo;
         }
         interface VirtualDiskSparseVer2BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            spaceUsedInKB?: number;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskSparseVer2BackingInfo;
         }
         interface VirtualDiskFlatVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            contentId?: string;
            parent?: vimService.vim.VirtualDiskFlatVer1BackingInfo;
         }
         interface VirtualDiskFlatVer2BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            split?: boolean;
            writeThrough?: boolean;
            thinProvisioned?: boolean;
            eagerlyScrub?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskFlatVer2BackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            deltaGrainSize?: number;
            deltaDiskFormatVariant?: string;
            sharing?: string;
         }
         interface VirtualDiskSeSparseBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            diskMode: string;
            writeThrough?: boolean;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskSeSparseBackingInfo;
            deltaDiskFormat?: string;
            digestEnabled?: boolean;
            grainSize?: number;
         }
         interface VirtualDiskRawDiskVer2BackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            descriptorFileName: string;
            uuid?: string;
            changeId?: string;
            sharing?: string;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingInfo extends vimService.vim.VirtualDiskRawDiskVer2BackingInfo {
            partition: Array<number>;
         }
         interface VirtualDiskRawDiskMappingVer1BackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
            lunUuid?: string;
            deviceName?: string;
            compatibilityMode?: string;
            diskMode?: string;
            uuid?: string;
            contentId?: string;
            changeId?: string;
            parent?: vimService.vim.VirtualDiskRawDiskMappingVer1BackingInfo;
            deltaDiskFormat?: string;
            deltaGrainSize?: number;
            sharing?: string;
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheConsistencyType {
            "strong",
            "weak",
         }
         enum VirtualDiskVFlashCacheConfigInfoCacheMode {
            "write_thru",
            "write_back",
         }
         interface VirtualDiskVFlashCacheConfigInfo extends vimService.vim.DynamicData {
            vFlashModule?: string;
            reservationInMB?: number;
            cacheConsistencyType?: string;
            cacheMode?: string;
            blockSizeInKB?: number;
         }
         interface VirtualDisk extends vimService.vim.VirtualDevice {
            capacityInKB: number;
            capacityInBytes?: number;
            shares?: vimService.vim.SharesInfo;
            storageIOAllocation?: vimService.vim.StorageIOAllocationInfo;
            diskObjectId?: string;
            vFlashCacheConfigInfo?: vimService.vim.VirtualDiskVFlashCacheConfigInfo;
            iofilter?: Array<string>;
         }
         interface ArrayOfVirtualDisk {
            virtualDisk?: Array<vimService.vim.VirtualDisk>;
         }
         interface VirtualDiskId extends vimService.vim.DynamicData {
            vm: vimService.vim.ManagedObjectReference;
            diskId: number;
         }
         interface ArrayOfVirtualDiskId {
            virtualDiskId?: Array<vimService.vim.VirtualDiskId>;
         }
         enum VirtualDiskMode {
            "persistent",
            "nonpersistent",
            "undoable",
            "independent_persistent",
            "independent_nonpersistent",
            "append",
         }
         enum VirtualDiskCompatibilityMode {
            "virtualMode",
            "physicalMode",
         }
         interface VirtualDiskSparseVer1BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskModes: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskSparseVer2BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
         }
         interface VirtualDiskFlatVer1BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
         }
         interface VirtualDiskDeltaDiskFormatsSupported extends vimService.vim.DynamicData {
            datastoreType: string;
            deltaDiskFormat: vimService.vim.ChoiceOption;
         }
         interface ArrayOfVirtualDiskDeltaDiskFormatsSupported {
            virtualDiskDeltaDiskFormatsSupported?: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskFlatVer2BackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            split: vimService.vim.BoolOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            thinProvisioned?: vimService.vim.BoolOption;
            eagerlyScrub?: vimService.vim.BoolOption;
            deltaDiskFormat?: vimService.vim.ChoiceOption;
            deltaDiskFormatsSupported?: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskSeSparseBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
            diskMode: vimService.vim.ChoiceOption;
            writeThrough: vimService.vim.BoolOption;
            growable: boolean;
            hotGrowable: boolean;
            uuid: boolean;
            deltaDiskFormatsSupported: Array<vimService.vim.VirtualDiskDeltaDiskFormatsSupported>;
         }
         interface VirtualDiskRawDiskVer2BackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions: vimService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskPartitionedRawDiskVer2BackingOption extends vimService.vim.VirtualDiskRawDiskVer2BackingOption {
         }
         interface VirtualDiskRawDiskMappingVer1BackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            descriptorFileNameExtensions?: vimService.vim.ChoiceOption;
            compatibilityMode: vimService.vim.ChoiceOption;
            diskMode: vimService.vim.ChoiceOption;
            uuid: boolean;
         }
         interface VirtualDiskOptionVFlashCacheConfigOption extends vimService.vim.DynamicData {
            cacheConsistencyType: vimService.vim.ChoiceOption;
            cacheMode: vimService.vim.ChoiceOption;
            reservationInMB: vimService.vim.LongOption;
            blockSizeInKB: vimService.vim.LongOption;
         }
         interface VirtualDiskOption extends vimService.vim.VirtualDeviceOption {
            capacityInKB: vimService.vim.LongOption;
            ioAllocationOption?: vimService.vim.StorageIOAllocationOption;
            vFlashCacheConfigOption?: vimService.vim.VirtualDiskOptionVFlashCacheConfigOption;
         }
         interface VirtualDiskConfigSpec extends vimService.vim.VirtualDeviceConfigSpec {
            diskMoveType?: string;
            migrateCache?: boolean;
         }
         interface VirtualE1000 extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000Option extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualE1000e extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualE1000eOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualEnsoniq1371 extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualEnsoniq1371Option extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualEthernetCardNetworkBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            network?: vimService.vim.ManagedObjectReference;
            inPassthroughMode?: boolean;
         }
         interface VirtualEthernetCardLegacyNetworkBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualEthernetCardDistributedVirtualPortBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            port: vimService.vim.DistributedVirtualSwitchPortConnection;
         }
         interface VirtualEthernetCardOpaqueNetworkBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            opaqueNetworkId: string;
            opaqueNetworkType: string;
         }
         interface VirtualEthernetCardResourceAllocation extends vimService.vim.DynamicData {
            reservation?: number;
            share: vimService.vim.SharesInfo;
            limit?: number;
         }
         interface VirtualEthernetCard extends vimService.vim.VirtualDevice {
            addressType?: string;
            macAddress?: string;
            wakeOnLanEnabled?: boolean;
            resourceAllocation?: vimService.vim.VirtualEthernetCardResourceAllocation;
            externalId?: string;
            uptCompatibilityEnabled?: boolean;
         }
         interface VirtualEthernetCardNetworkBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardOpaqueNetworkBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardLegacyNetworkDeviceName {
            "bridged",
            "nat",
            "hostonly",
         }
         interface VirtualEthernetCardLegacyNetworkBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualEthernetCardDVPortBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         enum VirtualEthernetCardMacType {
            "manual",
            "generated",
            "assigned",
         }
         interface VirtualEthernetCardOption extends vimService.vim.VirtualDeviceOption {
            supportedOUI: vimService.vim.ChoiceOption;
            macType: vimService.vim.ChoiceOption;
            wakeOnLanEnabled: vimService.vim.BoolOption;
            vmDirectPathGen2Supported?: boolean;
            uptCompatibilityEnabled?: vimService.vim.BoolOption;
         }
         interface VirtualFloppyImageBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualFloppyDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualFloppyRemoteDeviceBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
         }
         interface VirtualFloppy extends vimService.vim.VirtualDevice {
         }
         interface VirtualFloppyImageBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualFloppyDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualFloppyRemoteDeviceBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualFloppyOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualHdAudioCard extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualHdAudioCardOption extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualIDEController extends vimService.vim.VirtualController {
         }
         interface VirtualIDEControllerOption extends vimService.vim.VirtualControllerOption {
            numIDEDisks: vimService.vim.IntOption;
            numIDECdroms: vimService.vim.IntOption;
         }
         interface VirtualKeyboard extends vimService.vim.VirtualDevice {
         }
         interface VirtualKeyboardOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualLsiLogicController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualLsiLogicSASController extends vimService.vim.VirtualSCSIController {
         }
         interface VirtualLsiLogicSASControllerOption extends vimService.vim.VirtualSCSIControllerOption {
         }
         interface VirtualPCIController extends vimService.vim.VirtualController {
         }
         interface VirtualPCIControllerOption extends vimService.vim.VirtualControllerOption {
            numSCSIControllers: vimService.vim.IntOption;
            numEthernetCards: vimService.vim.IntOption;
            numVideoCards: vimService.vim.IntOption;
            numSoundCards: vimService.vim.IntOption;
            numVmiRoms: vimService.vim.IntOption;
            numVmciDevices?: vimService.vim.IntOption;
            numPCIPassthroughDevices?: vimService.vim.IntOption;
            numSasSCSIControllers?: vimService.vim.IntOption;
            numVmxnet3EthernetCards?: vimService.vim.IntOption;
            numParaVirtualSCSIControllers?: vimService.vim.IntOption;
            numSATAControllers?: vimService.vim.IntOption;
         }
         interface VirtualPCIPassthroughDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            id: string;
            deviceId: string;
            systemId: string;
            vendorId: number;
         }
         interface VirtualPCIPassthroughPluginBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
         }
         interface VirtualPCIPassthroughVmiopBackingInfo extends vimService.vim.VirtualPCIPassthroughPluginBackingInfo {
            vgpu?: string;
         }
         interface VirtualPCIPassthrough extends vimService.vim.VirtualDevice {
         }
         interface VirtualPCIPassthroughDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualPCIPassthroughPluginBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualPCIPassthroughVmiopBackingOption extends vimService.vim.VirtualPCIPassthroughPluginBackingOption {
            vgpu: vimService.vim.StringOption;
            maxInstances: number;
         }
         interface VirtualPCIPassthroughOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualPCNet32 extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualPCNet32Option extends vimService.vim.VirtualEthernetCardOption {
            supportsMorphing: boolean;
         }
         interface VirtualPS2Controller extends vimService.vim.VirtualController {
         }
         interface VirtualPS2ControllerOption extends vimService.vim.VirtualControllerOption {
            numKeyboards: vimService.vim.IntOption;
            numPointingDevices: vimService.vim.IntOption;
         }
         interface VirtualParallelPortFileBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualParallelPortDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualParallelPort extends vimService.vim.VirtualDevice {
         }
         interface VirtualParallelPortFileBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualParallelPortDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualParallelPortOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualPointingDeviceDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            hostPointingDevice: string;
         }
         interface VirtualPointingDevice extends vimService.vim.VirtualDevice {
         }
         enum VirtualPointingDeviceHostChoice {
            "autodetect",
            "intellimouseExplorer",
            "intellimousePs2",
            "logitechMouseman",
            "microsoft_serial",
            "mouseSystems",
            "mousemanSerial",
            "ps2",
         }
         interface VirtualPointingDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
            hostPointingDevice: vimService.vim.ChoiceOption;
         }
         interface VirtualPointingDeviceOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSATAController extends vimService.vim.VirtualController {
         }
         interface VirtualSATAControllerOption extends vimService.vim.VirtualControllerOption {
            numSATADisks: vimService.vim.IntOption;
            numSATACdroms: vimService.vim.IntOption;
         }
         enum VirtualSCSISharing {
            "noSharing",
            "virtualSharing",
            "physicalSharing",
         }
         interface ArrayOfVirtualSCSISharing {
            virtualSCSISharing?: Array<vimService.vim.VirtualSCSISharing>;
         }
         interface VirtualSCSIController extends vimService.vim.VirtualController {
            hotAddRemove?: boolean;
            sharedBus: vimService.vim.VirtualSCSISharing;
            scsiCtlrUnitNumber?: number;
         }
         interface VirtualSCSIControllerOption extends vimService.vim.VirtualControllerOption {
            numSCSIDisks: vimService.vim.IntOption;
            numSCSICdroms: vimService.vim.IntOption;
            numSCSIPassthrough: vimService.vim.IntOption;
            sharing: Array<vimService.vim.VirtualSCSISharing>;
            defaultSharedIndex: number;
            hotAddRemove: vimService.vim.BoolOption;
            scsiCtlrUnitNumber: number;
         }
         interface VirtualSCSIPassthroughDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSCSIPassthrough extends vimService.vim.VirtualDevice {
         }
         interface VirtualSCSIPassthroughDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSCSIPassthroughOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSIOController extends vimService.vim.VirtualController {
         }
         interface VirtualSIOControllerOption extends vimService.vim.VirtualControllerOption {
            numFloppyDrives: vimService.vim.IntOption;
            numSerialPorts: vimService.vim.IntOption;
            numParallelPorts: vimService.vim.IntOption;
         }
         interface VirtualSerialPortFileBackingInfo extends vimService.vim.VirtualDeviceFileBackingInfo {
         }
         interface VirtualSerialPortDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSerialPortPipeBackingInfo extends vimService.vim.VirtualDevicePipeBackingInfo {
            endpoint: string;
            noRxLoss?: boolean;
         }
         interface VirtualSerialPortURIBackingInfo extends vimService.vim.VirtualDeviceURIBackingInfo {
         }
         interface VirtualSerialPortThinPrintBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
         }
         interface VirtualSerialPort extends vimService.vim.VirtualDevice {
            yieldOnPoll: boolean;
         }
         enum VirtualSerialPortEndPoint {
            "client",
            "server",
         }
         interface VirtualSerialPortFileBackingOption extends vimService.vim.VirtualDeviceFileBackingOption {
         }
         interface VirtualSerialPortDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSerialPortPipeBackingOption extends vimService.vim.VirtualDevicePipeBackingOption {
            endpoint: vimService.vim.ChoiceOption;
            noRxLoss: vimService.vim.BoolOption;
         }
         interface VirtualSerialPortURIBackingOption extends vimService.vim.VirtualDeviceURIBackingOption {
         }
         interface VirtualSerialPortThinPrintBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSerialPortOption extends vimService.vim.VirtualDeviceOption {
            yieldOnPoll: vimService.vim.BoolOption;
         }
         interface VirtualSoundBlaster16 extends vimService.vim.VirtualSoundCard {
         }
         interface VirtualSoundBlaster16Option extends vimService.vim.VirtualSoundCardOption {
         }
         interface VirtualSoundCardDeviceBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualSoundCard extends vimService.vim.VirtualDevice {
         }
         interface VirtualSoundCardDeviceBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualSoundCardOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualSriovEthernetCardSriovBackingInfo extends vimService.vim.VirtualDeviceBackingInfo {
            physicalFunctionBacking?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionBacking?: vimService.vim.VirtualPCIPassthroughDeviceBackingInfo;
            virtualFunctionIndex?: number;
         }
         interface VirtualSriovEthernetCard extends vimService.vim.VirtualEthernetCard {
            allowGuestOSMtuChange?: boolean;
            sriovBacking?: vimService.vim.VirtualSriovEthernetCardSriovBackingInfo;
         }
         interface VirtualSriovEthernetCardSriovBackingOption extends vimService.vim.VirtualDeviceBackingOption {
         }
         interface VirtualSriovEthernetCardOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface VirtualUSBUSBBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
         }
         interface VirtualUSBRemoteHostBackingInfo extends vimService.vim.VirtualDeviceDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSBRemoteClientBackingInfo extends vimService.vim.VirtualDeviceRemoteDeviceBackingInfo {
            hostname: string;
         }
         interface VirtualUSB extends vimService.vim.VirtualDevice {
            connected: boolean;
            vendor?: number;
            product?: number;
            family?: Array<string>;
            speed?: Array<string>;
         }
         interface VirtualUSBControllerPciBusSlotInfo extends vimService.vim.VirtualDevicePciBusSlotInfo {
            ehciPciSlotNumber?: number;
         }
         interface VirtualUSBController extends vimService.vim.VirtualController {
            autoConnectDevices?: boolean;
            ehciEnabled?: boolean;
         }
         interface VirtualUSBControllerOption extends vimService.vim.VirtualControllerOption {
            autoConnectDevices: vimService.vim.BoolOption;
            ehciSupported: vimService.vim.BoolOption;
            supportedSpeeds?: Array<string>;
         }
         interface VirtualUSBUSBBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteHostBackingOption extends vimService.vim.VirtualDeviceDeviceBackingOption {
         }
         interface VirtualUSBRemoteClientBackingOption extends vimService.vim.VirtualDeviceRemoteDeviceBackingOption {
         }
         interface VirtualUSBOption extends vimService.vim.VirtualDeviceOption {
         }
         interface VirtualUSBXHCIController extends vimService.vim.VirtualController {
            autoConnectDevices?: boolean;
         }
         interface VirtualUSBXHCIControllerOption extends vimService.vim.VirtualControllerOption {
            autoConnectDevices: vimService.vim.BoolOption;
            supportedSpeeds: Array<string>;
         }
         enum VirtualMachineVMCIDeviceAction {
            "allow",
            "deny",
         }
         enum VirtualMachineVMCIDeviceProtocol {
            "hypervisor",
            "doorbell",
            "queuepair",
            "datagram",
            "stream",
            "anyProtocol",
         }
         enum VirtualMachineVMCIDeviceDirection {
            "guest",
            "host",
            "anyDirection",
         }
         interface VirtualMachineVMCIDeviceFilterSpec extends vimService.vim.DynamicData {
            rank: number;
            action: string;
            protocol: string;
            direction: string;
            lowerDstPortBoundary?: number;
            upperDstPortBoundary?: number;
         }
         interface ArrayOfVirtualMachineVMCIDeviceFilterSpec {
            virtualMachineVMCIDeviceFilterSpec?: Array<vimService.vim.VirtualMachineVMCIDeviceFilterSpec>;
         }
         interface VirtualMachineVMCIDeviceFilterInfo extends vimService.vim.DynamicData {
            filters?: Array<vimService.vim.VirtualMachineVMCIDeviceFilterSpec>;
         }
         interface VirtualMachineVMCIDevice extends vimService.vim.VirtualDevice {
            id?: number;
            allowUnrestrictedCommunication?: boolean;
            filterEnable?: boolean;
            filterInfo?: vimService.vim.VirtualMachineVMCIDeviceFilterInfo;
         }
         interface VirtualMachineVMCIDeviceOptionFilterSpecOption extends vimService.vim.DynamicData {
            action: vimService.vim.ChoiceOption;
            protocol: vimService.vim.ChoiceOption;
            direction: vimService.vim.ChoiceOption;
            lowerDstPortBoundary: vimService.vim.LongOption;
            upperDstPortBoundary: vimService.vim.LongOption;
         }
         interface VirtualMachineVMCIDeviceOption extends vimService.vim.VirtualDeviceOption {
            allowUnrestrictedCommunication: vimService.vim.BoolOption;
            filterSpecOption?: vimService.vim.VirtualMachineVMCIDeviceOptionFilterSpecOption;
            filterSupported?: vimService.vim.BoolOption;
         }
         interface VirtualMachineVMIROM extends vimService.vim.VirtualDevice {
         }
         interface VirtualVMIROMOption extends vimService.vim.VirtualDeviceOption {
         }
         enum VirtualMachineVideoCardUse3dRenderer {
            "automatic",
            "software",
            "hardware",
         }
         interface VirtualMachineVideoCard extends vimService.vim.VirtualDevice {
            videoRamSizeInKB?: number;
            numDisplays?: number;
            useAutoDetect?: boolean;
            enable3DSupport?: boolean;
            use3dRenderer?: string;
            graphicsMemorySizeInKB?: number;
         }
         interface VirtualVideoCardOption extends vimService.vim.VirtualDeviceOption {
            videoRamSizeInKB?: vimService.vim.LongOption;
            numDisplays?: vimService.vim.IntOption;
            useAutoDetect?: vimService.vim.BoolOption;
            support3D?: vimService.vim.BoolOption;
            use3dRendererSupported?: vimService.vim.BoolOption;
            graphicsMemorySizeInKB?: vimService.vim.LongOption;
            graphicsMemorySizeSupported?: vimService.vim.BoolOption;
         }
         interface VirtualVmxnet extends vimService.vim.VirtualEthernetCard {
         }
         interface VirtualVmxnet2 extends vimService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet2Option extends vimService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnet3 extends vimService.vim.VirtualVmxnet {
         }
         interface VirtualVmxnet3Option extends vimService.vim.VirtualVmxnetOption {
         }
         interface VirtualVmxnetOption extends vimService.vim.VirtualEthernetCardOption {
         }
         interface GuestAuthSubject extends vimService.vim.DynamicData {
         }
         interface ArrayOfGuestAuthSubject {
            guestAuthSubject?: Array<vimService.vim.GuestAuthSubject>;
         }
         interface GuestAuthAnySubject extends vimService.vim.GuestAuthSubject {
         }
         interface GuestAuthNamedSubject extends vimService.vim.GuestAuthSubject {
            name: string;
         }
         interface GuestAuthAliasInfo extends vimService.vim.DynamicData {
            subject: vimService.vim.GuestAuthSubject;
            comment: string;
         }
         interface ArrayOfGuestAuthAliasInfo {
            guestAuthAliasInfo?: Array<vimService.vim.GuestAuthAliasInfo>;
         }
         interface GuestAliases extends vimService.vim.DynamicData {
            base64Cert: string;
            aliases: Array<vimService.vim.GuestAuthAliasInfo>;
         }
         interface ArrayOfGuestAliases {
            guestAliases?: Array<vimService.vim.GuestAliases>;
         }
         interface GuestMappedAliases extends vimService.vim.DynamicData {
            base64Cert: string;
            username: string;
            subjects: Array<vimService.vim.GuestAuthSubject>;
         }
         interface ArrayOfGuestMappedAliases {
            guestMappedAliases?: Array<vimService.vim.GuestMappedAliases>;
         }
         interface GuestFileAttributes extends vimService.vim.DynamicData {
            modificationTime?: Date;
            accessTime?: Date;
            symlinkTarget?: string;
         }
         interface GuestPosixFileAttributes extends vimService.vim.GuestFileAttributes {
            ownerId?: number;
            groupId?: number;
            permissions?: number;
         }
         interface GuestWindowsFileAttributes extends vimService.vim.GuestFileAttributes {
            hidden?: boolean;
            readOnly?: boolean;
            createTime?: Date;
         }
         enum GuestFileType {
            "file",
            "directory",
            "symlink",
         }
         interface GuestFileInfo extends vimService.vim.DynamicData {
            path: string;
            type: string;
            size: number;
            attributes: vimService.vim.GuestFileAttributes;
         }
         interface ArrayOfGuestFileInfo {
            guestFileInfo?: Array<vimService.vim.GuestFileInfo>;
         }
         interface GuestListFileInfo extends vimService.vim.DynamicData {
            files?: Array<vimService.vim.GuestFileInfo>;
            remaining: number;
         }
         interface FileTransferInformation extends vimService.vim.DynamicData {
            attributes: vimService.vim.GuestFileAttributes;
            size: number;
            url: string;
         }
         interface GuestAuthentication extends vimService.vim.DynamicData {
            interactiveSession: boolean;
         }
         interface NamePasswordAuthentication extends vimService.vim.GuestAuthentication {
            username: string;
            password: string;
         }
         interface GuestProgramSpec extends vimService.vim.DynamicData {
            programPath: string;
            arguments: string;
            workingDirectory?: string;
            envVariables?: Array<string>;
         }
         interface GuestWindowsProgramSpec extends vimService.vim.GuestProgramSpec {
            startMinimized: boolean;
         }
         interface GuestProcessInfo extends vimService.vim.DynamicData {
            name: string;
            pid: number;
            owner: string;
            cmdLine: string;
            startTime: Date;
            endTime?: Date;
            exitCode?: number;
         }
         interface ArrayOfGuestProcessInfo {
            guestProcessInfo?: Array<vimService.vim.GuestProcessInfo>;
         }
         interface SAMLTokenAuthentication extends vimService.vim.GuestAuthentication {
            token: string;
            username?: string;
         }
         interface SSPIAuthentication extends vimService.vim.GuestAuthentication {
            sspiToken: string;
         }
         interface TicketedSessionAuthentication extends vimService.vim.GuestAuthentication {
            ticket: string;
         }
         enum GuestRegKeyWowSpec {
            "WOWNative",
            "WOW32",
            "WOW64",
         }
         interface GuestRegKeyNameSpec extends vimService.vim.DynamicData {
            registryPath: string;
            wowBitness: string;
         }
         interface GuestRegKeySpec extends vimService.vim.DynamicData {
            keyName: vimService.vim.GuestRegKeyNameSpec;
            classType: string;
            lastWritten: Date;
         }
         interface GuestRegKeyRecordSpec extends vimService.vim.DynamicData {
            key: vimService.vim.GuestRegKeySpec;
            fault?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfGuestRegKeyRecordSpec {
            guestRegKeyRecordSpec?: Array<vimService.vim.GuestRegKeyRecordSpec>;
         }
         interface GuestRegValueNameSpec extends vimService.vim.DynamicData {
            keyName: vimService.vim.GuestRegKeyNameSpec;
            name: string;
         }
         interface GuestRegValueDataSpec extends vimService.vim.DynamicData {
         }
         interface GuestRegValueDwordSpec extends vimService.vim.GuestRegValueDataSpec {
            value: number;
         }
         interface GuestRegValueQwordSpec extends vimService.vim.GuestRegValueDataSpec {
            value: number;
         }
         interface GuestRegValueStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueExpandStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueMultiStringSpec extends vimService.vim.GuestRegValueDataSpec {
            value?: Array<string>;
         }
         interface GuestRegValueBinarySpec extends vimService.vim.GuestRegValueDataSpec {
            value?: string;
         }
         interface GuestRegValueSpec extends vimService.vim.DynamicData {
            name: vimService.vim.GuestRegValueNameSpec;
            data: vimService.vim.GuestRegValueDataSpec;
         }
         interface ArrayOfGuestRegValueSpec {
            guestRegValueSpec?: Array<vimService.vim.GuestRegValueSpec>;
         }
         interface VsanClusterConfigInfoHostDefaultInfo extends vimService.vim.DynamicData {
            uuid?: string;
            autoClaimStorage?: boolean;
            checksumEnabled?: boolean;
         }
         interface VsanClusterConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            defaultConfig?: vimService.vim.VsanClusterConfigInfoHostDefaultInfo;
         }
         interface VsanHostClusterStatusStateCompletionEstimate extends vimService.vim.DynamicData {
            completeTime?: Date;
            percentComplete?: number;
         }
         interface VsanHostClusterStatusState extends vimService.vim.DynamicData {
            state: string;
            completion?: vimService.vim.VsanHostClusterStatusStateCompletionEstimate;
         }
         interface VsanHostClusterStatus extends vimService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
            health: string;
            nodeState: vimService.vim.VsanHostClusterStatusState;
            memberUuid?: Array<string>;
         }
         interface VsanHostConfigInfoStorageInfo extends vimService.vim.DynamicData {
            autoClaimStorage?: boolean;
            diskMapping?: Array<vimService.vim.VsanHostDiskMapping>;
            diskMapInfo?: Array<vimService.vim.VsanHostDiskMapInfo>;
            checksumEnabled?: boolean;
         }
         interface VsanHostConfigInfoClusterInfo extends vimService.vim.DynamicData {
            uuid?: string;
            nodeUuid?: string;
         }
         interface VsanHostConfigInfoNetworkInfoPortConfig extends vimService.vim.DynamicData {
            ipConfig?: vimService.vim.VsanHostIpConfig;
            device: string;
         }
         interface ArrayOfVsanHostConfigInfoNetworkInfoPortConfig {
            vsanHostConfigInfoNetworkInfoPortConfig?: Array<vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostConfigInfoNetworkInfo extends vimService.vim.DynamicData {
            port?: Array<vimService.vim.VsanHostConfigInfoNetworkInfoPortConfig>;
         }
         interface VsanHostFaultDomainInfo extends vimService.vim.DynamicData {
            name: string;
         }
         interface VsanHostConfigInfo extends vimService.vim.DynamicData {
            enabled?: boolean;
            hostSystem?: vimService.vim.ManagedObjectReference;
            clusterInfo?: vimService.vim.VsanHostConfigInfoClusterInfo;
            storageInfo?: vimService.vim.VsanHostConfigInfoStorageInfo;
            networkInfo?: vimService.vim.VsanHostConfigInfoNetworkInfo;
            faultDomainInfo?: vimService.vim.VsanHostFaultDomainInfo;
         }
         interface ArrayOfVsanHostConfigInfo {
            vsanHostConfigInfo?: Array<vimService.vim.VsanHostConfigInfo>;
         }
         enum VsanHostDecommissionModeObjectAction {
            "noAction",
            "ensureObjectAccessibility",
            "evacuateAllData",
         }
         interface VsanHostDecommissionMode extends vimService.vim.DynamicData {
            objectAction: string;
         }
         interface VsanHostDiskMapInfo extends vimService.vim.DynamicData {
            mapping: vimService.vim.VsanHostDiskMapping;
            mounted: boolean;
         }
         interface ArrayOfVsanHostDiskMapInfo {
            vsanHostDiskMapInfo?: Array<vimService.vim.VsanHostDiskMapInfo>;
         }
         interface VsanHostDiskMapResult extends vimService.vim.DynamicData {
            mapping: vimService.vim.VsanHostDiskMapping;
            diskResult?: Array<vimService.vim.VsanHostDiskResult>;
            error?: vimService.vim.LocalizedMethodFault;
         }
         interface ArrayOfVsanHostDiskMapResult {
            vsanHostDiskMapResult?: Array<vimService.vim.VsanHostDiskMapResult>;
         }
         interface VsanHostDiskMapping extends vimService.vim.DynamicData {
            ssd: vimService.vim.HostScsiDisk;
            nonSsd: Array<vimService.vim.HostScsiDisk>;
         }
         interface ArrayOfVsanHostDiskMapping {
            vsanHostDiskMapping?: Array<vimService.vim.VsanHostDiskMapping>;
         }
         enum VsanHostDiskResultState {
            "inUse",
            "eligible",
            "ineligible",
         }
         interface VsanHostDiskResult extends vimService.vim.DynamicData {
            disk: vimService.vim.HostScsiDisk;
            state: string;
            vsanUuid?: string;
            error?: vimService.vim.LocalizedMethodFault;
            degraded?: boolean;
         }
         interface ArrayOfVsanHostDiskResult {
            vsanHostDiskResult?: Array<vimService.vim.VsanHostDiskResult>;
         }
         enum VsanHostHealthState {
            "unknown",
            "healthy",
            "unhealthy",
         }
         interface VsanHostIpConfig extends vimService.vim.DynamicData {
            upstreamIpAddress: string;
            downstreamIpAddress: string;
         }
         interface VsanHostMembershipInfo extends vimService.vim.DynamicData {
            nodeUuid: string;
            hostname: string;
         }
         interface ArrayOfVsanHostMembershipInfo {
            vsanHostMembershipInfo?: Array<vimService.vim.VsanHostMembershipInfo>;
         }
         enum VsanHostNodeState {
            "error",
            "disabled",
            "agent",
            "master",
            "backup",
            "starting",
            "stopping",
            "enteringMaintenanceMode",
            "exitingMaintenanceMode",
            "decommissioning",
         }
         interface VsanHostVsanDiskInfo extends vimService.vim.DynamicData {
            vsanUuid: string;
            formatVersion: number;
         }
         enum VsanDiskIssueType {
            "nonExist",
            "stampMismatch",
            "unknown",
         }
         interface VsanHostRuntimeInfoDiskIssue extends vimService.vim.DynamicData {
            diskId: string;
            issue: string;
         }
         interface ArrayOfVsanHostRuntimeInfoDiskIssue {
            vsanHostRuntimeInfoDiskIssue?: Array<vimService.vim.VsanHostRuntimeInfoDiskIssue>;
         }
         interface VsanHostRuntimeInfo extends vimService.vim.DynamicData {
            membershipList?: Array<vimService.vim.VsanHostMembershipInfo>;
            diskIssues?: Array<vimService.vim.VsanHostRuntimeInfoDiskIssue>;
            accessGenNo?: number;
         }
         interface ID extends vimService.vim.DynamicData {
            id: string;
         }
      }
      interface vimPort {
         addAuthorizationRole(_this: vimService.vim.ManagedObjectReference, name: string, privIds: Array<string>): Promise<number>;
         removeAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, failIfUsed: boolean): Promise<void>;
         updateAuthorizationRole(_this: vimService.vim.ManagedObjectReference, roleId: number, newName: string, privIds: Array<string>): Promise<void>;
         mergePermissions(_this: vimService.vim.ManagedObjectReference, srcRoleId: number, dstRoleId: number): Promise<void>;
         retrieveRolePermissions(_this: vimService.vim.ManagedObjectReference, roleId: number): Promise<Array<vimService.vim.Permission>>;
         retrieveEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, inherited: boolean): Promise<Array<vimService.vim.Permission>>;
         retrieveAllPermissions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Permission>>;
         setEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         resetEntityPermissions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, permission: Array<vimService.vim.Permission>): Promise<void>;
         removeEntityPermission(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, user: string, isGroup: boolean): Promise<void>;
         hasPrivilegeOnEntity(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, sessionId: string, privId: Array<string>): Promise<Array<boolean>>;
         hasPrivilegeOnEntities(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>, sessionId: string, privId: Array<string>): Promise<Array<vimService.vim.EntityPrivilege>>;
         certMgrRefreshCACertificatesAndCRLsTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRefreshCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         certMgrRevokeCertificatesTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureClusterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ClusterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         applyRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         cancelRecommendation(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         recommendHostsForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterHostRecommendation>>;
         addHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, asConnected: boolean, resourcePool: vimService.vim.ManagedObjectReference, license: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         moveHostIntoTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, resourcePool: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         refreshRecommendation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         evcManager(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         retrieveDasAdvancedRuntimeInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterDasAdvancedRuntimeInfo>;
         clusterEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ClusterEnterMaintenanceResult>;
         placeVm(_this: vimService.vim.ManagedObjectReference, placementSpec: vimService.vim.PlacementSpec): Promise<vimService.vim.PlacementResult>;
         findRulesForVm(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterRuleInfo>>;
         stampAllRulesWithUuidTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         getResourceUsage(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ClusterResourceUsageSummary>;
         reconfigureComputeResourceTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ComputeResourceConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         addCustomFieldDef(_this: vimService.vim.ManagedObjectReference, name: string, moType: string, fieldDefPolicy: vimService.vim.PrivilegePolicyDef, fieldPolicy: vimService.vim.PrivilegePolicyDef): Promise<vimService.vim.CustomFieldDef>;
         removeCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         renameCustomFieldDef(_this: vimService.vim.ManagedObjectReference, key: number, name: string): Promise<void>;
         setField(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, key: number, value: string): Promise<void>;
         doesCustomizationSpecExist(_this: vimService.vim.ManagedObjectReference, name: string): Promise<boolean>;
         getCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.CustomizationSpecItem>;
         createCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         overwriteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<void>;
         deleteCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string): Promise<void>;
         duplicateCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         renameCustomizationSpec(_this: vimService.vim.ManagedObjectReference, name: string, newName: string): Promise<void>;
         customizationSpecItemToXml(_this: vimService.vim.ManagedObjectReference, item: vimService.vim.CustomizationSpecItem): Promise<string>;
         xmlToCustomizationSpecItem(_this: vimService.vim.ManagedObjectReference, specItemXml: string): Promise<vimService.vim.CustomizationSpecItem>;
         checkCustomizationResources(_this: vimService.vim.ManagedObjectReference, guestOs: string): Promise<void>;
         queryConnectionInfo(_this: vimService.vim.ManagedObjectReference, hostname: string, port: number, username: string, password: string, sslThumbprint: string): Promise<vimService.vim.HostConnectInfo>;
         queryConnectionInfoViaSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec): Promise<vimService.vim.HostConnectInfo>;
         powerOnMultiVMTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, option: Array<vimService.vim.OptionValue>): Promise<vimService.vim.ManagedObjectReference>;
         queryDatacenterConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         reconfigureDatacenterTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DatacenterConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         refreshDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         refreshDatastoreStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateVirtualMachineFilesTask(_this: vimService.vim.ManagedObjectReference, mountPathDatastoreMapping: Array<vimService.vim.DatastoreMountPathDatastorePair>): Promise<vimService.vim.ManagedObjectReference>;
         renameDatastore(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<void>;
         destroyDatastore(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         datastoreEnterMaintenanceMode(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StoragePlacementResult>;
         datastoreExitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDirectory(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, displayName: string, policy: string): Promise<string>;
         deleteDirectory(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         queryDescriptions(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.DiagnosticManagerLogDescriptor>>;
         browseDiagnosticLog(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, key: string, start: number, lines: number): Promise<vimService.vim.DiagnosticManagerLogHeader>;
         generateLogBundlesTask(_this: vimService.vim.ManagedObjectReference, includeDefault: boolean, host: Array<vimService.vim.ManagedObjectReference>, supportOptions: Array<vimService.vim.KeyValue>): Promise<vimService.vim.ManagedObjectReference>;
         fetchDVPortKeys(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<string>>;
         fetchDVPorts(_this: vimService.vim.ManagedObjectReference, criteria: vimService.vim.DistributedVirtualSwitchPortCriteria): Promise<Array<vimService.vim.DistributedVirtualPort>>;
         queryUsedVlanIdInDvs(_this: vimService.vim.ManagedObjectReference): Promise<Array<number>>;
         reconfigureDvsTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         performDvsProductSpecOperationTask(_this: vimService.vim.ManagedObjectReference, operation: string, productSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.ManagedObjectReference>;
         mergeDvsTask(_this: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         addDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.DVPortgroupConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         moveDVPortTask(_this: vimService.vim.ManagedObjectReference, portKey: Array<string>, destinationPortgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDvsCapability(_this: vimService.vim.ManagedObjectReference, capability: vimService.vim.DVSCapability): Promise<void>;
         reconfigureDVPortTask(_this: vimService.vim.ManagedObjectReference, port: Array<vimService.vim.DVPortConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         refreshDVPortState(_this: vimService.vim.ManagedObjectReference, portKeys: Array<string>): Promise<void>;
         rectifyDvsHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         updateNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         addNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DVSNetworkResourcePoolConfigSpec>): Promise<void>;
         removeNetworkResourcePool(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         dvsReconfigureVmVnicNetworkResourcePoolTask(_this: vimService.vim.ManagedObjectReference, configSpec: Array<vimService.vim.DvsVmVnicResourcePoolConfigSpec>): Promise<vimService.vim.ManagedObjectReference>;
         enableNetworkResourceManagement(_this: vimService.vim.ManagedObjectReference, enable: boolean): Promise<void>;
         dVSRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         createDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSHealthCheckConfigTask(_this: vimService.vim.ManagedObjectReference, healthCheckConfig: Array<vimService.vim.DVSHealthCheckConfig>): Promise<vimService.vim.ManagedObjectReference>;
         lookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         queryConfigOptionDescriptor(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualMachineConfigOptionDescriptor>>;
         queryConfigOption(_this: vimService.vim.ManagedObjectReference, key: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigOptionEx(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.EnvironmentBrowserConfigOptionQuerySpec): Promise<vimService.vim.VirtualMachineConfigOption>;
         queryConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ConfigTarget>;
         queryTargetCapabilities(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostCapability>;
         setCustomValue(_this: vimService.vim.ManagedObjectReference, key: string, value: string): Promise<void>;
         unregisterExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<void>;
         findExtension(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<vimService.vim.Extension>;
         registerExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         updateExtension(_this: vimService.vim.ManagedObjectReference, extension: vimService.vim.Extension): Promise<void>;
         getPublicKey(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         setPublicKey(_this: vimService.vim.ManagedObjectReference, extensionKey: string, publicKey: string): Promise<void>;
         setExtensionCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, certificatePem: string): Promise<void>;
         queryManagedBy(_this: vimService.vim.ManagedObjectReference, extensionKey: string): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryExtensionIpAllocationUsage(_this: vimService.vim.ManagedObjectReference, extensionKeys: Array<string>): Promise<Array<vimService.vim.ExtensionManagerIpAllocationUsage>>;
         moveDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         copyDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destinationName: string, destinationDatacenter: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         deleteDatastoreFileTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makeDirectory(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, createParentDirectories: boolean): Promise<void>;
         changeOwner(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, owner: string): Promise<void>;
         createFolder(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         moveIntoFolderTask(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, asTemplate: boolean, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createCluster(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         createClusterEx(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ClusterConfigSpecEx): Promise<vimService.vim.ManagedObjectReference>;
         addStandaloneHostTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostConnectSpec, compResSpec: vimService.vim.ComputeResourceConfigSpec, addConnected: boolean, license: string): Promise<vimService.vim.ManagedObjectReference>;
         createDatacenter(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         unregisterAndDestroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createDVSTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVSCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         createStoragePod(_this: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         setCollectorPageSize(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<void>;
         rewindCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryTpmAttestationReport(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostTpmAttestationReport>;
         queryHostConnectionInfo(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostConnectInfo>;
         updateSystemResources(_this: vimService.vim.ManagedObjectReference, resourceInfo: vimService.vim.HostSystemResourceInfo): Promise<void>;
         updateSystemSwapConfiguration(_this: vimService.vim.ManagedObjectReference, sysSwapConfig: vimService.vim.HostSystemSwapConfiguration): Promise<void>;
         reconnectHostTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec, reconnectSpec: vimService.vim.HostSystemReconnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         disconnectHostTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enterMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number, evacuatePoweredOffVms: boolean, maintenanceSpec: vimService.vim.HostMaintenanceSpec): Promise<vimService.vim.ManagedObjectReference>;
         exitMaintenanceModeTask(_this: vimService.vim.ManagedObjectReference, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         rebootHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         shutdownHostTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerDownHostToStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number, evacuatePoweredOffVms: boolean): Promise<vimService.vim.ManagedObjectReference>;
         powerUpHostFromStandByTask(_this: vimService.vim.ManagedObjectReference, timeoutSec: number): Promise<vimService.vim.ManagedObjectReference>;
         queryMemoryOverhead(_this: vimService.vim.ManagedObjectReference, memorySize: number, videoRamSize: number, numVcpus: number): Promise<number>;
         queryMemoryOverheadEx(_this: vimService.vim.ManagedObjectReference, vmConfigInfo: vimService.vim.VirtualMachineConfigInfo): Promise<number>;
         reconfigureHostForDASTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         updateFlags(_this: vimService.vim.ManagedObjectReference, flagInfo: vimService.vim.HostFlagInfo): Promise<void>;
         enterLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         exitLockdownMode(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireCimServicesTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostServiceTicket>;
         updateIpmi(_this: vimService.vim.ManagedObjectReference, ipmiInfo: vimService.vim.HostIpmiInfo): Promise<void>;
         retrieveHardwareUptime(_this: vimService.vim.ManagedObjectReference): Promise<number>;
         httpNfcLeaseGetManifest(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HttpNfcLeaseManifestEntry>>;
         httpNfcLeaseComplete(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         httpNfcLeaseAbort(_this: vimService.vim.ManagedObjectReference, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         httpNfcLeaseProgress(_this: vimService.vim.ManagedObjectReference, percent: number): Promise<void>;
         installIoFilterTask(_this: vimService.vim.ManagedObjectReference, vibUrl: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         uninstallIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         upgradeIoFilterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference, vibUrl: string): Promise<vimService.vim.ManagedObjectReference>;
         queryIoFilterIssues(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<vimService.vim.IoFilterQueryIssueResult>;
         queryIoFilterInfo(_this: vimService.vim.ManagedObjectReference, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ClusterIoFilterInfo>>;
         resolveInstallationErrorsOnHostTask(_this: vimService.vim.ManagedObjectReference, filterId: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resolveInstallationErrorsOnClusterTask(_this: vimService.vim.ManagedObjectReference, filterId: string, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryDisksUsingFilter(_this: vimService.vim.ManagedObjectReference, filterId: string, compRes: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VirtualDiskId>>;
         queryIpPools(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.IpPool>>;
         createIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<number>;
         updateIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, pool: vimService.vim.IpPool): Promise<void>;
         destroyIpPool(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, id: number, force: boolean): Promise<void>;
         allocateIpv4Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         allocateIpv6Address(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<string>;
         releaseIpAllocation(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, allocationId: string): Promise<void>;
         queryIPAllocations(_this: vimService.vim.ManagedObjectReference, dc: vimService.vim.ManagedObjectReference, poolId: number, extensionKey: string): Promise<Array<vimService.vim.IpPoolManagerIpAllocation>>;
         updateAssignedLicense(_this: vimService.vim.ManagedObjectReference, entity: string, licenseKey: string, entityDisplayName: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeAssignedLicense(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<void>;
         queryAssignedLicenses(_this: vimService.vim.ManagedObjectReference, entityId: string): Promise<Array<vimService.vim.LicenseAssignmentManagerLicenseAssignment>>;
         querySupportedFeatures(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseFeatureInfo>>;
         queryLicenseSourceAvailability(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LicenseAvailabilityInfo>>;
         queryLicenseUsage(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.LicenseUsageInfo>;
         setLicenseEdition(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<void>;
         checkLicenseFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         enableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         disableFeature(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, featureKey: string): Promise<boolean>;
         configureLicenseSource(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, licenseSource: vimService.vim.LicenseSource): Promise<void>;
         updateLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         addLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labels: Array<vimService.vim.KeyValue>): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         removeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<void>;
         decodeLicense(_this: vimService.vim.ManagedObjectReference, licenseKey: string): Promise<vimService.vim.LicenseManagerLicenseInfo>;
         updateLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string, labelValue: string): Promise<void>;
         removeLicenseLabel(_this: vimService.vim.ManagedObjectReference, licenseKey: string, labelKey: string): Promise<void>;
         reload(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         renameTask(_this: vimService.vim.ManagedObjectReference, newName: string): Promise<vimService.vim.ManagedObjectReference>;
         destroyTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyNetwork(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         lookupVmOverheadMemory(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<number>;
         validateHost(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, host: vimService.vim.ManagedObjectReference, vhp: vimService.vim.OvfValidateHostParams): Promise<vimService.vim.OvfValidateHostResult>;
         parseDescriptor(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, pdp: vimService.vim.OvfParseDescriptorParams): Promise<vimService.vim.OvfParseDescriptorResult>;
         createImportSpec(_this: vimService.vim.ManagedObjectReference, ovfDescriptor: string, resourcePool: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, cisp: vimService.vim.OvfCreateImportSpecParams): Promise<vimService.vim.OvfCreateImportSpecResult>;
         createDescriptor(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, cdp: vimService.vim.OvfCreateDescriptorParams): Promise<vimService.vim.OvfCreateDescriptorResult>;
         queryPerfProviderSummary(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<vimService.vim.PerfProviderSummary>;
         queryAvailablePerfMetric(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, beginTime: Date, endTime: Date, intervalId: number): Promise<Array<vimService.vim.PerfMetricId>>;
         queryPerfCounter(_this: vimService.vim.ManagedObjectReference, counterId: Array<number>): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerfCounterByLevel(_this: vimService.vim.ManagedObjectReference, level: number): Promise<Array<vimService.vim.PerfCounterInfo>>;
         queryPerf(_this: vimService.vim.ManagedObjectReference, querySpec: Array<vimService.vim.PerfQuerySpec>): Promise<Array<vimService.vim.PerfEntityMetricBase>>;
         queryPerfComposite(_this: vimService.vim.ManagedObjectReference, querySpec: vimService.vim.PerfQuerySpec): Promise<vimService.vim.PerfCompositeMetric>;
         createPerfInterval(_this: vimService.vim.ManagedObjectReference, intervalId: vimService.vim.PerfInterval): Promise<void>;
         removePerfInterval(_this: vimService.vim.ManagedObjectReference, samplePeriod: number): Promise<void>;
         updatePerfInterval(_this: vimService.vim.ManagedObjectReference, interval: vimService.vim.PerfInterval): Promise<void>;
         updateCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counterLevelMap: Array<vimService.vim.PerformanceManagerCounterLevelMapping>): Promise<void>;
         resetCounterLevelMapping(_this: vimService.vim.ManagedObjectReference, counters: Array<number>): Promise<void>;
         estimateDatabaseSize(_this: vimService.vim.ManagedObjectReference, dbSizeParam: vimService.vim.DatabaseSizeParam): Promise<vimService.vim.DatabaseSizeEstimate>;
         updateConfig(_this: vimService.vim.ManagedObjectReference, name: string, config: vimService.vim.ResourceConfigSpec): Promise<void>;
         moveIntoResourcePool(_this: vimService.vim.ManagedObjectReference, list: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         updateChildResourceConfiguration(_this: vimService.vim.ManagedObjectReference, spec: Array<vimService.vim.ResourceConfigSpec>): Promise<void>;
         createResourcePool(_this: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.ResourceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         destroyChildren(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createVApp(_this: vimService.vim.ManagedObjectReference, name: string, resSpec: vimService.vim.ResourceConfigSpec, configSpec: vimService.vim.VAppConfigSpec, vmFolder: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createChildVMTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VirtualMachineConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         registerChildVMTask(_this: vimService.vim.ManagedObjectReference, path: string, name: string, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         importVApp(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ImportSpec, folder: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryResourceConfigOption(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ResourceConfigOption>;
         refreshRuntime(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         findByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByDatastorePath(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, path: string): Promise<vimService.vim.ManagedObjectReference>;
         findByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<vimService.vim.ManagedObjectReference>;
         findByInventoryPath(_this: vimService.vim.ManagedObjectReference, inventoryPath: string): Promise<vimService.vim.ManagedObjectReference>;
         findChild(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, name: string): Promise<vimService.vim.ManagedObjectReference>;
         findAllByUuid(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, uuid: string, vmSearch: boolean, instanceUuid: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByDnsName(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, dnsName: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         findAllByIp(_this: vimService.vim.ManagedObjectReference, datacenter: vimService.vim.ManagedObjectReference, ip: string, vmSearch: boolean): Promise<Array<vimService.vim.ManagedObjectReference>>;
         currentTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         retrieveServiceContent(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ServiceContent>;
         validateMigration(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.Event>>;
         queryVMotionCompatibility(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>, compatibility: Array<string>): Promise<Array<vimService.vim.HostVMotionCompatibility>>;
         retrieveProductComponents(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProductComponentInfo>>;
         queryServiceList(_this: vimService.vim.ManagedObjectReference, serviceName: string, location: Array<string>): Promise<Array<vimService.vim.ServiceManagerServiceInfo>>;
         updateServiceMessage(_this: vimService.vim.ManagedObjectReference, message: string): Promise<void>;
         loginByToken(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<vimService.vim.UserSession>;
         login(_this: vimService.vim.ManagedObjectReference, userName: string, password: string, locale: string): Promise<vimService.vim.UserSession>;
         loginBySSPI(_this: vimService.vim.ManagedObjectReference, base64Token: string, locale: string): Promise<vimService.vim.UserSession>;
         logout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         acquireLocalTicket(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<vimService.vim.SessionManagerLocalTicket>;
         acquireGenericServiceTicket(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.SessionManagerServiceRequestSpec): Promise<vimService.vim.SessionManagerGenericServiceTicket>;
         terminateSession(_this: vimService.vim.ManagedObjectReference, sessionId: Array<string>): Promise<void>;
         setLocale(_this: vimService.vim.ManagedObjectReference, locale: string): Promise<void>;
         loginExtensionBySubjectName(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         loginExtensionByCertificate(_this: vimService.vim.ManagedObjectReference, extensionKey: string, locale: string): Promise<vimService.vim.UserSession>;
         impersonateUser(_this: vimService.vim.ManagedObjectReference, userName: string, locale: string): Promise<vimService.vim.UserSession>;
         sessionIsActive(_this: vimService.vim.ManagedObjectReference, sessionID: string, userName: string): Promise<boolean>;
         acquireCloneTicket(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         cloneSession(_this: vimService.vim.ManagedObjectReference, cloneTicket: string): Promise<vimService.vim.UserSession>;
         executeSimpleCommand(_this: vimService.vim.ManagedObjectReference, arguments: Array<string>): Promise<string>;
         configureDatastoreIORMTask(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageIORMConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryIORMConfigOption(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.StorageIORMConfigOption>;
         queryDatastorePerformanceSummary(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.StoragePerformanceSummary>>;
         applyStorageDrsRecommendationToPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, key: string): Promise<vimService.vim.ManagedObjectReference>;
         applyStorageDrsRecommendationTask(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         cancelStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, key: Array<string>): Promise<void>;
         refreshStorageDrsRecommendation(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference): Promise<void>;
         configureStorageDrsForPodTask(_this: vimService.vim.ManagedObjectReference, pod: vimService.vim.ManagedObjectReference, spec: vimService.vim.StorageDrsConfigSpec, modify: boolean): Promise<vimService.vim.ManagedObjectReference>;
         recommendDatastores(_this: vimService.vim.ManagedObjectReference, storageSpec: vimService.vim.StoragePlacementSpec): Promise<vimService.vim.StoragePlacementResult>;
         cancelTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateProgress(_this: vimService.vim.ManagedObjectReference, percentDone: number): Promise<void>;
         setTaskState(_this: vimService.vim.ManagedObjectReference, state: vimService.vim.TaskInfoState, result: any, fault: vimService.vim.LocalizedMethodFault): Promise<void>;
         setTaskDescription(_this: vimService.vim.ManagedObjectReference, description: vimService.vim.LocalizableMessage): Promise<void>;
         readNextTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         readPreviousTasks(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.TaskInfo>>;
         createCollectorForTasks(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.TaskFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         createTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, taskTypeId: string, initiatedBy: string, cancelable: boolean, parentTaskKey: string, activationId: string): Promise<vimService.vim.TaskInfo>;
         retrieveUserGroups(_this: vimService.vim.ManagedObjectReference, domain: string, searchStr: string, belongsToGroup: string, belongsToUser: string, exactMatch: boolean, findUsers: boolean, findGroups: boolean): Promise<Array<vimService.vim.UserSearchResult>>;
         updateVAppConfig(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppConfigSpec): Promise<void>;
         updateLinkedChildren(_this: vimService.vim.ManagedObjectReference, addChangeSet: Array<vimService.vim.VirtualAppLinkInfo>, removeSet: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         cloneVAppTask(_this: vimService.vim.ManagedObjectReference, name: string, target: vimService.vim.ManagedObjectReference, spec: vimService.vim.VAppCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVApp(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOnVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVAppTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         suspendVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         unregisterVAppTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualDiskSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         moveVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, force: boolean, profile: Array<vimService.vim.VirtualMachineProfileSpec>): Promise<vimService.vim.ManagedObjectReference>;
         copyVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, sourceName: string, sourceDatacenter: vimService.vim.ManagedObjectReference, destName: string, destDatacenter: vimService.vim.ManagedObjectReference, destSpec: vimService.vim.VirtualDiskSpec, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         extendVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, newCapacityKb: number, eagerZero: boolean): Promise<vimService.vim.ManagedObjectReference>;
         queryVirtualDiskFragmentation(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<number>;
         defragmentVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shrinkVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, copy: boolean): Promise<vimService.vim.ManagedObjectReference>;
         inflateVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         eagerZeroVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         zeroFillVirtualDiskTask(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference, uuid: string): Promise<void>;
         queryVirtualDiskUuid(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<string>;
         queryVirtualDiskGeometry(_this: vimService.vim.ManagedObjectReference, name: string, datacenter: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostDiskDimensionsChs>;
         importUnmanagedSnapshot(_this: vimService.vim.ManagedObjectReference, vdisk: string, datacenter: vimService.vim.ManagedObjectReference, vvolId: string): Promise<void>;
         refreshStorageInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSnapshotTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string, memory: boolean, quiesce: boolean): Promise<vimService.vim.ManagedObjectReference>;
         revertToCurrentSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeAllSnapshotsTask(_this: vimService.vim.ManagedObjectReference, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         consolidateVMDisksTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         estimateStorageForConsolidateSnapshotsTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         reconfigVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         upgradeVMTask(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.ManagedObjectReference>;
         extractOvfEnvironment(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         powerOnVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         powerOffVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         suspendVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         resetVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         shutdownGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         rebootGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         standbyGuest(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         answerVM(_this: vimService.vim.ManagedObjectReference, questionId: string, answerChoice: string): Promise<void>;
         customizeVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<vimService.vim.ManagedObjectReference>;
         checkCustomizationSpec(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.CustomizationSpec): Promise<void>;
         migrateVMTask(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, priority: vimService.vim.VirtualMachineMovePriority, state: vimService.vim.VirtualMachinePowerState): Promise<vimService.vim.ManagedObjectReference>;
         relocateVMTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, priority: vimService.vim.VirtualMachineMovePriority): Promise<vimService.vim.ManagedObjectReference>;
         cloneVMTask(_this: vimService.vim.ManagedObjectReference, folder: vimService.vim.ManagedObjectReference, name: string, spec: vimService.vim.VirtualMachineCloneSpec): Promise<vimService.vim.ManagedObjectReference>;
         exportVm(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         markAsTemplate(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         markAsVirtualMachine(_this: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         unregisterVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetGuestInformation(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         mountToolsInstallerImage(_this: vimService.vim.ManagedObjectReference, isoImage: vimService.vim.VirtualDeviceBackingInfo, auth: vimService.vim.GuestAuthentication): Promise<void>;
         unmountToolsInstaller(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         upgradeToolsTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string): Promise<vimService.vim.ManagedObjectReference>;
         upgradeToolsFromImageTask(_this: vimService.vim.ManagedObjectReference, installerOptions: string, isoImage: vimService.vim.VirtualDeviceBackingInfo, auth: vimService.vim.GuestAuthentication): Promise<vimService.vim.ManagedObjectReference>;
         acquireMksTicket(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VirtualMachineMksTicket>;
         acquireTicket(_this: vimService.vim.ManagedObjectReference, ticketType: string): Promise<vimService.vim.VirtualMachineTicket>;
         setScreenResolution(_this: vimService.vim.ManagedObjectReference, width: number, height: number): Promise<void>;
         defragmentAllDisks(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createSecondaryVMExTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, spec: vimService.vim.FaultToleranceConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         turnOffFaultToleranceForVMTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         makePrimaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         terminateFaultTolerantVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         disableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         enableSecondaryVMTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         setDisplayTopology(_this: vimService.vim.ManagedObjectReference, displays: Array<vimService.vim.VirtualMachineDisplayTopology>): Promise<void>;
         startRecordingTask(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<vimService.vim.ManagedObjectReference>;
         stopRecordingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         startReplayingTask(_this: vimService.vim.ManagedObjectReference, replaySnapshot: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         stopReplayingTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         promoteDisksTask(_this: vimService.vim.ManagedObjectReference, unlink: boolean, disks: Array<vimService.vim.VirtualDisk>): Promise<vimService.vim.ManagedObjectReference>;
         createScreenshotTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryChangedDiskAreas(_this: vimService.vim.ManagedObjectReference, snapshot: vimService.vim.ManagedObjectReference, deviceKey: number, startOffset: number, changeId: string): Promise<vimService.vim.DiskChangeInfo>;
         queryUnownedFiles(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         reloadVirtualMachineFromPathTask(_this: vimService.vim.ManagedObjectReference, configurationPath: string): Promise<vimService.vim.ManagedObjectReference>;
         queryFaultToleranceCompatibility(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         queryFaultToleranceCompatibilityEx(_this: vimService.vim.ManagedObjectReference, forLegacyFt: boolean): Promise<Array<vimService.vim.LocalizedMethodFault>>;
         terminateVM(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         sendNMI(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         performVsanUpgradePreflightCheck(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, downgradeFormat: boolean): Promise<vimService.vim.VsanUpgradeSystemPreflightCheckResult>;
         queryVsanUpgradeStatus(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanUpgradeSystemUpgradeStatus>;
         performVsanUpgradeTask(_this: vimService.vim.ManagedObjectReference, cluster: vimService.vim.ManagedObjectReference, performObjectUpgrade: boolean, downgradeFormat: boolean, allowReducedRedundancy: boolean, excludeHosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         removeAlarm(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAlarm(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<void>;
         createAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.AlarmSpec): Promise<vimService.vim.ManagedObjectReference>;
         getAlarm(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         areAlarmActionsEnabled(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<boolean>;
         enableAlarmActions(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         getAlarmState(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.AlarmState>>;
         acknowledgeAlarm(_this: vimService.vim.ManagedObjectReference, alarm: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<void>;
         configureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         disableEvcModeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkConfigureEvcModeTask(_this: vimService.vim.ManagedObjectReference, evcModeKey: string): Promise<vimService.vim.ManagedObjectReference>;
         checkAddHostEvcTask(_this: vimService.vim.ManagedObjectReference, cnxSpec: vimService.vim.HostConnectSpec): Promise<vimService.vim.ManagedObjectReference>;
         reconfigureDVPortgroupTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.DVPortgroupConfigSpec): Promise<vimService.vim.ManagedObjectReference>;
         dVPortgroupRollbackTask(_this: vimService.vim.ManagedObjectReference, entityBackup: vimService.vim.EntityBackupConfig): Promise<vimService.vim.ManagedObjectReference>;
         queryAvailableDvsSpec(_this: vimService.vim.ManagedObjectReference, recommended: boolean): Promise<Array<vimService.vim.DistributedVirtualSwitchProductSpec>>;
         queryCompatibleHostForNewDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryCompatibleHostForExistingDvs(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, recursive: boolean, dvs: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         queryDvsCompatibleHostSpec(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<Array<vimService.vim.DistributedVirtualSwitchHostProductSpec>>;
         queryDvsFeatureCapability(_this: vimService.vim.ManagedObjectReference, switchProductSpec: vimService.vim.DistributedVirtualSwitchProductSpec): Promise<vimService.vim.DVSFeatureCapability>;
         queryDvsByUuid(_this: vimService.vim.ManagedObjectReference, uuid: string): Promise<vimService.vim.ManagedObjectReference>;
         queryDvsConfigTarget(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, dvs: vimService.vim.ManagedObjectReference): Promise<vimService.vim.DVSManagerDvsConfigTarget>;
         queryDvsCheckCompatibility(_this: vimService.vim.ManagedObjectReference, hostContainer: vimService.vim.DistributedVirtualSwitchManagerHostContainer, dvsProductSpec: vimService.vim.DistributedVirtualSwitchManagerDvsProductSpec, hostFilterSpec: Array<vimService.vim.DistributedVirtualSwitchManagerHostDvsFilterSpec>): Promise<Array<vimService.vim.DistributedVirtualSwitchManagerCompatibilityResult>>;
         rectifyDvsOnHostTask(_this: vimService.vim.ManagedObjectReference, hosts: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerExportEntityTask(_this: vimService.vim.ManagedObjectReference, selectionSet: Array<vimService.vim.SelectionSet>): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerImportEntityTask(_this: vimService.vim.ManagedObjectReference, entityBackup: Array<vimService.vim.EntityBackupConfig>, importType: string): Promise<vimService.vim.ManagedObjectReference>;
         dVSManagerLookupDvPortGroup(_this: vimService.vim.ManagedObjectReference, switchUuid: string, portgroupKey: string): Promise<vimService.vim.ManagedObjectReference>;
         updateDVSLacpGroupConfigTask(_this: vimService.vim.ManagedObjectReference, lacpGroupSpec: Array<vimService.vim.VMwareDvsLacpGroupSpec>): Promise<vimService.vim.ManagedObjectReference>;
         readNextEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         readPreviousEvents(_this: vimService.vim.ManagedObjectReference, maxCount: number): Promise<Array<vimService.vim.Event>>;
         retrieveArgumentDescription(_this: vimService.vim.ManagedObjectReference, eventTypeId: string): Promise<Array<vimService.vim.EventArgDesc>>;
         createCollectorForEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<vimService.vim.ManagedObjectReference>;
         logUserEvent(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, msg: string): Promise<void>;
         queryEvents(_this: vimService.vim.ManagedObjectReference, filter: vimService.vim.EventFilterSpec): Promise<Array<vimService.vim.Event>>;
         postEvent(_this: vimService.vim.ManagedObjectReference, eventToPost: vimService.vim.Event, taskInfo: vimService.vim.TaskInfo): Promise<void>;
         joinDomainTask(_this: vimService.vim.ManagedObjectReference, domainName: string, userName: string, password: string): Promise<vimService.vim.ManagedObjectReference>;
         joinDomainWithCAMTask(_this: vimService.vim.ManagedObjectReference, domainName: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         importCertificateForCAMTask(_this: vimService.vim.ManagedObjectReference, certPath: string, camServer: string): Promise<vimService.vim.ManagedObjectReference>;
         leaveCurrentDomainTask(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         enableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         installSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference, certs: Array<string>): Promise<void>;
         removeSmartCardTrustAnchor(_this: vimService.vim.ManagedObjectReference, issuer: string, serial: string): Promise<void>;
         removeSmartCardTrustAnchorByFingerprint(_this: vimService.vim.ManagedObjectReference, fingerprint: string, digest: string): Promise<void>;
         listSmartCardTrustAnchors(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         disableSmartCardAuthentication(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureAutostart(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostAutoStartManagerConfig): Promise<void>;
         autoStartPowerOn(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         autoStartPowerOff(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryBootDevices(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostBootDeviceInfo>;
         updateBootDevice(_this: vimService.vim.ManagedObjectReference, key: string): Promise<void>;
         configureHostCacheTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostCacheConfigurationSpec): Promise<vimService.vim.ManagedObjectReference>;
         generateCertificateSigningRequest(_this: vimService.vim.ManagedObjectReference, useIpAddressAsCommonName: boolean): Promise<string>;
         generateCertificateSigningRequestByDn(_this: vimService.vim.ManagedObjectReference, distinguishedName: string): Promise<string>;
         installServerCertificate(_this: vimService.vim.ManagedObjectReference, cert: string): Promise<void>;
         replaceCACertificatesAndCRLs(_this: vimService.vim.ManagedObjectReference, caCert: Array<string>, caCrl: Array<string>): Promise<void>;
         listCACertificates(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         listCACertificateRevocationLists(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         enableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         disableHyperThreading(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         searchDatastoreTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         searchDatastoreSubFoldersTask(_this: vimService.vim.ManagedObjectReference, datastorePath: string, searchSpec: vimService.vim.HostDatastoreBrowserSearchSpec): Promise<vimService.vim.ManagedObjectReference>;
         deleteFile(_this: vimService.vim.ManagedObjectReference, datastorePath: string): Promise<void>;
         updateLocalSwapDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableDisksForVmfs(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostScsiDisk>>;
         queryVmfsDatastoreCreateOptions(_this: vimService.vim.ManagedObjectReference, devicePath: string, vmfsMajorVersion: number): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         createVmfsDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryVmfsDatastoreExtendOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, devicePath: string, suppressExpandCandidates: boolean): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         queryVmfsDatastoreExpandOptions(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.VmfsDatastoreOption>>;
         extendVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExtendSpec): Promise<vimService.vim.ManagedObjectReference>;
         expandVmfsDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference, spec: vimService.vim.VmfsDatastoreExpandSpec): Promise<vimService.vim.ManagedObjectReference>;
         createNasDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostNasVolumeSpec): Promise<vimService.vim.ManagedObjectReference>;
         createLocalDatastore(_this: vimService.vim.ManagedObjectReference, name: string, path: string): Promise<vimService.vim.ManagedObjectReference>;
         createVvolDatastore(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDatastoreSystemVvolDatastoreSpec): Promise<vimService.vim.ManagedObjectReference>;
         removeDatastore(_this: vimService.vim.ManagedObjectReference, datastore: vimService.vim.ManagedObjectReference): Promise<void>;
         removeDatastoreExTask(_this: vimService.vim.ManagedObjectReference, datastore: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         configureDatastorePrincipal(_this: vimService.vim.ManagedObjectReference, userName: string, password: string): Promise<void>;
         queryUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resignatureUnresolvedVmfsVolumeTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: vimService.vim.HostUnresolvedVmfsResignatureSpec): Promise<vimService.vim.ManagedObjectReference>;
         updateDateTimeConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDateTimeConfig): Promise<void>;
         queryAvailableTimeZones(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDateTimeSystemTimeZone>>;
         queryDateTime(_this: vimService.vim.ManagedObjectReference): Promise<Date>;
         updateDateTime(_this: vimService.vim.ManagedObjectReference, dateTime: Date): Promise<void>;
         refreshDateTimeSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailablePartition(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostDiagnosticPartition>>;
         selectActivePartition(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition): Promise<void>;
         queryPartitionCreateOptions(_this: vimService.vim.ManagedObjectReference, storageType: string, diagnosticType: string): Promise<Array<vimService.vim.HostDiagnosticPartitionCreateOption>>;
         queryPartitionCreateDesc(_this: vimService.vim.ManagedObjectReference, diskUuid: string, diagnosticType: string): Promise<vimService.vim.HostDiagnosticPartitionCreateDescription>;
         createDiagnosticPartition(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostDiagnosticPartitionCreateSpec): Promise<void>;
         esxAgentHostManagerUpdateConfig(_this: vimService.vim.ManagedObjectReference, configInfo: vimService.vim.HostEsxAgentHostManagerConfigInfo): Promise<void>;
         updateDefaultPolicy(_this: vimService.vim.ManagedObjectReference, defaultPolicy: vimService.vim.HostFirewallDefaultPolicy): Promise<void>;
         enableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         disableRuleset(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         updateRuleset(_this: vimService.vim.ManagedObjectReference, id: string, spec: vimService.vim.HostFirewallRulesetRulesetSpec): Promise<void>;
         refreshFirewall(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetFirmwareToFactoryDefaults(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         backupFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         queryFirmwareConfigUploadURL(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         restoreFirmwareConfiguration(_this: vimService.vim.ManagedObjectReference, force: boolean): Promise<void>;
         refreshGraphicsManager(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         isSharedGraphicsActive(_this: vimService.vim.ManagedObjectReference): Promise<boolean>;
         refreshHealthStatusSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         resetSystemHealthInfo(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveHostAccessControlEntries(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostAccessControlEntry>>;
         changeAccessMode(_this: vimService.vim.ManagedObjectReference, principal: string, isGroup: boolean, accessMode: vimService.vim.HostAccessMode): Promise<void>;
         queryDcuiAccess(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateDcuiAccess(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         querySystemUsers(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateSystemUsers(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         queryLockdownExceptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<string>>;
         updateLockdownExceptions(_this: vimService.vim.ManagedObjectReference, users: Array<string>): Promise<void>;
         changeLockdownMode(_this: vimService.vim.ManagedObjectReference, mode: vimService.vim.HostLockdownMode): Promise<void>;
         hostImageConfigGetAcceptance(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         hostImageConfigGetProfile(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostImageProfileSummary>;
         updateHostImageAcceptanceLevel(_this: vimService.vim.ManagedObjectReference, newAcceptanceLevel: string): Promise<void>;
         queryVnicStatus(_this: vimService.vim.ManagedObjectReference, vnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryPnicStatus(_this: vimService.vim.ManagedObjectReference, pnicDevice: string): Promise<vimService.vim.IscsiStatus>;
         queryBoundVnics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         queryCandidateNics(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string): Promise<Array<vimService.vim.IscsiPortInfo>>;
         bindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string): Promise<void>;
         unbindVnic(_this: vimService.vim.ManagedObjectReference, iScsiHbaName: string, vnicDevice: string, force: boolean): Promise<void>;
         queryMigrationDependencies(_this: vimService.vim.ManagedObjectReference, pnicDevice: Array<string>): Promise<vimService.vim.IscsiMigrationDependency>;
         queryModules(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.KernelModuleInfo>>;
         updateModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string, options: string): Promise<void>;
         queryConfiguredModuleOptionString(_this: vimService.vim.ManagedObjectReference, name: string): Promise<string>;
         createUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         updateUser(_this: vimService.vim.ManagedObjectReference, user: vimService.vim.HostAccountSpec): Promise<void>;
         createGroup(_this: vimService.vim.ManagedObjectReference, group: vimService.vim.HostAccountSpec): Promise<void>;
         removeUser(_this: vimService.vim.ManagedObjectReference, userName: string): Promise<void>;
         removeGroup(_this: vimService.vim.ManagedObjectReference, groupName: string): Promise<void>;
         assignUserToGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         unassignUserFromGroup(_this: vimService.vim.ManagedObjectReference, user: string, group: string): Promise<void>;
         reconfigureServiceConsoleReservation(_this: vimService.vim.ManagedObjectReference, cfgBytes: number): Promise<void>;
         reconfigureVirtualMachineReservation(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineMemoryReservationSpec): Promise<void>;
         updateNetworkConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostNetworkConfig, changeMode: string): Promise<vimService.vim.HostNetworkConfigResult>;
         updateDnsConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostDnsConfig): Promise<void>;
         updateIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateConsoleIpRouteConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteConfig): Promise<void>;
         updateIpRouteTableConfig(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostIpRouteTableConfig): Promise<void>;
         addVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         removeVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string): Promise<void>;
         updateVirtualSwitch(_this: vimService.vim.ManagedObjectReference, vswitchName: string, spec: vimService.vim.HostVirtualSwitchSpec): Promise<void>;
         addPortGroup(_this: vimService.vim.ManagedObjectReference, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         removePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string): Promise<void>;
         updatePortGroup(_this: vimService.vim.ManagedObjectReference, pgName: string, portgrp: vimService.vim.HostPortGroupSpec): Promise<void>;
         updatePhysicalNicLinkSpeed(_this: vimService.vim.ManagedObjectReference, device: string, linkSpeed: vimService.vim.PhysicalNicLinkInfo): Promise<void>;
         queryNetworkHint(_this: vimService.vim.ManagedObjectReference, device: Array<string>): Promise<Array<vimService.vim.PhysicalNicHintInfo>>;
         addVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         addServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, portgroup: string, nic: vimService.vim.HostVirtualNicSpec): Promise<string>;
         removeServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         updateServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string, nic: vimService.vim.HostVirtualNicSpec): Promise<void>;
         restartServiceConsoleVirtualNic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         refreshNetworkSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         checkHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         scanHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         stageHostPatchTask(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchTask(_this: vimService.vim.ManagedObjectReference, repository: vimService.vim.HostPatchManagerLocator, updateID: string, force: boolean): Promise<vimService.vim.ManagedObjectReference>;
         installHostPatchV2Task(_this: vimService.vim.ManagedObjectReference, metaUrls: Array<string>, bundleUrls: Array<string>, vibUrls: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         uninstallHostPatchTask(_this: vimService.vim.ManagedObjectReference, bulletinIds: Array<string>, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryHostPatchTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostPatchManagerPatchManagerOperationSpec): Promise<vimService.vim.ManagedObjectReference>;
         refresh(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updatePassthruConfig(_this: vimService.vim.ManagedObjectReference, config: Array<vimService.vim.HostPciPassthruConfig>): Promise<void>;
         configurePowerPolicy(_this: vimService.vim.ManagedObjectReference, key: number): Promise<void>;
         updateServicePolicy(_this: vimService.vim.ManagedObjectReference, id: string, policy: string): Promise<void>;
         startService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         stopService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         restartService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         uninstallService(_this: vimService.vim.ManagedObjectReference, id: string): Promise<void>;
         refreshServices(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureSnmpAgent(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostSnmpConfigSpec): Promise<void>;
         sendTestNotification(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         retrieveDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<Array<vimService.vim.HostDiskPartitionInfo>>;
         computeDiskPartitionInfo(_this: vimService.vim.ManagedObjectReference, devicePath: string, layout: vimService.vim.HostDiskPartitionLayout, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         computeDiskPartitionInfoForResize(_this: vimService.vim.ManagedObjectReference, partition: vimService.vim.HostScsiDiskPartition, blockRange: vimService.vim.HostDiskPartitionBlockRange, partitionFormat: string): Promise<vimService.vim.HostDiskPartitionInfo>;
         updateDiskPartitions(_this: vimService.vim.ManagedObjectReference, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         formatVmfs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVmfsSpec): Promise<vimService.vim.HostVmfsVolume>;
         mountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         unmountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         mountVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         unmapVmfsVolumeExTask(_this: vimService.vim.ManagedObjectReference, vmfsUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteVmfsVolumeState(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanVmfs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         attachVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         expandVmfsExtent(_this: vimService.vim.ManagedObjectReference, vmfsPath: string, extent: vimService.vim.HostScsiDiskPartition): Promise<void>;
         upgradeVmfs(_this: vimService.vim.ManagedObjectReference, vmfsPath: string): Promise<void>;
         upgradeVmLayout(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryUnresolvedVmfsVolume(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostUnresolvedVmfsVolume>>;
         resolveMultipleUnresolvedVmfsVolumes(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<Array<vimService.vim.HostUnresolvedVmfsResolutionResult>>;
         resolveMultipleUnresolvedVmfsVolumesExTask(_this: vimService.vim.ManagedObjectReference, resolutionSpec: Array<vimService.vim.HostUnresolvedVmfsResolutionSpec>): Promise<vimService.vim.ManagedObjectReference>;
         unmountForceMountedVmfsVolume(_this: vimService.vim.ManagedObjectReference, vmfsUuid: string): Promise<void>;
         rescanHba(_this: vimService.vim.ManagedObjectReference, hbaDevice: string): Promise<void>;
         rescanAllHba(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         updateSoftwareInternetScsiEnabled(_this: vimService.vim.ManagedObjectReference, enabled: boolean): Promise<void>;
         updateInternetScsiDiscoveryProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, discoveryProperties: vimService.vim.HostInternetScsiHbaDiscoveryProperties): Promise<void>;
         updateInternetScsiAuthenticationProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, authenticationProperties: vimService.vim.HostInternetScsiHbaAuthenticationProperties, targetSet: vimService.vim.HostInternetScsiHbaTargetSet): Promise<void>;
         updateInternetScsiDigestProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, digestProperties: vimService.vim.HostInternetScsiHbaDigestProperties): Promise<void>;
         updateInternetScsiAdvancedOptions(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targetSet: vimService.vim.HostInternetScsiHbaTargetSet, options: Array<vimService.vim.HostInternetScsiHbaParamValue>): Promise<void>;
         updateInternetScsiIPProperties(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, ipProperties: vimService.vim.HostInternetScsiHbaIPProperties): Promise<void>;
         updateInternetScsiName(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiName: string): Promise<void>;
         updateInternetScsiAlias(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, iScsiAlias: string): Promise<void>;
         addInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         removeInternetScsiSendTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaSendTarget>): Promise<void>;
         addInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         removeInternetScsiStaticTargets(_this: vimService.vim.ManagedObjectReference, iScsiHbaDevice: string, targets: Array<vimService.vim.HostInternetScsiHbaStaticTarget>): Promise<void>;
         enableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         disableMultipathPath(_this: vimService.vim.ManagedObjectReference, pathName: string): Promise<void>;
         setMultipathLunPolicy(_this: vimService.vim.ManagedObjectReference, lunId: string, policy: vimService.vim.HostMultipathInfoLogicalUnitPolicy): Promise<void>;
         queryPathSelectionPolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostPathSelectionPolicyOption>>;
         queryStorageArrayTypePolicyOptions(_this: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.HostStorageArrayTypePolicyOption>>;
         updateScsiLunDisplayName(_this: vimService.vim.ManagedObjectReference, lunUuid: string, displayName: string): Promise<void>;
         detachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         detachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         deleteScsiLunState(_this: vimService.vim.ManagedObjectReference, lunCanonicalName: string): Promise<void>;
         attachScsiLun(_this: vimService.vim.ManagedObjectReference, lunUuid: string): Promise<void>;
         attachScsiLunExTask(_this: vimService.vim.ManagedObjectReference, lunUuid: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         refreshStorageSystem(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         discoverFcoeHbas(_this: vimService.vim.ManagedObjectReference, fcoeSpec: vimService.vim.FcoeConfigFcoeSpecification): Promise<void>;
         markForRemoval(_this: vimService.vim.ManagedObjectReference, hbaName: string, remove: boolean): Promise<void>;
         formatVffs(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.HostVffsSpec): Promise<vimService.vim.HostVffsVolume>;
         extendVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string, devicePath: string, spec: vimService.vim.HostDiskPartitionSpec): Promise<void>;
         destroyVffs(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<void>;
         mountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         unmountVffsVolume(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         deleteVffsVolumeState(_this: vimService.vim.ManagedObjectReference, vffsUuid: string): Promise<void>;
         rescanVffs(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryAvailableSsds(_this: vimService.vim.ManagedObjectReference, vffsPath: string): Promise<Array<vimService.vim.HostScsiDisk>>;
         setNFSUser(_this: vimService.vim.ManagedObjectReference, user: string, password: string): Promise<void>;
         changeNFSUserPassword(_this: vimService.vim.ManagedObjectReference, password: string): Promise<void>;
         queryNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostNasVolumeUserInfo>;
         clearNFSUser(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         turnDiskLocatorLedOnTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         turnDiskLocatorLedOffTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuids: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         markAsSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonSsdTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         markAsNonLocalTask(_this: vimService.vim.ManagedObjectReference, scsiDiskUuid: string): Promise<vimService.vim.ManagedObjectReference>;
         configureVFlashResourceExTask(_this: vimService.vim.ManagedObjectReference, devicePath: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         hostConfigureVFlashResource(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashResourceConfigSpec): Promise<void>;
         hostRemoveVFlashResource(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         hostConfigVFlashCache(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.HostVFlashManagerVFlashCacheConfigSpec): Promise<void>;
         hostGetVFlashModuleDefaultConfig(_this: vimService.vim.ManagedObjectReference, vFlashModule: string): Promise<vimService.vim.VirtualDiskVFlashCacheConfigInfo>;
         updateIpConfig(_this: vimService.vim.ManagedObjectReference, ipConfig: vimService.vim.HostIpConfig): Promise<void>;
         selectVnic(_this: vimService.vim.ManagedObjectReference, device: string): Promise<void>;
         deselectVnic(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         queryNetConfig(_this: vimService.vim.ManagedObjectReference, nicType: string): Promise<vimService.vim.VirtualNicManagerNetConfig>;
         selectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         deselectVnicForNicType(_this: vimService.vim.ManagedObjectReference, nicType: string, device: string): Promise<void>;
         queryCmmds(_this: vimService.vim.ManagedObjectReference, queries: Array<vimService.vim.HostVsanInternalSystemCmmdsQuery>): Promise<string>;
         queryPhysicalVsanDisks(_this: vimService.vim.ManagedObjectReference, props: Array<string>): Promise<string>;
         queryVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         queryObjectsOnPhysicalVsanDisk(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<string>;
         abdicateDomOwnership(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<Array<string>>;
         queryVsanStatistics(_this: vimService.vim.ManagedObjectReference, labels: Array<string>): Promise<string>;
         reconfigureDomObject(_this: vimService.vim.ManagedObjectReference, uuid: string, policy: string): Promise<void>;
         querySyncingVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         runVsanPhysicalDiskDiagnostics(_this: vimService.vim.ManagedObjectReference, disks: Array<string>): Promise<Array<vimService.vim.HostVsanInternalSystemVsanPhysicalDiskDiagnosticsResult>>;
         getVsanObjExtAttrs(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>): Promise<string>;
         reconfigurationSatisfiable(_this: vimService.vim.ManagedObjectReference, pcbs: Array<vimService.vim.VsanPolicyChangeBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         canProvisionObjects(_this: vimService.vim.ManagedObjectReference, npbs: Array<vimService.vim.VsanNewPolicyBatch>, ignoreSatisfiability: boolean): Promise<Array<vimService.vim.VsanPolicySatisfiability>>;
         deleteVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, force: boolean): Promise<Array<vimService.vim.HostVsanInternalSystemDeleteVsanObjectsResult>>;
         upgradeVsanObjects(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, newVersion: number): Promise<Array<vimService.vim.HostVsanInternalSystemVsanObjectOperationResult>>;
         queryVsanObjectUuidsByFilter(_this: vimService.vim.ManagedObjectReference, uuids: Array<string>, limit: number, version: number): Promise<Array<string>>;
         queryDisksForVsan(_this: vimService.vim.ManagedObjectReference, canonicalName: Array<string>): Promise<Array<vimService.vim.VsanHostDiskResult>>;
         addDisksTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>): Promise<vimService.vim.ManagedObjectReference>;
         initializeDisksTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskTask(_this: vimService.vim.ManagedObjectReference, disk: Array<vimService.vim.HostScsiDisk>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         removeDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         unmountDiskMappingTask(_this: vimService.vim.ManagedObjectReference, mapping: Array<vimService.vim.VsanHostDiskMapping>): Promise<vimService.vim.ManagedObjectReference>;
         updateVsanTask(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.VsanHostConfigInfo): Promise<vimService.vim.ManagedObjectReference>;
         queryHostStatus(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.VsanHostClusterStatus>;
         evacuateVsanNodeTask(_this: vimService.vim.ManagedObjectReference, maintenanceSpec: vimService.vim.HostMaintenanceSpec, timeout: number): Promise<vimService.vim.ManagedObjectReference>;
         recommissionVsanNodeTask(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryOptions(_this: vimService.vim.ManagedObjectReference, name: string): Promise<Array<vimService.vim.OptionValue>>;
         updateOptions(_this: vimService.vim.ManagedObjectReference, changedValue: Array<vimService.vim.OptionValue>): Promise<void>;
         checkComplianceTask(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ComplianceResult>>;
         clearComplianceStatus(_this: vimService.vim.ManagedObjectReference, profile: Array<vimService.vim.ManagedObjectReference>, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         queryExpressionMetadata(_this: vimService.vim.ManagedObjectReference, expressionName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileExpressionMetadata>>;
         retrieveDescription(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileDescription>;
         destroyProfile(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         associateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         dissociateProfile(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<void>;
         checkProfileComplianceTask(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         exportProfile(_this: vimService.vim.ManagedObjectReference): Promise<string>;
         createProfile(_this: vimService.vim.ManagedObjectReference, createSpec: vimService.vim.ProfileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         queryPolicyMetadata(_this: vimService.vim.ManagedObjectReference, policyName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfilePolicyMetadata>>;
         findAssociatedProfile(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         updateClusterProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.ClusterProfileConfigSpec): Promise<void>;
         updateReferenceHost(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<void>;
         updateHostProfile(_this: vimService.vim.ManagedObjectReference, config: vimService.vim.HostProfileConfigSpec): Promise<void>;
         executeHostProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, deferredParam: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ProfileExecuteResult>;
         applyHostConfigTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, userInput: Array<vimService.vim.ProfileDeferredPolicyOptionParameter>): Promise<vimService.vim.ManagedObjectReference>;
         generateConfigTaskList(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.HostProfileManagerConfigTaskList>;
         generateHostProfileTaskListTask(_this: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.HostConfigSpec, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         queryHostProfileMetadata(_this: vimService.vim.ManagedObjectReference, profileName: Array<string>, profile: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ProfileMetadata>>;
         queryProfileStructure(_this: vimService.vim.ManagedObjectReference, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ProfileProfileStructure>;
         createDefaultProfile(_this: vimService.vim.ManagedObjectReference, profileType: string, profileTypeName: string, profile: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ApplyProfile>;
         updateAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, configSpec: vimService.vim.AnswerFileCreateSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveAnswerFile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.AnswerFile>;
         retrieveAnswerFileForProfile(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, applyProfile: vimService.vim.HostApplyProfile): Promise<vimService.vim.AnswerFile>;
         exportAnswerFileTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkAnswerFileStatusTask(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         queryAnswerFileStatus(_this: vimService.vim.ManagedObjectReference, host: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.AnswerFileStatusResult>>;
         removeScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         reconfigureScheduledTask(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<void>;
         runScheduledTask(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveEntityScheduledTask(_this: vimService.vim.ManagedObjectReference, entity: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         createObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference, spec: vimService.vim.ScheduledTaskSpec): Promise<vimService.vim.ManagedObjectReference>;
         retrieveObjectScheduledTask(_this: vimService.vim.ManagedObjectReference, obj: vimService.vim.ManagedObjectReference): Promise<Array<vimService.vim.ManagedObjectReference>>;
         openInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         closeInventoryViewFolder(_this: vimService.vim.ManagedObjectReference, entity: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         modifyListView(_this: vimService.vim.ManagedObjectReference, add: Array<vimService.vim.ManagedObjectReference>, remove: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<Array<vimService.vim.ManagedObjectReference>>;
         resetListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<void>;
         destroyView(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createInventoryView(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         createContainerView(_this: vimService.vim.ManagedObjectReference, container: vimService.vim.ManagedObjectReference, type: Array<string>, recursive: boolean): Promise<vimService.vim.ManagedObjectReference>;
         createListView(_this: vimService.vim.ManagedObjectReference, obj: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         createListViewFromView(_this: vimService.vim.ManagedObjectReference, view: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         revertToSnapshotTask(_this: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, suppressPowerOn: boolean): Promise<vimService.vim.ManagedObjectReference>;
         removeSnapshotTask(_this: vimService.vim.ManagedObjectReference, removeChildren: boolean, consolidate: boolean): Promise<vimService.vim.ManagedObjectReference>;
         renameSnapshot(_this: vimService.vim.ManagedObjectReference, name: string, description: string): Promise<void>;
         exportSnapshot(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         checkCompatibilityTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         queryVMotionCompatibilityExTask(_this: vimService.vim.ManagedObjectReference, vm: Array<vimService.vim.ManagedObjectReference>, host: Array<vimService.vim.ManagedObjectReference>): Promise<vimService.vim.ManagedObjectReference>;
         checkMigrateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, host: vimService.vim.ManagedObjectReference, pool: vimService.vim.ManagedObjectReference, state: vimService.vim.VirtualMachinePowerState, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         checkRelocateTask(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, spec: vimService.vim.VirtualMachineRelocateSpec, testType: Array<string>): Promise<vimService.vim.ManagedObjectReference>;
         addGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, mapCert: boolean, base64Cert: string, aliasInfo: vimService.vim.GuestAuthAliasInfo): Promise<void>;
         removeGuestAlias(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string, subject: vimService.vim.GuestAuthSubject): Promise<void>;
         removeGuestAliasByCert(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string, base64Cert: string): Promise<void>;
         listGuestAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, username: string): Promise<Array<vimService.vim.GuestAliases>>;
         listGuestMappedAliases(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<Array<vimService.vim.GuestMappedAliases>>;
         validateCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         acquireCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, requestedAuth: vimService.vim.GuestAuthentication, sessionID: number): Promise<vimService.vim.GuestAuthentication>;
         releaseCredentialsInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication): Promise<void>;
         makeDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, createParentDirectories: boolean): Promise<void>;
         deleteFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string): Promise<void>;
         deleteDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, directoryPath: string, recursive: boolean): Promise<void>;
         moveDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcDirectoryPath: string, dstDirectoryPath: string): Promise<void>;
         moveFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, srcFilePath: string, dstFilePath: string, overwrite: boolean): Promise<void>;
         createTemporaryFileInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         createTemporaryDirectoryInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, prefix: string, suffix: string, directoryPath: string): Promise<string>;
         listFilesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, filePath: string, index: number, maxResults: number, matchPattern: string): Promise<vimService.vim.GuestListFileInfo>;
         changeFileAttributesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes): Promise<void>;
         initiateFileTransferFromGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string): Promise<vimService.vim.FileTransferInformation>;
         initiateFileTransferToGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, guestFilePath: string, fileAttributes: vimService.vim.GuestFileAttributes, fileSize: number, overwrite: boolean): Promise<string>;
         startProgramInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, spec: vimService.vim.GuestProgramSpec): Promise<number>;
         listProcessesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pids: Array<number>): Promise<Array<vimService.vim.GuestProcessInfo>>;
         terminateProcessInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, pid: number): Promise<void>;
         readEnvironmentVariableInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, names: Array<string>): Promise<Array<string>>;
         createRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, isVolatile: boolean, classType: string): Promise<void>;
         listRegistryKeysInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegKeyRecordSpec>>;
         deleteRegistryKeyInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, recursive: boolean): Promise<void>;
         setRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, value: vimService.vim.GuestRegValueSpec): Promise<void>;
         listRegistryValuesInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, keyName: vimService.vim.GuestRegKeyNameSpec, expandStrings: boolean, matchPattern: string): Promise<Array<vimService.vim.GuestRegValueSpec>>;
         deleteRegistryValueInGuest(_this: vimService.vim.ManagedObjectReference, vm: vimService.vim.ManagedObjectReference, auth: vimService.vim.GuestAuthentication, valueName: vimService.vim.GuestRegValueNameSpec): Promise<void>;
         destroyPropertyFilter(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         createFilter(_this: vimService.vim.ManagedObjectReference, spec: vimService.vim.PropertyFilterSpec, partialUpdates: boolean): Promise<vimService.vim.ManagedObjectReference>;
         retrieveProperties(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>): Promise<Array<vimService.vim.ObjectContent>>;
         checkForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         waitForUpdates(_this: vimService.vim.ManagedObjectReference, version: string): Promise<vimService.vim.UpdateSet>;
         cancelWaitForUpdates(_this: vimService.vim.ManagedObjectReference): Promise<void>;
         waitForUpdatesEx(_this: vimService.vim.ManagedObjectReference, version: string, options: vimService.vim.WaitOptions): Promise<vimService.vim.UpdateSet>;
         retrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, specSet: Array<vimService.vim.PropertyFilterSpec>, options: vimService.vim.RetrieveOptions): Promise<vimService.vim.RetrieveResult>;
         continueRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<vimService.vim.RetrieveResult>;
         cancelRetrievePropertiesEx(_this: vimService.vim.ManagedObjectReference, token: string): Promise<void>;
         createPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<vimService.vim.ManagedObjectReference>;
         destroyPropertyCollector(_this: vimService.vim.ManagedObjectReference): Promise<void>;
      }
      namespace vimPort {
      }
   }
}
declare module "vsphere" {
   export = vsphere;
}